src,tgt
"Translate Python to Java: def validPosition ( arr , N , K ) : NEW_LINE INDENT count = 0 ; sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if ( ( arr [ i ] + K ) > ( sum - arr [ i ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT","static int validPosition ( int arr [ ] , int N , int K ) { int count = 0 , sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] + K ) > ( sum - arr [ i ] ) ) count ++ ; } return count ; }"
"Translate Python to Java: def maxLen ( arr , n ) : NEW_LINE INDENT min_val = min ( arr ) NEW_LINE freq = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == min_val ) : NEW_LINE INDENT freq += 1 NEW_LINE DEDENT DEDENT return freq NEW_LINE DEDENT","static int maxLen ( int [ ] arr , int n ) { int min_val = Arrays . stream ( arr ) . min ( ) . getAsInt ( ) ; int freq = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == min_val ) freq ++ ; } return freq ; }"
"Translate Python to Java: def allBitsSetInRepeatingToRange ( n , l , r ) : NEW_LINE INDENT num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) NEW_LINE new_num = n & num NEW_LINE if ( new_num == 0 ) : NEW_LINE INDENT return "" Yes "" NEW_LINE DEDENT return "" No "" NEW_LINE DEDENT","static String allBitsSetInTheGivenRange ( int n , int l , int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; int new_num = n & num ; if ( new_num == 0 ) return "" Yes "" ; return "" No "" ; }"
"Translate Python to Java: def sameAdjacentSetInTheToRange ( n , l , r ) : NEW_LINE INDENT num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) NEW_LINE new_num = n & num NEW_LINE if ( num == new_num ) : NEW_LINE INDENT return "" Yes "" NEW_LINE DEDENT return "" No "" NEW_LINE DEDENT","static String allBitsSetInTheGivenRange ( int n , int l , int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; int new_num = n & num ; if ( num == new_num ) return "" Yes "" ; return "" No "" ; }"
"Translate Python to Java: def coutnKivSubarrays ( A , n , K ) : NEW_LINE INDENT freq = [ 0 for i in range ( K ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT rem = A [ i ] % K NEW_LINE if ( rem != 0 ) : NEW_LINE INDENT ans += freq [ K - rem ] NEW_LINE DEDENT else : NEW_LINE INDENT ans += freq [ 0 ] NEW_LINE DEDENT freq [ rem ] += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT","static int countKdivPairs ( int A [ ] , int n , int K ) { int [ ] freq = new int [ K ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int rem = A [ i ] % K ; if ( rem != 0 ) ans += freq [ K - rem ] ; else ans += freq [ 0 ] ; freq [ rem ] ++ ; } return ans ; }"
"Translate Python to Java: def isSpiltPossible ( n , a ) : NEW_LINE INDENT Sum = 0 NEW_LINE c1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += a [ i ] NEW_LINE if ( a [ i ] == 1 ) : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT DEDENT if ( Sum % 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( ( Sum // 2 ) % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( c1 > 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT","static boolean isSpiltPossible ( int n , int a [ ] ) { int sum = 0 , c1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; if ( a [ i ] == 1 ) { c1 ++ ; } } if ( sum % 2 != 0 ) return false ; if ( ( sum / 2 ) % 2 == 0 ) return true ; if ( c1 > 0 ) return true ; else return false ; }"
Translate Python to Java: def findParity ( x ) : NEW_LINE INDENT y = x ^ ( x >> 1 ) NEW_LINE y = y ^ ( y >> 2 ) NEW_LINE y = y ^ ( y >> 4 ) NEW_LINE y = y ^ ( y >> 8 ) NEW_LINE y = y ^ ( y >> 16 ) NEW_LINE if ( y & 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT,static boolean findParity ( int x ) { int y = x ^ ( x >> 1 ) ; y = y ^ ( y >> 2 ) ; y = y ^ ( y >> 4 ) ; y = y ^ ( y >> 8 ) ; y = y ^ ( y >> 16 ) ; if ( ( y & 1 ) > 0 ) return true ; return false ; }
Translate Python to Java: def missing_elements ( vec ) : NEW_LINE INDENT mis = [ ] NEW_LINE for i in range ( len ( vec ) ) : NEW_LINE INDENT temp = abs ( vec [ i ] ) - 1 NEW_LINE if vec [ temp ] > 0 : NEW_LINE INDENT vec [ temp ] = - vec [ temp ] NEW_LINE DEDENT DEDENT for i in range ( len ( vec ) ) : NEW_LINE INDENT if ( vec [ i ] > 0 ) : NEW_LINE INDENT mis . append ( i + 1 ) NEW_LINE DEDENT DEDENT return mis NEW_LINE DEDENT,"static Vector missing_elements ( Vector vec ) { Vector mis = new Vector ( ) ; for ( int i = 0 ; i < vec . size ( ) ; i ++ ) { int temp = Math . abs ( ( int ) vec . get ( i ) ) - 1 ; if ( ( int ) vec . get ( temp ) > 0 ) vec . set ( temp , - ( int ) vec . get ( temp ) ) ; else vec . set ( temp , vec . get ( temp ) ) ; } for ( int i = 0 ; i < vec . size ( ) ; i ++ ) { if ( ( int ) vec . get ( i ) > 0 ) mis . add ( i + 1 ) ; } return mis ; }"
"Translate Python to Java: def findSubsequence ( arr , n ) : NEW_LINE INDENT length = 1 NEW_LINE dp = [ 0 ] * 10 NEW_LINE tmp = arr [ 0 ] NEW_LINE while ( tmp > 0 ) : NEW_LINE INDENT dp [ tmp % 10 ] = 1 NEW_LINE tmp //= 10 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT tmp = arr [ i ] NEW_LINE locMax = 1 NEW_LINE cnt = [ 0 ] * 10 NEW_LINE while ( tmp > 0 ) : NEW_LINE INDENT cnt [ tmp % 10 ] = 1 NEW_LINE tmp //= 10 NEW_LINE DEDENT for d in range ( 10 ) : NEW_LINE INDENT if ( cnt [ d ] ) : NEW_LINE INDENT dp [ d ] += 1 NEW_LINE locMax = max ( locMax , dp [ d ] ) NEW_LINE DEDENT DEDENT for d in range ( 10 ) : NEW_LINE INDENT if ( cnt [ d ] ) : NEW_LINE INDENT dp [ d ] = locMax NEW_LINE DEDENT DEDENT length = max ( length , locMax ) NEW_LINE DEDENT return length NEW_LINE DEDENT","static int findSubsequence ( int arr [ ] , int n ) { int len = 1 ; int tmp ; int i , j , d ; int dp [ ] = new int [ 10 ] ; int cnt [ ] = new int [ 10 ] ; int locMax ; tmp = arr [ 0 ] ; while ( tmp > 0 ) { dp [ tmp % 10 ] = 1 ; tmp /= 10 ; } for ( i = 1 ; i < n ; i ++ ) { tmp = arr [ i ] ; locMax = 1 ; Arrays . fill ( cnt , 0 ) ; while ( tmp > 0 ) { cnt [ tmp % 10 ] = 1 ; tmp /= 10 ; } for ( d = 0 ; d <= 9 ; d ++ ) { if ( cnt [ d ] == 1 ) { dp [ d ] ++ ; locMax = Math . max ( locMax , dp [ d ] ) ; } } for ( d = 0 ; d <= 9 ; d ++ ) { if ( cnt [ d ] == 1 ) { dp [ d ] = locMax ; } } len = Math . max ( len , locMax ) ; } return len ; }"
"Translate Python to Java: def Distinct_Prime_factors ( a ) : NEW_LINE INDENT m = [ ] NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT sq = int ( math . sqrt ( a [ i ] ) ) NEW_LINE for j in range ( 2 , sq + 1 ) : NEW_LINE INDENT if ( a [ i ] % j == 0 ) : NEW_LINE INDENT m . append ( j ) NEW_LINE while ( a [ i ] % j == 0 ) : NEW_LINE INDENT a [ i ] //= j NEW_LINE DEDENT DEDENT DEDENT if ( a [ i ] > 2 ) : NEW_LINE INDENT m . append ( a [ i ] ) NEW_LINE DEDENT DEDENT return len ( m ) NEW_LINE DEDENT","static int Distinct_Prime_factors ( Vector < Integer > a ) { HashSet < Integer > m = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < a . size ( ) ; i ++ ) { int sq = ( int ) Math . sqrt ( a . get ( i ) ) ; for ( int j = 2 ; j <= sq ; j ++ ) { if ( a . get ( i ) % j == 0 ) { m . add ( j ) ; while ( a . get ( i ) % j == 0 ) { a . set ( i , a . get ( i ) / j ) ; } } } if ( a . get ( i ) > 1 ) { m . add ( a . get ( i ) ) ; } } return m . size ( ) ; }"
"Translate Python to Java: def findSum ( arr , n , k ) : NEW_LINE INDENT ans = arr [ n - k - 1 ] - arr [ 0 ] NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT ans = min ( arr [ n - 1 - ( k - i ) ] - arr [ i ] , ans ) NEW_LINE DEDENT return ans NEW_LINE DEDENT","static int findSum ( int [ ] arr , int n , int k ) { int ans = arr [ n - k - 1 ] - arr [ 0 ] ; for ( int i = 1 ; i <= k ; i ++ ) { ans = Math . min ( arr [ n - 1 - ( k - i ) ] - arr [ i ] , ans ) ; } return ans ; }"
"Translate Python to Java: def solve ( X , A ) : NEW_LINE INDENT minimum = sys . maxsize NEW_LINE ind = - 1 NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT if ( A [ i ] < minimum ) : NEW_LINE INDENT minimum = A [ i ] NEW_LINE ind = i NEW_LINE DEDENT DEDENT maxIndChosen = X // minimum NEW_LINE ans = [ ] NEW_LINE if ( maxIndChosen == 0 ) : NEW_LINE INDENT return ans NEW_LINE DEDENT for i in range ( maxIndChosen ) : NEW_LINE INDENT ans . append ( ind ) NEW_LINE DEDENT temp = maxIndChosen NEW_LINE sum = maxIndChosen * A [ ind ] NEW_LINE for i in range ( ind ) : NEW_LINE INDENT if ( sum - X == 0 or temp == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT while ( ( sum - A [ ind ] + A [ i ] ) <= X and temp != 0 ) : NEW_LINE INDENT del ( ans [ 0 ] ) NEW_LINE ans . append ( i ) NEW_LINE temp -= 1 NEW_LINE sum += ( A [ i ] - A [ ind ] ) NEW_LINE DEDENT DEDENT ans . sort ( ) NEW_LINE return ans NEW_LINE DEDENT","static Vector < Integer > solve ( int X , Vector < Integer > A ) { int min = Integer . MAX_VALUE ; int ind = - 1 ; for ( int i = 0 ; i < A . size ( ) ; i ++ ) { if ( A . get ( i ) < min ) { min = A . get ( i ) ; ind = i ; } } int maxIndChosen = X / min ; Vector < Integer > ans = new Vector < > ( ) ; if ( maxIndChosen == 0 ) { return ans ; } for ( int i = 0 ; i < maxIndChosen ; i ++ ) { ans . add ( ind ) ; } int temp = maxIndChosen ; int sum = maxIndChosen * A . get ( ind ) ; for ( int i = 0 ; i < ind ; i ++ ) { if ( sum - X == 0 || temp == 0 ) break ; while ( ( sum - A . get ( ind ) + A . get ( i ) ) <= X && temp != 0 ) { ans . remove ( 0 ) ; ans . add ( i ) ; temp -- ; sum += ( A . get ( i ) - A . get ( ind ) ) ; } } Collections . sort ( ans ) ; return ans ; }"
"Translate Python to Java: def run_tasks ( A , B ) : NEW_LINE INDENT total_time = 0 NEW_LINE while ( len ( A ) > 0 ) : NEW_LINE INDENT x = A . popleft ( ) NEW_LINE y = B . popleft ( ) NEW_LINE if ( x == y ) : NEW_LINE INDENT total_time += 1 NEW_LINE DEDENT else : NEW_LINE INDENT B . appendleft ( y ) NEW_LINE A . append ( x ) NEW_LINE total_time += 2 NEW_LINE DEDENT DEDENT return total_time NEW_LINE DEDENT","static int run_tasks ( Queue < Integer > A , Queue < Integer > B ) { int total_time = 0 ; while ( ! A . isEmpty ( ) ) { int x = A . peek ( ) ; int y = B . peek ( ) ; if ( x == y ) { A . remove ( ) ; B . remove ( ) ; total_time ++ ; } else { A . remove ( ) ; A . add ( x ) ; total_time += 2 ; } } return total_time ; }"
"Translate Python to Java: def countPairs ( A1 , A2 , n1 , n2 , K ) : NEW_LINE INDENT res = 0 NEW_LINE m = dict ( ) NEW_LINE for i in range ( 0 , n1 ) : NEW_LINE INDENT if A1 [ i ] not in m . keys ( ) : NEW_LINE INDENT m [ A1 [ i ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ A1 [ i ] ] = m [ A1 [ i ] ] + 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n2 ) : NEW_LINE INDENT temp = K - A2 [ i ] NEW_LINE if temp in m . keys ( ) : NEW_LINE INDENT res = res + 1 NEW_LINE m [ temp ] = m [ temp ] - 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT","static int countPairs ( int A1 [ ] , int A2 [ ] , int n1 , int n2 , int K ) { int res = 0 ; Map < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n1 ; ++ i ) { if ( m . containsKey ( A1 [ i ] ) ) m . put ( A1 [ i ] , m . get ( A1 [ i ] ) + 1 ) ; else m . put ( A1 [ i ] , 1 ) ; } for ( int i = 0 ; i < n2 ; ++ i ) { int temp = K - A2 [ i ] ; if ( m . containsKey ( temp ) && m . get ( temp ) != 0 ) { res ++ ; m . put ( temp , m . get ( A1 [ i ] ) - 1 ) ; } } return res ; }"
"Translate Python to Java: def calcluate ( array , size ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( array [ i ] % 2 == 0 and array [ i ] != 0 and array [ i ] != 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT","public static int calculate ( int ar [ ] , int size ) { int count = 0 ; for ( int i = 0 ; i < size ; i ++ ) if ( ar [ i ] % 2 == 0 && ar [ i ] != 0 && ar [ i ] != 2 ) count ++ ; return count ; }"
"Translate Python to Java: def find_sub ( s , k ) : NEW_LINE INDENT Len = len ( s ) NEW_LINE lp , rp = 0 , 0 NEW_LINE ans = 0 NEW_LINE hash_char = [ 0 for i in range ( 256 ) ] NEW_LINE for rp in range ( Len ) : NEW_LINE INDENT hash_char [ ord ( s [ rp ] ) ] += 1 NEW_LINE while ( hash_char [ ord ( s [ rp ] ) ] > k ) : NEW_LINE INDENT hash_char [ ord ( s [ lp ] ) ] -= 1 NEW_LINE lp += 1 NEW_LINE DEDENT ans += rp - lp + 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT","static int find_sub ( String s , int k ) { int len = s . length ( ) ; int lp = 0 , rp = 0 ; int ans = 0 ; int [ ] hash_char = new int [ 26 ] ; for ( ; rp < len ; rp ++ ) { hash_char [ s . charAt ( rp ) - ' a ' ] ++ ; while ( hash_char [ s . charAt ( rp ) - ' a ' ] > k ) { hash_char [ s . charAt ( lp ) - ' a ' ] -- ; lp ++ ; } ans += rp - lp + 1 ; } return ans ; }"
Translate Python to Java: def count ( n ) : NEW_LINE INDENT x = ( n // 3 ) - 1 NEW_LINE if ( n % 3 > 0 ) : NEW_LINE INDENT x += 1 NEW_LINE DEDENT return ( 4 * x + 4 * n ) NEW_LINE DEDENT,static int count ( int n ) { int x = ( n / 3 ) - 1 ; if ( n % 3 > 0 ) { x ++ ; } return ( 4 * x + 4 * n ) ; }
Translate Python to Java: def Survives ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while ( True ) : NEW_LINE INDENT if ( i > n ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n -= n // i NEW_LINE i += 1 NEW_LINE DEDENT DEDENT,static boolean Survives ( int n ) { for ( int i = 2 ; ; i ++ ) { if ( i > n ) return true ; if ( n % i == 0 ) return false ; n -= n / i ; } }
"Translate Python to Java: def computeXOR ( n ) : NEW_LINE INDENT switch = { 0 : n , 1 : 1 , 2 : n + 1 , 3 : 0 , } NEW_LINE return switch . get ( n & 3 , "" "" ) NEW_LINE DEDENT",static long computeXOR ( int n ) { int x = n & 3 ; switch ( x ) { case 0 : return n ; case 1 : return 1 ; case 2 : return n + 1 ; case 3 : return 0 ; } return 0 ; }
"Translate Python to Java: def lehmann ( n , t ) : NEW_LINE INDENT random.seed ( 1234 ) NEW_LINE a = random . randint ( 2 , n - 1 ) NEW_LINE e = ( n - 1 ) / 2 NEW_LINE while ( t > 0 ) : NEW_LINE INDENT result = ( ( int ) ( a ** e ) ) % n NEW_LINE if ( ( result % n ) == 1 or ( result % n ) == ( n - 1 ) ) : NEW_LINE INDENT a = random . randint ( 2 , n - 1 ) NEW_LINE t -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT","static int lehmann ( int n , int t ) { Random rand = new Random ( ) ; rand . setSeed ( 1234 ) ; int a = rand . nextInt ( n - 3 ) + 2 ; float e = ( n - 1 ) / 2 ; while ( t > 0 ) { int result = ( ( int ) ( Math . pow ( a , e ) ) ) % n ; if ( ( result % n ) == 1 || ( result % n ) == ( n - 1 ) ) { a = rand . nextInt ( n - 3 ) + 2 ; t -= 1 ; } else return - 1 ; } return 1 ; }"
"Translate Python to Java: def check ( a , n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( n // 2 ) : NEW_LINE INDENT if a [ i ] != a [ i + ( n // 2 ) ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT","static boolean check ( int a [ ] , int n ) { if ( n % 2 == 1 ) return false ; for ( int i = 0 ; i < n / 2 ; i ++ ) { if ( a [ i ] != a [ i + ( n / 2 ) ] ) return false ; } return true ; }"
"Translate Python to Java: def findSubstrings ( s , k ) : NEW_LINE INDENT ans = 0 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt = [ 0 ] * 26 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT cnt [ ord ( s [ j ] ) - ord ( ' a ' ) ] += 1 NEW_LINE if ( cnt [ ord ( s [ j ] ) - ord ( ' a ' ) ] <= k ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT","static int findSubstrings ( String s , int k ) { int ans = 0 ; int cnt [ ] = new int [ 26 ] ; int i , j , n = s . length ( ) ; for ( i = 0 ; i < n ; i ++ ) { Arrays . fill ( cnt , 0 ) ; for ( j = i ; j < n ; j ++ ) { cnt [ s . charAt ( j ) - ' a ' ] ++ ; if ( cnt [ s . charAt ( j ) - ' a ' ] <= k ) { ans ++ ; } else { break ; } } } return ans ; }"
"Translate Python to Java: def getSubSeq ( s , n ) : NEW_LINE INDENT res = "" "" NEW_LINE cr = 0 NEW_LINE while ( cr < n ) : NEW_LINE INDENT mx = s [ cr ] NEW_LINE for i in range ( cr + 1 , n ) : NEW_LINE INDENT mx = max ( mx , s [ i ] ) NEW_LINE DEDENT lst = cr NEW_LINE for i in range ( cr , n ) : NEW_LINE INDENT if ( s [ i ] == mx ) : NEW_LINE INDENT res += s [ i ] NEW_LINE lst = i NEW_LINE DEDENT DEDENT cr = lst + 1 NEW_LINE DEDENT return res NEW_LINE DEDENT","static String getSubSeq ( String s , int n ) { String res = "" "" ; int cr = 0 ; while ( cr < n ) { char mx = s . charAt ( cr ) ; for ( int i = cr + 1 ; i < n ; i ++ ) { mx = ( char ) Math . max ( mx , s . charAt ( i ) ) ; } int lst = cr ; for ( int i = cr ; i < n ; i ++ ) { if ( s . charAt ( i ) == mx ) { res += s . charAt ( i ) ; lst = i ; } } cr = lst + 1 ; } return res ; }"
"Translate Python to Java: def isDefeat ( s1 , s2 , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( ( s1 [ i ] == '0' and s2 [ i ] == '1' ) or ( s1 [ i ] == '1' and s2 [ i ] == '0' ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( ( s1 [ i ] == '0' and s2 [ i ] == ' Z ' ) or ( s1 [ i ] == ' Z ' and s2 [ i ] == '0' ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT","static boolean isDefeat ( String s1 , String s2 , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( ( s1 . charAt ( i ) == '0' && s2 . charAt ( i ) == '1' ) || ( s1 . charAt ( i ) == '1' && s2 . charAt ( i ) == '0' ) ) continue ; else if ( ( s1 . charAt ( i ) == '0' && s2 . charAt ( i ) == ' Z ' ) || ( s1 . charAt ( i ) == ' Z ' && s2 . charAt ( i ) == '0' ) ) continue ; else { return true ; } } return false ; }"
"Translate Python to Java: def sum ( a , b , c , d , x ) : NEW_LINE INDENT ans = ( ( x * ( a + b ) * ( c - d ) ) / ( ( a * d ) - ( b * c ) ) ) NEW_LINE return ans NEW_LINE DEDENT","static double sum ( double a , double b , double c , double d , double x ) { double ans = ( x * ( a + b ) * ( c - d ) ) / ( ( a * d ) - ( b * c ) ) ; return ans ; }"
"Translate Python to Java: def minReplacement ( s , length ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT if i % 2 == 0 and s [ i ] == '1' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT if i % 2 == 1 and s [ i ] == '0' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return min ( ans , length - ans ) NEW_LINE DEDENT","static int minReplacement ( String s , int len ) { int ans = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( i % 2 == 0 && s . charAt ( i ) == '1' ) ans ++ ; if ( i % 2 == 1 && s . charAt ( i ) == '0' ) ans ++ ; } return Math . min ( ans , len - ans ) ; }"
"Translate Python to Java: def solve ( n , k ) : NEW_LINE INDENT intervals = { n : 1 } NEW_LINE lens = [ - n ] NEW_LINE ls = 0 NEW_LINE rs = 0 NEW_LINE while k > 0 : NEW_LINE INDENT val = - heapq . heappop ( lens ) NEW_LINE num = intervals [ val ] NEW_LINE del intervals [ val ] NEW_LINE k = k - num NEW_LINE ls = int ( ( val - 1 ) / 2 ) NEW_LINE rs = val - ls - 1 NEW_LINE if not ls in intervals : NEW_LINE INDENT intervals [ ls ] = 0 NEW_LINE heapq . heappush ( lens , - ls ) NEW_LINE DEDENT if not rs in intervals : NEW_LINE INDENT intervals [ rs ] = 0 NEW_LINE heapq . heappush ( lens , - rs ) NEW_LINE DEDENT intervals [ rs ] = intervals [ rs ] + num NEW_LINE intervals [ ls ] = intervals [ ls ] + num NEW_LINE DEDENT return ( max ( ls , rs ) , min ( ls , rs ) ) NEW_LINE DEDENT","public static long [ ] solve ( long N , long K ) { if ( K == 1 ) { long [ ] arr = new long [ 2 ] ; arr [ 0 ] = N / 2 ; arr [ 1 ] = ( N - 1 ) / 2 ; return arr ; } if ( K % 2 == 0 ) { return solve ( N / 2 , K / 2 ) ; } return solve ( ( N - 1 ) / 2 , K / 2 ) ; }"
"Translate Python to Java: def powerNumbers ( n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( 2 , int ( math . pow ( n , 1.0 / 3.0 ) ) + 1 ) : NEW_LINE INDENT j = i * i NEW_LINE while ( j * i <= n ) : NEW_LINE INDENT j = j * i NEW_LINE s = int ( math . sqrt ( j ) ) NEW_LINE if ( s * s != j ) : NEW_LINE INDENT v . append ( j ) NEW_LINE DEDENT DEDENT DEDENT v . sort ( ) NEW_LINE v = list ( dict . fromkeys ( v ) ) NEW_LINE return len ( v ) + int ( math . sqrt ( n ) ) NEW_LINE DEDENT",static long powerNumbers ( int n ) { HashSet < Long > v = new HashSet < Long > ( ) ; for ( long i = 2 ; i * i * i <= n ; i ++ ) { long j = i * i ; while ( j * i <= n ) { j *= i ; long s = ( long ) Math . sqrt ( j ) ; if ( s * s != j ) v . add ( j ) ; } } return v . size ( ) + ( long ) Math . sqrt ( n ) ; }
"Translate Python to Java: def digit ( x , y ) : NEW_LINE INDENT if x < y : NEW_LINE INDENT return digit ( y , x ) NEW_LINE DEDENT elif y != 0 : NEW_LINE INDENT return ( x + digit ( x , y - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT","static int product ( int x , int y ) { if ( x < y ) return product ( y , x ) ; else if ( y != 0 ) return ( x + product ( x , y - 1 ) ) ; else return 0 ; }"
"Translate Python to Java: def decideWinner ( a , n ) : NEW_LINE INDENT count0 = 0 NEW_LINE count1 = 0 NEW_LINE count2 = 0 NEW_LINE count3 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 4 == 0 ) : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT elif ( a [ i ] % 4 == 1 ) : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT elif ( a [ i ] % 4 == 2 ) : NEW_LINE INDENT count2 += 1 NEW_LINE DEDENT elif ( a [ i ] % 4 == 3 ) : NEW_LINE INDENT count3 += 1 NEW_LINE DEDENT DEDENT if ( count0 % 2 == 0 and count1 % 2 == 0 and count2 % 2 == 0 and count3 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT","static int decideWinner ( int [ ] a , int n ) { int count0 = 0 ; int count1 = 0 ; int count2 = 0 ; int count3 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 4 == 0 ) count0 ++ ; else if ( a [ i ] % 4 == 1 ) count1 ++ ; else if ( a [ i ] % 4 == 2 ) count2 ++ ; else if ( a [ i ] % 4 == 3 ) count3 ++ ; } if ( count0 % 2 == 0 && count1 % 2 == 0 && count2 % 2 == 0 && count3 == 0 ) return 1 ; else return 2 ; }"
"Translate Python to Java: def lenOfLongIncSubArr ( arr , n ) : NEW_LINE INDENT m = 1 NEW_LINE l = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT l = l + 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( m < l ) : NEW_LINE INDENT m = l NEW_LINE DEDENT l = 1 NEW_LINE DEDENT DEDENT if ( m < l ) : NEW_LINE INDENT m = l NEW_LINE DEDENT return m NEW_LINE DEDENT","public static int lenOfLongIncSubArr ( int arr [ ] , int n ) { int max = 1 , len = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] ) len ++ ; else { if ( max < len ) max = len ; len = 1 ; } } if ( max < len ) max = len ; return max ; }"
"Translate Python to Java: def subsetSum ( arr , n , i , sum , count ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( sum == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT count = subsetSum ( arr , n , i + 1 , sum - arr [ i ] , count ) NEW_LINE count = subsetSum ( arr , n , i + 1 , sum , count ) NEW_LINE return count NEW_LINE DEDENT","static int subsetSum ( int arr [ ] , int n , int i , int sum , int count ) { if ( i == n ) { if ( sum == 0 ) { count ++ ; } return count ; } count = subsetSum ( arr , n , i + 1 , sum - arr [ i ] , count ) ; count = subsetSum ( arr , n , i + 1 , sum , count ) ; return count ; }"
Translate Python to Java: def center_hexadecagonal_num ( n ) : NEW_LINE INDENT return 8 * n * n - 8 * n + 1 NEW_LINE DEDENT,static int center_hexadecagonal_num ( int n ) { return 8 * n * n - 8 * n + 1 ; }
Translate Python to Java: def seriesFunc ( n ) : NEW_LINE INDENT sumSquare = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 NEW_LINE sumNatural = ( n * ( n + 1 ) / 2 ) NEW_LINE return ( sumSquare + sumNatural + 1 ) NEW_LINE DEDENT,static int seriesFunc ( int n ) { int sumSquare = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; int sumNatural = ( n * ( n + 1 ) / 2 ) ; return ( sumSquare + sumNatural + 1 ) ; }
Translate Python to Java: def maxSumLCM ( n ) : NEW_LINE INDENT max_sum = 0 NEW_LINE i = 1 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT max_sum = max_sum + i NEW_LINE if ( n // i != i ) : NEW_LINE INDENT max_sum = max_sum + ( n // i ) NEW_LINE DEDENT DEDENT i = i + 1 NEW_LINE DEDENT return max_sum NEW_LINE DEDENT,static int maxSumLCM ( int n ) { int max_sum = 0 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { max_sum += i ; if ( n / i != i ) max_sum += ( n / i ) ; } } return max_sum ; }
"Translate Python to Java: def findGreater ( x , y ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT","static boolean findGreater ( int x , int y ) { if ( x > y ) { return false ; } else { return true ; } }"
"Translate Python to Java: def solve ( n , m , obstacles , rangee ) : NEW_LINE INDENT val = min ( n , m ) NEW_LINE rangee = sorted ( rangee ) NEW_LINE c = 1 NEW_LINE for i in range ( obstacles - 1 , - 1 , - 1 ) : NEW_LINE INDENT rangee [ i ] = 2 * rangee [ i ] NEW_LINE val -= rangee [ i ] NEW_LINE if ( val <= 0 ) : NEW_LINE INDENT return c NEW_LINE DEDENT else : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if ( val > 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT","static int solve ( int n , int m , int obstacles , double range [ ] ) { double val = Math . min ( n , m ) ; Arrays . sort ( range ) ; int c = 1 ; for ( int i = obstacles - 1 ; i >= 0 ; i -- ) { range [ i ] = 2 * range [ i ] ; val -= range [ i ] ; if ( val <= 0 ) { return c ; } else { c ++ ; } } if ( val > 0 ) { return - 1 ; } return 0 ; }"
"Translate Python to Java: def check ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT","static boolean check ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == 1 ) return true ; return false ; }"
Translate Python to Java: def center_octadecagon_num ( n ) : NEW_LINE INDENT return ( 9 * n * n - 9 * n + 1 ) NEW_LINE DEDENT,static int center_octadecagon_num ( int n ) { return 9 * n * n - 9 * n + 1 ; }
"Translate Python to Java: def percent ( a , b ) : NEW_LINE INDENT result = int ( ( ( b - a ) * 100 ) / a ) NEW_LINE return result NEW_LINE DEDENT","static int percent ( int a , int b ) { float result = 0 ; result = ( ( b - a ) * 100 ) / a ; return ( int ) result ; }"
Translate Python to Java: def AvgofSquareN ( n ) : NEW_LINE INDENT return ( ( n + 1 ) * ( 2 * n + 1 ) ) / 6 NEW_LINE DEDENT,static float AvgofSquareN ( int n ) { return ( float ) ( ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; }
"Translate Python to Java: def ksmallest ( arr , n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] <= k ) : NEW_LINE INDENT k = k + 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return k NEW_LINE DEDENT","static int ksmallest ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] <= k ) k ++ ; else break ; } return k ; }"
"Translate Python to Java: def getChicks ( n ) : NEW_LINE INDENT chicks = pow ( 3 , n - 1 ) NEW_LINE return chicks NEW_LINE DEDENT","static int getChicks ( int n ) { int chicks = ( int ) Math . pow ( 3 , n - 1 ) ; return chicks ; }"
"Translate Python to Java: def findTerm ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT term = 7 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT term = term * 2 + ( i - 1 ) NEW_LINE DEDENT DEDENT return term NEW_LINE DEDENT",static int findTerm ( int n ) { if ( n == 1 ) return n ; else { int term = 7 ; for ( int i = 2 ; i <= n ; i ++ ) term = term * 2 + ( i - 1 ) ; return term ; } }
"Translate Python to Java: def countSubArrayProductLessThanK ( a , k ) : NEW_LINE INDENT n = len ( a ) NEW_LINE p = 1 NEW_LINE res = 0 NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE while ( end < n ) : NEW_LINE INDENT p *= a [ end ] NEW_LINE while ( start < end and p >= k ) : NEW_LINE INDENT p = int ( p // a [ start ] ) NEW_LINE start += 1 NEW_LINE DEDENT if ( p < k ) : NEW_LINE INDENT l = end - start + 1 NEW_LINE res += l NEW_LINE DEDENT end += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT","static int countSubArrayProductLessThanK ( ArrayList < Integer > a , long k ) { int n = a . size ( ) ; long p = 1 ; int res = 0 ; for ( int start = 0 , end = 0 ; end < n ; end ++ ) { p *= a . get ( end ) ; while ( start < end && p >= k ) p /= a . get ( start ++ ) ; if ( p < k ) { int len = end - start + 1 ; res += len ; } } return res ; }"
"Translate Python to Java: def getOccurence ( n , d ) : NEW_LINE INDENT result = 0 NEW_LINE itr = d NEW_LINE while ( itr <= n ) : NEW_LINE INDENT if ( itr % 10 == d ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT if ( itr != 0 and math . floor ( itr / 10 ) == d ) : NEW_LINE INDENT result += 1 NEW_LINE itr += 1 NEW_LINE DEDENT elif ( math . floor ( itr / 10 ) == d - 1 ) : NEW_LINE INDENT itr = itr + ( 10 - d ) NEW_LINE DEDENT else : NEW_LINE INDENT itr = itr + 10 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT","static int getOccurence ( int n , int d ) { int result = 0 ; int itr = d ; while ( itr <= n ) { if ( itr % 10 == d ) result ++ ; if ( itr != 0 && itr / 10 == d ) { result ++ ; itr ++ ; } else if ( itr / 10 == d - 1 ) itr = itr + ( 10 - d ) ; else itr = itr + 10 ; } return result ; }"
"Translate Python to Java: def findMissingPositive ( arr , n ) : NEW_LINE INDENT m = 1 NEW_LINE x = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( m < arr [ i ] ) : NEW_LINE INDENT x . append ( arr [ i ] ) NEW_LINE DEDENT elif ( m == arr [ i ] ) : NEW_LINE INDENT m = m + 1 NEW_LINE while ( x . count ( m ) ) : NEW_LINE INDENT x . remove ( m ) NEW_LINE m = m + 1 NEW_LINE DEDENT DEDENT DEDENT return m NEW_LINE DEDENT","static int findMissingPositive ( int arr [ ] , int n ) { int m = 1 ; HashSet < Integer > x = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( m < arr [ i ] ) { x . add ( arr [ i ] ) ; } else if ( m == arr [ i ] ) { m = m + 1 ; while ( x . contains ( m ) ) { x . remove ( m ) ; m = m + 1 ; } } } return m ; }"
"Translate Python to Java: def ways ( n ) : NEW_LINE INDENT first = 2 NEW_LINE second = 3 NEW_LINE res = 0 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT res = first + second NEW_LINE first = second NEW_LINE second = res NEW_LINE DEDENT return res NEW_LINE DEDENT",static int ways ( int n ) { int first = 2 ; int second = 3 ; int res = 0 ; for ( int i = 3 ; i <= n ; i ++ ) { res = first + second ; first = second ; second = res ; } return res ; }
"Translate Python to Java: def calculateAreaSum ( l , b ) : NEW_LINE INDENT size = 1 NEW_LINE maxSize = min ( l , b ) NEW_LINE totalArea = 0 NEW_LINE for i in range ( 1 , maxSize + 1 ) : NEW_LINE INDENT totalSquares = ( ( l - size + 1 ) * ( b - size + 1 ) ) NEW_LINE area = ( totalSquares * size * size ) NEW_LINE totalArea += area NEW_LINE size += 1 NEW_LINE DEDENT return totalArea NEW_LINE DEDENT","static int calculateAreaSum ( int l , int b ) { int size = 1 ; int maxSize = Math . min ( l , b ) ; int totalArea = 0 ; for ( int i = 1 ; i <= maxSize ; i ++ ) { int totalSquares = ( l - size + 1 ) * ( b - size + 1 ) ; int area = totalSquares * size * size ; totalArea += area ; size ++ ; } return totalArea ; }"
Translate Python to Java: def count ( N ) : NEW_LINE INDENT a = 0 NEW_LINE a = ( N * ( N + 1 ) ) / 2 NEW_LINE return int ( a ) NEW_LINE DEDENT,static int count ( int N ) { int a = 0 ; a = ( N * ( N + 1 ) ) / 2 ; return a ; }
"Translate Python to Java: def countIterations ( arr , n ) : NEW_LINE INDENT oneFound = False NEW_LINE res = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT oneFound = True NEW_LINE DEDENT while ( i < n and arr [ i ] == 1 ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT count_zero = 0 NEW_LINE while ( i < n and arr [ i ] == 0 ) : NEW_LINE INDENT count_zero += 1 NEW_LINE i += 1 NEW_LINE DEDENT if ( oneFound == False and i == n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT curr_count = 0 NEW_LINE if ( i < n and oneFound == True ) : NEW_LINE INDENT if ( ( count_zero & 1 ) == 0 ) : NEW_LINE INDENT curr_count = count_zero // 2 NEW_LINE DEDENT else : NEW_LINE INDENT curr_count = ( count_zero + 1 ) // 2 NEW_LINE DEDENT count_zero = 0 NEW_LINE DEDENT else : NEW_LINE INDENT curr_count = count_zero NEW_LINE count_zero = 0 NEW_LINE DEDENT res = max ( res , curr_count ) NEW_LINE DEDENT return res NEW_LINE DEDENT","static int countIterations ( int arr [ ] , int n ) { boolean oneFound = false ; int res = 0 ; for ( int i = 0 ; i < n ; ) { if ( arr [ i ] == 1 ) oneFound = true ; while ( i < n && arr [ i ] == 1 ) i ++ ; int count_zero = 0 ; while ( i < n && arr [ i ] == 0 ) { count_zero ++ ; i ++ ; } if ( oneFound == false && i == n ) return - 1 ; int curr_count ; if ( i < n && oneFound == true ) { if ( ( count_zero & 1 ) == 0 ) curr_count = count_zero / 2 ; else curr_count = ( count_zero + 1 ) / 2 ; count_zero = 0 ; } else { curr_count = count_zero ; count_zero = 0 ; } res = Math . max ( res , curr_count ) ; } return res ; }"
"Translate Python to Java: def lnogestSbuForm ( arr , n ) : NEW_LINE INDENT isZeroPresent = False NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT isZeroPresent = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( isZeroPresent ) : NEW_LINE INDENT return n NEW_LINE DEDENT return 0 NEW_LINE DEDENT","static int longestSubArray ( int arr [ ] , int n ) { boolean isZeroPresent = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { isZeroPresent = true ; break ; } } if ( isZeroPresent ) return n ; return 0 ; }"
Translate Python to Java: def solve ( s ) : NEW_LINE INDENT area = ( 1.732 * s ** 2 ) / 8 NEW_LINE return area NEW_LINE DEDENT,"static double solve ( int s ) { double area = ( 1.732 * Math . pow ( s , 2 ) ) / 8 ; return area ; }"
"Translate Python to Java: def maxOfSegmentMins ( a , n , k ) : NEW_LINE INDENT if k == 1 : NEW_LINE INDENT return min ( a ) NEW_LINE DEDENT if k == 2 : NEW_LINE INDENT return max ( a [ 0 ] , a [ n - 1 ] ) NEW_LINE DEDENT return max ( a ) NEW_LINE DEDENT","static int maxOfSegmentMins ( int [ ] a , int n , int k ) { if ( k == 1 ) { Arrays . sort ( a ) ; return a [ 0 ] ; } if ( k == 2 ) return Math . max ( a [ 0 ] , a [ n - 1 ] ) ; return a [ n - 1 ] ; }"
"Translate Python to Java: def countsubarray ( array , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if array [ i ] <= k : NEW_LINE INDENT count += 1 NEW_LINE DEDENT mul = array [ i ] NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT mul = mul * array [ j ] NEW_LINE if mul <= k : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT","static int countsubarray ( int array [ ] , int n , int k ) { int count = 0 ; int i , j , mul ; for ( i = 0 ; i < n ; i ++ ) { if ( array [ i ] <= k ) count ++ ; mul = array [ i ] ; for ( j = i + 1 ; j < n ; j ++ ) { mul = mul * array [ j ] ; if ( mul <= k ) count ++ ; else break ; } } return count ; }"
Translate Python to Java: def solve ( n ) : NEW_LINE INDENT ans = ( n * n // 4 ) NEW_LINE return ans NEW_LINE DEDENT,public static int solve ( int n ) { int ans = ( n * n / 4 ) ; return ans ; }
"Translate Python to Java: def make_permutation ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += abs ( i + 1 - arr [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT","static int make_permutation ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += Math . abs ( i + 1 - arr [ i ] ) ; return ans ; }"
"Translate Python to Java: def getMinCost ( arr , n ) : NEW_LINE INDENT min_ele = min ( arr ) NEW_LINE return min_ele * ( n - 1 ) NEW_LINE DEDENT","public static int getMinCost ( Integer arr [ ] , int n ) { int min_ele = Collections . min ( Arrays . asList ( arr ) ) ; return min_ele * ( n - 1 ) ; }"
"Translate Python to Java: def maxDistance ( array ) : NEW_LINE INDENT max1 = - 2147483648 NEW_LINE min1 = + 2147483647 NEW_LINE max2 = - 2147483648 NEW_LINE min2 = + 2147483647 NEW_LINE for i in range ( len ( array ) ) : NEW_LINE INDENT max1 = max ( max1 , array [ i ] + i ) NEW_LINE min1 = min ( min1 , array [ i ] + i ) NEW_LINE max2 = max ( max2 , array [ i ] - i ) NEW_LINE min2 = min ( min2 , array [ i ] - i ) NEW_LINE DEDENT return max ( max1 - min1 , max2 - min2 ) NEW_LINE DEDENT","private static int maxDistance ( int [ ] array ) { int max1 = Integer . MIN_VALUE ; int min1 = Integer . MAX_VALUE ; int max2 = Integer . MIN_VALUE ; int min2 = Integer . MAX_VALUE ; for ( int i = 0 ; i < array . length ; i ++ ) { max1 = Math . max ( max1 , array [ i ] + i ) ; min1 = Math . min ( min1 , array [ i ] + i ) ; max2 = Math . max ( max2 , array [ i ] - i ) ; min2 = Math . min ( min2 , array [ i ] - i ) ; } return Math . max ( max1 - min1 , max2 - min2 ) ; }"
"Translate Python to Java: def check ( n , m ) : NEW_LINE INDENT if ( m % n == 0 ) : NEW_LINE INDENT return "" YES "" NEW_LINE DEDENT else : NEW_LINE INDENT return "" NO "" NEW_LINE DEDENT DEDENT","static String check ( int n , int m ) { if ( m % n == 0 ) { return "" YES "" ; } else { return "" NO "" ; } }"
"Translate Python to Java: def pointsAreOnSameSideOfLine ( a , b , c , x1 , y1 , x2 , y2 ) : NEW_LINE INDENT fx1 = 0 NEW_LINE fx2 = 0 NEW_LINE fx1 = a * x1 + b * y1 - c NEW_LINE fx2 = a * x2 + b * y2 - c NEW_LINE if ( ( fx1 * fx2 ) > 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT","static boolean pointsAreOnSameSideOfLine ( int a , int b , int c , int x1 , int y1 , int x2 , int y2 ) { int fx1 ; int fx2 ; fx1 = a * x1 + b * y1 - c ; fx2 = a * x2 + b * y2 - c ; if ( ( fx1 * fx2 ) > 0 ) return true ; return false ; }"
Translate Python to Java: def countSolutions ( a ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( a + 1 ) : NEW_LINE INDENT if ( a == ( i + ( a ^ i ) ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT,static int countSolutions ( int a ) { int count = 0 ; for ( int i = 0 ; i <= a ; i ++ ) { if ( a == ( i + ( a ^ i ) ) ) count ++ ; } return count ; }
"Translate Python to Java: def maxAND ( L , R ) : NEW_LINE INDENT if ( L == R ) : NEW_LINE INDENT return L NEW_LINE DEDENT elif ( ( R - L ) == 1 ) : NEW_LINE INDENT return ( R & L ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( ( ( R - 1 ) & R ) > ( ( R - 2 ) & ( R - 1 ) ) ) : NEW_LINE INDENT return ( ( R - 1 ) & R ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( R - 2 ) & ( R - 1 ) ) NEW_LINE DEDENT DEDENT DEDENT","static int maxAND ( int L , int R ) { if ( L == R ) return L ; else if ( ( R - L ) == 1 ) return ( R & L ) ; else { if ( ( ( R - 1 ) & R ) > ( ( R - 2 ) & ( R - 1 ) ) ) return ( ( R - 1 ) & R ) ; else return ( ( R - 2 ) & ( R - 1 ) ) ; } }"
"Translate Python to Java: def findSmallest ( a , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( ( a [ j ] % a [ i ] ) >= 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( j == n - 1 ) : NEW_LINE INDENT return a [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT","static int findSmallest ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( a [ j ] % a [ i ] >= 1 ) break ; if ( j == n ) return a [ i ] ; } return - 1 ; }"
"Translate Python to Java: def sum ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 1 / pow ( 3 , n ) + sum ( n - 1 ) NEW_LINE DEDENT","static double sum ( int n ) { if ( n == 0 ) return 1 ; double ans = 1 / ( double ) Math . pow ( 3 , n ) + sum ( n - 1 ) ; return ans ; }"
"Translate Python to Java: def submatrixXor ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT top_left = ( i + 1 ) * ( j + 1 ) NEW_LINE bottom_right = ( n - i ) * ( n - j ) NEW_LINE if ( top_left % 2 == 1 and bottom_right % 2 == 1 ) : NEW_LINE INDENT ans = ( ans ^ arr [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT","static int submatrixXor ( int [ ] [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int top_left = ( i + 1 ) * ( j + 1 ) ; int bottom_right = ( n - i ) * ( n - j ) ; if ( ( top_left % 2 == 1 ) && ( bottom_right % 2 == 1 ) ) ans = ( ans ^ arr [ i ] [ j ] ) ; } } return ans ; }"
"Translate Python to Java: def xorEqualsOrCount ( N ) : NEW_LINE INDENT count = 0 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT bit = N % 2 NEW_LINE if bit == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT N //= 2 NEW_LINE DEDENT return int ( pow ( 2 , count ) ) NEW_LINE DEDENT","static int xorEqualsOrCount ( int N ) { int count = 0 ; int bit ; while ( N > 0 ) { bit = N % 2 ; if ( bit == 0 ) count ++ ; N = N / 2 ; } return ( int ) Math . pow ( 2 , count ) ; }"
"Translate Python to Java: def isUnique ( a , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT sum += n - 1 NEW_LINE return ( sum == k ) NEW_LINE DEDENT","static boolean isUnique ( int [ ] a , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; sum += n - 1 ; return ( sum == k ) ; }"
"Translate Python to Java: def check ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE s = ' ' . join ( sorted ( s ) ) NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT if ord ( s [ i ] ) - ord ( s [ i - 1 ] ) != 1 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT",static boolean check ( char s [ ] ) { int l = s . length ; Arrays . sort ( s ) ; for ( int i = 1 ; i < l ; i ++ ) { if ( s [ i ] - s [ i - 1 ] != 1 ) return false ; } return true ; }
Translate Python to Java: def onlyFirstAndLastAreSet ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return ( ( ( n - 1 ) & ( n - 2 ) ) == 0 ) NEW_LINE DEDENT,static boolean onlyFirstAndLastAreSet ( int n ) { if ( n == 1 ) return true ; if ( n == 2 ) return false ; return ( ( ( n - 1 ) & ( n - 2 ) ) == 0 ) ; }
"Translate Python to Java: def maxPartition ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE P = 0 NEW_LINE current = "" "" NEW_LINE previous = "" "" NEW_LINE for i in range ( n ) : NEW_LINE INDENT current += s [ i ] NEW_LINE if ( current != previous ) : NEW_LINE INDENT previous = current NEW_LINE current = "" "" NEW_LINE P += 1 NEW_LINE DEDENT DEDENT return P NEW_LINE DEDENT","static int maxPartition ( String s ) { int n = s . length ( ) , P = 0 ; String current = "" "" , previous = "" "" ; for ( int i = 0 ; i < n ; i ++ ) { current += s . charAt ( i ) ; if ( ! current . equals ( previous ) ) { previous = current ; current = "" "" ; P ++ ; } } return P ; }"
"Translate Python to Java: def findNum ( N , K ) : NEW_LINE INDENT rem = N % K NEW_LINE if ( rem == 0 ) : NEW_LINE INDENT return N NEW_LINE DEDENT else : NEW_LINE INDENT return N - rem NEW_LINE DEDENT DEDENT","static int findNum ( int N , int K ) { int rem = N % K ; if ( rem == 0 ) return N ; else return N - rem ; }"
"Translate Python to Java: def successiveChange ( arr , N ) : NEW_LINE INDENT result = 0 NEW_LINE var1 = arr [ 0 ] NEW_LINE var2 = arr [ 1 ] NEW_LINE result = float ( var1 + var2 + ( float ( var1 * var2 ) / 100 ) ) NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT result = ( result + arr [ i ] + ( float ( result * arr [ i ] ) / 100 ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT","static float successiveChange ( int arr [ ] , int N ) { float var1 , var2 , result = 0 ; var1 = arr [ 0 ] ; var2 = arr [ 1 ] ; result = var1 + var2 + ( ( var1 * var2 ) / 100 ) ; for ( int i = 2 ; i < N ; i ++ ) result = result + arr [ i ] + ( ( result * arr [ i ] ) / 100 ) ; return result ; }"
"Translate Python to Java: def answer ( arr , ranges , reversals , index ) : NEW_LINE INDENT i = reversals - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT left = ranges [ i ] [ 0 ] NEW_LINE right = ranges [ i ] [ 1 ] NEW_LINE if ( left <= index and right >= index ) : NEW_LINE INDENT index = right + left - index NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return arr [ index ] NEW_LINE DEDENT","static int answer ( int [ ] arr , int [ ] [ ] ranges , int reversals , int index ) { for ( int i = reversals - 1 ; i >= 0 ; i -- ) { int left = ranges [ i ] [ 0 ] , right = ranges [ i ] [ 1 ] ; if ( left <= index && right >= index ) index = right + left - index ; } return arr [ index ] ; }"
Translate Python to Java: def judgeSquareSum ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n % i == 0 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n = int ( n / i ) NEW_LINE DEDENT if ( i % 4 == 3 and count % 2 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return n % 4 != 3 NEW_LINE DEDENT,public static boolean judgeSquareSum ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { int count = 0 ; if ( n % i == 0 ) { while ( n % i == 0 ) { count ++ ; n /= i ; } if ( i % 4 == 3 && count % 2 != 0 ) return false ; } } return n % 4 != 3 ; }
"Translate Python to Java: def getCount ( a , b ) : NEW_LINE INDENT if ( len ( b ) % len ( a ) != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT count = int ( len ( b ) / len ( a ) ) NEW_LINE a = a * count NEW_LINE if ( a == b ) : NEW_LINE INDENT return count NEW_LINE DEDENT return - 1 NEW_LINE DEDENT","static int getCount ( String a , String b ) { if ( b . length ( ) % a . length ( ) != 0 ) return - 1 ; int count = b . length ( ) / a . length ( ) ; String str = "" "" ; for ( int i = 0 ; i < count ; i ++ ) { str = str + a ; } if ( str . equals ( b ) ) return count ; return - 1 ; }"
"Translate Python to Java: def tidyNum ( str , len ) : NEW_LINE INDENT for i in range ( len - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] > str [ i + 1 ] ) : NEW_LINE INDENT str [ i ] -= 1 NEW_LINE for j in range ( i + 1 , len ) : NEW_LINE INDENT str [ j ] = 9 NEW_LINE DEDENT DEDENT DEDENT return str NEW_LINE DEDENT","static String tidyNum ( String str1 , int len ) { char [ ] str = str1 . toCharArray ( ) ; for ( int i = len - 2 ; i >= 0 ; i -- ) { if ( str [ i ] > str [ i + 1 ] ) { str [ i ] -- ; for ( int j = i + 1 ; j < len ; j ++ ) str [ j ] = '9' ; } } return String . valueOf ( str ) ; }"
"Translate Python to Java: def findMinValue ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE val = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT val += ( math . log ( arr [ i ] ) ) NEW_LINE DEDENT left = arr [ 0 ] NEW_LINE right = arr [ n - 1 ] + 1 NEW_LINE while ( left <= right ) : NEW_LINE INDENT mid = ( left + right ) // 2 NEW_LINE temp = n * ( math . log ( mid ) ) NEW_LINE if ( val < temp ) : NEW_LINE INDENT ans = mid NEW_LINE right = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT left = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT","static long findMinValue ( long arr [ ] , int n ) { Arrays . sort ( arr ) ; double val = 0 ; for ( int i = 0 ; i < n ; i ++ ) { val += ( double ) ( Math . log ( ( double ) ( arr [ i ] ) ) ) ; } long left = arr [ 0 ] , right = arr [ n - 1 ] ; long ans = 0 ; while ( left <= right ) { long mid = ( left + right ) / 2 ; double temp = ( double ) n * ( double ) ( Math . log ( ( double ) ( mid ) ) ) ; if ( val < temp ) { ans = mid ; right = mid - 1 ; } else { left = mid + 1 ; } } return ans ; }"
"Translate Python to Java: def largestSubStr ( s ) : NEW_LINE INDENT while ( len ( s ) and s [ len ( s ) - 1 ] == '1' ) : NEW_LINE INDENT s = s [ : len ( s ) - 1 ] NEW_LINE DEDENT if ( len ( s ) == 0 ) : NEW_LINE INDENT return "" - 1"" NEW_LINE DEDENT else : NEW_LINE INDENT return s NEW_LINE DEDENT DEDENT","static String largestSubStr ( String s ) { while ( s . length ( ) != 0 && s . charAt ( s . length ( ) - 1 ) == '1' ) s = s . substring ( 0 , s . length ( ) - 1 ) ; if ( s . length ( ) == 0 ) return "" - 1"" ; else return s ; }"
"Translate Python to Java: def MinRemove ( a , n , k ) : NEW_LINE INDENT cnt = [ 0 ] * k NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT cnt [ 0 ] += 1 NEW_LINE DEDENT elif ( cnt [ a [ i ] - 1 ] > 0 ) : NEW_LINE INDENT cnt [ a [ i ] - 1 ] -= 1 NEW_LINE cnt [ a [ i ] ] += 1 NEW_LINE DEDENT DEDENT return n - ( k * cnt [ k - 1 ] ) NEW_LINE DEDENT","static int MinRemove ( int [ ] a , int n , int k ) { int [ ] cnt = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) cnt [ 0 ] ++ ; else if ( cnt [ a [ i ] - 1 ] > 0 ) { cnt [ a [ i ] - 1 ] -- ; cnt [ a [ i ] ] ++ ; } } return n - ( k * cnt [ k - 1 ] ) ; }"
"Translate Python to Java: def getMaxMedian ( arr , n , k ) : NEW_LINE INDENT size = n + k NEW_LINE arr . sort ( reverse = False ) NEW_LINE if ( size % 2 == 0 ) : NEW_LINE INDENT median = ( arr [ int ( size / 2 ) - 1 ] + arr [ int ( size / 2 ) ] ) / 2 NEW_LINE return median NEW_LINE DEDENT median = arr [ int ( size / 2 ) ] NEW_LINE return median NEW_LINE DEDENT","static double getMaxMedian ( int [ ] arr , int n , int k ) { int size = n + k ; Arrays . sort ( arr ) ; if ( size % 2 == 0 ) { double median = ( double ) ( arr [ ( size / 2 ) - 1 ] + arr [ size / 2 ] ) / 2 ; return median ; } double median1 = arr [ size / 2 ] ; return median1 ; }"
"Translate Python to Java: def MinStep ( a , n ) : NEW_LINE INDENT positive = 0 NEW_LINE negative = 0 NEW_LINE zero = 0 NEW_LINE step = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT elif ( a [ i ] < 0 ) : NEW_LINE INDENT negative += 1 NEW_LINE step = step + ( - 1 - a [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT positive += 1 NEW_LINE step = step + ( a [ i ] - 1 ) NEW_LINE DEDENT DEDENT if ( negative % 2 == 0 ) : NEW_LINE INDENT step = step + zero NEW_LINE DEDENT else : NEW_LINE INDENT if ( zero > 0 ) : NEW_LINE INDENT step = step + zero NEW_LINE DEDENT else : NEW_LINE INDENT step = step + 2 NEW_LINE DEDENT DEDENT return step NEW_LINE DEDENT","static int MinStep ( int a [ ] , int n ) { int positive = 0 , negative = 0 , zero = 0 ; int step = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { zero ++ ; } else if ( a [ i ] < 0 ) { negative ++ ; step = step + ( - 1 - a [ i ] ) ; } else { positive ++ ; step = step + ( a [ i ] - 1 ) ; } } if ( negative % 2 == 0 ) { step = step + zero ; } else { if ( zero > 0 ) { step = step + zero ; } else { step = step + 2 ; } } return step ; }"
"Translate Python to Java: def findNthEvenDigitNumber ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT v = [ ] NEW_LINE n = n - 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT v . append ( n % 5 ) NEW_LINE n = n // 5 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( len ( v ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT result = result * 10 NEW_LINE result = result + v [ i ] NEW_LINE DEDENT return 2 * result NEW_LINE DEDENT",static int findNthEvenDigitNumber ( int n ) { if ( n == 1 ) { return 0 ; } Vector < Integer > v = new Vector < > ( ) ; n = n - 1 ; while ( n > 0 ) { v . add ( n % 5 ) ; n = n / 5 ; } int result = 0 ; for ( int i = v . size ( ) - 1 ; i >= 0 ; i -- ) { result = result * 10 ; result = result + v . get ( i ) ; } return 2 * result ; }
Translate Python to Java: def areSetBitIncreasing ( n ) : NEW_LINE INDENT prev_count = sys . maxsize NEW_LINE while ( n > 0 ) : NEW_LINE INDENT while ( n > 0 and n % 2 == 0 ) : NEW_LINE INDENT n = int ( n / 2 ) NEW_LINE DEDENT curr_count = 1 NEW_LINE while ( n > 0 and n % 2 == 1 ) : NEW_LINE INDENT n = n / 2 NEW_LINE curr_count += 1 NEW_LINE DEDENT if ( curr_count >= prev_count ) : NEW_LINE INDENT return False NEW_LINE DEDENT prev_count = curr_count NEW_LINE DEDENT return True NEW_LINE DEDENT,static boolean areSetBitsIncreasing ( int n ) { int prev_count = Integer . MAX_VALUE ; while ( n > 0 ) { while ( n > 0 && n % 2 == 0 ) n = n / 2 ; int curr_count = 1 ; while ( n > 0 && n % 2 == 1 ) { n = n / 2 ; curr_count ++ ; } if ( curr_count >= prev_count ) return false ; prev_count = curr_count ; } return true ; }
"Translate Python to Java: def closestMultiple ( n , x ) : NEW_LINE INDENT if x > n : NEW_LINE INDENT return x NEW_LINE DEDENT z = ( int ) ( x / 2 ) NEW_LINE n = n + z NEW_LINE n = n - ( n % x ) NEW_LINE return n NEW_LINE DEDENT","static int closestMultiple ( int n , int x ) { if ( x > n ) return x ; n = n + x / 2 ; n = n - ( n % x ) ; return n ; }"
"Translate Python to Java: def sumOfTheSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT k = 2 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT sum = sum + k NEW_LINE k = k + 2 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT",static int sumOfTheSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int k = 2 ; for ( int j = 1 ; j <= i ; j ++ ) { sum += k ; k += 2 ; } } return sum ; }
"Translate Python to Java: def sumOfParallelSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT k = 1 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT sum += k NEW_LINE k += 2 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT",static int sumOfTheSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int k = 1 ; for ( int j = 1 ; j <= i ; j ++ ) { sum += k ; k += 2 ; } } return sum ; }
"Translate Python to Java: def find_maxm ( arr , n ) : NEW_LINE INDENT mpp = { } NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] in mpp ) : NEW_LINE INDENT mpp . update ( { arr [ i ] : mpp [ arr [ i ] ] + 1 } ) NEW_LINE DEDENT else : NEW_LINE INDENT mpp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for value , freq in mpp . items ( ) : NEW_LINE INDENT if ( value == freq ) : NEW_LINE INDENT ans = max ( ans , value ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT","static int find_maxm ( int arr [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } int ans = 0 ; for ( Map . Entry < Integer , Integer > x : mp . entrySet ( ) ) { int value = x . getKey ( ) ; int freq = x . getValue ( ) ; if ( value == freq ) { ans = Math . max ( ans , value ) ; } } return ans ; }"
"Translate Python to Java: def getMaxLength ( arr , n ) : NEW_LINE INDENT l = n NEW_LINE i = 0 ; maxlen = 0 NEW_LINE while ( i < l ) : NEW_LINE INDENT j = i NEW_LINE while ( i + 1 < l and ( abs ( arr [ i ] - arr [ i + 1 ] ) == 1 or abs ( arr [ i ] - arr [ i + 1 ] ) == 0 ) ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT currLen = i - j + 1 NEW_LINE if ( maxlen < currLen ) : NEW_LINE INDENT maxlen = currLen NEW_LINE DEDENT if ( j == i ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return maxlen NEW_LINE DEDENT","public static int getMaxLength ( int arr [ ] ) { int l = arr . length ; int i = 0 , maxlen = 0 ; while ( i < l ) { int j = i ; while ( i + 1 < l && ( Math . abs ( arr [ i ] - arr [ i + 1 ] ) == 1 || Math . abs ( arr [ i ] - arr [ i + 1 ] ) == 0 ) ) { i ++ ; } int currLen = i - j + 1 ; if ( maxlen < currLen ) maxlen = currLen ; if ( j == i ) i ++ ; } maxlen = ( maxlen == 1 ) ? 0 : maxlen ; return maxlen ; }"
"Translate Python to Java: def countPairs ( a , n ) : NEW_LINE INDENT mp = dict . fromkeys ( a , 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ a [ i ] ] += 1 NEW_LINE DEDENT a . sort ( reverse = True ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( mp [ a [ i ] ] < 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT cur = 1 NEW_LINE while ( cur <= a [ i ] ) : NEW_LINE INDENT cur = cur << 1 NEW_LINE DEDENT if ( cur - a [ i ] in mp . keys ( ) ) : NEW_LINE INDENT if ( cur - a [ i ] == a [ i ] and mp [ a [ i ] ] == 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT count += 1 NEW_LINE mp [ cur - a [ i ] ] -= 1 NEW_LINE mp [ a [ i ] ] -= 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT","static int countPairs ( int [ ] a , int n ) { TreeMap < Integer , Integer > map = new TreeMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { map . put ( a [ i ] , 1 ) ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( map . get ( a [ i ] ) < 1 ) continue ; int cur = 1 ; while ( cur <= a [ i ] ) cur <<= 1 ; if ( map . containsKey ( cur - a [ i ] ) ) { if ( cur - a [ i ] == a [ i ] && map . get ( a [ i ] ) == 1 ) continue ; count ++ ; map . put ( cur - a [ i ] , map . get ( cur - a [ i ] ) - 1 ) ; map . put ( a [ i ] , map . get ( a [ i ] ) - 1 ) ; } } return count ; }"
Translate Python to Java: def tggle ( n ) : NEW_LINE INDENT temp = 1 NEW_LINE while ( temp <= n ) : NEW_LINE INDENT n = n ^ temp NEW_LINE temp = temp << 1 NEW_LINE DEDENT return n NEW_LINE DEDENT,static int toggle ( int n ) { int temp = 1 ; while ( temp <= n ) { n = n ^ temp ; temp = temp << 1 ; } return n ; }
"Translate Python to Java: def minChanges ( A , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT if ( ( i - 1 >= 0 ) and A [ i - 1 ] == 1 and A [ i + 1 ] == 1 and A [ i ] == 0 ) : NEW_LINE INDENT A [ i + 1 ] = 0 NEW_LINE cnt = cnt + 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT","static int minChanges ( int [ ] A , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 2 ; ++ i ) { if ( ( i - 1 >= 0 ) && A [ i - 1 ] == 1 && A [ i + 1 ] == 1 && A [ i ] == 0 ) { A [ i + 1 ] = 0 ; cnt ++ ; } } return cnt ; }"
Translate Python to Java: def Convert ( radian ) : NEW_LINE INDENT pi = 3.14159 NEW_LINE degree = radian * ( 180 / pi ) NEW_LINE return degree NEW_LINE DEDENT,static double Convert ( double radian ) { double pi = 3.14159 ; return ( radian * ( 180 / pi ) ) ; }
Translate Python to Java: def edgeDisjoint ( n ) : NEW_LINE INDENT result = 0 NEW_LINE result = math . floor ( n / 2 ) NEW_LINE return result NEW_LINE DEDENT,static double edgeDisjoint ( int n ) { double result = 0 ; result = Math . floor ( n / 2 ) ; return result ; }
"Translate Python to Java: def sumOfAP ( a , d , n ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT sum = sum + a NEW_LINE a = a + d NEW_LINE i = i + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT","static float sumOfAP ( float a , float d , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + a ; a = a + d ; } return sum ; }"
Translate Python to Java: def makeOdd ( n ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT resul = 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = n / 2 NEW_LINE resul = resul * 2 NEW_LINE DEDENT return resul NEW_LINE DEDENT,static int makeOdd ( int n ) { if ( n % 2 != 0 ) return 1 ; int ans = 1 ; while ( n % 2 == 0 ) { n /= 2 ; ans *= 2 ; } return ans ; }
"Translate Python to Java: def Square ( row , column , moves ) : NEW_LINE INDENT a = 0 ; b = 0 ; c = 0 NEW_LINE d = 0 ; total = 0 NEW_LINE a = row - moves NEW_LINE b = row + moves NEW_LINE c = column - moves NEW_LINE d = column + moves NEW_LINE if ( a < 1 ) : NEW_LINE INDENT a = 1 NEW_LINE DEDENT if ( c < 1 ) : NEW_LINE INDENT c = 1 NEW_LINE DEDENT if ( b > 8 ) : NEW_LINE INDENT b = 8 NEW_LINE DEDENT if ( d > 8 ) : NEW_LINE INDENT d = 8 NEW_LINE DEDENT total = ( b - a + 1 ) * ( d - c + 1 ) - 1 NEW_LINE return total NEW_LINE DEDENT","static int Square ( int row , int column , int moves ) { int a = 0 , b = 0 , c = 0 , d = 0 , total = 0 ; a = row - moves ; b = row + moves ; c = column - moves ; d = column + moves ; if ( a < 1 ) a = 1 ; if ( c < 1 ) c = 1 ; if ( b > 8 ) b = 8 ; if ( d > 8 ) d = 8 ; total = ( b - a + 1 ) * ( d - c + 1 ) - 1 ; return total ; }"
Translate Python to Java: def findNumber ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE i = 1 NEW_LINE while n >= 0 : NEW_LINE INDENT n -= i NEW_LINE i += 1 NEW_LINE DEDENT return ( n + i ) NEW_LINE DEDENT,static int findNumber ( int n ) { n -- ; int i = 1 ; while ( n >= 0 ) { n -= i ; ++ i ; } return ( n + i ) ; }
"Translate Python to Java: def findSmallest ( s ) : NEW_LINE INDENT length = len ( s ) NEW_LINE loccur = [ - 1 ] * 26 NEW_LINE for i in range ( length - 1 , - 1 , - 1 ) : NEW_LINE INDENT chI = ord ( s [ i ] ) - ord ( ' a ' ) NEW_LINE if ( loccur [ chI ] == - 1 ) : NEW_LINE INDENT loccur [ chI ] = i NEW_LINE DEDENT DEDENT sorted_s = s NEW_LINE sorted_s . sort ( ) NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( s [ i ] != sorted_s [ i ] ) : NEW_LINE INDENT chI = ord ( sorted_s [ i ] ) - ord ( ' a ' ) NEW_LINE last_occ = loccur [ chI ] NEW_LINE s [ i ] , s [ last_occ ] = s [ last_occ ] , s [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT return "" "" . join ( s ) NEW_LINE DEDENT","static String findSmallest ( char [ ] s ) { int len = s . length ; int [ ] loccur = new int [ 26 ] ; Arrays . fill ( loccur , - 1 ) ; for ( int i = len - 1 ; i >= 0 ; -- i ) { int chI = s [ i ] - ' a ' ; if ( loccur [ chI ] == - 1 ) { loccur [ chI ] = i ; } } char [ ] sorted_s = s ; Arrays . sort ( sorted_s ) ; for ( int i = 0 ; i < len ; ++ i ) { if ( s [ i ] != sorted_s [ i ] ) { int chI = sorted_s [ i ] - ' a ' ; int last_occ = loccur [ chI ] ; char temp = s [ last_occ ] ; s [ last_occ ] = s [ i ] ; s [ i ] = temp ; break ; } } return String . valueOf ( s ) ; }"
"Translate Python to Java: def rangesum ( n , l , r ) : NEW_LINE INDENT arr = [ 0 ] * n NEW_LINE c = 1 ; i = 0 NEW_LINE while ( c <= n ) : NEW_LINE INDENT arr [ i ] = c NEW_LINE i += 1 NEW_LINE c += 2 NEW_LINE DEDENT c = 2 NEW_LINE while ( c <= n ) : NEW_LINE INDENT arr [ i ] = c NEW_LINE i += 1 NEW_LINE c += 2 NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( l - 1 , r , 1 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT","static int rangesum ( int n , int l , int r ) { int [ ] arr = new int [ n ] ; int c = 1 , i = 0 ; while ( c <= n ) { arr [ i ++ ] = c ; c += 2 ; } c = 2 ; while ( c <= n ) { arr [ i ++ ] = c ; c += 2 ; } int sum = 0 ; for ( i = l - 1 ; i < r ; i ++ ) { sum += arr [ i ] ; } return sum ; }"
"Translate Python to Java: def getHCF ( x , y ) : NEW_LINE INDENT minimum = min ( x , y ) NEW_LINE if ( x % minimum == 0 and y % minimum == 0 ) : NEW_LINE INDENT return minimum NEW_LINE DEDENT for i in range ( minimum // 2 , 1 , - 1 ) : NEW_LINE INDENT if ( x % i == 0 and y % i == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT","static int getHCF ( int x , int y ) { int minimum = Math . min ( x , y ) ; if ( x % minimum == 0 && y % minimum == 0 ) return minimum ; for ( int i = minimum / 2 ; i >= 2 ; i -- ) { if ( x % i == 0 && y % i == 0 ) return i ; } return 1 ; }"
"Translate Python to Java: def findNthNumber ( A , B , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT sum = A + B NEW_LINE A = B NEW_LINE B = sum NEW_LINE DEDENT return sum NEW_LINE DEDENT","static int findNthNumber ( int A , int B , int N ) { int sum = 0 ; for ( int i = 2 ; i < N ; i ++ ) { sum = A + B ; A = B ; B = sum ; } return sum ; }"
"Translate Python to Java: def findOccurrences ( str , substr ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == substr [ 0 ] ) : NEW_LINE INDENT for j in range ( i + 1 , len ( str ) ) : NEW_LINE INDENT if ( str [ j ] == substr [ 1 ] ) : NEW_LINE INDENT for k in range ( j + 1 , len ( str ) ) : NEW_LINE INDENT if ( str [ k ] == substr [ 2 ] ) : NEW_LINE INDENT counter = counter + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return counter NEW_LINE DEDENT","public static int findOccurrences ( String str1 , String substr1 ) { int counter = 0 ; char [ ] str = str1 . toCharArray ( ) ; char [ ] substr = substr1 . toCharArray ( ) ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { if ( str [ i ] == substr [ 0 ] ) { for ( int j = i + 1 ; j < str1 . length ( ) ; j ++ ) { if ( str [ j ] == substr [ 1 ] ) { for ( int k = j + 1 ; k < str1 . length ( ) ; k ++ ) { if ( str [ k ] == substr [ 2 ] ) counter ++ ; } } } } } return counter ; }"
"Translate Python to Java: def emi_calculator ( p , r , t ) : NEW_LINE INDENT r = r / ( 12 * 100 ) NEW_LINE t = t * 12 NEW_LINE emi = ( p * r * pow ( 1 + r , t ) ) / ( pow ( 1 + r , t ) - 1 ) NEW_LINE return emi NEW_LINE DEDENT","static float emi_calculator ( float p , float r , float t ) { float emi ; r = r / ( 12 * 100 ) ; t = t * 12 ; emi = ( p * r * ( float ) Math . pow ( 1 + r , t ) ) / ( float ) ( Math . pow ( 1 + r , t ) - 1 ) ; return ( emi ) ; }"
"Translate Python to Java: def countTriplets ( A , B , C ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , A + 1 ) : NEW_LINE INDENT for j in range ( 1 , B + 1 ) : NEW_LINE INDENT for k in range ( 1 , C + 1 ) : NEW_LINE INDENT if ( i * k > j * j ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT","static long countTriplets ( int A , int B , int C ) { long ans = 0 ; for ( int i = 1 ; i <= A ; i ++ ) { for ( int j = 1 ; j <= B ; j ++ ) { for ( int k = 1 ; k <= C ; k ++ ) { if ( i * k > j * j ) ans ++ ; } } } return ans ; }"
"Translate Python to Java: def countNums ( l , r ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT lastDigit = ( i % 10 ) NEW_LINE if ( ( lastDigit % 10 ) == 2 or ( lastDigit % 10 ) == 3 or ( lastDigit % 10 ) == 9 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT","static int countNums ( int l , int r ) { int cnt = 0 ; for ( int i = l ; i <= r ; i ++ ) { int lastDigit = ( i % 10 ) ; if ( ( lastDigit % 10 ) == 2 || ( lastDigit % 10 ) == 3 || ( lastDigit % 10 ) == 9 ) { cnt ++ ; } } return cnt ; }"
"Translate Python to Java: def longestAr ( n , arr ) : NEW_LINE INDENT count = dict ( ) NEW_LINE for i in arr : NEW_LINE INDENT count [ i ] = count . get ( i , 0 ) + 1 NEW_LINE DEDENT kset = count . keys ( ) NEW_LINE maxm = 0 NEW_LINE for it in list ( kset ) : NEW_LINE INDENT a = it NEW_LINE cur = 0 NEW_LINE cur1 = 0 NEW_LINE cur2 = 0 NEW_LINE if ( ( a + 1 ) in count ) : NEW_LINE INDENT cur1 = count [ a + 1 ] NEW_LINE DEDENT if ( ( a - 1 ) in count ) : NEW_LINE INDENT cur2 = count [ a - 1 ] NEW_LINE DEDENT cur = count [ a ] + max ( cur1 , cur2 ) NEW_LINE if ( cur > maxm ) : NEW_LINE INDENT maxm = cur NEW_LINE DEDENT DEDENT return maxm NEW_LINE DEDENT","public static int longestAr ( int n , int arr [ ] ) { Hashtable < Integer , Integer > count = new Hashtable < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( count . containsKey ( arr [ i ] ) ) count . put ( arr [ i ] , count . get ( arr [ i ] ) + 1 ) ; else count . put ( arr [ i ] , 1 ) ; } Set < Integer > kset = count . keySet ( ) ; Iterator < Integer > it = kset . iterator ( ) ; int max = 0 ; while ( it . hasNext ( ) ) { int a = ( int ) it . next ( ) ; int cur = 0 ; int cur1 = 0 ; int cur2 = 0 ; if ( count . containsKey ( a + 1 ) ) cur1 = count . get ( a + 1 ) ; if ( count . containsKey ( a - 1 ) ) cur2 = count . get ( a - 1 ) ; cur = count . get ( a ) + Math . max ( cur1 , cur2 ) ; if ( cur > max ) max = cur ; } return ( max ) ; }"
"Translate Python to Java: def findMaxLenEven ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE i = 0 NEW_LINE currlen = 0 NEW_LINE maxlen = 0 NEW_LINE st = - 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( str [ i ] == '  ' ) : NEW_LINE INDENT if ( currlen % 2 == 0 ) : NEW_LINE INDENT if ( maxlen < currlen ) : NEW_LINE INDENT maxlen = currlen NEW_LINE st = i - currlen NEW_LINE DEDENT DEDENT currlen = 0 NEW_LINE DEDENT else : NEW_LINE INDENT currlen += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( currlen % 2 == 0 ) : NEW_LINE INDENT if ( maxlen < currlen ) : NEW_LINE INDENT maxlen = currlen NEW_LINE st = i - currlen NEW_LINE DEDENT DEDENT if ( st == - 1 ) : NEW_LINE INDENT print ( "" trie "" ) NEW_LINE return "" - 1"" NEW_LINE DEDENT return str [ st : st + maxlen ] NEW_LINE DEDENT","static String findMaxLenEven ( String str ) { int n = str . length ( ) ; int i = 0 ; int currlen = 0 ; int maxlen = 0 ; int st = - 1 ; while ( i < n ) { if ( str . charAt ( i ) == '  ' ) { if ( currlen % 2 == 0 ) { if ( maxlen < currlen ) { maxlen = currlen ; st = i - currlen ; } } currlen = 0 ; } else { currlen ++ ; } i ++ ; } if ( currlen % 2 == 0 ) { if ( maxlen < currlen ) { maxlen = currlen ; st = i - currlen ; } } if ( st == - 1 ) return "" - 1"" ; return str . substring ( st , st + maxlen ) ; }"
Translate Python to Java: def cnt ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE p = 1 NEW_LINE while ( p <= n ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE p *= 2 NEW_LINE DEDENT return cnt NEW_LINE DEDENT,static int count ( int n ) { int cnt = 0 ; int p = 1 ; while ( p <= n ) { cnt ++ ; p *= 2 ; } return cnt ; }
"Translate Python to Java: def lexo_small ( n , k ) : NEW_LINE INDENT arr = "" "" NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr += ' a ' NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT k -= i NEW_LINE if ( k >= 0 ) : NEW_LINE INDENT if ( k >= 26 ) : NEW_LINE INDENT arr = arr [ : i ] + ' z ' + arr [ i + 1 : ] NEW_LINE k -= 26 NEW_LINE DEDENT else : NEW_LINE INDENT c = ( k + 97 - 1 ) NEW_LINE arr = arr [ : i ] + chr ( c ) + arr [ i + 1 : ] NEW_LINE k -= ord ( arr [ i ] ) - ord ( ' a ' ) + 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT k += i NEW_LINE DEDENT return arr NEW_LINE DEDENT","public static char [ ] lexo_small ( int n , int k ) { char arr [ ] = new char [ n ] ; Arrays . fill ( arr , ' a ' ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { k -= i ; if ( k >= 0 ) { if ( k >= 26 ) { arr [ i ] = ' z ' ; k -= 26 ; } else { arr [ i ] = ( char ) ( k + 97 - 1 ) ; k -= arr [ i ] - ' a ' + 1 ; } } else break ; k += i ; } return arr ; }"
"Translate Python to Java: def maxDistance ( n , fuel ) : NEW_LINE INDENT dist_covered = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT dist_covered = dist_covered + ( fuel / n ) NEW_LINE n = n - 1 NEW_LINE DEDENT return dist_covered NEW_LINE DEDENT","static double maxDistance ( int n , int fuel ) { double dist_covered = 0 ; while ( n > 0 ) { dist_covered += ( double ) fuel / n ; n -= 1 ; } return dist_covered ; }"
"Translate Python to Java: def findSplit ( arr , n ) : NEW_LINE INDENT preSum = 0 NEW_LINE ind1 = - 1 NEW_LINE ind2 = - 1 NEW_LINE S = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT S += arr [ i ] NEW_LINE DEDENT if ( S % 3 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT S1 = S / 3 NEW_LINE S2 = 2 * S1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT preSum += arr [ i ] NEW_LINE if ( preSum % S1 == 0 and ind1 == - 1 ) : NEW_LINE INDENT ind1 = i NEW_LINE DEDENT elif ( preSum % S2 == 0 ) : NEW_LINE INDENT ind2 = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( ind1 != - 1 and ind2 != - 1 ) : NEW_LINE INDENT print ( "" ( { } ,  { } ) "" . format ( ind1 , ind2 ) ) NEW_LINE return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT","static int findSplit ( int [ ] arr , int n ) { int i ; int preSum = 0 ; int ind1 = - 1 , ind2 = - 1 ; int S ; S = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) S += arr [ i ] ; if ( S % 3 != 0 ) return 0 ; int S1 = S / 3 ; int S2 = 2 * S1 ; for ( i = 0 ; i < n ; i ++ ) { preSum += arr [ i ] ; if ( preSum % S1 == 0 && ind1 == - 1 ) ind1 = i ; else if ( preSum % S2 == 0 ) { ind2 = i ; break ; } } if ( ind1 != - 1 && ind2 != - 1 ) { System . out . print ( "" ( "" + ind1 + "" ,  "" + ind2 + "" ) "" ) ; return 1 ; } return 0 ; }"
"Translate Python to Java: def findSum ( arr , n , left , right ) : NEW_LINE INDENT k = right - left NEW_LINE d = arr [ 1 ] - arr [ 0 ] NEW_LINE ans = arr [ left - 1 ] * ( k + 1 ) NEW_LINE ans = ans + ( d * ( k * ( k + 1 ) ) ) // 2 NEW_LINE return ans NEW_LINE DEDENT","static int findSum ( int [ ] arr , int n , int left , int right ) { int k = right - left ; int d = arr [ 1 ] - arr [ 0 ] ; int ans = arr [ left - 1 ] * ( k + 1 ) ; ans = ans + ( d * ( k * ( k + 1 ) ) ) / 2 ; return ans ; }"
"Translate Python to Java: def isWordPresent ( sentence , word ) : NEW_LINE INDENT s = sentence . split ( ""  "" ) NEW_LINE for i in s : NEW_LINE INDENT if ( i == word ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT","static boolean isWordPresent ( String sentence , String word ) { String [ ] s = sentence . split ( ""  "" ) ; for ( String temp : s ) { if ( temp . compareTo ( word ) == 0 ) { return true ; } } return false ; }"
"Translate Python to Java: def countDigit ( n ) : NEW_LINE INDENT return math . floor ( math . log ( n , 10 ) + 1 ) NEW_LINE DEDENT",static int countDigit ( long n ) { return ( int ) Math . floor ( Math . log10 ( n ) + 1 ) ; }
"Translate Python to Java: def canBeEqual ( a , b , c , k ) : NEW_LINE INDENT arr = [ 0 ] * 3 NEW_LINE arr [ 0 ] = a NEW_LINE arr [ 1 ] = b NEW_LINE arr [ 2 ] = c NEW_LINE arr . sort ( ) NEW_LINE diff = 2 * arr [ 2 ] - arr [ 1 ] - arr [ 0 ] NEW_LINE k = k - diff NEW_LINE if ( k < 0 or k % 3 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT","static boolean canBeEqual ( int a , int b , int c , int k ) { int [ ] arr = new int [ 3 ] ; arr [ 0 ] = a ; arr [ 1 ] = b ; arr [ 2 ] = c ; Arrays . sort ( arr ) ; int diff = 2 * arr [ 2 ] - arr [ 1 ] - arr [ 0 ] ; k = k - diff ; if ( k < 0 || k % 3 != 0 ) return false ; return true ; }"
"Translate Python to Java: def isRotation ( x , y ) : NEW_LINE INDENT x64 = x | ( x << 32 ) NEW_LINE while ( x64 >= y ) : NEW_LINE INDENT if ( ( x64 ) == y ) : NEW_LINE INDENT return True NEW_LINE DEDENT x64 >>= 1 NEW_LINE DEDENT return False NEW_LINE DEDENT","static boolean isRotation ( long x , long y ) { long x64 = x | ( x << 32 ) ; while ( x64 >= y ) { if ( x64 == y ) { return true ; } x64 >>= 1 ; } return false ; }"
Translate Python to Java: def countConsecutive ( s ) : NEW_LINE INDENT count = - 1 NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if ( i <= len ( s ) ) : NEW_LINE INDENT if ( s [ i ] is s [ i + 1 ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT,static int countConsecutive ( String s ) { int count = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) { i ++ ; } else { count ++ ; } } return count ; }
"Translate Python to Java: def countChars ( string , n ) : NEW_LINE INDENT i = 0 ; cnt = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( string [ i ] == '0' ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 2 NEW_LINE DEDENT cnt += 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT","static int countChars ( String str , int n ) { int i = 0 , cnt = 0 ; while ( i < n ) { if ( str . charAt ( i ) == '0' ) i += 1 ; else i += 2 ; cnt += 1 ; } return cnt ; }"
"Translate Python to Java: def findMinRemoval ( arr , n ) : NEW_LINE INDENT value = 0 NEW_LINE maximum = 0 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( i != 0 and i != n - 1 ) : NEW_LINE INDENT value = value + abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE temp = ( abs ( arr [ i ] - arr [ i + 1 ] ) + abs ( arr [ i ] - arr [ i - 1 ] ) - abs ( arr [ i - 1 ] - arr [ i + 1 ] ) ) NEW_LINE DEDENT elif ( i == 0 ) : NEW_LINE INDENT value = value + abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE temp = abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT temp = abs ( arr [ i ] - arr [ i - 1 ] ) NEW_LINE DEDENT maximum = max ( maximum , temp ) NEW_LINE DEDENT return ( value - maximum ) NEW_LINE DEDENT","static int findMinRemoval ( int arr [ ] , int n ) { int temp , value = 0 ; int maximum = 0 ; if ( n == 1 ) return 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i != 0 && i != n - 1 ) { value = value + Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; temp = Math . abs ( arr [ i ] - arr [ i + 1 ] ) + Math . abs ( arr [ i ] - arr [ i - 1 ] ) - Math . abs ( arr [ i - 1 ] - arr [ i + 1 ] ) ; } else if ( i == 0 ) { value = value + Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; temp = Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; } else temp = Math . abs ( arr [ i ] - arr [ i - 1 ] ) ; maximum = Math . max ( maximum , temp ) ; } return ( value - maximum ) ; }"
"Translate Python to Java: def countMaxSetBits ( left , right ) : NEW_LINE INDENT while ( left | ( left + 1 ) ) <= right : NEW_LINE INDENT left |= left + 1 NEW_LINE DEDENT return left NEW_LINE DEDENT","static int countMaxSetBits ( int left , int right ) { while ( ( left | ( left + 1 ) ) <= right ) left |= left + 1 ; return left ; }"
Translate Python to Java: def setBitNumber ( n ) : NEW_LINE INDENT n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE n = n + 1 NEW_LINE return ( n >> 1 ) NEW_LINE DEDENT,static int setBitNumber ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n = n + 1 ; return ( n >> 1 ) ; }
Translate Python to Java: def isPerfect ( n ) : NEW_LINE INDENT sum = 1 NEW_LINE i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT sum = sum + i + n / i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ( True if sum == n and n != 1 else False ) NEW_LINE DEDENT,static boolean isPerfect ( int n ) { int sum = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i * i != n ) sum = sum + i + n / i ; else sum = sum + i ; } } if ( sum == n && n != 1 ) return true ; return false ; }
Translate Python to Java: def oddDays ( N ) : NEW_LINE INDENT hund1 = N // 100 NEW_LINE hund4 = N // 400 NEW_LINE leap = N >> 2 NEW_LINE ordd = N - leap NEW_LINE if ( hund1 ) : NEW_LINE INDENT ordd += hund1 NEW_LINE leap -= hund1 NEW_LINE DEDENT if ( hund4 ) : NEW_LINE INDENT ordd -= hund4 NEW_LINE leap += hund4 NEW_LINE DEDENT days = ordd + leap * 2 NEW_LINE odd = days % 7 NEW_LINE return odd NEW_LINE DEDENT,static int oddDays ( int N ) { int hund1 = N / 100 ; int hund4 = N / 400 ; int leap = N >> 2 ; int ord = N - leap ; if ( hund1 > 0 ) { ord += hund1 ; leap -= hund1 ; } if ( hund4 > 0 ) { ord -= hund4 ; leap += hund4 ; } int days = ord + leap * 2 ; int odd = days % 7 ; return odd ; }
Translate Python to Java: def circumference ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = 1.22 * a NEW_LINE return d NEW_LINE DEDENT,static double pentdiagonal ( double a ) { if ( a < 0 ) return - 1 ; double d = 1.22 * a ; return d ; }
"Translate Python to Java: def frequencyDigits ( n , d ) : NEW_LINE INDENT c = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n % 10 == d ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT n = int ( n / 10 ) NEW_LINE DEDENT return c NEW_LINE DEDENT","static int frequencyDigits ( int n , int d ) { int c = 0 ; while ( n > 0 ) { if ( n % 10 == d ) c ++ ; n = n / 10 ; } return c ; }"
"Translate Python to Java: def check ( start , rest ) : NEW_LINE INDENT if rest : NEW_LINE INDENT return check ( start + rest [ 0 ] , rest [ 1 : ] ) or check ( start - rest [ 0 ] , rest [ 1 : ] ) NEW_LINE DEDENT else : NEW_LINE INDENT return not ( start % 360 ) NEW_LINE DEDENT DEDENT","public static boolean check ( int index , int [ ] arr , int n , int sum ) { if ( index == n ) { if ( sum % 360 == 0 ) return true ; else return false ; } return check ( index + 1 , arr , n , sum + arr [ index ] ) || check ( index + 1 , arr , n , sum - arr [ index ] ) ; }"
Translate Python to Java: def validate ( n ) : NEW_LINE INDENT count = [ 0 for i in range ( 10 ) ] NEW_LINE while ( n > 0 ) : NEW_LINE INDENT r = n % 10 NEW_LINE if ( count [ r ] == r ) : NEW_LINE INDENT return False NEW_LINE DEDENT count [ r ] += 1 NEW_LINE n = n // 10 NEW_LINE DEDENT return True NEW_LINE DEDENT,static boolean validate ( long n ) { int count [ ] = new int [ 10 ] ; while ( n > 0 ) { int r = ( int ) n % 10 ; if ( count [ r ] == r ) return false ; count [ r ] ++ ; n /= 10 ; } return true ; }
"Translate Python to Java: def canMakeEqual ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT while ( a [ i ] % 5 == 0 ) : NEW_LINE INDENT a [ i ] //= 5 NEW_LINE DEDENT while ( a [ i ] % 3 == 0 ) : NEW_LINE INDENT a [ i ] //= 3 NEW_LINE DEDENT DEDENT last = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] != last ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT","static boolean canMakeEqual ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { while ( a [ i ] % 5 == 0 ) { a [ i ] /= 5 ; } while ( a [ i ] % 3 == 0 ) { a [ i ] /= 3 ; } } int last = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] != last ) { return false ; } } return true ; }"
"Translate Python to Java: def printNthElement ( n ) : NEW_LINE INDENT arr = [ 0 ] * ( n + 1 ) NEW_LINE arr [ 1 ] = 4 NEW_LINE arr [ 2 ] = 7 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT if ( i % 2 != 0 ) : NEW_LINE INDENT arr [ i ] = arr [ i // 2 ] * 10 + 4 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = arr [ ( i // 2 ) - 1 ] * 10 + 7 NEW_LINE DEDENT DEDENT return arr [ n ] NEW_LINE DEDENT",static int printNthElement ( int n ) { int arr [ ] = new int [ n + 1 ] ; arr [ 1 ] = 4 ; arr [ 2 ] = 7 ; for ( int i = 3 ; i <= n ; i ++ ) { if ( i % 2 != 0 ) arr [ i ] = arr [ i / 2 ] * 10 + 4 ; else arr [ i ] = arr [ ( i / 2 ) - 1 ] * 10 + 7 ; } return arr [ n ] ; }
"Translate Python to Java: def printNthFirst ( n ) : NEW_LINE INDENT arr = [ 0 ] * ( n + 1 ) NEW_LINE arr [ 1 ] = 3 NEW_LINE arr [ 2 ] = 5 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT if ( i % 2 != 0 ) : NEW_LINE INDENT arr [ i ] = arr [ i // 2 ] * 10 + 3 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = arr [ ( i // 2 ) - 1 ] * 10 + 5 NEW_LINE DEDENT DEDENT return arr [ n ] NEW_LINE DEDENT",static int printNthElement ( int n ) { int arr [ ] = new int [ n + 1 ] ; arr [ 1 ] = 3 ; arr [ 2 ] = 5 ; for ( int i = 3 ; i <= n ; i ++ ) { if ( i % 2 != 0 ) arr [ i ] = arr [ i / 2 ] * 10 + 3 ; else arr [ i ] = arr [ ( i / 2 ) - 1 ] * 10 + 5 ; } return arr [ n ] ; }
"Translate Python to Java: def printNthElement ( n ) : NEW_LINE INDENT arr = [ 0 ] * ( n + 1 ) NEW_LINE arr [ 1 ] = 1 NEW_LINE arr [ 2 ] = 2 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT if ( i % 2 != 0 ) : NEW_LINE INDENT arr [ i ] = arr [ i // 2 ] * 10 + 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = arr [ ( i // 2 ) - 1 ] * 10 + 2 NEW_LINE DEDENT DEDENT return arr [ n ] NEW_LINE DEDENT",static int printNthElement ( int n ) { int arr [ ] = new int [ n + 1 ] ; arr [ 1 ] = 1 ; arr [ 2 ] = 2 ; for ( int i = 3 ; i <= n ; i ++ ) { if ( i % 2 != 0 ) arr [ i ] = arr [ i / 2 ] * 10 + 1 ; else arr [ i ] = arr [ ( i / 2 ) - 1 ] * 10 + 2 ; } return arr [ n ] ; }
"Translate Python to Java: def isPossibleToZero ( a , n ) : NEW_LINE INDENT num = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = num * 10 + a [ i ] NEW_LINE DEDENT return ( num % 11 == 0 ) NEW_LINE DEDENT","static boolean isPossibleToZero ( int a [ ] , int n ) { int num = 0 ; for ( int i = 0 ; i < n ; i ++ ) num = num * 10 + a [ i ] ; return ( num % 11 == 0 ) ; }"
"Translate Python to Java: def squareArea ( l , b , h ) : NEW_LINE INDENT if l < 0 or b < 0 or h < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( l * b ) / ( l + b ) NEW_LINE return a * a NEW_LINE DEDENT","static float squareArea ( float l , float b , float h ) { if ( l < 0 || b < 0 || h < 0 ) return - 1 ; float a = ( l * b ) / ( l + b ) ; return a * a ; }"
"Translate Python to Java: def FirstAndLast ( string ) : NEW_LINE INDENT ch = list ( string ) NEW_LINE i = 0 NEW_LINE while i < len ( ch ) : NEW_LINE INDENT k = i NEW_LINE while ( i < len ( ch ) and ch [ i ] != '  ' ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if ( ord ( ch [ k ] ) >= 97 and ord ( ch [ k ] ) <= 122 ) : NEW_LINE INDENT ch [ k ] = chr ( ord ( ch [ k ] ) - 32 ) NEW_LINE DEDENT else : NEW_LINE INDENT ch [ k ] = ch [ k ] NEW_LINE DEDENT if ( ord ( ch [ i - 1 ] ) >= 90 and ord ( ch [ i - 1 ] ) <= 122 ) : NEW_LINE INDENT ch [ i - 1 ] = chr ( ord ( ch [ i - 1 ] ) - 32 ) NEW_LINE DEDENT else : NEW_LINE INDENT ch [ i - 1 ] = ch [ i - 1 ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return "" "" . join ( ch ) NEW_LINE DEDENT",static String FirstAndLast ( String str ) { char [ ] ch = str . toCharArray ( ) ; for ( int i = 0 ; i < ch . length ; i ++ ) { int k = i ; while ( i < ch . length && ch [ i ] != '  ' ) i ++ ; ch [ k ] = ( char ) ( ch [ k ] >= ' a ' && ch [ k ] <= ' z ' ? ( ( int ) ch [ k ] - 32 ) : ( int ) ch [ k ] ) ; ch [ i - 1 ] = ( char ) ( ch [ i - 1 ] >= ' a ' && ch [ i - 1 ] <= ' z ' ? ( ( int ) ch [ i - 1 ] - 32 ) : ( int ) ch [ i - 1 ] ) ; } return new String ( ch ) ; }
Translate Python to Java: def findBucketNo ( p ) : NEW_LINE INDENT return math . ceil ( ( math . sqrt ( 8 * p + 1 ) - 1 ) / 2 ) NEW_LINE DEDENT,static int findBucketNo ( int p ) { return ( int ) Math . ceil ( ( Math . sqrt ( 8 * p + 1 ) - 1 ) / 2 ) ; }
"Translate Python to Java: def LongestSubarray ( a , n , k ) : NEW_LINE INDENT pre = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > k ) : NEW_LINE INDENT pre [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT pre [ i ] = - 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + pre [ i ] NEW_LINE DEDENT Len = 0 NEW_LINE lo = 1 NEW_LINE hi = n NEW_LINE while ( lo <= hi ) : NEW_LINE INDENT mid = ( lo + hi ) // 2 NEW_LINE ok = False NEW_LINE for i in range ( mid - 1 , n ) : NEW_LINE INDENT x = pre [ i ] NEW_LINE if ( i - mid >= 0 ) : NEW_LINE INDENT x -= pre [ i - mid ] NEW_LINE DEDENT if ( x > 0 ) : NEW_LINE INDENT ok = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( ok == True ) : NEW_LINE INDENT Len = mid NEW_LINE lo = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT hi = mid - 1 NEW_LINE DEDENT DEDENT return Len NEW_LINE DEDENT","static int LongestSubarray ( int a [ ] , int n , int k ) { int [ ] pre = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > k ) pre [ i ] = 1 ; else pre [ i ] = - 1 ; } for ( int i = 1 ; i < n ; i ++ ) pre [ i ] = pre [ i - 1 ] + pre [ i ] ; int len = 0 ; int lo = 1 , hi = n ; while ( lo <= hi ) { int mid = ( lo + hi ) / 2 ; boolean ok = false ; for ( int i = mid - 1 ; i < n ; i ++ ) { int x = pre [ i ] ; if ( i - mid >= 0 ) x -= pre [ i - mid ] ; if ( x > 0 ) { ok = true ; break ; } } if ( ok == true ) { len = mid ; lo = mid + 1 ; } else hi = mid - 1 ; } return len ; }"
"Translate Python to Java: def areDistinct ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE s = set ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT return ( len ( s ) == len ( arr ) ) NEW_LINE DEDENT",public static boolean areDistinct ( Integer arr [ ] ) { Set < Integer > s = new HashSet < Integer > ( Arrays . asList ( arr ) ) ; return ( s . size ( ) == arr . length ) ; }
"Translate Python to Java: def countDistinctCode ( string ) : NEW_LINE INDENT codes = set ( ) NEW_LINE for i in range ( 0 , len ( string ) - 1 ) : NEW_LINE INDENT codes . add ( string [ i : i + 2 ] ) NEW_LINE DEDENT return len ( codes ) NEW_LINE DEDENT","static int countDistinctCode ( String str ) { Set < String > codes = new HashSet < > ( ) ; for ( int i = 0 ; i < str . length ( ) - 1 ; i ++ ) codes . add ( str . substring ( i , i + 2 ) ) ; return codes . size ( ) ; }"
"Translate Python to Java: def mostCommon ( lower , higher ) : NEW_LINE INDENT if ( lower == higher ) : NEW_LINE INDENT return lower NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT","public static int mostCommon ( int lower , int higher ) { if ( lower == higher ) return lower ; else return 2 ; }"
"Translate Python to Java: def extractMaximum ( ss ) : NEW_LINE INDENT num , res = 0 , 0 NEW_LINE for i in range ( len ( ss ) ) : NEW_LINE INDENT if ss [ i ] >= ""0"" and ss [ i ] <= ""9"" : NEW_LINE INDENT num = num * 10 + int ( int ( ss [ i ] ) - 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT res = max ( res , num ) NEW_LINE num = 0 NEW_LINE DEDENT DEDENT return max ( res , num ) NEW_LINE DEDENT","static int extractMaximum ( String str ) { int num = 0 , res = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( Character . isDigit ( str . charAt ( i ) ) ) num = num * 10 + ( str . charAt ( i ) - '0' ) ; else { res = Math . max ( res , num ) ; num = 0 ; } } return Math . max ( res , num ) ; }"
"Translate Python to Java: def longestInteger ( s , length ) : NEW_LINE INDENT count = 0 NEW_LINE maximum = 0 NEW_LINE pos = - 1 NEW_LINE l = 0 NEW_LINE for i in range ( length ) : NEW_LINE INDENT pre_pos = pos NEW_LINE pre_len = l NEW_LINE count = 0 NEW_LINE l = 0 NEW_LINE if ( s [ i ] . isdecimal ( ) ) : NEW_LINE INDENT pos = i NEW_LINE DEDENT while ( s [ i ] . isdecimal ( ) ) : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE l += 1 NEW_LINE DEDENT if ( count > maximum ) : NEW_LINE INDENT maximum = count NEW_LINE DEDENT else : NEW_LINE INDENT pos = pre_pos NEW_LINE l = pre_len NEW_LINE DEDENT DEDENT return ( s [ pos : pos + l ] ) NEW_LINE DEDENT","static String longestInteger ( String str , int l ) { int count = 0 , max = 0 , pos = - 1 , pre_pos , pre_len , len = 0 ; for ( int i = 0 ; i < l ; i ++ ) { pre_pos = pos ; pre_len = len ; count = 0 ; len = 0 ; if ( Character . isDigit ( str . charAt ( i ) ) ) pos = i ; while ( Character . isDigit ( str . charAt ( i ) ) ) { count ++ ; i ++ ; len ++ ; } if ( count > max ) { max = count ; } else { pos = pre_pos ; len = pre_len ; } } return ( str . substring ( pos , pos + len ) ) ; }"
"Translate Python to Java: def subarrayArea ( N , M , K ) : NEW_LINE INDENT while ( K > 0 and N > 0 and M > 0 ) : NEW_LINE INDENT if ( N > M ) : NEW_LINE INDENT N = N - M NEW_LINE DEDENT else : NEW_LINE INDENT M = M - N NEW_LINE DEDENT K = K - 1 NEW_LINE DEDENT if ( N > 0 and M > 0 ) : NEW_LINE INDENT return N * M NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT","static int remainingArea ( int N , int M , int K ) { while ( K -- > 0 && N > 0 && M > 0 ) { if ( N > M ) N = N - M ; else M = M - N ; } if ( N > 0 && M > 0 ) return N * M ; else return 0 ; }"
"Translate Python to Java: def isValid ( string , length ) : NEW_LINE INDENT for i in range ( 1 , length ) : NEW_LINE INDENT if string [ i ] == string [ i - 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT","static boolean isValid ( String str , int len ) { for ( int i = 1 ; i < len ; i ++ ) { if ( str . charAt ( i ) == str . charAt ( i - 1 ) ) return false ; } return true ; }"
Translate Python to Java: def getValue ( n ) : NEW_LINE INDENT i = 0 NEW_LINE k = 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT i = i + k NEW_LINE k = k * 2 NEW_LINE DEDENT return int ( k / 2 ) NEW_LINE DEDENT,"static int getValue ( int n ) { int i = 0 , k = 1 ; while ( i < n ) { i = i + k ; k = k * 2 ; } return k / 2 ; }"
"Translate Python to Java: def sameLength ( A , B ) : NEW_LINE INDENT while ( A > 0 and B > 0 ) : NEW_LINE INDENT A = A / 10 NEW_LINE B = B / 10 NEW_LINE DEDENT if ( A == 0 and B == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT","static boolean sameLength ( int A , int B ) { while ( ( A > 0 ) && ( B > 0 ) ) { A = A / 10 ; B = B / 10 ; } if ( ( A == 0 ) && ( B == 0 ) ) return true ; return false ; }"
"Translate Python to Java: def zeroPosible ( x , y ) : NEW_LINE INDENT if ( ( x - y ) == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT","static boolean isPossible ( int x , int y ) { if ( ( x - y ) == 1 ) return false ; return true ; }"
"Translate Python to Java: def countPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE right = 0 NEW_LINE left = 0 NEW_LINE visited = [ False for i in range ( n ) ] NEW_LINE while ( right < n ) : NEW_LINE INDENT while ( right < n and visited [ arr [ right ] ] == False ) : NEW_LINE INDENT count += ( right - left ) NEW_LINE visited [ arr [ right ] ] = True NEW_LINE right += 1 NEW_LINE DEDENT while ( left < right and ( right != n and visited [ arr [ right ] ] == True ) ) : NEW_LINE INDENT visited [ arr [ left ] ] = False NEW_LINE left += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT","static int countPairs ( int arr [ ] , int n ) { int count = 0 ; int right = 0 , left = 0 ; boolean visited [ ] = new boolean [ n ] ; for ( int i = 0 ; i < n ; i ++ ) visited [ i ] = false ; while ( right < n ) { while ( right < n && ! visited [ arr [ right ] ] ) { count += ( right - left ) ; visited [ arr [ right ] ] = true ; right ++ ; } while ( left < right && ( right != n && visited [ arr [ right ] ] ) ) { visited [ arr [ left ] ] = false ; left ++ ; } } return count ; }"
"Translate Python to Java: def tribWord ( n ) : NEW_LINE INDENT Sn_1 = ""1"" NEW_LINE Sn_2 = ""12"" NEW_LINE Sn_3 = ""1213"" NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT tmp = Sn_3 NEW_LINE Sn_3 += ( Sn_2 + Sn_1 ) NEW_LINE Sn_1 = Sn_2 NEW_LINE Sn_2 = tmp NEW_LINE DEDENT return Sn_3 NEW_LINE DEDENT","static String tribWord ( int n ) { String Sn_1 = ""1"" ; String Sn_2 = ""12"" ; String Sn_3 = ""1213"" ; String tmp ; for ( int i = 3 ; i <= n ; i ++ ) { tmp = Sn_3 ; Sn_3 += ( Sn_2 + Sn_1 ) ; Sn_1 = Sn_2 ; Sn_2 = tmp ; } return Sn_3 ; }"
"Translate Python to Java: def minSteps ( arr , n ) : NEW_LINE INDENT min_Steps = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i > 0 ) : NEW_LINE INDENT min_Steps += abs ( arr [ i ] - arr [ i - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT min_Steps += abs ( arr [ i ] ) NEW_LINE DEDENT DEDENT return min_Steps NEW_LINE DEDENT","public static int minSteps ( int arr [ ] , int n ) { int min_Steps = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i > 0 ) min_Steps += Math . abs ( arr [ i ] - arr [ i - 1 ] ) ; else min_Steps += Math . abs ( arr [ i ] ) ; } return min_Steps ; }"
Translate Python to Java: def fnMod ( n ) : NEW_LINE INDENT rem = n % 4 NEW_LINE if ( rem == 0 or rem == 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( rem == 1 or rem == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT,static int fnMod ( int n ) { int rem = n % 4 ; if ( rem == 0 || rem == 3 ) return 0 ; else if ( rem == 1 || rem == 2 ) return 1 ; return 0 ; }
"Translate Python to Java: def calculate_sum ( a , N ) : NEW_LINE INDENT m = N / a NEW_LINE sum = m * ( m + 1 ) / 2 NEW_LINE ans = a * sum NEW_LINE return ans NEW_LINE DEDENT","static int calculate_sum ( int a , int N ) { int m = N / a ; int sum = m * ( m + 1 ) / 2 ; int ans = a * sum ; return ans ; }"
Translate Python to Java: def MDAS_Factorial ( N ) : NEW_LINE INDENT if N <= 2 : NEW_LINE INDENT return N NEW_LINE DEDENT if N <= 4 : NEW_LINE INDENT return N + 3 NEW_LINE DEDENT if ( N - 4 ) % 4 == 0 : NEW_LINE INDENT return N + 1 NEW_LINE DEDENT elif ( N - 4 ) % 4 <= 2 : NEW_LINE INDENT return N + 2 NEW_LINE DEDENT else : NEW_LINE INDENT return N - 1 NEW_LINE DEDENT DEDENT,public static int MDAS_Factorial ( int N ) { if ( N <= 2 ) return N ; if ( N <= 4 ) return ( N + 3 ) ; if ( ( N - 4 ) % 4 == 0 ) return ( N + 1 ) ; else if ( ( N - 4 ) % 4 <= 2 ) return ( N + 2 ) ; else return ( N - 1 ) ; }
"Translate Python to Java: def checkArray ( arr , n ) : NEW_LINE INDENT return ( ( arr [ 0 ] % 2 ) and ( arr [ n - 1 ] % 2 ) and ( n % 2 ) ) NEW_LINE DEDENT","static int checkArray ( int [ ] arr , int n ) { return ( ( arr [ 0 ] % 2 ) > 0 && ( arr [ n - 1 ] % 2 ) > 0 && ( n % 2 ) > 0 ) ? 1 : 0 ; }"
"Translate Python to Java: def countSum ( N , L , R ) : NEW_LINE INDENT if ( L > R ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( N == 1 ) : NEW_LINE INDENT return R - L + 1 NEW_LINE DEDENT if ( N > 1 ) : NEW_LINE INDENT return ( N - 2 ) * ( R - L ) + 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT","static int countSum ( int N , int L , int R ) { if ( L > R ) { return 0 ; } if ( N == 1 ) { return R - L + 1 ; } if ( N > 1 ) { return ( N - 2 ) * ( R - L ) + 1 ; } return 0 ; }"
"Translate Python to Java: def findMax ( arr , n ) : NEW_LINE INDENT m = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT m = max ( m , arr [ i ] ) NEW_LINE DEDENT freq = [ 0 ] * ( m + 2 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 1 , m + 2 ) : NEW_LINE INDENT j = i NEW_LINE cnt = 0 NEW_LINE while ( j <= m ) : NEW_LINE INDENT cnt += freq [ j ] NEW_LINE j += i NEW_LINE DEDENT if ( not cnt ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return m + 1 NEW_LINE DEDENT","static int findMin ( int arr [ ] , int n ) { int m = 0 ; for ( int i = 0 ; i < n ; i ++ ) m = Math . max ( m , arr [ i ] ) ; int freq [ ] = new int [ m + 2 ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; for ( int i = 1 ; i <= m + 1 ; i ++ ) { int j = i ; int cnt = 0 ; while ( j <= m ) { cnt += freq [ j ] ; j += i ; } if ( cnt == 0 ) return i ; } return m + 1 ; }"
"Translate Python to Java: def smallestPoss ( s , n ) : NEW_LINE INDENT ans = "" "" NEW_LINE arr = [ 0 ] * 10 NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ ord ( s [ i ] ) - 48 ] += 1 NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT for j in range ( arr [ i ] ) : NEW_LINE INDENT ans = ans + str ( i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT","static String smallestPoss ( String s , int n ) { String ans = "" "" ; int arr [ ] = new int [ 10 ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ s . charAt ( i ) - 48 ] ++ ; } for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < arr [ i ] ; j ++ ) ans = ans + String . valueOf ( i ) ; } return ans ; }"
"Translate Python to Java: def totalBoxesRemoved ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE prev = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > prev ) : NEW_LINE INDENT count += ( arr [ i ] - prev ) NEW_LINE arr [ i ] = prev NEW_LINE prev = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT prev = arr [ i ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT","static int totalBoxesRemoved ( int arr [ ] , int n ) { int count = 0 ; int prev = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > prev ) { count += ( arr [ i ] - prev ) ; arr [ i ] = prev ; prev = arr [ i ] ; } else { prev = arr [ i ] ; } } return count ; }"
Translate Python to Java: def spiralVaule ( s ) : NEW_LINE INDENT sum_char = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT sum_char += ord ( s [ i ] ) NEW_LINE DEDENT return sum_char // len ( s ) NEW_LINE DEDENT,public static int averageValue ( String s ) { int sum_char = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { sum_char += ( int ) s . charAt ( i ) ; } return sum_char / s . length ( ) ; }
"Translate Python to Java: def bankNotes ( A , B , S , N ) : NEW_LINE INDENT numerator = S - ( B * N ) NEW_LINE denominator = A - B NEW_LINE if ( numerator % denominator == 0 ) : NEW_LINE INDENT return ( numerator // denominator ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT","static int bankNotes ( int A , int B , int S , int N ) { int numerator = S - ( B * N ) ; int denominator = A - B ; if ( numerator % denominator == 0 ) return ( numerator / denominator ) ; return - 1 ; }"
"Translate Python to Java: def lcm ( x , y ) : NEW_LINE INDENT return ( x * y ) // math . gcd ( x , y ) NEW_LINE DEDENT","public static long lcm ( int a , int b ) { int temp ; long c = a ; c *= b ; while ( ( temp = a % b ) != 0 ) { a = b ; b = temp ; } return c / b ; }"
Translate Python to Java: def CountTrailingZeros ( n ) : NEW_LINE INDENT bit = bin ( n ) [ 2 : ] NEW_LINE bit = bit [ : : - 1 ] NEW_LINE zero = 0 NEW_LINE for i in range ( len ( bit ) ) : NEW_LINE INDENT if ( bit [ i ] == '0' ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return zero NEW_LINE DEDENT,static int CountTrailingZeros ( int n ) { String bit = Integer . toBinaryString ( n ) ; StringBuilder bit1 = new StringBuilder ( ) ; bit1 . append ( bit ) ; bit1 = bit1 . reverse ( ) ; int zero = 0 ; for ( int i = 0 ; i < 64 ; i ++ ) { if ( bit1 . charAt ( i ) == '0' ) zero ++ ; else break ; } return zero ; }
"Translate Python to Java: def Xor_Sum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE index , left_xor = 0 , 0 NEW_LINE right_xor = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT left_xor = left_xor ^ arr [ i ] NEW_LINE right_xor = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT right_xor = right_xor ^ arr [ j ] NEW_LINE DEDENT if ( left_xor + right_xor > sum ) : NEW_LINE INDENT sum = left_xor + right_xor NEW_LINE index = i NEW_LINE DEDENT DEDENT return index + 1 NEW_LINE DEDENT","public static int Xor_Sum ( int [ ] arr , int n ) { int sum = 0 , index = - 1 ; int left_xor = 0 , right_xor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { left_xor = left_xor ^ arr [ i ] ; right_xor = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) { right_xor = right_xor ^ arr [ j ] ; } if ( left_xor + right_xor > sum ) { sum = left_xor + right_xor ; index = i ; } } return index + 1 ; }"
"Translate Python to Java: def lds ( arr , n ) : NEW_LINE INDENT lds = [ 0 for i in range ( n ) ] NEW_LINE lds [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT lds [ i ] = 1 NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( lds [ j ] != 0 and arr [ i ] % arr [ j ] == 0 ) : NEW_LINE INDENT lds [ i ] = max ( lds [ i ] , lds [ j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT return max ( lds ) NEW_LINE DEDENT","static int lds ( Integer arr [ ] , int n ) { Integer lds [ ] = new Integer [ n ] ; lds [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { lds [ i ] = 1 ; for ( int j = 0 ; j < i ; j ++ ) if ( lds [ j ] != 0 && arr [ i ] % arr [ j ] == 0 ) lds [ i ] = Math . max ( lds [ i ] , lds [ j ] + 1 ) ; } int max = ( int ) Collections . max ( Arrays . asList ( lds ) ) ; return max ; }"
"Translate Python to Java: def equalize ( arr , n , k ) : NEW_LINE INDENT min_ele = min ( arr ) NEW_LINE flag = True NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( not ( ( arr [ i ] + k ) >= ( min_ele + k ) and ( min_ele + k ) >= ( arr [ i ] - k ) ) ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT return min_ele + k NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT","static int equalize ( int arr [ ] , int n , int k ) { int min_ele = Arrays . stream ( arr ) . min ( ) . getAsInt ( ) ; boolean flag = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! ( ( arr [ i ] + k ) >= min_ele + k && min_ele + k >= ( arr [ i ] - k ) ) ) { flag = false ; break ; } } if ( flag ) { return min_ele + k ; } else return - 1 ; }"
"Translate Python to Java: def numLen ( K ) : NEW_LINE INDENT if ( K % 2 == 0 or K % 5 == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT number = 0 NEW_LINE len = 1 NEW_LINE for len in range ( 1 , K + 1 ) : NEW_LINE INDENT number = number * 10 + 1 NEW_LINE if ( ( number % K == 0 ) ) : NEW_LINE INDENT return len NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT",static int numLen ( int K ) { if ( K % 2 == 0 || K % 5 == 0 ) { return - 1 ; } int number = 0 ; int len = 1 ; for ( len = 1 ; len <= K ; len ++ ) { number = number * 10 + 1 ; if ( ( number % K == 0 ) ) { return len ; } } return - 1 ; }
"Translate Python to Java: def numLen ( K ) : NEW_LINE INDENT if ( K % 2 == 0 or K % 5 == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT number = 0 NEW_LINE len = 1 NEW_LINE for len in range ( 1 , K + 1 ) : NEW_LINE INDENT number = ( number * 10 + 1 ) % K NEW_LINE if number == 0 : NEW_LINE INDENT return len NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT",public static int numLen ( int K ) { if ( K % 2 == 0 || K % 5 == 0 ) return - 1 ; int number = 0 ; int len = 1 ; for ( len = 1 ; len <= K ; len ++ ) { number = ( number * 10 + 1 ) % K ; if ( number == 0 ) return len ; } return - 1 ; }
"Translate Python to Java: def changeTheArray ( arr , n ) : NEW_LINE INDENT minEle = min ( arr ) NEW_LINE maxEle = max ( arr ) NEW_LINE minOperations = sys . maxsize NEW_LINE for num in range ( minEle , maxEle + 1 ) : NEW_LINE INDENT operations = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] != num : NEW_LINE INDENT operations += ( abs ( num - arr [ i ] ) - 1 ) NEW_LINE DEDENT DEDENT minOperations = min ( minOperations , operations ) NEW_LINE DEDENT return minOperations NEW_LINE DEDENT","static int changeTheArray ( int arr [ ] , int n ) { int minEle = Arrays . stream ( arr ) . min ( ) . getAsInt ( ) ; int maxEle = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int minOperations = Integer . MAX_VALUE ; for ( int num = minEle ; num <= maxEle ; num ++ ) { int operations = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != num ) { operations += ( Math . abs ( num - arr [ i ] ) - 1 ) ; } } minOperations = Math . min ( minOperations , operations ) ; } return minOperations ; }"
Translate Python to Java: def calSum ( n ) : NEW_LINE INDENT a = 3 NEW_LINE b = 0 NEW_LINE c = 2 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return 5 NEW_LINE DEDENT sum = 5 NEW_LINE while ( n > 2 ) : NEW_LINE INDENT d = a + b NEW_LINE sum = sum + d NEW_LINE a = b NEW_LINE b = c NEW_LINE c = d NEW_LINE n = n - 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT,"static int calSum ( int n ) { int a = 3 , b = 0 , c = 2 ; if ( n == 0 ) return 3 ; if ( n == 1 ) return 3 ; if ( n == 2 ) return 5 ; int sum = 5 ; while ( n > 2 ) { int d = a + b ; sum += d ; a = b ; b = c ; c = d ; n -- ; } return sum ; }"
"Translate Python to Java: def sqroot ( s ) : NEW_LINE INDENT pSq = 0 NEW_LINE N = 0 NEW_LINE for i in range ( int ( s ) , 0 , - 1 ) : NEW_LINE INDENT for j in range ( 1 , i ) : NEW_LINE INDENT if ( j * j == i ) : NEW_LINE INDENT pSq = i NEW_LINE N = j NEW_LINE break NEW_LINE DEDENT DEDENT if ( pSq > 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT d = s - pSq NEW_LINE P = d / ( 2.0 * N ) NEW_LINE A = N + P NEW_LINE sqrt_of_s = A - ( ( P * P ) / ( 2.0 * A ) ) NEW_LINE return sqrt_of_s NEW_LINE DEDENT",static float sqroot ( float s ) { int pSq = 0 ; int N = 0 ; for ( int i = ( int ) ( s ) ; i > 0 ; i -- ) { for ( int j = 1 ; j < i ; j ++ ) { if ( j * j == i ) { pSq = i ; N = j ; break ; } } if ( pSq > 0 ) break ; } float d = s - pSq ; float P = d / ( 2.0f * N ) ; float A = N + P ; float sqrt_of_s = A - ( ( P * P ) / ( 2.0f * A ) ) ; return sqrt_of_s ; }
"Translate Python to Java: def isEqual ( n ) : NEW_LINE INDENT fac = [ 0 for i in range ( 10 ) ] NEW_LINE fac [ 0 ] = 1 NEW_LINE fac [ 1 ] = 1 NEW_LINE for i in range ( 2 , 10 , 1 ) : NEW_LINE INDENT fac [ i ] = fac [ i - 1 ] * i NEW_LINE DEDENT sum = 0 NEW_LINE x = n NEW_LINE while ( x ) : NEW_LINE INDENT sum += fac [ x % 10 ] NEW_LINE x = int ( x / 10 ) NEW_LINE DEDENT if ( sum % n == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT",static boolean isPossible ( int n ) { int fac [ ] = new int [ 10 ] ; fac [ 0 ] = fac [ 1 ] = 1 ; for ( int i = 2 ; i < 10 ; i ++ ) fac [ i ] = fac [ i - 1 ] * i ; int sum = 0 ; int x = n ; while ( x != 0 ) { sum += fac [ x % 10 ] ; x /= 10 ; } if ( sum % n == 0 ) return true ; return false ; }
"Translate Python to Java: def getProbability ( p , q ) : NEW_LINE INDENT p /= 100 NEW_LINE q /= 100 NEW_LINE probability = ( p * p + q * q ) / ( p + q ) NEW_LINE return probability NEW_LINE DEDENT","static double getProbability ( double p , double q ) { p /= 100 ; q /= 100 ; double probability = ( p * p + q * q ) / ( p + q ) ; return probability ; }"
"Translate Python to Java: def seiresPalin ( str1 , len1 ) : NEW_LINE INDENT ans = ord ( str1 [ 0 ] ) NEW_LINE for i in range ( 1 , len1 ) : NEW_LINE INDENT ans = ( ans ^ ( ord ( str1 [ i ] ) ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT","static int XorAscii ( String str , int len ) { int ans = ( str . charAt ( 0 ) ) ; for ( int i = 1 ; i < len ; i ++ ) { ans = ( ans ^ ( ( str . charAt ( i ) ) ) ) ; } return ans ; }"
Translate Python to Java: def checkFibinnary ( n ) : NEW_LINE INDENT prev_last = 0 NEW_LINE while ( n ) : NEW_LINE INDENT if ( ( n & 1 ) and prev_last ) : NEW_LINE INDENT return False NEW_LINE DEDENT prev_last = n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT,static boolean checkFibinnary ( int n ) { int prev_last = 0 ; while ( n != 0 ) { if ( ( n & 1 ) != 0 && prev_last != 0 ) return false ; prev_last = n & 1 ; n >>= 1 ; } return true ; }
"Translate Python to Java: def areVowelsInOrder ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c = chr ( 64 ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == ' a ' or s [ i ] == ' e ' or s [ i ] == ' i ' or s [ i ] == ' o ' or s [ i ] == ' u ' ) : NEW_LINE INDENT if s [ i ] < c : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT c = s [ i ] NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT",static boolean areVowelsInOrder ( String s ) { int n = s . length ( ) ; char c = ( char ) 64 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' a ' || s . charAt ( i ) == ' e ' || s . charAt ( i ) == ' i ' || s . charAt ( i ) == ' o ' || s . charAt ( i ) == ' u ' ) { if ( s . charAt ( i ) < c ) return false ; else { c = s . charAt ( i ) ; } } } return true ; }
"Translate Python to Java: def counLastDigitK ( low , high , k ) : NEW_LINE INDENT count = ( high - low ) / 10 NEW_LINE if ( high % 10 >= k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( low % 10 > k ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT return int ( count ) NEW_LINE DEDENT","public static int counLastDigitK ( int low , int high , int k ) { int count = ( high - low ) / 10 ; if ( high % 10 >= k ) count ++ ; if ( low % 10 > k ) count -- ; return count ; }"
"Translate Python to Java: def minAbsDiff ( n ) : NEW_LINE INDENT left = 1 << ( int ) ( math . floor ( math . log2 ( n ) ) ) NEW_LINE right = left * 2 NEW_LINE return min ( ( n - left ) , ( right - n ) ) NEW_LINE DEDENT","static int minAbsDiff ( int n ) { int left = 1 << ( ( int ) Math . floor ( Math . log ( n ) / Math . log ( 2 ) ) ) ; int right = left * 2 ; return Math . min ( ( n - left ) , ( right - n ) ) ; }"
"Translate Python to Java: def ReuleauxArea ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = 0.70477 * 2 * pow ( r , 2 ) NEW_LINE return A NEW_LINE DEDENT","static double ReuleauxArea ( double r ) { if ( r < 0 ) return - 1 ; double A = 0.70477 * 2 * Math . pow ( r , 2 ) ; return A ; }"
"Translate Python to Java: def newString ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE freq = [ 0 ] * ( 26 ) NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT ans = "" "" NEW_LINE for i in range ( 0 , 26 ) : NEW_LINE INDENT for j in range ( 0 , freq [ i ] ) : NEW_LINE INDENT ans += chr ( 97 + i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT","static String newString ( String s ) { int l = s . length ( ) ; int freq [ ] = new int [ 26 ] ; for ( int i = 0 ; i < l ; i ++ ) { freq [ s . charAt ( i ) - ' a ' ] += 1 ; } String ans = "" "" ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 0 ; j < freq [ i ] ; j ++ ) { ans += ( char ) ( 97 + i ) ; } } return ans ; }"
"Translate Python to Java: def search ( ar , size ) : NEW_LINE INDENT a = 0 NEW_LINE b = size - 1 NEW_LINE mid = 0 NEW_LINE while b > a + 1 : NEW_LINE INDENT mid = ( a + b ) // 2 NEW_LINE if ( ar [ a ] - a ) != ( ar [ mid ] - mid ) : NEW_LINE INDENT b = mid NEW_LINE DEDENT elif ( ar [ b ] - b ) != ( ar [ mid ] - mid ) : NEW_LINE INDENT a = mid NEW_LINE DEDENT DEDENT return ar [ mid ] + 1 NEW_LINE DEDENT","static int search ( int ar [ ] , int size ) { int a = 0 , b = size - 1 ; int mid = 0 ; while ( ( b - a ) > 1 ) { mid = ( a + b ) / 2 ; if ( ( ar [ a ] - a ) != ( ar [ mid ] - mid ) ) b = mid ; else if ( ( ar [ b ] - b ) != ( ar [ mid ] - mid ) ) a = mid ; } return ( ar [ mid ] + 1 ) ; }"
Translate Python to Java: def minSteps ( str ) : NEW_LINE INDENT count = 0 NEW_LINE i = 0 NEW_LINE while i < len ( str ) - 2 : NEW_LINE INDENT if str [ i ] == '0' : NEW_LINE INDENT if ( str [ i + 1 ] == '1' ) : NEW_LINE INDENT if ( str [ i + 2 ] == '0' ) : NEW_LINE INDENT count = count + 1 NEW_LINE i = i + 2 NEW_LINE DEDENT DEDENT DEDENT i = i + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT,static int minSteps ( String str ) { int count = 0 ; for ( int i = 0 ; i < str . length ( ) - 2 ; i ++ ) { if ( ( ( int ) str . charAt ( i ) ) == '0' ) { if ( str . charAt ( i + 1 ) == '1' ) { if ( str . charAt ( i + 2 ) == '0' ) { count ++ ; i += 2 ; } } } } return count ; }
"Translate Python to Java: def firstEven ( arr , n ) : NEW_LINE INDENT map1 = { } NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] not in map1 : NEW_LINE INDENT map1 [ arr [ i ] ] = False NEW_LINE DEDENT else : NEW_LINE INDENT map1 [ arr [ i ] ] = not map1 [ arr [ i ] ] NEW_LINE DEDENT DEDENT for j in range ( 0 , n ) : NEW_LINE INDENT if map1 [ arr [ j ] ] == True : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return arr [ j ] NEW_LINE DEDENT","public static int firstEven ( int arr [ ] , int n ) { HashMap < Integer , Boolean > map = new HashMap < Integer , Boolean > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( map . get ( arr [ i ] ) == null ) map . put ( arr [ i ] , false ) ; else { boolean val = map . get ( arr [ i ] ) ; if ( val == true ) map . put ( arr [ i ] , false ) ; else map . put ( arr [ i ] , true ) ; } } int j = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( map . get ( arr [ j ] ) == true ) break ; } return arr [ j ] ; }"
"Translate Python to Java: def maxXOR ( arr , n ) : NEW_LINE INDENT xorArr = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xorArr ^= arr [ i ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , ( xorArr ^ arr [ i ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT","static int maxXOR ( int arr [ ] , int n ) { int xorArr = 0 ; for ( int i = 0 ; i < n ; i ++ ) xorArr ^= arr [ i ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans = Math . max ( ans , ( xorArr ^ arr [ i ] ) ) ; return ans ; }"
"Translate Python to Java: def isReachable ( sx , sy , dx , dy ) : NEW_LINE INDENT if ( sx > dx or sy > dy ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( sx == dx and sy == dy ) : NEW_LINE INDENT return True NEW_LINE DEDENT return ( isReachable ( sx + sy , sy , dx , dy ) or isReachable ( sx , sy + sx , dx , dy ) ) NEW_LINE DEDENT","static boolean isReachable ( int sx , int sy , int dx , int dy ) { if ( sx > dx || sy > dy ) return false ; if ( sx == dx && sy == dy ) return true ; return ( isReachable ( sx + sy , sy , dx , dy ) || isReachable ( sx , sy + sx , dx , dy ) ) ; }"
Translate Python to Java: def cntWays ( n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n - 2 ) // 4 NEW_LINE DEDENT DEDENT,static int cntWays ( int n ) { if ( n % 2 == 1 ) { return 0 ; } else { return ( n - 2 ) / 4 ; } }
"Translate Python to Java: def countSubSeq ( i , Sum , cnt , a , n ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( Sum == 0 and cnt > 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE ans += countSubSeq ( i + 1 , Sum , cnt , a , n ) NEW_LINE ans += countSubSeq ( i + 1 , Sum + a [ i ] , cnt + 1 , a , n ) NEW_LINE return ans NEW_LINE DEDENT","static int countSubSeq ( int i , int sum , int cnt , int a [ ] , int n ) { if ( i == n ) { if ( sum == 0 && cnt > 0 ) { return 1 ; } else { return 0 ; } } int ans = 0 ; ans += countSubSeq ( i + 1 , sum , cnt , a , n ) ; ans += countSubSeq ( i + 1 , sum + a [ i ] , cnt + 1 , a , n ) ; return ans ; }"
"Translate Python to Java: def countSubseq ( arr , n ) : NEW_LINE INDENT um = { i : 0 for i in range ( 8 ) } NEW_LINE count = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT um [ arr [ i ] ] += 1 NEW_LINE DEDENT for key , values in um . items ( ) : NEW_LINE INDENT if ( values > 0 ) : NEW_LINE INDENT count *= values NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT","public static long countSubseq ( int [ ] arr , int n ) { HashMap < Integer , Integer > um = new HashMap < > ( ) ; long count = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( um . get ( arr [ i ] ) != null ) { int a = um . get ( arr [ i ] ) ; um . put ( arr [ i ] , ++ a ) ; } else um . put ( arr [ i ] , 1 ) ; } for ( HashMap . Entry < Integer , Integer > entry : um . entrySet ( ) ) { count *= entry . getValue ( ) ; } return count ; }"
Translate Python to Java: def AVLnodes ( height ) : NEW_LINE INDENT if ( height == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( height == 1 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return ( 1 + AVLnodes ( height - 1 ) + AVLnodes ( height - 2 ) ) NEW_LINE DEDENT,static int AVLnodes ( int height ) { if ( height == 0 ) return 1 ; else if ( height == 1 ) return 2 ; return ( 1 + AVLnodes ( height - 1 ) + AVLnodes ( height - 2 ) ) ; }
"Translate Python to Java: def steps ( source , step , dest ) : NEW_LINE INDENT if ( abs ( source ) > ( dest ) ) : NEW_LINE INDENT return sys . maxsize NEW_LINE DEDENT if ( source == dest ) : NEW_LINE INDENT return step NEW_LINE DEDENT pos = steps ( source + step + 1 , step + 1 , dest ) NEW_LINE neg = steps ( source - step - 1 , step + 1 , dest ) NEW_LINE return min ( pos , neg ) NEW_LINE DEDENT","static int steps ( int source , int step , int dest ) { if ( Math . abs ( source ) > ( dest ) ) return Integer . MAX_VALUE ; if ( source == dest ) return step ; int pos = steps ( source + step + 1 , step + 1 , dest ) ; int neg = steps ( source - step - 1 , step + 1 , dest ) ; return Math . min ( pos , neg ) ; }"
"Translate Python to Java: def countnndSay ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return ""1"" NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return ""11"" NEW_LINE DEDENT s = ""11"" NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT s += ' $ ' NEW_LINE l = len ( s ) NEW_LINE cnt = 1 NEW_LINE tmp = "" "" NEW_LINE for j in range ( 1 , l ) : NEW_LINE INDENT if ( s [ j ] != s [ j - 1 ] ) : NEW_LINE INDENT tmp += str ( cnt + 0 ) NEW_LINE tmp += s [ j - 1 ] NEW_LINE cnt = 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT s = tmp NEW_LINE DEDENT return s NEW_LINE DEDENT","static String countnndSay ( int n ) { if ( n == 1 ) return ""1"" ; if ( n == 2 ) return ""11"" ; String str = ""11"" ; for ( int i = 3 ; i <= n ; i ++ ) { str += ' $ ' ; int len = str . length ( ) ; int cnt = 1 ; String tmp = "" "" ; char [ ] arr = str . toCharArray ( ) ; for ( int j = 1 ; j < len ; j ++ ) { if ( arr [ j ] != arr [ j - 1 ] ) { tmp += cnt + 0 ; tmp += arr [ j - 1 ] ; cnt = 1 ; } else cnt ++ ; } str = tmp ; } return str ; }"
"Translate Python to Java: def maxLength ( arr , N ) : NEW_LINE INDENT product = 1 NEW_LINE Len = 0 NEW_LINE for i in arr : NEW_LINE INDENT product *= i NEW_LINE DEDENT if ( product >= 0 ) : NEW_LINE INDENT return N NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT Len = max ( Len , max ( N - i - 1 , i ) ) NEW_LINE DEDENT DEDENT return Len NEW_LINE DEDENT","static int maxLength ( int arr [ ] , int N ) { int product = 1 , len = 0 ; for ( int i = 0 ; i < N ; i ++ ) { product *= arr [ i ] ; } if ( product >= 0 ) { return N ; } for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < 0 ) { len = Math . max ( len , Math . max ( N - i - 1 , i ) ) ; } } return len ; }"
"Translate Python to Java: def normal ( m , n ) : NEW_LINE INDENT N = ( ( abs ( m ) * abs ( n ) ) / math . sqrt ( ( abs ( m ) * abs ( m ) ) + ( abs ( n ) * abs ( n ) ) ) ) NEW_LINE return N NEW_LINE DEDENT","static float normal ( float m , float n ) { float N = ( float ) ( ( Math . abs ( m ) * Math . abs ( n ) ) / Math . sqrt ( ( Math . abs ( m ) * Math . abs ( m ) ) + ( Math . abs ( n ) * Math . abs ( n ) ) ) ) ; return N ; }"
"Translate Python to Java: def countSubarray ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( sum + arr [ j ] < k ) : NEW_LINE INDENT sum = arr [ j ] + sum NEW_LINE count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT","static int countSubarray ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = i ; j < n ; j ++ ) { if ( sum + arr [ j ] < k ) { sum = arr [ j ] + sum ; count ++ ; } else { break ; } } } return count ; }"
"Translate Python to Java: def countTripletsLessThanL ( n , L , arr ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE ways = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT mostDistantDistance = arr [ k ] - arr [ i ] NEW_LINE if ( mostDistantDistance <= L ) : NEW_LINE INDENT ways += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ways NEW_LINE DEDENT","static int countTripletsLessThanL ( int n , int L , int [ ] arr ) { Arrays . sort ( arr ) ; int ways = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { int mostDistantDistance = arr [ k ] - arr [ i ] ; if ( mostDistantDistance <= L ) { ways ++ ; } } } } return ways ; }"
"Translate Python to Java: def findTwoThreePrime ( l , r ) : NEW_LINE INDENT if ( l == 1 ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT num = i NEW_LINE while ( num % 2 == 0 ) : NEW_LINE INDENT num //= 2 NEW_LINE DEDENT while ( num % 3 == 0 ) : NEW_LINE INDENT num //= 3 NEW_LINE DEDENT if ( num == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT","static int findTwoThreePrime ( int l , int r ) { if ( l == 1 ) l ++ ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int num = i ; while ( num % 2 == 0 ) num /= 2 ; while ( num % 3 == 0 ) num /= 3 ; if ( num == 1 ) count ++ ; } return count ; }"
"Translate Python to Java: def toggleLastMBits ( n , m ) : NEW_LINE INDENT num = ( 1 << m ) - 1 NEW_LINE return ( n ^ num ) NEW_LINE DEDENT","public static int toggleLastMBits ( int n , int m ) { int num = ( 1 << m ) - 1 ; return ( n ^ num ) ; }"
"Translate Python to Java: def countNumbers ( L , R , K ) : NEW_LINE INDENT if ( K == 9 ) : NEW_LINE INDENT K = 0 NEW_LINE DEDENT totalnumbers = R - L + 1 NEW_LINE factor9 = totalnumbers // 9 NEW_LINE rem = totalnumbers % 9 NEW_LINE ans = factor9 NEW_LINE for i in range ( R , R - rem , - 1 ) : NEW_LINE INDENT rem1 = i % 9 NEW_LINE if ( rem1 == K ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT","static int countNumbers ( int L , int R , int K ) { if ( K == 9 ) { K = 0 ; } int totalnumbers = R - L + 1 ; int factor9 = totalnumbers / 9 ; int rem = totalnumbers % 9 ; int ans = factor9 ; for ( int i = R ; i > R - rem ; i -- ) { int rem1 = i % 9 ; if ( rem1 == K ) { ans ++ ; } } return ans ; }"
"Translate Python to Java: def firstkdigits ( n , k ) : NEW_LINE INDENT product = n * math . log ( n , 10 ) NEW_LINE decimal_part = product - math . floor ( product ) NEW_LINE decimal_part = pow ( 10 , decimal_part ) NEW_LINE digits = pow ( 10 , k - 1 ) NEW_LINE return math . floor ( decimal_part * digits ) NEW_LINE DEDENT","public static long firstkdigits ( int n , int k ) { double product = n * Math . log10 ( n ) ; double decimal_part = product - Math . floor ( product ) ; decimal_part = Math . pow ( 10 , decimal_part ) ; double digits = Math . pow ( 10 , k - 1 ) , i = 0 ; return ( ( long ) ( decimal_part * digits ) ) ; }"
"Translate Python to Java: def FindElement ( A , n ) : NEW_LINE INDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT flag = 0 NEW_LINE for j in range ( 0 , i , 1 ) : NEW_LINE INDENT if ( A [ j ] >= A [ i ] ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT for j in range ( i + 1 , n , 1 ) : NEW_LINE INDENT if ( A [ j ] <= A [ i ] ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT return A [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT","static int FindElement ( int [ ] A , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int flag = 0 ; for ( int j = 0 ; j < i ; j ++ ) if ( A [ j ] >= A [ i ] ) { flag = 1 ; break ; } for ( int j = i + 1 ; j < n ; j ++ ) if ( A [ j ] <= A [ i ] ) { flag = 1 ; break ; } if ( flag == 0 ) return A [ i ] ; } return - 1 ; }"
"Translate Python to Java: def minimumIncrease ( a , b , c ) : NEW_LINE INDENT arr = [ a , b , c ] NEW_LINE arr . sort ( ) NEW_LINE if arr [ 0 ] + arr [ 1 ] >= arr [ 2 ] : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return arr [ 2 ] - ( arr [ 0 ] + arr [ 1 ] ) NEW_LINE DEDENT DEDENT","static int minimumIncrease ( int a , int b , int c ) { int arr [ ] = { a , b , c } ; Arrays . sort ( arr ) ; if ( arr [ 0 ] + arr [ 1 ] >= arr [ 2 ] ) return 0 ; else return arr [ 2 ] - ( arr [ 0 ] + arr [ 1 ] ) ; }"
