java
static void printStringAlternate ( String str ) { int [ ] occ = new int [ 122 ] ; String s = str . toLowerCase ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char temp = s . charAt ( i ) ; occ [ temp ] ++ ; if ( occ [ temp ] % 2 != 0 ) System . out . print ( str . charAt ( i ) ) ; } System . out . println ( ) ; }
"static void digitsNum ( int N ) { if ( N == 0 ) System . out . println ( ""0"" ) ; if ( N % 9 != 0 ) System . out . print ( ( N % 9 ) ) ; for ( int i = 1 ; i <= ( N / 9 ) ; ++ i ) System . out . print ( ""9"" ) ; for ( int i = 1 ; i <= N ; ++ i ) System . out . print ( ""0"" ) ; System . out . print ( """" ) ; }"
"public static int arraySum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + arr [ i ] ; return sum ; }"
"static void thirdLargest ( int arr [ ] , int arr_size ) { if ( arr_size < 3 ) { System . out . printf ( "" Invalid Input "" ) ; return ; } int first = arr [ 0 ] ; for ( int i = 1 ; i < arr_size ; i ++ ) if ( arr [ i ] > first ) first = arr [ i ] ; int second = Integer . MIN_VALUE ; for ( int i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > second && arr [ i ] < first ) second = arr [ i ] ; int third = Integer . MIN_VALUE ; for ( int i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > third && arr [ i ] < second ) third = arr [ i ] ; System . out . printf ( ""The third Largest "" + ""element is %d\n"" , third ) ; }"
"static boolean isPossibleToZero ( int a [ ] , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( i & 1 ) == 0 ) odd += a [ i ] ; else even += a [ i ] ; } return ( odd == even ) ; }"
"static int maxElement ( int a [ ] , int n ) { if ( n < 3 ) return - 1 ; int maxElement = a [ 0 ] ; int maxProd = a [ n - 1 ] * a [ 1 ] ; for ( int i = 1 ; i < n ; i ++ ) { int currProd = a [ i - 1 ] * a [ ( i + 1 ) % n ] ; if ( currProd > maxProd ) { maxProd = currProd ; maxElement = a [ i ] ; } else if ( currProd == maxProd ) { maxElement = Math . max ( maxElement , a [ i ] ) ; } } return maxElement ; }"
"public static int kthSmallest ( Integer [ ] arr , int k ) { Arrays . sort ( arr ) ; return arr [ k - 1 ] ; }"
"static int CountSubSet ( int arr [ ] , int n , int X ) { int N = ( int ) Math . pow ( 2 , n ) ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) != 0 ) if ( arr [ j ] == X ) count += 1 ; } } return count ; }"
static long removeRecur ( long n ) { long prev_digit = n % 10 ; long pow = 10 ; long res = prev_digit ; while ( n > 0 ) { long curr_digit = n % 10 ; if ( curr_digit != prev_digit ) { res += curr_digit * pow ; prev_digit = curr_digit ; pow *= 10 ; } n = n / 10 ; } return res ; }
"static void asciiToSentence ( String str , int len ) { int num = 0 ; for ( int i = 0 ; i < len ; i ++ ) { num = num * 10 + ( str . charAt ( i ) - '0' ) ; if ( num >= 32 && num <= 122 ) { char ch = ( char ) num ; System . out . print ( ch ) ; num = 0 ; } } }"
"static boolean findWinner ( int x , int y , int n ) { boolean [ ] dp = new boolean [ n + 1 ] ; Arrays . fill ( dp , false ) ; dp [ 0 ] = false ; dp [ 1 ] = true ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i - 1 >= 0 && dp [ i - 1 ] == false ) dp [ i ] = true ; else if ( i - x >= 0 && dp [ i - x ] == false ) dp [ i ] = true ; else if ( i - y >= 0 && dp [ i - y ] == false ) dp [ i ] = true ; else dp [ i ] = false ; } return dp [ n ] ; }"
public static int sumOfSeries ( int n ) { int x = ( n * ( n + 1 ) / 2 ) ; return x * x ; }
"static int countOfSubstringWithKOnes ( String s , int K ) { int N = s . length ( ) ; int res = 0 ; int countOfOne = 0 ; int [ ] freq = new int [ N + 1 ] ; freq [ 0 ] = 1 ; for ( int i = 0 ; i < N ; i ++ ) { countOfOne += ( s . charAt ( i ) - '0' ) ; if ( countOfOne >= K ) { res += freq [ countOfOne - K ] ; } freq [ countOfOne ] ++ ; } return res ; }"
"static int calculate ( int a [ ] , int n ) { int maximum = Arrays . stream ( a ) . max ( ) . getAsInt ( ) ; int frequency [ ] = new int [ maximum + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { frequency [ a [ i ] ] += 1 ; } int answer = 0 ; for ( int i = 0 ; i < ( maximum ) + 1 ; i ++ ) { answer = answer + frequency [ i ] * ( frequency [ i ] - 1 ) ; } return answer / 2 ; }"
static int countSetBits ( int n ) { int i = 0 ; int ans = 0 ; while ( ( 1 << i ) <= n ) { boolean k = false ; int change = 1 << i ; for ( int j = 0 ; j <= n ; j ++ ) { if ( k == true ) ans += 1 ; else ans += 0 ; if ( change == 1 ) { k = ! k ; change = 1 << i ; } else { change -- ; } } i ++ ; } return ans ; }
"static int totalNumber ( int n ) { return 8 * ( int ) Math . pow ( 9 , n - 1 ) ; }"
"static int findS ( int s ) { int l = 1 , r = ( s / 2 ) + 1 ; while ( l <= r ) { int mid = ( l + r ) / 2 ; int sum = mid * ( mid + 1 ) / 2 ; if ( sum == s ) return mid ; else if ( sum > s ) r = mid - 1 ; else l = mid + 1 ; } return - 1 ; }"
public static int findY ( int x ) { if ( x > 2 ) return x - 2 ; return x + 2 ; }
"static void findUniquePair ( int [ ] arr , int n ) { int XOR = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) XOR = XOR ^ arr [ i ] ; int set_bit_no = XOR & ~ ( XOR - 1 ) ; int x = 0 , y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & set_bit_no ) > 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } System . out . println ( ""The unique pair is ("" + x + "","" + y + "")"" ) ; }"
public static void solve ( int x ) { int num = ( int ) Math . ceil ( ( Math . sqrt ( 1 + ( 4 * 2 * x ) ) - 1 ) / 2 ) ; long s = ( num * ( num + 1 ) ) / 2 ; if ( s - x != 1 ) { System . out . println ( num ) ; } else { System . out . println ( num + 1 ) ; } }
"static boolean check ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) { return true ; } } return false ; }"
"public static int minProduct ( int [ ] arr , int n , int k ) { PriorityQueue < Integer > pq = new PriorityQueue < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) pq . add ( arr [ i ] ) ; int count = 0 , ans = 1 ; while ( pq . isEmpty ( ) == false && count < k ) { ans = ans * pq . element ( ) ; pq . remove ( ) ; count ++ ; } return ans ; }"
static int countNonDecreasing ( int n ) { int dp [ ] [ ] = new int [ 10 ] [ n + 1 ] ; for ( int i = 0 ; i < 10 ; i ++ ) dp [ i ] [ 1 ] = 1 ; for ( int digit = 0 ; digit <= 9 ; digit ++ ) { for ( int len = 2 ; len <= n ; len ++ ) { for ( int x = 0 ; x <= digit ; x ++ ) dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] ; } } int count = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) count += dp [ i ] [ n ] ; return count ; }
public static int countPairs ( int n ) { if ( n == 2 ) return 4 ; int num = ( ( n / 2 ) + 1 ) ; int max = n % num ; int count = n - max ; return count ; }
"static int minOperations ( int arr [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } int maxFreq = Integer . MIN_VALUE ; maxFreq = Collections . max ( mp . entrySet ( ) , Comparator . comparingInt ( Map . Entry :: getKey ) ) . getValue ( ) ; return ( n - maxFreq ) ; }"
static int findSum ( int N ) { return ( N * ( N + 1 ) * ( 2 * N - 5 ) + 4 * N ) / 2 ; }
"public static int getSum ( int arr [ ] , int p ) { return arr . length ; }"
"static int countSolutions ( int n ) { int x = 0 , yCount , res = 0 ; for ( yCount = 0 ; yCount * yCount < n ; yCount ++ ) ; while ( yCount != 0 ) { res += yCount ; x ++ ; while ( yCount != 0 && ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) yCount -- ; } return res ; }"
"static double Area ( int b1 , int b2 , int h ) { return ( ( b1 + b2 ) / 2 ) * h ; }"
"static int countSubArrays ( int arr [ ] , int n , int K ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int bitwise_or = 0 ; for ( int k = i ; k <= j ; k ++ ) { bitwise_or = bitwise_or | arr [ k ] ; } if ( bitwise_or >= K ) count ++ ; } } return count ; }"
"static int numberOfMen ( int D , int m , int d ) { int Men = ( m * ( D - d ) ) / d ; return Men ; }"
"static boolean CheckArray ( int arr [ ] , int n ) { int prod = 1 ; for ( int i = 0 ; i < n ; ++ i ) prod *= arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) if ( arr [ i ] == prod / arr [ i ] ) return true ; return false ; }"
"void printRepeating ( int arr [ ] , int size ) { int count [ ] = new int [ size ] ; int i ; System . out . println ( ""Repeated elements are : "" ) ; for ( i = 0 ; i < size ; i ++ ) { if ( count [ arr [ i ] ] == 1 ) System . out . print ( arr [ i ] + "" "" ) ; else count [ arr [ i ] ] ++ ; } }"
"static long answer ( long n ) { long m = 2 ; long ans = 1 ; long r = 1 ; while ( r < n ) { r = ( ( long ) Math . pow ( 2 , m ) - 1 ) * ( ( long ) Math . pow ( 2 , m - 1 ) ) ; if ( r < n ) ans = r ; m ++ ; } return ans ; }"
"static float rectanglearea ( float a , float b ) { if ( a < 0 || b < 0 ) return - 1 ; return 2 * a * b ; }"
"static double maxAvgSubArray ( int a [ ] , int n , int x , int y ) { int prefix [ ] = new int [ n ] ; prefix [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix [ i ] = prefix [ i - 1 ] + a [ i ] ; double maximum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + x - 1 ; j < i + y && j < n ; j ++ ) { double sum = prefix [ j ] ; if ( i > 0 ) sum -= prefix [ i - 1 ] ; double current = sum / ( double ) ( j - i + 1 ) ; maximum = Math . max ( maximum , current ) ; } } return maximum ; }"
"static void countPairs ( int arr [ ] , int n , int k ) { int i , j , cnt = 0 ; for ( i = 0 ; i < n - 1 ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( ( arr [ i ] - arr [ j ] + k ) % k == 0 ) cnt += 1 ; } } System . out . print ( cnt + ""\n"" ) ; }"
"static int getOddOccurrence ( int arr [ ] , int arr_size ) { int i ; for ( i = 0 ; i < arr_size ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < arr_size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count % 2 != 0 ) return arr [ i ] ; } return - 1 ; }"
"static boolean checkCount ( int [ ] arr , int n , int k ) { int count ; for ( int i = 0 ; i < n ; i ++ ) { count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] == arr [ i ] ) count ++ ; if ( count > 2 * k ) return false ; } } return true ; }"
"static void possibleOrNot ( long a1 , long a2 , long b1 , long b2 , long c1 , long c2 ) { long dis1 = ( long ) Math . pow ( b1 - a1 , 2 ) + ( long ) Math . pow ( b2 - a2 , 2 ) ; long dis2 = ( long ) Math . pow ( c1 - b1 , 2 ) + ( long ) Math . pow ( c2 - b2 , 2 ) ; if ( dis1 != dis2 ) System . out . print ( ""No"" ) ; else if ( b1 == ( ( a1 + c1 ) / 2.0 ) && b2 == ( ( a2 + c2 ) / 2.0 ) ) System . out . print ( ""No"" ) ; else System . out . print ( ""Yes"" ) ; }"
"static void checkEvenOdd ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { System . out . print ( ""Even"" ) ; return ; } } System . out . println ( ""Odd"" ) ; }"
"static int countSubStr ( String str , int len ) { int ans = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str . charAt ( i ) == '0' ) ans += ( i + 1 ) ; } return ans ; }"
"static long squareDigitSum ( String s ) { long lengthN = s . length ( ) ; long result = ( lengthN / 9 ) * 81 + ( long ) Math . pow ( ( lengthN % 9 ) , 2 ) ; return result ; }"
"static void find ( int n ) { int b = n ; int a = b * ( n - 1 ) ; if ( a * b > n && a / b < n ) { System . out . print ( ""a = "" + a + "", b = "" + b ) ; } else System . out . println ( - 1 ) ; }"
"static int gcd ( int a , int b ) { int tmp ; while ( a % b != 0 ) { tmp = b ; b = a % b ; a = tmp ; } return b ; }"
"static int getModulo ( int n , int d ) { return ( n & ( d - 1 ) ) ; }"
"static int countPairs ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( ( a [ i ] & a [ j ] ) == 0 ) count += 2 ; } return count ; }"
"static int getPairs ( int a [ ] , int n ) { HashSet < Integer > visited1 = new HashSet < Integer > ( ) ; int un [ ] = new int [ n ] ; un [ n - 1 ] = 0 ; int count = 0 ; for ( int i = n - 1 ; i > 0 ; i -- ) { if ( visited1 . contains ( a [ i ] ) ) un [ i - 1 ] = count ; else un [ i - 1 ] = ++ count ; visited1 . add ( a [ i ] ) ; } HashSet < Integer > visited2 = new HashSet < Integer > ( ) ; int answer = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( visited2 . contains ( a [ i ] ) ) continue ; answer += un [ i ] ; visited2 . add ( a [ i ] ) ; } return answer ; }"
"public static double sumOfSeries ( double num ) { double res = 0 , fact = 1 ; for ( int i = 1 ; i <= num ; i ++ ) { fact = fact * i ; res = res + ( i / fact ) ; } return ( res ) ; }"
"static boolean subarrayPossible ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum <= 0 ) return true ; } sum = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { sum += arr [ i ] ; if ( sum <= 0 ) return true ; } return false ; }"
"static int PowerOFPINnfactorial ( int n , int p ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int count = 0 , temp = i ; while ( temp % p == 0 ) { count ++ ; temp = temp / p ; } ans += count ; } return ans ; }"
"static void line ( double x0 , double y0 ) { double c = ( int ) ( 2 * y0 * x0 ) ; System . out . println ( y0 + ""x"" + "" + "" + x0 + ""y = "" + c ) ; }"
"static int getMinimumOps ( Vector < Integer > ar ) { int n = ar . size ( ) ; int small = Collections . min ( ar ) ; int large = Collections . max ( ar ) ; int [ ] [ ] dp = new int [ n ] [ large + 1 ] ; for ( int j = small ; j <= large ; j ++ ) { dp [ 0 ] [ j ] = Math . abs ( ar . get ( 0 ) - j ) ; } for ( int i = 1 ; i < n ; i ++ ) { int minimum = Integer . MAX_VALUE ; for ( int j = small ; j <= large ; j ++ ) { minimum = Math . min ( minimum , dp [ i - 1 ] [ j ] ) ; dp [ i ] [ j ] = minimum + Math . abs ( ar . get ( i ) - j ) ; } } int ans = Integer . MAX_VALUE ; for ( int j = small ; j <= large ; j ++ ) { ans = Math . min ( ans , dp [ n - 1 ] [ j ] ) ; } return ans ; }"
"static void findNthTerm ( int n ) { n = n * 2 ; int a = 1 , b = 1 , c = - 1 * n ; int d = b * b - 4 * a * c ; double sqrt_val = Math . sqrt ( Math . abs ( d ) ) ; int x1 = ( int ) ( ( - b + sqrt_val ) / ( 2 * a ) ) ; int x2 = ( int ) ( ( - b - sqrt_val ) / ( 2 * a ) ) ; if ( x1 >= 1 ) System . out . println ( ( char ) ( 'a' + x1 ) ) ; else if ( x2 >= 1 ) System . out . println ( ( char ) ( 'a' + x2 ) ) ; }"
"static int count ( String a , String b , int m , int n ) { if ( ( m == 0 && n == 0 ) || n == 0 ) return 1 ; if ( m == 0 ) return 0 ; if ( a . charAt ( m - 1 ) == b . charAt ( n - 1 ) ) return count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ; else return count ( a , b , m - 1 , n ) ; }"
"static void evaluate ( int n ) { if ( n == 1 || n == 2 ) System . out . println ( ""No Pythagoras "" + ""Triplet exists"" ) ; else if ( n % 2 == 0 ) { int var = 1 * n * n / 4 ; System . out . print ( ""Pythagoras Triplets "" + ""exist i.e. "" ) ; System . out . print ( n + "" "" ) ; System . out . print ( var - 1 + "" "" ) ; System . out . println ( var + 1 + "" "" ) ; } else if ( n % 2 != 0 ) { int var = 1 * n * n + 1 ; System . out . print ( ""Pythagoras Triplets "" + ""exist i.e. "" ) ; System . out . print ( n + "" "" ) ; System . out . print ( var / 2 - 1 + "" "" ) ; System . out . println ( var / 2 + "" "" ) ; } }"
"static float areaOfKite ( int d1 , int d2 ) { float area = ( d1 * d2 ) / 2 ; return area ; }"
"static int maxTripletSum ( int arr [ ] , int n ) { int sum = - 1000000 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) sum = arr [ i ] + arr [ j ] + arr [ k ] ; return sum ; }"
"static int maxSum ( int arr [ ] , int n ) { int res = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int index = ( i + j ) % n ; curr_sum += j * arr [ index ] ; } res = Math . max ( res , curr_sum ) ; } return res ; }"
"static int reversDigits ( int num ) { boolean negativeFlag = false ; if ( num < 0 ) { negativeFlag = true ; num = - num ; } int prev_rev_num = 0 , rev_num = 0 ; while ( num != 0 ) { int curr_digit = num % 10 ; rev_num = ( rev_num * 10 ) + curr_digit ; if ( ( rev_num - curr_digit ) / 10 != prev_rev_num ) { System . out . println ( ""WARNING OVERFLOWED!!!"" ) ; return 0 ; } prev_rev_num = rev_num ; num = num / 10 ; } return ( negativeFlag == true ) ? - rev_num : rev_num ; }"
"public static int arraySum ( int arr [ ] , int n ) { int x = ( n + 1 ) / 2 ; return ( arr [ 0 ] - 1 ) * n + x * x ; }"
"static int bridge_length ( int trainLength , int Speed , int Time ) { return ( ( Time * Speed ) - trainLength ) ; }"
"static String findNumber ( int n , int d ) { String ans = """" ; if ( d != 10 ) { ans += Integer . toString ( d ) ; for ( int i = 1 ; i < n ; i ++ ) ans += '0' ; } else { if ( n == 1 ) ans += ""Impossible"" ; else { ans += '1' ; for ( int i = 1 ; i < n ; i ++ ) ans += '0' ; } } return ans ; }"
"static int countMaxSetBits ( int left , int right ) { int max_count = - 1 , num = 0 ; for ( int i = left ; i <= right ; ++ i ) { int temp = i , cnt = 0 ; while ( temp > 0 ) { if ( temp % 2 == 1 ) ++ cnt ; temp >>= 1 ; } if ( cnt > max_count ) { max_count = cnt ; num = i ; } } return num ; }"
"static int countWays ( int n , int arr [ ] , int k ) { if ( k <= 0 || k >= n ) return 0 ; Set < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) s . add ( arr [ i ] ) ; if ( s . size ( ) <= k ) return 0 ; return s . size ( ) - k ; }"
"public static void printCubeFree ( int n ) { boolean [ ] cubFree = new boolean [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) cubFree [ i ] = true ; for ( int i = 2 ; i * i * i <= n ; i ++ ) { if ( cubFree [ i ] ) { for ( int multiple = 1 ; i * i * i * multiple <= n ; multiple ++ ) { cubFree [ i * i * i * multiple ] = false ; } } } for ( int i = 2 ; i <= n ; i ++ ) { if ( cubFree [ i ] == true ) System . out . print ( i + "" "" ) ; } }"
"public static float volumeOfEllipsoid ( float r1 , float r2 , float r3 ) { float pi = ( float ) 3.14 ; return ( float ) 1.33 * pi * r1 * r2 * r3 ; }"
"static int longestSubstring ( String s ) { int cnt = 1 , maxi = 1 ; int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( i - 1 ) ) cnt ++ ; else { maxi = Math . max ( cnt , maxi ) ; cnt = 1 ; } } maxi = Math . max ( cnt , maxi ) ; return maxi ; }"
"static int maxSum ( int arr [ ] , int n ) { if ( n < 2 ) return - 1 ; int ans = arr [ 0 ] + arr [ 1 ] ; for ( int i = 1 ; i + 1 < n ; i ++ ) ans = Math . min ( ans , ( arr [ i ] + arr [ i + 1 ] ) ) ; return ans ; }"
"static void checkPalindrome ( int num ) { String str = Integer . toString ( num ) ; int l = 0 , r = str . length ( ) - 1 ; while ( l < r ) { if ( str . charAt ( l ) != str . charAt ( r ) ) { System . out . print ( ""No"" ) ; return ; } l ++ ; r -- ; } System . out . print ( ""Yes"" ) ; return ; }"
"static void palindrome ( int arr [ ] , int n ) { int flag = 0 ; for ( int i = 0 ; i <= n / 2 && n != 0 ; i ++ ) { if ( arr [ i ] != arr [ n - i - 1 ] ) { flag = 1 ; break ; } } if ( flag == 1 ) System . out . println ( ""Not Palindrome"" ) ; else System . out . println ( ""Palindrome"" ) ; }"
"public static String nextWord ( String str ) { if ( str == """" ) return ""a"" ; int i = str . length ( ) - 1 ; while ( str . charAt ( i ) == 'z' && i >= 0 ) i -- ; if ( i == - 1 ) str = str + 'a' ; else str = str . substring ( 0 , i ) + ( char ) ( ( int ) ( str . charAt ( i ) ) + 1 ) + str . substring ( i + 1 ) ; return str ; }"
static int GIF ( double n ) { return ( int ) Math . floor ( n ) ; }
"static float knapSack ( int W , float wt [ ] , float val [ ] , int n ) { float maxratio = Integer . MIN_VALUE ; int maxindex = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( val [ i ] / wt [ i ] ) > maxratio ) { maxratio = ( val [ i ] / wt [ i ] ) ; maxindex = i ; } } return ( W * maxratio ) ; }"
"static boolean checkSubarraySum ( int arr [ ] , int n , int k , int sum ) { for ( int i = 0 ; i < n - k + 1 ; i ++ ) { int current_sum = 0 ; for ( int j = 0 ; j < k ; j ++ ) current_sum = current_sum + arr [ i + j ] ; if ( current_sum == sum ) return true ; } return false ; }"
"static int findMinimumDeletion ( int l , int r , int dp [ ] [ ] , String s ) { if ( l > r ) { return 0 ; } if ( l == r ) { return 1 ; } if ( dp [ l ] [ r ] != - 1 ) { return dp [ l ] [ r ] ; } int res = 1 + findMinimumDeletion ( l + 1 , r , dp , s ) ; for ( int i = l + 1 ; i <= r ; ++ i ) { if ( s . charAt ( l ) == s . charAt ( i ) ) { res = Math . min ( res , findMinimumDeletion ( l + 1 , i - 1 , dp , s ) + findMinimumDeletion ( i , r , dp , s ) ) ; } } return dp [ l ] [ r ] = res ; }"
"public static void ZigZag ( int rows , int columns , int numbers [ ] ) { int k = 0 ; int [ ] [ ] arr = new int [ rows ] [ columns ] ; for ( int i = 0 ; i < rows ; i ++ ) { if ( i % 2 == 0 ) { for ( int j = 0 ; j < columns && numbers [ k ] > 0 ; j ++ ) { arr [ i ] [ j ] = k + 1 ; numbers [ k ] -- ; if ( numbers [ k ] == 0 ) k ++ ; } } else { for ( int j = columns - 1 ; j >= 0 && numbers [ k ] > 0 ; j -- ) { arr [ i ] [ j ] = k + 1 ; numbers [ k ] -- ; if ( numbers [ k ] == 0 ) k ++ ; } } } for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < columns ; j ++ ) System . out . print ( arr [ i ] [ j ] + "" "" ) ; System . out . println ( ) ; } }"
"static void ReplaceElements ( int arr [ ] , int n ) { int min_ele = arr [ 0 ] ; arr [ 0 ] = - 1 ; for ( int i = 1 ; i < n ; ++ i ) { if ( min_ele < arr [ i ] ) { arr [ i ] = min_ele ; } else if ( min_ele >= arr [ i ] ) { int temp = arr [ i ] ; arr [ i ] = min_ele ; min_ele = temp ; } } }"
"public static int first ( int a , int b , int c ) { a %= b ; for ( int i = 1 ; i <= b ; i ++ ) { a = a * 10 ; if ( a / b == c ) return i ; a %= b ; } return - 1 ; }"
"static long getSum ( int n , int d ) { long sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 10 == d ) sum += i ; } return sum ; }"
"static int countNegative ( int M [ ] [ ] , int n , int m ) { int count = 0 ; int i = 0 ; int j = m - 1 ; while ( j >= 0 && i < n ) { if ( M [ i ] [ j ] < 0 ) { count += j + 1 ; i += 1 ; } else j -= 1 ; } return count ; }"
"static void factorize ( long n ) { int count = 0 ; while ( ! ( n % 2 > 0 ) ) { n >>= 1 ; count ++ ; } if ( count > 0 ) { System . out . println ( ""2"" + "" "" + count ) ; } for ( long i = 3 ; i <= ( long ) Math . sqrt ( n ) ; i += 2 ) { count = 0 ; while ( n % i == 0 ) { count ++ ; n = n / i ; } if ( count > 0 ) { System . out . println ( i + "" "" + count ) ; } } if ( n > 2 ) { System . out . println ( n + "" "" + ""1"" ) ; } }"
"static int countXorPair ( int arr [ ] , int n ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } return odd * even ; }"
"static int check ( int n , List < Integer > marks ) { Integer x = Collections . max ( marks ) ; int bonus = 100 - x ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( marks . get ( i ) + bonus >= 50 ) c += 1 ; } return c ; }"
"static void minSwaps ( String str1 , String str2 ) { int count = 0 ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { if ( str1 . charAt ( i ) != str2 . charAt ( i ) ) count ++ ; } if ( count % 2 == 0 ) System . out . println ( count / 2 ) ; else System . out . println ( ""Not Possible"" ) ; }"
static int xorCalc ( int k ) { if ( k == 1 ) return 2 ; if ( ( ( k + 1 ) & k ) == 0 ) return k / 2 ; return 1 ; }
"static void minSpacePreferLarge ( int wall , int m , int n ) { int num_m = 0 , num_n = 0 , min_empty = wall ; int p = 0 , q = 0 , rem ; while ( wall >= n ) { p = wall / m ; rem = wall % m ; if ( rem <= min_empty ) { num_m = p ; num_n = q ; min_empty = rem ; } q += 1 ; wall = wall - n ; } System . out . println ( num_m + "" "" + num_n + "" "" + min_empty ) ; }"
"static int maxSum ( int arr [ ] , int n ) { int sum = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n / 2 ; i ++ ) { sum -= ( 2 * arr [ i ] ) ; sum += ( 2 * arr [ n - i - 1 ] ) ; } return sum ; }"
"static int printKDistinct ( int arr [ ] , int n , int k ) { int dist_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ j ] == arr [ i ] ) break ; if ( j == n ) dist_count ++ ; if ( dist_count == k ) return arr [ i ] ; } return - 1 ; }"
static boolean checking ( String s ) { int c = 0 ; int n = s . length ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s . charAt ( i ) == '0' ) c ++ ; if ( c >= 6 && s . charAt ( i ) == '1' ) return true ; } return false ; }
"static void printCollatz ( int n ) { while ( n != 1 ) { System . out . print ( n + "" "" ) ; if ( ( n & 1 ) == 1 ) n = 3 * n + 1 ; else n = n / 2 ; } System . out . print ( n ) ; }"
"static long fun ( int marks [ ] , int n ) { long dp [ ] = new long [ n ] ; int temp ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( marks [ i ] > marks [ i + 1 ] ) { temp = i ; while ( true ) { if ( ( marks [ temp ] > marks [ temp + 1 ] ) && temp >= 0 ) { if ( dp [ temp ] > dp [ temp + 1 ] ) { temp -= 1 ; continue ; } else { dp [ temp ] = dp [ temp + 1 ] + 1 ; temp -= 1 ; } } else break ; } } else if ( marks [ i ] < marks [ i + 1 ] ) dp [ i + 1 ] = dp [ i ] + 1 ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += dp [ i ] ; return sum ; }"
"static void sortUsingHash ( int a [ ] , int n ) { int max = Arrays . stream ( a ) . max ( ) . getAsInt ( ) ; int hash [ ] = new int [ max + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) hash [ a [ i ] ] += 1 ; for ( int i = 0 ; i <= max ; i ++ ) { if ( hash [ i ] != 0 ) { for ( int j = 0 ; j < hash [ i ] ; j ++ ) { System . out . print ( i + "" "" ) ; } } } }"
"static boolean check ( String s1 , String s2 ) { int n = s1 . length ( ) ; int m = s2 . length ( ) ; boolean dp [ ] [ ] = new boolean [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { dp [ i ] [ j ] = false ; } } dp [ 0 ] [ 0 ] = true ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { for ( int j = 0 ; j <= s2 . length ( ) ; j ++ ) { if ( dp [ i ] [ j ] ) { if ( j < s2 . length ( ) && ( Character . toUpperCase ( s1 . charAt ( i ) ) == s2 . charAt ( j ) ) ) dp [ i + 1 ] [ j + 1 ] = true ; if ( ! Character . isUpperCase ( s1 . charAt ( i ) ) ) dp [ i + 1 ] [ j ] = true ; } } } return ( dp [ n ] [ m ] ) ; }"
"static void newvol ( double x ) { System . out . print ( ""percentage increase "" + ""in the volume of the cube is "" + ( Math . pow ( x , 3 ) / 10000 + 3 * x + ( 3 * Math . pow ( x , 2 ) ) / 100 ) ) ; System . out . print ( ""%"" ) ; }"
"static void Vertices ( int x , int y ) { int val = Math . abs ( x ) + Math . abs ( y ) ; System . out . print ( val * ( x < 0 ? - 1 : 1 ) + "" 0 "" ) ; System . out . print ( ""0 "" + val * ( y < 0 ? - 1 : 1 ) ) ; }"
"public static int sum ( int N ) { int S1 , S2 , S3 ; S1 = ( ( N / 2 ) ) * ( 2 * 2 + ( N / 2 - 1 ) * 2 ) / 2 ; S2 = ( ( N / 7 ) ) * ( 2 * 7 + ( N / 7 - 1 ) * 7 ) / 2 ; S3 = ( ( N / 14 ) ) * ( 2 * 14 + ( N / 14 - 1 ) * 14 ) / 2 ; return S1 + S2 - S3 ; }"
"static String decToBin ( int n ) { if ( n == 0 ) return ""0"" ; String bin = """" ; while ( n > 0 ) { bin = ( ( n & 1 ) == 0 ? '0' : '1' ) + bin ; n >>= 1 ; } return bin ; }"
static int calcMaxValue ( String str ) { int res = str . charAt ( 0 ) - '0' ; for ( int i = 1 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == '0' || str . charAt ( i ) == '1' || res < 2 ) res += ( str . charAt ( i ) - '0' ) ; else res *= ( str . charAt ( i ) - '0' ) ; } return res ; }
"static void parallel ( int a [ ] [ ] ) { boolean x = true , y = true ; for ( int i = 0 ; i < a . length - 1 ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { if ( a [ i ] [ 0 ] != a [ i + 1 ] [ 0 ] ) x = false ; if ( a [ i ] [ 1 ] != a [ i + 1 ] [ 1 ] ) y = false ; } } if ( x ) System . out . println ( ""Parallel to X Axis"" ) ; else if ( y ) System . out . println ( ""Parallel to Y Axis"" ) ; else System . out . println ( ""Not parallel to X"" + "" and Y axis"" ) ; }"
"static void swap ( int a , int b , int c , int d ) { a = a + b ; b = a - b ; a = a - b ; b = b + c ; c = b - c ; b = b - c ; c = c + d ; d = c - d ; c = c - d ; System . out . println ( ""values after "" + ""swapping are : "" ) ; System . out . println ( ""a = "" + a ) ; System . out . println ( ""b = "" + b ) ; System . out . println ( ""c = "" + c ) ; System . out . println ( ""d = "" + d ) ; }"
public static int [ ] fix ( int [ ] A ) { for ( int i = 0 ; i < A . length ; i ++ ) { if ( A [ i ] != - 1 && A [ i ] != i ) { int x = A [ i ] ; while ( A [ x ] != - 1 && A [ x ] != x ) { int y = A [ x ] ; A [ x ] = x ; x = y ; } A [ x ] = x ; if ( A [ i ] != i ) { A [ i ] = - 1 ; } } } return A ; }
"static int number_of_tower ( int house [ ] , int range , int n ) { Arrays . sort ( house ) ; int numOfTower = 0 ; int i = 0 ; while ( i < n ) { numOfTower ++ ; int loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; -- i ; loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; } return numOfTower ; }"
static long cal_minimum_time ( long X ) { long t = 0 ; long sum = 0 ; while ( sum < X ) { t ++ ; sum = sum + t ; } return t ; }
"static int gcd ( int a , int b ) { if ( a == 0 || b == 0 ) return 0 ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }"
static void findRemainder ( int n ) { int l = n % 10 ; while ( n >= 10 ) n /= 10 ; int f = n ; int remainder = f % l ; System . out . println ( remainder ) ; }
"public static int nth_term ( int n ) { int a = 1 , b = 1 , c = 1 ; for ( int i = 0 ; i < n ; i ++ ) { c = a + b ; a = b ; b = c ; } return c ; }"
"static int findXorSum ( int arr [ ] , int n ) { int sum = 0 ; int mul = 1 ; for ( int i = 0 ; i < 30 ; i ++ ) { int c_odd = 0 ; boolean odd = false ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) odd = ( ! odd ) ; if ( odd ) c_odd ++ ; } for ( int j = 0 ; j < n ; j ++ ) { sum += ( mul * c_odd ) ; if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) c_odd = ( n - j - c_odd ) ; } mul *= 2 ; } return sum ; }"
"static int countNum ( int arr [ ] , int n ) { HashSet < Integer > s = new HashSet < > ( ) ; int count = 0 , maxm = Integer . MIN_VALUE , minm = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { s . add ( arr [ i ] ) ; if ( arr [ i ] < minm ) minm = arr [ i ] ; if ( arr [ i ] > maxm ) maxm = arr [ i ] ; } for ( int i = minm ; i <= maxm ; i ++ ) if ( ! s . contains ( i ) ) count ++ ; return count ; }"
"public static void psuedoBinary ( int n ) { while ( n != 0 ) { int temp = n , m = 0 , p = 1 ; while ( temp != 0 ) { int rem = temp % 10 ; temp = temp / 10 ; if ( rem != 0 ) m += p ; p *= 10 ; } System . out . print ( m + "" "" ) ; n = n - m ; } System . out . println ( "" "" ) ; }"
"static int seiresSum ( int n , int [ ] a ) { return n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ; }"
static boolean isMultipleof5 ( int n ) { while ( n > 0 ) n = n - 5 ; if ( n == 0 ) return true ; return false ; }
"static int countUnique ( int arr [ ] , int n ) { HashSet < Integer > s = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { s . add ( arr [ i ] ) ; } int count = ( int ) Math . pow ( s . size ( ) , 2 ) ; return count ; }"
"static boolean subArray ( int [ ] arr , int n , int m ) { int i ; HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( i = 0 ; i < n ; i ++ ) { mp . put ( arr [ i ] , i + 1 ) ; } int sumcur = 0 ; int p = Integer . MAX_VALUE ; Vector < Integer > ans = new Vector < Integer > ( ) ; for ( i = 1 ; i <= m ; i ++ ) { sumcur += mp . get ( i ) ; p = Math . min ( p , mp . get ( i ) ) ; int val = p * i - i + ( i * ( i + 1 ) ) / 2 ; if ( i == m ) { if ( val == sumcur ) { return true ; } else return false ; } } return false ; }"
"private static void printSorted ( int [ ] arr , int start , int end ) { if ( start > end ) return ; printSorted ( arr , start * 2 + 1 , end ) ; System . out . print ( arr [ start ] + "" "" ) ; printSorted ( arr , start * 2 + 2 , end ) ; }"
"static int MinCostTree ( int arr [ ] , int n ) { int ans = 0 ; Vector < Integer > st = new Vector < Integer > ( ) ; st . add ( Integer . MAX_VALUE ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( st . get ( st . size ( ) - 1 ) <= arr [ i ] ) { int x = st . get ( st . size ( ) - 1 ) ; st . remove ( st . size ( ) - 1 ) ; ans += x * Math . min ( st . get ( st . size ( ) - 1 ) , arr [ i ] ) ; } st . add ( arr [ i ] ) ; } for ( int i = 2 ; i < st . size ( ) ; i ++ ) ans += st . get ( i ) * st . get ( i - 1 ) ; return ans ; }"
"static long sumOfLastDig ( long n , long m ) { long sum = 0 , k ; k = n / m ; long [ ] arr = new long [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { arr [ i ] = m * ( i + 1 ) % 10 ; sum += arr [ i ] ; } long rem = k % 10 ; long ans = ( k / 10 ) * sum ; for ( int i = 0 ; i < rem ; i ++ ) { ans += arr [ i ] ; } return ans ; }"
"public static int countUnvisited ( int n , int m ) { int X = ( m * n ) - m - n ; Queue < Integer > queue = new LinkedList < > ( ) ; queue . add ( X ) ; int count = 0 ; while ( ! queue . isEmpty ( ) ) { int curr = queue . poll ( ) ; count ++ ; if ( curr - m > 0 ) queue . add ( curr - m ) ; if ( curr - n > 0 ) queue . add ( curr - n ) ; } return count ; }"
"static int MaxSumDifference ( Integer [ ] a , int n ) { List < Integer > finalSequence = new ArrayList < Integer > ( ) ; Arrays . sort ( a ) ; for ( int i = 0 ; i < n / 2 ; ++ i ) { finalSequence . add ( a [ i ] ) ; finalSequence . add ( a [ n - i - 1 ] ) ; } int MaximumSum = 0 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { MaximumSum = MaximumSum + Math . abs ( finalSequence . get ( i ) - finalSequence . get ( i + 1 ) ) ; } MaximumSum = MaximumSum + Math . abs ( finalSequence . get ( n - 1 ) - finalSequence . get ( 0 ) ) ; return MaximumSum ; }"
"static void findNthRoot ( double x , int n ) { double low , high ; if ( x >= 0 && x <= 1 ) { low = x ; high = 1 ; } else { low = 1 ; high = x ; } double epsilon = 0.00000001 ; double guess = ( low + high ) / 2 ; while ( Math . abs ( ( Math . pow ( guess , n ) ) - x ) >= epsilon ) { if ( Math . pow ( guess , n ) > x ) { high = guess ; } else { low = guess ; } guess = ( low + high ) / 2 ; } System . out . println ( guess ) ; }"
"static int solve ( int A [ ] , int B [ ] , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( Integer . bitCount ( A [ i ] & A [ j ] ) == B [ j ] ) { cnt ++ ; } } } return cnt ; }"
"public static int checkValidity ( int a , int b , int c ) { if ( a + b <= c || a + c <= b || b + c <= a ) return 0 ; else return 1 ; }"
int factorial ( int n ) { return ( n == 1 || n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
"static float exponential ( int n , float x ) { float sum = 1 ; for ( int i = n - 1 ; i > 0 ; -- i ) sum = 1 + x * sum / i ; return sum ; }"
"static void equation_plane ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int x3 , int y3 , int z3 , int x , int y , int z ) { int a1 = x2 - x1 ; int b1 = y2 - y1 ; int c1 = z2 - z1 ; int a2 = x3 - x1 ; int b2 = y3 - y1 ; int c2 = z3 - z1 ; int a = b1 * c2 - b2 * c1 ; int b = a2 * c1 - a1 * c2 ; int c = a1 * b2 - b1 * a2 ; int d = ( - a * x1 - b * y1 - c * z1 ) ; if ( a * x + b * y + c * z + d == 0 ) System . out . println ( ""Coplanar"" ) ; else System . out . println ( ""Not Coplanar"" ) ; }"
"static void countOddRotations ( int n ) { int odd_count = 0 , even_count = 0 ; do { int digit = n % 10 ; if ( digit % 2 == 1 ) odd_count ++ ; else even_count ++ ; n = n / 10 ; } while ( n != 0 ) ; System . out . println ( ""Odd = "" + odd_count ) ; System . out . println ( ""Even = "" + even_count ) ; }"
"static int countSubSeq ( String str , int len ) { int ans = 0 ; int mul = 1 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str . charAt ( i ) == '0' ) ans += mul ; mul *= 2 ; } return ans ; }"
"static void minSet ( ArrayList < Integer > nums ) { ArrayList < Integer > A = new ArrayList < Integer > ( ) ; Collections . sort ( nums ) ; int sum = 0 ; for ( int i = 0 ; i < nums . size ( ) ; i ++ ) sum += nums . get ( i ) ; int temp = 0 ; for ( int i = nums . size ( ) - 1 ; i >= 0 && temp <= sum / 2 ; i -- ) { A . add ( nums . get ( i ) ) ; temp += nums . get ( i ) ; } for ( int i = 0 ; i < A . size ( ) ; i ++ ) System . out . print ( A . get ( i ) + "" "" ) ; }"
static boolean isOsiris ( int n ) { int a = n % 10 ; int b = ( n / 10 ) % 10 ; int c = n / 100 ; int digit_sum = a + b + c ; if ( n == ( 2 * ( digit_sum ) * 11 ) ) { return true ; } return false ; }
"static void twoWaySort ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) != 0 ) arr [ i ] *= - 1 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) != 0 ) arr [ i ] *= - 1 ; }"
"static int modInverse ( int a , int m ) { a = a % m ; for ( int x = 1 ; x < m ; x ++ ) if ( ( a * x ) % m == 1 ) return x ; return 1 ; }"
"static int maxLines ( int n , int x1 [ ] , int y1 [ ] , int x2 [ ] , int y2 [ ] ) { Set < Double > s = new HashSet < Double > ( ) ; double slope ; for ( int i = 0 ; i < n ; ++ i ) { if ( x1 [ i ] == x2 [ i ] ) slope = Integer . MAX_VALUE ; else slope = ( y2 [ i ] - y1 [ i ] ) * 1.0 / ( x2 [ i ] - x1 [ i ] ) * 1.0 ; s . add ( slope ) ; } return s . size ( ) ; }"
"static int printKDistinct ( int arr [ ] , int n , int k ) { Map < Integer , Integer > h = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( h . containsKey ( arr [ i ] ) ) h . put ( arr [ i ] , h . get ( arr [ i ] ) + 1 ) ; else h . put ( arr [ i ] , 1 ) ; } if ( h . size ( ) < k ) return - 1 ; int dist_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( h . get ( arr [ i ] ) == 1 ) dist_count ++ ; if ( dist_count == k ) return arr [ i ] ; } return - 1 ; }"
static char maxRepeating ( String str ) { int n = str . length ( ) ; int count = 0 ; char res = str . charAt ( 0 ) ; int cur_count = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n - 1 && str . charAt ( i ) == str . charAt ( i + 1 ) ) cur_count ++ ; else { if ( cur_count > count ) { count = cur_count ; res = str . charAt ( i ) ; } cur_count = 1 ; } } return res ; }
"public static int dealnnoy ( int n , int m ) { if ( m == 0 || n == 0 ) return 1 ; return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 ) ; }"
"static int longestsubarray ( int arr [ ] , int n , int k ) { int current_count = 0 ; int max_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) current_count ++ ; else current_count = 0 ; max_count = Math . max ( current_count , max_count ) ; } return max_count ; }"
"static int SUM ( int n , int m ) { if ( m == 1 ) return ( n * ( n + 1 ) / 2 ) ; int sum = SUM ( n , m - 1 ) ; return ( sum * ( sum + 1 ) / 2 ) ; }"
"public static long maxOR ( long arr [ ] , int n , int k , int x ) { long preSum [ ] = new long [ n + 1 ] ; long suffSum [ ] = new long [ n + 1 ] ; long res = 0 , pow = 1 ; for ( int i = 0 ; i < k ; i ++ ) pow *= x ; preSum [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) preSum [ i + 1 ] = preSum [ i ] | arr [ i ] ; suffSum [ n ] = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) suffSum [ i ] = suffSum [ i + 1 ] | arr [ i ] ; res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res = Math . max ( res , preSum [ i ] | ( arr [ i ] * pow ) | suffSum [ i + 1 ] ) ; return res ; }"
static boolean findDuplicateparenthesis ( String s ) { Stack < Character > Stack = new Stack < > ( ) ; char [ ] str = s . toCharArray ( ) ; for ( char ch : str ) { if ( ch == ')' ) { char top = Stack . peek ( ) ; Stack . pop ( ) ; int elementsInside = 0 ; while ( top != '(' ) { elementsInside ++ ; top = Stack . peek ( ) ; Stack . pop ( ) ; } if ( elementsInside < 1 ) { return true ; } } else { Stack . push ( ch ) ; } } return false ; }
static int countDigit ( long n ) { if ( n == 0 ) return 0 ; return 1 + countDigit ( n / 10 ) ; }
"static int findNthOccur ( String str , char ch , int N ) { int occur = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ch ) { occur += 1 ; } if ( occur == N ) return i ; } return - 1 ; }"
"static String minNum ( char num [ ] , int k ) { int len = num . length ; if ( len == 0 || k == 0 ) { String num_str = new String ( num ) ; return num_str ; } if ( len == 1 ) return ""0"" ; if ( num [ 0 ] != '1' ) { num [ 0 ] = '1' ; k -- ; } int i = 1 ; while ( k > 0 && i < len ) { if ( num [ i ] != '0' ) { num [ i ] = '0' ; k -- ; } i ++ ; } String num_str = new String ( num ) ; return num_str ; }"
"static boolean checkPandigital ( int b , String n ) { if ( n . length ( ) < b ) return false ; boolean hash [ ] = new boolean [ b ] ; Arrays . fill ( hash , false ) ; for ( int i = 0 ; i < n . length ( ) ; i ++ ) { if ( n . charAt ( i ) >= '0' && n . charAt ( i ) <= '9' ) hash [ n . charAt ( i ) - '0' ] = true ; else if ( n . charAt ( i ) - 'A' <= b - 11 ) hash [ n . charAt ( i ) - 'A' + 10 ] = true ; } for ( int i = 0 ; i < b ; i ++ ) if ( hash [ i ] == false ) return false ; return true ; }"
"static int max_sum ( int a [ ] , int n ) { int [ ] dp = new int [ n ] ; if ( n == 1 ) { dp [ 0 ] = Math . max ( 0 , a [ 0 ] ) ; } else if ( n == 2 ) { dp [ 0 ] = Math . max ( 0 , a [ 0 ] ) ; dp [ 1 ] = Math . max ( a [ 1 ] , dp [ 0 ] ) ; } else if ( n >= 3 ) { dp [ 0 ] = Math . max ( 0 , a [ 0 ] ) ; dp [ 1 ] = Math . max ( a [ 1 ] , Math . max ( 0 , a [ 0 ] ) ) ; dp [ 2 ] = Math . max ( a [ 2 ] , Math . max ( a [ 1 ] , Math . max ( 0 , a [ 0 ] ) ) ) ; int i = 3 ; while ( i < n ) { dp [ i ] = Math . max ( dp [ i - 1 ] , a [ i ] + dp [ i - 3 ] ) ; i ++ ; } } return dp [ n - 1 ] ; }"
"static int [ ] solve ( int [ ] arr , int n ) { int [ ] b = new int [ n ] ; int p = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { b [ p ] = arr [ i -- ] ; if ( i >= 0 ) b [ n - 1 - p ] = arr [ i ] ; p ++ ; } return b ; }"
"static long numbers ( int n ) { return ( long ) ( Math . pow ( 2 , n + 1 ) ) - 2 ; }"
static int countDigit ( long n ) { int count = 0 ; while ( n != 0 ) { n = n / 10 ; ++ count ; } return count ; }
"static int maxSum ( int arr [ ] , int n ) { int cum_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) cum_sum += arr [ i ] ; int curr_val = 0 ; for ( int i = 0 ; i < n ; i ++ ) curr_val += i * arr [ i ] ; int res = curr_val ; for ( int i = 1 ; i < n ; i ++ ) { int next_val = curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) ; curr_val = next_val ; res = Math . max ( res , next_val ) ; } return res ; }"
"static void findIntegers ( int n , int x , int y ) { ArrayList < Integer > ans = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) ans . add ( 1 ) ; if ( y - ( n - 1 ) <= 0 ) { System . out . print ( ""-1"" ) ; return ; } ans . add ( y - ( n - 1 ) ) ; int store = 0 ; for ( int i = 0 ; i < n ; i ++ ) store += ans . get ( i ) * ans . get ( i ) ; if ( store < x ) { System . out . print ( ""-1"" ) ; return ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( ans . get ( i ) + "" "" ) ; }"
"static int Minsteps ( int n , int m ) { int ans = 0 ; while ( m > n ) { if ( m % 2 != 0 ) { m ++ ; ans ++ ; } m /= 2 ; ans ++ ; } return ans + n - m ; }"
"static boolean findNature ( int a , int b , int n ) { if ( n == 0 ) return ( a & 1 ) == 1 ? true : false ; if ( n == 1 ) return ( b & 1 ) == 1 ? true : false ; if ( ( a & 1 ) == 0 ) { if ( ( b & 1 ) == 0 ) return false ; else return ( n % 3 != 0 ) ; } else { if ( ( b & 1 ) == 0 ) return ( ( n - 1 ) % 3 != 0 ) ; else return ( ( n + 1 ) % 3 != 0 ) ; } }"
"static int minimumMoves ( int n , int a [ ] , int s , int t ) { int i , x ; x = s ; for ( i = 1 ; i <= n ; i ++ ) { if ( x == t ) break ; x = a [ x ] ; } if ( x == t ) return i - 1 ; else return - 1 ; }"
"static void printPattern ( int n ) { int var1 , var = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 != 0 ) { var = var + i - 1 ; for ( int j = 1 ; j <= i ; j ++ ) { if ( j == 1 ) { System . out . print ( var ) ; } else System . out . print ( ""*"" + var ) ; var ++ ; } } else { var1 = var + i - 1 ; for ( int j = 1 ; j <= i ; j ++ ) { if ( j == 1 ) { System . out . print ( var1 ) ; } else { System . out . print ( ""*"" + var1 ) ; } var1 -- ; } } System . out . print ( ""\n"" ) ; } }"
"static int findoptimal ( int N ) { if ( N <= 6 ) return N ; int [ ] screen = new int [ N ] ; int b ; int n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = Math . max ( 2 * screen [ n - 4 ] , Math . max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) ; } return screen [ N - 1 ] ; }"
"static int sumofoddFactors ( int n ) { int res = 1 ; while ( n % 2 == 0 ) n = n / 2 ; for ( int i = 3 ; i <= Math . sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }"
"static void printKMissing ( int [ ] arr , int n , int k ) { Arrays . sort ( arr ) ; int i = 0 ; while ( i < n && arr [ i ] <= 0 ) i ++ ; int count = 0 , curr = 1 ; while ( count < k && i < n ) { if ( arr [ i ] != curr ) { System . out . print ( curr + "" "" ) ; count ++ ; } else i ++ ; curr ++ ; } while ( count < k ) { System . out . print ( curr + "" "" ) ; curr ++ ; count ++ ; } }"
static int smallestDivisor ( int n ) { if ( n % 2 == 0 ) return 2 ; for ( int i = 3 ; i * i <= n ; i += 2 ) { if ( n % i == 0 ) return i ; } return n ; }
public static int numberOfSquares ( int base ) { base = ( base - 2 ) ; base = base / 2 ; return base * ( base + 1 ) / 2 ; }
"public static void print2largest ( int arr [ ] , int arr_size ) { int i , first , second ; if ( arr_size < 2 ) { System . out . print ( "" Invalid Input "" ) ; return ; } first = second = Integer . MIN_VALUE ; for ( i = 0 ; i < arr_size ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second && arr [ i ] != first ) second = arr [ i ] ; } if ( second == Integer . MIN_VALUE ) System . out . print ( ""There is no second largest"" + "" element\n"" ) ; else System . out . print ( ""The second largest element"" + "" is "" + second ) ; }"
"static void printGP ( int a , int r , int n ) { int curr_term ; for ( int i = 0 ; i < n ; i ++ ) { curr_term = a * ( int ) Math . pow ( r , i ) ; System . out . print ( curr_term + "" "" ) ; } }"
"static void subString ( char str [ ] , int n ) { for ( int len = 1 ; len <= n ; len ++ ) { for ( int i = 0 ; i <= n - len ; i ++ ) { int j = i + len - 1 ; for ( int k = i ; k <= j ; k ++ ) { System . out . print ( str [ k ] ) ; } System . out . println ( ) ; } } }"
"static boolean isComposite ( int n ) { if ( n <= 1 ) System . out . println ( ""False"" ) ; if ( n <= 3 ) System . out . println ( ""False"" ) ; if ( n % 2 == 0 || n % 3 == 0 ) return true ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; return false ; }"
"static String LexicographicalMaxString ( String str ) { String mx = """" ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { if ( mx . compareTo ( str . substring ( i ) ) <= 0 ) { mx = str . substring ( i ) ; } } return mx ; }"
"static void print_first_N_primes ( int N ) { int i , j , flag ; System . out . println ( ""Prime numbers between 1 and "" + N + "" are:"" ) ; for ( i = 1 ; i <= N ; i ++ ) { if ( i == 1 || i == 0 ) continue ; flag = 1 ; for ( j = 2 ; j <= i / 2 ; ++ j ) { if ( i % j == 0 ) { flag = 0 ; break ; } } if ( flag == 1 ) System . out . print ( i + "" "" ) ; } }"
static boolean isPerfectSquareString ( String str ) { int sum = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) sum += ( int ) str . charAt ( i ) ; long squareRoot = ( long ) Math . sqrt ( sum ) ; return ( ( squareRoot - Math . floor ( squareRoot ) ) == 0 ) ; }
"static int NumberOfSolutions ( int x , int y , int z , int n ) { int ans = 0 ; for ( int i = 0 ; i <= x ; i ++ ) { for ( int j = 0 ; j <= y ; j ++ ) { int temp = n - i - j ; if ( temp >= 0 ) { temp = Math . min ( temp , z ) ; ans += temp + 1 ; } } } return ans ; }"
"static int countWords ( String str , int len ) { int count = 1 ; if ( len == 1 ) return count ; if ( str . charAt ( 0 ) == str . charAt ( 1 ) ) count *= 1 ; else count *= 2 ; for ( int j = 1 ; j < len - 1 ; j ++ ) { if ( str . charAt ( j ) == str . charAt ( j - 1 ) && str . charAt ( j ) == str . charAt ( j + 1 ) ) count *= 1 ; else if ( str . charAt ( j ) == str . charAt ( j - 1 ) || str . charAt ( j ) == str . charAt ( j + 1 ) || str . charAt ( j - 1 ) == str . charAt ( j + 1 ) ) count *= 2 ; else count *= 3 ; } if ( str . charAt ( len - 1 ) == str . charAt ( len - 2 ) ) count *= 1 ; else count *= 2 ; return count ; }"
"static int maxLength ( String s , int n ) { int dp [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( s . charAt ( i ) == '(' && s . charAt ( i + 1 ) == ')' ) dp [ i ] [ i + 1 ] = 2 ; for ( int l = 2 ; l < n ; l ++ ) { for ( int i = 0 , j = l ; j < n ; i ++ , j ++ ) { if ( s . charAt ( i ) == '(' && s . charAt ( j ) == ')' ) dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] ; for ( int k = i ; k < j ; k ++ ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) ; } } return dp [ 0 ] [ n - 1 ] ; }"
static char first ( String str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( Character . isUpperCase ( str . charAt ( i ) ) ) return str . charAt ( i ) ; return 0 ; }
static long hexadecagonalNum ( long n ) { return ( ( 14 * n * n ) - 12 * n ) / 2 ; }
"static int Remainder ( String str , int R ) { int len = str . length ( ) ; int Num , Rem = 0 ; for ( int i = 0 ; i < len ; i ++ ) { Num = Rem * 10 + ( str . charAt ( i ) - '0' ) ; Rem = Num % R ; } return Rem ; }"
"public static int oddSum ( int n ) { int sum = 0 , curr = 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum += curr ; curr += 2 ; } return sum ; }"
"static void pattern ( int n ) { int i , j , k = 0 ; for ( i = n - 1 ; i >= 0 ; i -- ) { for ( j = n - 1 ; j > k ; j -- ) { System . out . print ( "" "" ) ; } System . out . print ( ( char ) ( i + 65 ) ) ; for ( j = 1 ; j < ( k * 2 ) ; j ++ ) System . out . print ( "" "" ) ; if ( i < n - 1 ) System . out . print ( ( char ) ( i + 65 ) ) ; System . out . print ( ""\n"" ) ; k ++ ; } }"
static int countSubsequences ( String s ) { int aCount = 0 ; int bCount = 0 ; int cCount = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == 'a' ) aCount = ( 1 + 2 * aCount ) ; else if ( s . charAt ( i ) == 'b' ) bCount = ( aCount + 2 * bCount ) ; else if ( s . charAt ( i ) == 'c' ) cCount = ( bCount + 2 * cCount ) ; } return cCount ; }
"static int sameOccurrence ( int arr [ ] , int n , int x , int y ) { int result = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { int ctX = 0 , ctY = 0 ; for ( int j = i ; j <= n - 1 ; j ++ ) { if ( arr [ j ] == x ) ctX += 1 ; else if ( arr [ j ] == y ) ctY += 1 ; if ( ctX == ctY ) result += 1 ; } } return ( result ) ; }"
static int center_nonadecagon_num ( int n ) { return ( 19 * n * n - 19 * n + 2 ) / 2 ; }
static int invertBits ( int n ) { int x = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; int m = 1 << x ; m = m | m - 1 ; n = n ^ m ; return n ; }
"static int max_xor ( int arr [ ] , int n ) { int maxx = 0 , mask = 0 ; HashSet < Integer > se = new HashSet < Integer > ( ) ; for ( int i = 30 ; i >= 0 ; i -- ) { mask |= ( 1 << i ) ; for ( int j = 0 ; j < n ; ++ j ) { se . add ( arr [ j ] & mask ) ; } int newMaxx = maxx | ( 1 << i ) ; for ( int prefix : se ) { if ( se . contains ( newMaxx ^ prefix ) ) { maxx = newMaxx ; break ; } } se . clear ( ) ; } return maxx ; }"
"static int countGroups ( int position , int previous_sum , int length , String num ) { if ( position == length ) return 1 ; int res = 0 ; int sum = 0 ; for ( int i = position ; i < length ; i ++ ) { sum += ( num . charAt ( i ) - '0' ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } return res ; }"
"static void findSet ( int arr [ ] , int n , int k , int m ) { Vector < Integer > [ ] remainder_set = new Vector [ k ] ; for ( int i = 0 ; i < k ; i ++ ) { remainder_set [ i ] = new Vector < Integer > ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { int rem = arr [ i ] % k ; remainder_set [ rem ] . add ( arr [ i ] ) ; } for ( int i = 0 ; i < k ; i ++ ) { if ( remainder_set [ i ] . size ( ) >= m ) { System . out . println ( ""Yes"" ) ; for ( int j = 0 ; j < m ; j ++ ) System . out . print ( remainder_set [ i ] . get ( j ) + "" "" ) ; return ; } } System . out . print ( ""No"" ) ; }"
"static String Hex ( int num ) { HashMap < Integer , Character > m = new HashMap < Integer , Character > ( ) ; char digit = '0' ; char c = 'a' ; for ( int i = 0 ; i <= 15 ; i ++ ) { if ( i < 10 ) { m . put ( i , digit ) ; digit ++ ; } else { m . put ( i , c ) ; c ++ ; } } String res = """" ; if ( num == 0 ) { return ""0"" ; } if ( num > 0 ) { while ( num != 0 ) { res = m . get ( num % 16 ) + res ; num /= 16 ; } } else { int n = num ; while ( n != 0 ) { res = m . get ( n % 16 ) + res ; n /= 16 ; } } return res ; }"
"static int minItems ( int k , int r ) { for ( int i = 1 ; i < 10 ; i ++ ) if ( ( i * k - r ) % 10 == 0 || ( i * k ) % 10 == 0 ) return i ; return 10 ; }"
"static int countNum ( int N , int arr [ ] ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( i == j ) continue ; else sum += arr [ j ] ; } if ( sum % arr [ i ] == 0 ) count ++ ; } return count ; }"
"static void removeZeros ( int [ ] a , int n ) { int ind = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] != 0 ) { ind = i ; break ; } } if ( ind == - 1 ) { System . out . print ( ""Array has leading zeros only"" ) ; return ; } int [ ] b = new int [ n - ind ] ; for ( int i = 0 ; i < n - ind ; i ++ ) b [ i ] = a [ ind + i ] ; for ( int i = 0 ; i < n - ind ; i ++ ) System . out . print ( b [ i ] + "" "" ) ; }"
"static void printPattern ( int radius ) { double dist ; for ( int i = 0 ; i <= 2 * radius ; i ++ ) { for ( int j = 0 ; j <= 2 * radius ; j ++ ) { dist = Math . sqrt ( ( i - radius ) * ( i - radius ) + ( j - radius ) * ( j - radius ) ) ; if ( dist > radius - 0.5 && dist < radius + 0.5 ) System . out . print ( ""*"" ) ; else System . out . print ( "" "" ) ; } System . out . print ( ""\n"" ) ; } }"
"static boolean EqualNumbers ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { while ( a [ i ] % 2 == 0 ) { a [ i ] /= 2 ; } while ( a [ i ] % 3 == 0 ) { a [ i ] /= 3 ; } if ( a [ i ] != a [ 0 ] ) { return false ; } } return true ; }"
"static void stoogesort ( int arr [ ] , int l , int h ) { if ( l >= h ) return ; if ( arr [ l ] > arr [ h ] ) { int t = arr [ l ] ; arr [ l ] = arr [ h ] ; arr [ h ] = t ; } if ( h - l + 1 > 2 ) { int t = ( h - l + 1 ) / 3 ; stoogesort ( arr , l , h - t ) ; stoogesort ( arr , l + t , h ) ; stoogesort ( arr , l , h - t ) ; } }"
"static int maxSubarrayXOR ( int arr [ ] , int n ) { int ans = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int curr_xor = 0 ; for ( int j = i ; j < n ; j ++ ) { curr_xor = curr_xor ^ arr [ j ] ; ans = Math . max ( ans , curr_xor ) ; } } return ans ; }"
static int leonardo ( int n ) { if ( n == 0 || n == 1 ) return 1 ; return ( leonardo ( n - 1 ) + leonardo ( n - 2 ) + 1 ) ; }
"static String nthprimedigitsnumber ( int number ) { int rem ; String num = """" ; while ( number > 0 ) { rem = number % 4 ; switch ( rem ) { case 1 : num += '2' ; break ; case 2 : num += '3' ; break ; case 3 : num += '5' ; break ; case 0 : num += '7' ; break ; } if ( number % 4 == 0 ) number -- ; number = number / 4 ; } return new StringBuilder ( num ) . reverse ( ) . toString ( ) ; }"
"static int findMin ( int arr [ ] , int n ) { int ans = 1 ; for ( int i = 0 ; i < n ; i ++ ) { int j = i + 1 ; while ( j < n && arr [ j ] >= arr [ j - 1 ] ) j ++ ; ans = Math . max ( ans , j - i ) ; i = j - 1 ; } return n - ans ; }"
"static int sum ( int a , int b ) { int sum = 0 ; for ( int i = 1 ; i <= Math . min ( a , b ) ; i ++ ) if ( a % i == 0 && b % i == 0 ) sum += i ; return sum ; }"
"static int smallestIndexsum ( int arr [ ] , int n ) { int i = n - 1 ; while ( i >= 0 && arr [ i ] % 2 == 1 ) i -- ; int sum = 0 ; for ( int j = 0 ; j <= i ; j ++ ) sum += arr [ j ] ; return sum ; }"
"static boolean canBecomeEmpty ( String str , String sub_str ) { while ( str . length ( ) > 0 ) { int idx = str . indexOf ( sub_str ) ; if ( idx == - 1 ) { break ; } str = str . replaceFirst ( sub_str , """" ) ; } return ( str . length ( ) == 0 ) ; }"
public static int [ ] sortArrays ( int [ ] arr ) { int length = arr . length ; for ( int j = 0 ; j < length - 1 ; j ++ ) { if ( arr [ j ] > arr [ j + 1 ] ) { int temp = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; j = - 1 ; } } return arr ; }
"public static boolean check_elements ( int arr [ ] , int n , int A , int B ) { int range = B - A ; for ( int i = 0 ; i < n ; i ++ ) { if ( Math . abs ( arr [ i ] ) >= A && Math . abs ( arr [ i ] ) <= B ) { int z = Math . abs ( arr [ i ] ) - A ; if ( arr [ z ] > 0 ) { arr [ z ] = arr [ z ] * - 1 ; } } } int count = 0 ; for ( int i = 0 ; i <= range && i < n ; i ++ ) { if ( arr [ i ] > 0 ) return false ; else count ++ ; } if ( count != ( range + 1 ) ) return false ; return true ; }"
"static String sumBaseB ( String a , String b , int base ) { int len_a , len_b ; len_a = a . length ( ) ; len_b = b . length ( ) ; String sum , s ; s = """" ; sum = """" ; int diff ; diff = Math . abs ( len_a - len_b ) ; for ( int i = 1 ; i <= diff ; i ++ ) s += ""0"" ; if ( len_a < len_b ) a = s + a ; else b = s + b ; int curr , carry = 0 ; for ( int i = Math . max ( len_a , len_b ) - 1 ; i > - 1 ; i -- ) { curr = carry + ( a . charAt ( i ) - '0' ) + ( b . charAt ( i ) - '0' ) ; carry = curr / base ; curr = curr % base ; sum = ( char ) ( curr + '0' ) + sum ; } if ( carry > 0 ) sum = ( char ) ( carry + '0' ) + sum ; return sum ; }"
int Circumference ( int a ) { return 4 * a ; }
static boolean isDivBy9 ( int n ) { if ( n == 0 || n == 9 ) return true ; if ( n < 9 ) return false ; return isDivBy9 ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 ) ) ; }
"static int minimumOperations ( int arr [ ] , int n ) { int brr [ ] = { 0 , 0 , 0 , 0 }; for ( int i = 0 ; i < n ; i ++ ) brr [ arr [ i ] % 4 ] ++ ; if ( ( brr [ 1 ] + 2 * brr [ 2 ] + 3 * brr [ 3 ] ) % 4 == 0 ) { int min_opr = Math . min ( brr [ 3 ] , brr [ 1 ] ) ; brr [ 3 ] -= min_opr ; brr [ 1 ] -= min_opr ; min_opr += brr [ 2 ] / 2 ; brr [ 2 ] %= 2 ; if ( brr [ 2 ] == 1 ) { min_opr += 2 ; brr [ 2 ] = 0 ; if ( brr [ 3 ] == 1 ) brr [ 3 ] -= 2 ; if ( brr [ 1 ] == 1 ) brr [ 1 ] -= 2 ; } if ( brr [ 1 ] == 1 ) min_opr += ( brr [ 1 ] / 4 ) * 3 ; if ( brr [ 3 ] == 1 ) min_opr += ( brr [ 3 ] / 4 ) * 3 ; return min_opr ; } return - 1 ; }"
"static int countDivisors ( int n , int k ) { int count = 0 , i ; for ( i = 1 ; i < Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i % k == 0 ) { count ++ ; } if ( ( n / i ) % k == 0 ) { count ++ ; } } } if ( ( i * i == n ) && ( i % k == 0 ) ) { count -- ; } return count ; }"
"static String lexicographicSubConcat ( String s ) { int n = s . length ( ) ; int sub_count = n * ( n + 1 ) / 2 ; String [ ] arr = new String [ sub_count ] ; int index = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int len = 1 ; len <= n - i ; len ++ ) { arr [ index ++ ] = s . substring ( i , i + len ) ; } Arrays . sort ( arr ) ; String res = """" ; for ( int i = 0 ; i < sub_count ; i ++ ) res += arr [ i ] ; return res ; }"
static int avg_of_even_num ( int n ) { return n + 1 ; }
"static int minInsertions ( int [ ] H , int n , int K ) { int inser = 0 ; for ( int i = 1 ; i < n ; ++ i ) { float diff = Math . abs ( H [ i ] - H [ i - 1 ] ) ; if ( diff <= K ) continue ; else inser += Math . ceil ( diff / K ) - 1 ; } return inser ; }"
static boolean isOneFlip ( String str ) { int sum = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) sum += str . charAt ( i ) - '0' ; return ( sum == n - 1 || sum == 1 ) ; }
"static void CalculatePairs ( int a [ ] , int n ) { int cnt_zero = 0 ; int cnt_one = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 0 ) cnt_zero += 1 ; else cnt_one += 1 ; } int total_XOR_pairs = cnt_zero * cnt_one ; int total_AND_pairs = ( cnt_one ) * ( cnt_one - 1 ) / 2 ; int total_OR_pairs = cnt_zero * cnt_one + ( cnt_one ) * ( cnt_one - 1 ) / 2 ; System . out . println ( ""cntXOR = "" + total_XOR_pairs ) ; System . out . println ( ""cntAND = "" + total_AND_pairs ) ; System . out . println ( ""cntOR = "" + total_OR_pairs ) ; }"
"static int maxSubStr ( String str , int n ) { int count0 = 0 , count1 = 0 ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == '0' ) { count0 ++ ; } else { count1 ++ ; } if ( count0 == count1 ) { cnt ++ ; } } if ( count0 != count1 ) { return - 1 ; } return cnt ; }"
"static int LucasSum ( int N ) { int sum = 0 ; int a = 2 , b = 1 , c ; sum += a ; while ( b <= N ) { sum += b ; c = a + b ; a = b ; b = c ; } return sum ; }"
"static void sortit ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = i + 1 ; } }"
"static void findElements ( int arr [ ] , int n ) { int first = Integer . MIN_VALUE ; int second = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < second ) System . out . print ( arr [ i ] + "" "" ) ; }"
"static void spiralPrint ( int m , int n , int a [ ] [ ] ) { int i , k = 0 , l = 0 ; while ( k < m && l < n ) { for ( i = l ; i < n ; ++ i ) { System . out . print ( a [ k ] [ i ] + "" "" ) ; } k ++ ; for ( i = k ; i < m ; ++ i ) { System . out . print ( a [ i ] [ n - 1 ] + "" "" ) ; } n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) { System . out . print ( a [ m - 1 ] [ i ] + "" "" ) ; } m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) { System . out . print ( a [ i ] [ l ] + "" "" ) ; } l ++ ; } } }"
"static String smallestString ( int N , int [ ] A ) { char ch = 'a' ; String S = """" ; if ( N < 1 || A [ 0 ] != 1 ) { S = ""-1"" ; return S ; } S += ch ; ch ++ ; for ( int i = 1 ; i < N ; i ++ ) { int diff = A [ i ] - A [ i - 1 ] ; if ( diff > 1 || diff < 0 || A [ i ] > 26 ) { S = ""-1"" ; return S ; } else if ( diff == 0 ) S += 'a' ; else { S += ch ; ch ++ ; } } return S ; }"
"static long getSum ( long n , int d ) { if ( n < d ) return 0 ; while ( n % 10 != d ) n -- ; long k = n / 10 ; return ( k + 1 ) * d + ( k * 10 + 10 * k * k ) / 2 ; }"
"static void SubarraysWithSumS ( int n , int k , int s ) { for ( int i = 0 ; i < k ; i ++ ) System . out . print ( s + "" "" ) ; for ( int i = k ; i < n ; i ++ ) System . out . print ( s + 1 + "" "" ) ; }"
"static int maxDiff ( int [ ] arr , int n ) { int SubsetSum_1 = 0 , SubsetSum_2 = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { boolean isSingleOccurance = true ; for ( int j = i + 1 ; j <= n - 1 ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { isSingleOccurance = false ; arr [ i ] = arr [ j ] = 0 ; break ; } } if ( isSingleOccurance ) { if ( arr [ i ] > 0 ) SubsetSum_1 += arr [ i ] ; else SubsetSum_2 += arr [ i ] ; } } return Math . abs ( SubsetSum_1 - SubsetSum_2 ) ; }"
"static void printmaxSubseq ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( i + 1 < n && arr [ i ] < arr [ i + 1 ] ) System . out . print ( arr [ i ] + "" "" ) ; else System . out . print ( arr [ i ] + ""\n"" ) ; } }"
static void translate ( char str [ ] ) { for ( int i = 1 ; i < str . length ; i ++ ) { if ( str [ i - 1 ] == 'A' && str [ i ] == 'B' ) { str [ i - 1 ] = 'C' ; int j ; for ( j = i ; j < str . length - 1 ; j ++ ) str [ j ] = str [ j + 1 ] ; str [ j ] = ' ' ; } } return ; }
"static int findRotations ( String str ) { String tmp = str + str ; int n = str . length ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { String substring = tmp . substring ( i , str . length ( ) ) ; if ( str == substring ) return i ; } return n ; }"
"static int countPair ( int a , int b ) { String s = String . valueOf ( b ) ; int i ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) != '9' ) break ; } int result ; if ( i == s . length ( ) ) result = a * s . length ( ) ; else result = a * ( s . length ( ) - 1 ) ; return result ; }"
"static boolean DivisibleBy41 ( int first , int second , int c , int n ) { int digit [ ] = new int [ n ] ; digit [ 0 ] = first ; digit [ 1 ] = second ; for ( int i = 2 ; i < n ; i ++ ) digit [ i ] = ( digit [ i - 1 ] * c + digit [ i - 2 ] ) % 10 ; int ans = digit [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) ans = ( ans * 10 + digit [ i ] ) % 41 ; if ( ans % 41 == 0 ) return true ; else return false ; }"
static int findSum ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) ans += ( i / j ) ; return ans ; }
"static int countOccurrences ( int arr [ ] , int n , int x ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( x == arr [ i ] ) res ++ ; return res ; }"
"static int countSub ( int arr [ ] , int n ) { int count [ ] = new int [ 10 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = arr [ i ] - 1 ; j >= 0 ; j -- ) count [ arr [ i ] ] += count [ j ] ; count [ arr [ i ] ] ++ ; } int result = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) result += count [ i ] ; return result ; }"
"static int nthTerm ( int n ) { return 4 * ( int ) Math . pow ( n , 2 ) - 7 * n + 3 ; }"
"static int PointInKSquares ( int n , int a [ ] , int k ) { Arrays . sort ( a ) ; return a [ n - k ] ; }"
"static void minAdjDifference ( int arr [ ] , int n ) { if ( n < 2 ) return ; int res = Math . abs ( arr [ 1 ] - arr [ 0 ] ) ; for ( int i = 2 ; i < n ; i ++ ) res = Math . min ( res , Math . abs ( arr [ i ] - arr [ i - 1 ] ) ) ; res = Math . min ( res , Math . abs ( arr [ n - 1 ] - arr [ 0 ] ) ) ; System . out . print ( ""Min Difference = "" + res ) ; }"
"static String reverse ( char [ ] str , int len , int l , int r ) { if ( l < 0 || r >= len || l > r ) return ""Invalid range!"" ; while ( l < r ) { char c = str [ l ] ; str [ l ] = str [ r ] ; str [ r ] = c ; l ++ ; r -- ; } String string = new String ( str ) ; return string ; }"
static double findSum ( long n ) { return Math . sqrt ( 3 ) * ( n * ( n + 1 ) / 2 ) ; }
"static int countPairs ( int arr [ ] , int n ) { int result = 0 ; HashSet < Integer > Hash = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Hash . add ( arr [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int product = arr [ i ] * arr [ j ] ; if ( Hash . contains ( product ) ) { result ++ ; } } } return result ; }"
"static int count_pairs ( int n , int a [ ] ) { HashMap < Integer , Integer > frequency = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! frequency . containsKey ( a [ i ] ) ) frequency . put ( a [ i ] , 0 ) ; frequency . put ( a [ i ] , frequency . get ( a [ i ] ) + 1 ) ; } int count = 0 ; for ( Map . Entry < Integer , Integer > x : frequency . entrySet ( ) ) { int f = x . getValue ( ) ; count += f * ( f - 1 ) / 2 ; } return ( ( n * ( n - 1 ) ) / 2 ) - count ; }"
"static int freqPairs ( int arr [ ] , int n ) { int max = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int freq [ ] = new int [ max + 1 ] ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 2 * arr [ i ] ; j <= max ; j += arr [ i ] ) { if ( freq [ j ] >= 1 ) { count += freq [ j ] ; } } if ( freq [ arr [ i ] ] > 1 ) { count += freq [ arr [ i ] ] - 1 ; freq [ arr [ i ] ] -- ; } } return count ; }"
"static int log_a_to_base_b ( int a , int b ) { int rslt = ( a > b - 1 ) ? 1 + log_a_to_base_b ( a / b , b ) : 0 ; return rslt ; }"
static int findS ( int s ) { int sum = 0 ; for ( int n = 1 ; sum < s ; n ++ ) { sum += n * n ; if ( sum == s ) return n ; } return - 1 ; }
"public static double answer ( double X , double K ) { double i = 10 ; double MAX = Math . pow ( i , K ) - 1 ; return ( MAX - ( MAX % X ) ) ; }"
"static float findVolume ( float l , float b , float h ) { float volume = ( l * b * h ) / 2 ; return volume ; }"
"static void possibleTripletInRange ( int L , int R ) { boolean flag = false ; int possibleA = 0 , possibleB = 0 , possibleC = 0 ; int numbersInRange = ( R - L + 1 ) ; if ( numbersInRange < 3 ) { flag = false ; } else if ( numbersInRange > 3 ) { flag = true ; if ( L % 2 > 0 ) { L ++ ; } possibleA = L ; possibleB = L + 1 ; possibleC = L + 2 ; } else { if ( ! ( L % 2 > 0 ) ) { flag = true ; possibleA = L ; possibleB = L + 1 ; possibleC = L + 2 ; } else { flag = false ; } } if ( flag == true ) { System . out . println ( ""("" + possibleA + "", "" + possibleB + "", "" + possibleC + "")"" + "" is one such possible"" + "" triplet between "" + L + "" and "" + R ) ; } else { System . out . println ( ""No Such Triplet"" + "" exists between "" + L + "" and "" + R ) ; } }"
static int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; 1 << i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { int num = ( 1 << i ) + ( 1 << j ) ; if ( num <= n ) sum += num ; } } return sum ; }
"static int KnapSack ( int val [ ] , int wt [ ] , int n , int W ) { int [ ] dp = new int [ W + 1 ] ; Arrays . fill ( dp , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = W ; j >= wt [ i ] ; j -- ) dp [ j ] = Math . max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) ; return dp [ W ] ; }"
public static int findNth ( int n ) { int nthElement = 19 + ( n - 1 ) * 9 ; int outliersCount = ( int ) Math . log10 ( nthElement ) - 1 ; nthElement += 9 * outliersCount ; return nthElement ; }
"static boolean isPossible ( int w , int h , int x , int y ) { if ( x * 2 == w && y * 2 == h ) return true ; return false ; }"
static int countPairs ( int N ) { int count = 0 ; for ( int i = 1 ; i <= Math . cbrt ( N ) ; i ++ ) { int cb = i * i * i ; int diff = N - cb ; int cbrtDiff = ( int ) Math . cbrt ( diff ) ; if ( cbrtDiff * cbrtDiff * cbrtDiff == diff ) count ++ ; } return count ; }
"public static void rearrangeArr ( int arr [ ] , int n ) { int evenPos = n / 2 ; int oddPos = n - evenPos ; int [ ] tempArr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) tempArr [ i ] = arr [ i ] ; Arrays . sort ( tempArr ) ; int j = oddPos - 1 ; for ( int i = 0 ; i < n ; i += 2 ) { arr [ i ] = tempArr [ j ] ; j -- ; } j = oddPos ; for ( int i = 1 ; i < n ; i += 2 ) { arr [ i ] = tempArr [ j ] ; j ++ ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + "" "" ) ; }"
"static void printTwins ( int low , int high ) { boolean prime [ ] = new boolean [ high + 1 ] , twin = false ; for ( int i = 0 ; i < prime . length ; i ++ ) { prime [ i ] = true ; } prime [ 0 ] = prime [ 1 ] = false ; for ( int p = 2 ; p <= Math . floor ( Math . sqrt ( high ) ) + 1 ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= high ; i += p ) { prime [ i ] = false ; } } } for ( int i = low ; i <= high ; i ++ ) { if ( prime [ i ] && prime [ i + 2 ] ) { int a = i + 2 ; System . out . print ( ""Smallest twins in given range: ("" + i + "", "" + a + "")"" ) ; twin = true ; break ; } } if ( twin == false ) { System . out . println ( ""No such pair exists"" ) ; } }"
static int findCullen ( int n ) { return ( 1 << n ) * n + 1 ; }
"static int minCoins ( int coins [ ] , int m , int V ) { if ( V == 0 ) return 0 ; int res = Integer . MAX_VALUE ; for ( int i = 0 ; i < m ; i ++ ) { if ( coins [ i ] <= V ) { int sub_res = minCoins ( coins , m , V - coins [ i ] ) ; if ( sub_res != Integer . MAX_VALUE && sub_res + 1 < res ) res = sub_res + 1 ; } } return res ; }"
"static void powerSet ( String str , int index , String curr ) { int n = str . length ( ) ; if ( index == n ) { return ; } System . out . println ( curr ) ; for ( int i = index + 1 ; i < n ; i ++ ) { curr += str . charAt ( i ) ; powerSet ( str , i , curr ) ; curr = curr . substring ( 0 , curr . length ( ) - 1 ) ; } }"
"static int longestSubseqWithDiffOne ( int arr [ ] , int n ) { int dp [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( ( arr [ i ] == arr [ j ] + 1 ) || ( arr [ i ] == arr [ j ] - 1 ) ) dp [ i ] = Math . max ( dp [ i ] , dp [ j ] + 1 ) ; } } int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( result < dp [ i ] ) result = dp [ i ] ; return result ; }"
"static int NumberOfRectangles ( int n , int m ) { if ( n % 2 == 0 ) return ( n / 2 ) * m ; else if ( m % 2 == 0 ) return ( m / 2 ) * n ; return ( n * m - 1 ) / 2 ; }"
"static int minDiff ( int arr [ ] , int n , int k ) { int result = Integer . MAX_VALUE ; Arrays . sort ( arr ) ; for ( int i = 0 ; i <= n - k ; i ++ ) result = Math . min ( result , arr [ i + k - 1 ] - arr [ i ] ) ; return result ; }"
"static int policeThief ( char arr [ ] , int n , int k ) { int res = 0 ; ArrayList < Integer > thi = new ArrayList < Integer > ( ) ; ArrayList < Integer > pol = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 'P' ) pol . add ( i ) ; else if ( arr [ i ] == 'T' ) thi . add ( i ) ; } int l = 0 , r = 0 ; while ( l < thi . size ( ) && r < pol . size ( ) ) { if ( Math . abs ( thi . get ( l ) - pol . get ( r ) ) <= k ) { res ++ ; l ++ ; r ++ ; } else if ( thi . get ( l ) < pol . get ( r ) ) l ++ ; else r ++ ; } return res ; }"
"static void maxProduct ( int arr [ ] , int n ) { if ( n < 2 ) { System . out . println ( ""No pairs exists"" ) ; return ; } int a = arr [ 0 ] , b = arr [ 1 ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] * arr [ j ] > a * b ) { a = arr [ i ] ; b = arr [ j ] ; } System . out . println ( ""Max product pair is {"" + a + "", "" + b + ""}"" ) ; }"
static boolean checkYear ( int year ) { if ( year % 400 == 0 ) return true ; if ( year % 100 == 0 ) return false ; if ( year % 4 == 0 ) return true ; return false ; }
"static void perfectCube ( int N ) { int cube_root ; cube_root = ( int ) Math . round ( Math . cbrt ( N ) ) ; if ( cube_root * cube_root * cube_root == N ) { System . out . println ( ""Yes"" ) ; return ; } else { System . out . println ( ""NO"" ) ; return ; } }"
"public static double polygonArea ( double X [ ] , double Y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; j = i ; } return Math . abs ( area / 2.0 ) ; }"
"int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return - 1 ; }"
"static int countTriangles ( int a [ ] , int n ) { int cnt = 0 ; int pairs = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { pairs += a [ i ] / 2 ; if ( a [ i ] % 2 == 1 && pairs > 0 ) { cnt += 1 ; pairs -= 1 ; } } cnt += ( 2 * pairs ) / 3 ; return cnt ; }"
"static long difference ( long M , long N ) { return M + N ; }"
"static int minimumChanges ( int n , int a [ ] ) { int i ; int [ ] sf = new int [ n + 1 ] ; sf [ n ] = 0 ; for ( i = n - 1 ; i >= 0 ; i -- ) { sf [ i ] = sf [ i + 1 ] ; if ( a [ i ] <= 0 ) sf [ i ] ++ ; } int pos = 0 ; int mn = n ; for ( i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] >= 0 ) pos ++ ; mn = Math . min ( mn , pos + sf [ i + 1 ] ) ; } return mn ; }"
"static boolean isOdd ( int [ ] arr , int n ) { int l , r , flag = 0 , flag1 = 0 , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] % 2 == 0 && flag == 0 ) { flag = 1 ; l = arr [ i ] ; } if ( arr [ i ] % 2 != 0 && flag1 == 0 ) { r = arr [ i ] ; flag1 = 1 ; } } if ( sum % 2 != 0 ) { return true ; } else { if ( flag1 == 1 && flag == 1 ) return true ; else return false ; } }"
static int stringReduction ( String str ) { int n = str . length ( ) ; int count [ ] = new int [ 3 ] ; for ( int i = 0 ; i < n ; ++ i ) { count [ str . charAt ( i ) - 'a' ] ++ ; } if ( count [ 0 ] == n || count [ 1 ] == n || count [ 2 ] == n ) { return n ; } if ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) && ( count [ 1 ] % 2 ) == ( count [ 2 ] % 2 ) ) { return 2 ; } return 1 ; }
"static int minMoves ( int arr [ ] , int n ) { int expectedItem = n ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] == expectedItem ) expectedItem -- ; } return expectedItem ; }"
static int NthSmallest ( int K ) { Queue < Integer > Q = new LinkedList < > ( ) ; int x = 0 ; for ( int i = 1 ; i < 10 ; i ++ ) Q . add ( i ) ; for ( int i = 1 ; i <= K ; i ++ ) { x = Q . peek ( ) ; Q . remove ( ) ; if ( x % 10 != 0 ) { Q . add ( x * 10 + x % 10 - 1 ) ; } Q . add ( x * 10 + x % 10 ) ; if ( x % 10 != 9 ) { Q . add ( x * 10 + x % 10 + 1 ) ; } } return x ; }
static int sumDigits ( int no ) { return no == 0 ? 0 : no % 10 + sumDigits ( no / 10 ) ; }
"static int maxcoefficientvalue ( int n ) { int [ ] [ ] C = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int maxvalue = 0 ; for ( int i = 0 ; i <= n ; i ++ ) maxvalue = Math . max ( maxvalue , C [ n ] [ i ] ) ; return maxvalue ; }"
"static int findRepeatFirstN2 ( String s ) { int p = - 1 , i , j ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { for ( j = i + 1 ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( i ) == s . charAt ( j ) ) { p = i ; break ; } } if ( p != - 1 ) break ; } return p ; }"
"static void checkPoint ( int radius , int x , int y , float percent , float startAngle ) { float endAngle = 360 / percent + startAngle ; double polarradius = Math . sqrt ( x * x + y * y ) ; double Angle = Math . atan ( y / x ) ; if ( Angle >= startAngle && Angle <= endAngle && polarradius < radius ) System . out . print ( ""Point"" + ""("" + x + "","" + y + "")"" + "" exist in the circle sector\n"" ) ; else System . out . print ( ""Point"" + ""("" + x + "","" + y + "")"" + "" exist in the circle sector\n"" ) ; }"
"static void pushZerosToEnd ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; }"
static long evenPowerSum ( int n ) { return ( 8 * n * ( n + 1 ) * ( 2 * n + 1 ) * ( 3 * n * n + 3 * n - 1 ) ) / 15 ; }
"static int sum ( int x , int y , int n ) { int sum1 = ( int ) ( ( Math . pow ( x , 2 ) * ( Math . pow ( x , 2 * n ) - 1 ) ) / ( Math . pow ( x , 2 ) - 1 ) ) ; int sum2 = ( int ) ( ( x * y * ( Math . pow ( x , n ) * Math . pow ( y , n ) - 1 ) ) / ( x * y - 1 ) ) ; return sum1 + sum2 ; }"
"static int findCount ( int m , int n ) { int num1 = 0 ; for ( int i = 0 ; i < m ; i ++ ) num1 = ( num1 * 10 ) + 9 ; int num2 = 0 ; for ( int i = 0 ; i < ( m - 1 ) ; i ++ ) num2 = ( num2 * 10 ) + 9 ; return ( ( num1 / n ) - ( num2 / n ) ) ; }"
"static int [ ] orgazineInOrder ( int [ ] vec , int [ ] op , int n ) { int [ ] result = new int [ n ] ; Arrays . sort ( vec ) ; int i = 0 , j = n - 1 , k = 0 ; while ( i <= j && k <= n - 2 ) { if ( op [ k ] == '<' ) { result [ k ] = vec [ i ++ ] ; } else { result [ k ] = vec [ j -- ] ; } k ++ ; } result [ n - 1 ] = vec [ i ] ; return result ; }"
public static int removeAlternate ( int n ) { if ( n == 1 ) return 1 ; if ( n % 2 == 0 ) return 2 * removeAlternate ( n / 2 ) - 1 ; else return 2 * removeAlternate ( ( ( n - 1 ) / 2 ) ) + 1 ; }
"static void myCopy ( char s1 [ ] , char s2 [ ] ) { int i = 0 ; for ( i = 0 ; i < s1 . length ; i ++ ) s2 [ i ] = s1 [ i ] ; }"
"static void findPairs ( int arr1 [ ] , int arr2 [ ] , int n , int m , int x ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( arr1 [ i ] + arr2 [ j ] == x ) System . out . println ( arr1 [ i ] + "" "" + arr2 [ j ] ) ; }"
"static void encode ( String s , int k ) { String newS = """" ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { int val = s . charAt ( i ) ; int dup = k ; if ( val + k > 122 ) { k -= ( 122 - val ) ; k = k % 26 ; newS += ( char ) ( 96 + k ) ; } else { newS += ( char ) ( val + k ) ; } k = dup ; } System . out . println ( newS ) ; }"
"static int getMod ( String str , int n , int k ) { int pwrTwo [ ] = new int [ n ] ; pwrTwo [ 0 ] = 1 % k ; for ( int i = 1 ; i < n ; i ++ ) { pwrTwo [ i ] = pwrTwo [ i - 1 ] * ( 2 % k ) ; pwrTwo [ i ] %= k ; } int res = 0 ; int i = 0 , j = n - 1 ; while ( i < n ) { if ( str . charAt ( j ) == '1' ) { res += ( pwrTwo [ i ] ) ; res %= k ; } i ++ ; j -- ; } return res ; }"
"static void makePolygon ( double a ) { double n = 360 / ( 180 - a ) ; if ( n == ( int ) n ) System . out . println ( ""YES"" ) ; else System . out . println ( ""NO"" ) ; }"
static int height ( int N ) { return ( int ) Math . ceil ( Math . log ( N + 1 ) / Math . log ( 2 ) ) - 1 ; }
"static int nthElement ( int a , int b , int n ) { ArrayList < Integer > seq = new ArrayList < Integer > ( n * n + 1 ) ; for ( int i = 1 ; i <= n ; i ++ ) seq . add ( a * i ) ; Collections . sort ( seq ) ; for ( int i = 1 , k = n ; i <= n && k > 0 ; i ++ ) { if ( seq . indexOf ( b * i ) == - 1 ) { seq . add ( b * i ) ; Collections . sort ( seq ) ; k -- ; } } return seq . get ( n - 1 ) ; }"
static int count ( int n ) { if ( n < 4 ) return - 1 ; int rem = n % 4 ; if ( rem == 0 ) return n / 4 ; if ( rem == 1 ) { if ( n < 9 ) return - 1 ; return ( n - 9 ) / 4 + 1 ; } if ( rem == 2 ) return ( n - 6 ) / 4 + 1 ; if ( rem == 3 ) { if ( n < 15 ) return - 1 ; return ( n - 15 ) / 4 + 2 ; } return 0 ; }
"static int findProduct ( int arr [ ] , int n , int k ) { int prod = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) { prod *= arr [ i ] ; } } return prod ; }"
"static long gcd ( long a , long b ) { if ( b % a == 0 ) return ( a ) ; else return ( gcd ( b % a , a ) ) ; }"
"public static int Valid ( int a , int b , int c , int d ) { if ( a + b + c + d == 360 ) return 1 ; return 0 ; }"
"static int coutSubSeq ( int A [ ] , int N , int M ) { int sum = 0 ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { for ( int k = j + 1 ; k < N ; k ++ ) { sum = A [ i ] + A [ j ] + A [ k ] ; if ( sum % M == 0 ) ans ++ ; } } } return ans ; }"
"static void constructArr ( int arr [ ] , int pair [ ] , int n ) { arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) / 2 ; for ( int i = 1 ; i < n ; i ++ ) arr [ i ] = pair [ i - 1 ] - arr [ 0 ] ; }"
public static int countSetBits ( int n ) { if ( n == 0 ) return 0 ; else return 1 + countSetBits ( n & ( n - 1 ) ) ; }
static boolean inProportion ( int [ ] arr ) { int n = 4 ; Arrays . sort ( arr ) ; long extremes = ( long ) arr [ 0 ] * ( long ) arr [ 3 ] ; long means = ( long ) arr [ 1 ] * ( long ) arr [ 2 ] ; if ( extremes == means ) return true ; return false ; }
"static int offeringNumber ( int n , int templeHeight [ ] ) { int sum = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int left = 0 , right = 0 ; for ( int j = i - 1 ; j >= 0 ; -- j ) { if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) ++ left ; else break ; } for ( int j = i + 1 ; j < n ; ++ j ) { if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) ++ right ; else break ; } sum += Math . max ( right , left ) + 1 ; } return sum ; }"
"static void maxLengthSubSeq ( int a [ ] , int n ) { int temp [ ] = new int [ n ] ; int print [ ] = new int [ n ] ; int y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j = 0 ; int x = 0 ; temp [ j ++ ] = a [ x ] ; x = a [ x ] + x ; while ( x < n ) { temp [ j ++ ] = a [ x ] ; x = a [ x ] + x ; } if ( y < j ) { for ( int k = 0 ; k < j ; k ++ ) { print [ k ] = temp [ k ] ; y = j ; } } } for ( int i = 0 ; i < y ; i ++ ) System . out . print ( print [ i ] + "" "" ) ; }"
"static int minSum ( int arr [ ] , int n ) { int sum = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) { int j = i ; while ( j < n && arr [ j ] <= arr [ j - 1 ] ) { arr [ j ] = arr [ j ] + 1 ; j ++ ; } } sum = sum + arr [ i ] ; } return sum ; }"
"static void numbersWith3Divisors ( int n ) { boolean [ ] prime = new boolean [ n + 1 ] ; Arrays . fill ( prime , true ) ; prime [ 0 ] = prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } System . out . println ( ""Numbers with 3 divisors : "" ) ; for ( int i = 0 ; i * i <= n ; i ++ ) if ( prime [ i ] ) System . out . print ( i * i + "" "" ) ; }"
"static int findMinimumAdjacentSwaps ( int arr [ ] , int N ) { boolean [ ] visited = new boolean [ N + 1 ] ; int minimumSwaps = 0 ; Arrays . fill ( visited , false ) ; for ( int i = 0 ; i < 2 * N ; i ++ ) { if ( visited [ arr [ i ] ] == false ) { visited [ arr [ i ] ] = true ; int count = 0 ; for ( int j = i + 1 ; j < 2 * N ; j ++ ) { if ( visited [ arr [ j ] ] == false ) count ++ ; else if ( arr [ i ] == arr [ j ] ) minimumSwaps += count ; } } } return minimumSwaps ; }"
"static int waysToKAdjacentSetBits ( int n , int k , int currentIndex , int adjacentSetBits , int lastBit ) { if ( currentIndex == n ) { if ( adjacentSetBits == k ) return 1 ; return 0 ; } int noOfWays = 0 ; if ( lastBit == 1 ) { noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits + 1 , 1 ) ; noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; } else if ( lastBit == 0 ) { noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 1 ) ; noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; } return noOfWays ; }"
"static boolean isPower ( int n ) { for ( int x = 2 ; x <= Math . sqrt ( n ) ; x ++ ) { int y = 2 ; double p = Math . pow ( x , y ) ; while ( p <= n && p > 0 ) { if ( p == n ) return true ; y ++ ; p = Math . pow ( x , y ) ; } } return false ; }"
"static int toDecimal ( String binary , int i ) { int n = binary . length ( ) ; if ( i == n - 1 ) return binary . charAt ( i ) - '0' ; return ( ( binary . charAt ( i ) - '0' ) << ( n - i - 1 ) ) + toDecimal ( binary , i + 1 ) ; }"
"static boolean isHeterogram ( String s , int n ) { int hash [ ] = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) != ' ' ) { if ( hash [ s . charAt ( i ) - 'a' ] == 0 ) hash [ s . charAt ( i ) - 'a' ] = 1 ; else return false ; } } return true ; }"
"static boolean isSubSequence ( String str1 , String str2 , int m , int n ) { int j = 0 ; for ( int i = 0 ; i < n && j < m ; i ++ ) if ( str1 . charAt ( j ) == str2 . charAt ( i ) ) j ++ ; return ( j == m ) ; }"
"static int getCount ( int a , int b , int c ) { int count = 0 ; for ( int i = 1 ; i <= 81 ; i ++ ) { int cr = b * ( int ) Math . pow ( i , a ) + c ; int tmp = cr ; int sm = 0 ; while ( tmp != 0 ) { sm += tmp % 10 ; tmp /= 10 ; } if ( sm == i && cr < 1e9 ) count ++ ; } return count ; }"
public static boolean isEven ( int n ) { return ( n % 2 == 0 ) ; }
"static int calcFunction ( int n , int r ) { int finalDenominator = 1 ; int mx = Math . max ( r , n - r ) ; for ( int i = mx + 1 ; i <= n ; i ++ ) { int denominator = ( int ) Math . pow ( i , i ) ; int numerator = ( int ) Math . pow ( i - mx , i - mx ) ; finalDenominator = ( finalDenominator * denominator ) / numerator ; } return finalDenominator ; }"
static int printCountDP ( int dist ) { int [ ] count = new int [ dist + 1 ] ; count [ 0 ] = 1 ; count [ 1 ] = 1 ; count [ 2 ] = 2 ; for ( int i = 3 ; i <= dist ; i ++ ) count [ i ] = count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] ; return count [ dist ] ; }
static int getPairs ( int a [ ] ) { int n = a . length ; int count = ( n * ( n - 1 ) ) / 2 ; return count ; }
static int countTrees ( int n ) { int BT [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) BT [ i ] = 0 ; BT [ 0 ] = BT [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; ++ i ) for ( int j = 0 ; j < i ; j ++ ) BT [ i ] += BT [ j ] * BT [ i - j - 1 ] ; return BT [ n ] ; }
"static int findMinZero ( int p ) { int first = 1 , second = 1 , number = 2 , next = 1 ; while ( next > 0 ) { next = ( first + second ) % p ; first = second ; second = next ; number ++ ; } return number ; }"
"static void leafNode ( int preorder [ ] , int n ) { Stack < Integer > s = new Stack < Integer > ( ) ; for ( int i = 0 , j = 1 ; j < n ; i ++ , j ++ ) { boolean found = false ; if ( preorder [ i ] > preorder [ j ] ) s . push ( preorder [ i ] ) ; else { while ( ! s . isEmpty ( ) ) { if ( preorder [ j ] > s . peek ( ) ) { s . pop ( ) ; found = true ; } else break ; } } if ( found ) System . out . print ( preorder [ i ] + "" "" ) ; } System . out . println ( preorder [ n - 1 ] ) ; }"
"static int countFact ( int low , int high ) { int fact = 1 , x = 1 ; while ( fact < low ) { fact = fact * x ; x ++ ; } int res = 0 ; while ( fact <= high ) { res ++ ; fact = fact * x ; x ++ ; } return res ; }"
"static int maximumOccurrence ( String s ) { int n = s . length ( ) ; HashMap < String , Integer > freq = new HashMap < String , Integer > ( ) ; int i , j ; for ( i = 0 ; i < n ; i ++ ) { String temp = """" ; temp += s . charAt ( i ) ; if ( freq . containsKey ( temp ) ) { freq . put ( temp , freq . get ( temp ) + 1 ) ; } else { freq . put ( temp , 1 ) ; } } for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { String temp = """" ; temp += s . charAt ( i ) ; temp += s . charAt ( j ) ; if ( freq . containsKey ( temp ) ) freq . put ( temp , freq . get ( temp ) + 1 ) ; else freq . put ( temp , 1 ) ; } } int answer = Integer . MIN_VALUE ; for ( int it : freq . values ( ) ) answer = Math . max ( answer , it ) ; return answer ; }"
"static boolean flipsPossible ( int [ ] a , int n ) { int count_odd = 0 , count_even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] & 1 ) == 1 ) count_odd ++ ; else count_even ++ ; } if ( count_odd % 2 == 1 && count_even % 2 == 1 ) return false ; else return true ; }"
"static void printFirstNegativeInteger ( int arr [ ] , int n , int k ) { boolean flag ; for ( int i = 0 ; i < ( n - k + 1 ) ; i ++ ) { flag = false ; for ( int j = 0 ; j < k ; j ++ ) { if ( arr [ i + j ] < 0 ) { System . out . print ( ( arr [ i + j ] ) + "" "" ) ; flag = true ; break ; } } if ( ! flag ) System . out . print ( ""0"" + "" "" ) ; } }"
static double areaCircle ( double b ) { double area = ( double ) 3.1415926 * b * b ; return area ; }
"static int power ( int n , int r ) { int count = 0 ; for ( int i = r ; ( n / i ) >= 1 ; i = i * r ) count += n / i ; return count ; }"
"static int minimumCost ( int cost [ ] , int n ) { int dp1 = 0 , dp2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int dp0 = cost [ i ] + Math . min ( dp1 , dp2 ) ; dp2 = dp1 ; dp1 = dp0 ; } return Math . min ( dp1 , dp2 ) ; }"
"static void minAbsSumPair ( int arr [ ] , int arr_size ) { int inv_count = 0 ; int l , r , min_sum , sum , min_l , min_r ; if ( arr_size < 2 ) { System . out . println ( ""Invalid Input"" ) ; return ; } min_l = 0 ; min_r = 1 ; min_sum = arr [ 0 ] + arr [ 1 ] ; for ( l = 0 ; l < arr_size - 1 ; l ++ ) { for ( r = l + 1 ; r < arr_size ; r ++ ) { sum = arr [ l ] + arr [ r ] ; if ( Math . abs ( min_sum ) > Math . abs ( sum ) ) { min_sum = sum ; min_l = l ; min_r = r ; } } } System . out . println ( "" The two elements whose "" + ""sum is minimum are "" + arr [ min_l ] + "" and "" + arr [ min_r ] ) ; }"
"static int nCr ( int n , int r ) { int fac [ ] = new int [ 100 ] ; for ( int i = 0 ; i < n ; i ++ ) fac [ i ] = 1 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { fac [ i ] = fac [ i - 1 ] * i ; } int ans = fac [ n ] / ( fac [ n - r ] * fac [ r ] ) ; return ans ; }"
"static int findCount ( int arr [ ] , int n ) { int countOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 1 ) countOdd ++ ; if ( countOdd % 2 == 0 ) return 1 ; else return 0 ; }"
"public static int jumpSearch ( int [ ] arr , int x ) { int n = arr . length ; int step = ( int ) Math . floor ( Math . sqrt ( n ) ) ; int prev = 0 ; while ( arr [ Math . min ( step , n ) - 1 ] < x ) { prev = step ; step += ( int ) Math . floor ( Math . sqrt ( n ) ) ; if ( prev >= n ) return - 1 ; } while ( arr [ prev ] < x ) { prev ++ ; if ( prev == Math . min ( step , n ) ) return - 1 ; } if ( arr [ prev ] == x ) return prev ; return - 1 ; }"
"public static int difference ( int arr [ ] [ ] , int n ) { int d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { d1 += arr [ i ] [ i ] ; d2 += arr [ i ] [ n - i - 1 ] ; } return Math . abs ( d1 - d2 ) ; }"
"static void findMissing ( int a [ ] , int b [ ] , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < m ; j ++ ) if ( a [ i ] == b [ j ] ) break ; if ( j == m ) System . out . print ( a [ i ] + "" "" ) ; } }"
"static int minOps ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int max = arr [ arr . length - 1 ] ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( max - arr [ i ] ) % k != 0 ) return - 1 ; else res += ( max - arr [ i ] ) / k ; } return res ; }"
"static void findSetBits ( int n ) { int [ ] dp = new int [ n + 1 ] ; System . out . print ( dp [ 0 ] + "" "" ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) { dp [ i ] = dp [ i / 2 ] ; } else { dp [ i ] = dp [ i / 2 ] + 1 ; } System . out . print ( dp [ i ] + "" "" ) ; } }"
static boolean isPerfectSquare ( int n ) { for ( int i = 1 ; i * i <= n ; i ++ ) { if ( ( n % i == 0 ) && ( n / i == i ) ) { return true ; } } return false ; }
"static int sumNth ( int A [ ] , int B [ ] , int m , int n ) { int res = 0 ; if ( n == 1 ) { for ( int i = 0 ; i < m ; i ++ ) res = res + A [ i ] ; } else if ( n == 2 ) { for ( int i = 0 ; i < m ; i ++ ) res = res + B [ i ] * m ; } else { int f [ ] = new int [ n ] ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; for ( int i = 0 ; i < m ; i ++ ) { res = res + ( m * ( B [ i ] * f [ n - 1 ] ) ) + ( m * ( A [ i ] * f [ n - 2 ] ) ) ; } } return res ; }"
"static int maxHamming ( int arr [ ] , int n ) { int brr [ ] = new int [ 2 * n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ i ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ n + i ] = arr [ i ] ; int maxHam = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int currHam = 0 ; for ( int j = i , k = 0 ; j < ( i + n ) ; j ++ , k ++ ) if ( brr [ j ] != arr [ k ] ) currHam ++ ; if ( currHam == n ) return n ; maxHam = Math . max ( maxHam , currHam ) ; } return maxHam ; }"
"static void findPermutation ( int n ) { Vector < Integer > res = new Vector < Integer > ( ) ; int en = 2 , on = 1 ; if ( n % 2 == 0 ) { for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { res . add ( en ) ; en += 2 ; } else { res . add ( on ) ; on += 2 ; } } } else { for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( i % 2 == 0 ) { res . add ( en ) ; en += 2 ; } else { res . add ( on ) ; on += 2 ; } } res . add ( n ) ; res . add ( n - 2 ) ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( res . get ( i ) + "" "" ) ; } System . out . println ( """" ) ; }"
"static int minRemovalsDP ( int arr [ ] , int n ) { int longest_start = - 1 , longest_end = 0 ; for ( int start = 0 ; start < n ; start ++ ) { int min = Integer . MAX_VALUE , max = Integer . MIN_VALUE ; for ( int end = start ; end < n ; end ++ ) { int val = arr [ end ] ; if ( val < min ) { min = val ; } if ( val > max ) { max = val ; } if ( 2 * min <= max ) { break ; } if ( end - start > longest_end - longest_start || longest_start == - 1 ) { longest_start = start ; longest_end = end ; } } } if ( longest_start == - 1 ) { return n ; } return ( n - ( longest_end - longest_start + 1 ) ) ; }"
"static void printRoots ( int n ) { double theta = 3.14 * 2 / n ; for ( int k = 0 ; k < n ; k ++ ) { double real = Math . cos ( k * theta ) ; double img = Math . sin ( k * theta ) ; System . out . println ( real ) ; if ( img >= 0 ) System . out . println ( "" + i "" ) ; else System . out . println ( "" - i "" ) ; System . out . println ( Math . abs ( img ) ) ; } }"
"static int FindMinNumber ( int arr [ ] , int n , int k ) { int i = 0 ; int j = 0 ; int min_num = Integer . MAX_VALUE ; boolean found = false ; int sum = 0 ; while ( i < n ) { sum = sum + arr [ i ] ; if ( sum == k ) { min_num = Math . min ( min_num , ( ( n - ( i + 1 ) ) + j ) ) ; found = true ; } else if ( sum > k ) { while ( sum > k ) { sum = sum - arr [ j ] ; j ++ ; } if ( sum == k ) { min_num = Math . min ( min_num , ( ( n - ( i + 1 ) ) + j ) ) ; found = true ; } } i ++ ; } if ( found ) return min_num ; return - 1 ; }"
static int countWays ( int n ) { int [ ] A = new int [ n + 1 ] ; int [ ] B = new int [ n + 1 ] ; A [ 0 ] = 1 ; A [ 1 ] = 0 ; B [ 0 ] = 0 ; B [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ] ; B [ i ] = A [ i - 1 ] + B [ i - 2 ] ; } return A [ n ] ; }
"static void nDigitPerfectSquares ( int n ) { int smallest = ( int ) Math . pow ( Math . ceil ( Math . sqrt ( Math . pow ( 10 , n - 1 ) ) ) , 2 ) ; System . out . print ( smallest + "" "" ) ; int largest = ( int ) Math . pow ( Math . ceil ( Math . sqrt ( Math . pow ( 10 , n ) ) ) - 1 , 2 ) ; System . out . print ( largest ) ; }"
"static int dayofweek ( int d , int m , int y ) { int t [ ] = { 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 }; y -= ( m < 3 ) ? 1 : 0 ; return ( y + y / 4 - y / 100 + y / 400 + t [ m - 1 ] + d ) % 7 ; }"
"public static void search ( int [ ] arr , int low , int high ) { if ( low > high ) return ; if ( low == high ) { System . out . println ( ""The required element is "" + arr [ low ] ) ; return ; } int mid = ( low + high ) / 2 ; if ( mid % 2 == 0 ) { if ( arr [ mid ] == arr [ mid + 1 ] ) search ( arr , mid + 2 , high ) ; else search ( arr , low , mid ) ; } else if ( mid % 2 == 1 ) { if ( arr [ mid ] == arr [ mid - 1 ] ) search ( arr , mid + 1 , high ) ; else search ( arr , low , mid - 1 ) ; } }"
"static boolean productSumDivisible ( int n , int size ) { int sum = 0 , product = 1 ; while ( n > 0 ) { if ( size % 2 == 0 ) { product *= n % 10 ; } else { sum += n % 10 ; } n = n / 10 ; size -- ; } if ( product % sum == 0 ) { return true ; } return false ; }"
"static void replace_elements ( int arr [ ] , int n ) { int pos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ pos ++ ] = arr [ i ] ; while ( pos > 1 && arr [ pos - 2 ] == arr [ pos - 1 ] ) { pos -- ; arr [ pos - 1 ] ++ ; } } for ( int i = 0 ; i < pos ; i ++ ) System . out . print ( arr [ i ] + "" "" ) ; }"
static int countMultiples ( int n ) { return n / 3 + n / 7 - n / 21 ; }
"static int nthTerm ( int n ) { return 2 * ( int ) Math . pow ( n , 2 ) + 4 * n - 2 ; }"
"static boolean CheckArray ( int arr [ ] , int n ) { int prod = 1 ; ArrayList < Integer > freq = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { freq . add ( arr [ i ] ) ; prod *= arr [ i ] ; } int root = ( int ) Math . sqrt ( prod ) ; if ( root * root == prod ) { if ( freq . contains ( root ) & freq . lastIndexOf ( root ) != ( freq . size ( ) ) ) { return true ; } } return false ; }"
"static int minElements ( int arr [ ] , int n ) { int halfSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) halfSum = halfSum + arr [ i ] ; halfSum = halfSum / 2 ; Arrays . sort ( arr ) ; int res = 0 , curr_sum = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { curr_sum += arr [ i ] ; res ++ ; if ( curr_sum > halfSum ) return res ; } return res ; }"
static int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
"static void specialNumber ( int n ) { if ( n < 10 || n > 99 ) System . out . println ( ""Invalid Input! "" + ""Number should have "" + ""2 digits only"" ) ; else { int first = n / 10 ; int last = n % 10 ; int sum = first + last ; int pro = first * last ; if ( ( sum + pro ) == n ) { System . out . println ( n + "" is a Special"" + "" Two-Digit Number"" ) ; } else { System . out . println ( n + "" is Not a Special"" + "" Two-Digit Number"" ) ; } } }"
"static void countDigit ( int n ) { int temp = n , sum = 0 , product = 1 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 ) { sum += d ; product *= d ; } } System . out . print ( ""Sum = "" + sum ) ; System . out . print ( ""\nProduct = "" + product ) ; }"
"static boolean findTriplet ( int a1 [ ] , int a2 [ ] , int a3 [ ] , int n1 , int n2 , int n3 , int sum ) { for ( int i = 0 ; i < n1 ; i ++ ) for ( int j = 0 ; j < n2 ; j ++ ) for ( int k = 0 ; k < n3 ; k ++ ) if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) return true ; return false ; }"
"static int binomialCoeffSum ( int n ) { int C [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) sum += C [ n ] [ i ] ; return sum ; }"
"static int colourVisible ( int height [ ] , int colour [ ] , int K ) { int arr [ ] = new int [ K + 1 ] ; int visible = 0 ; int max = height [ K - 1 ] ; arr [ colour [ K - 1 ] ] = 1 ; for ( int i = K - 2 ; i >= 0 ; i -- ) { if ( height [ i ] > max ) { max = height [ i ] ; arr [ colour [ i ] ] = 1 ; } } for ( int i = 1 ; i <= K ; i ++ ) { if ( arr [ i ] == 1 ) visible ++ ; } return visible ; }"
"static void removeSpecialCharacter ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) < 'A' || s . charAt ( i ) > 'Z' && s . charAt ( i ) < 'a' || s . charAt ( i ) > 'z' ) { s = s . substring ( 0 , i ) + s . substring ( i + 1 ) ; i -- ; } } System . out . print ( s ) ; }"
"static void ladder_pattern ( int N ) { for ( int i = 0 ; i <= N ; i ++ ) { System . out . println ( ""* *"" ) ; System . out . println ( ""* *"" ) ; if ( i < N ) { System . out . println ( ""*****"" ) ; } } }"
"static int countEndless ( boolean input [ ] [ ] , int n ) { boolean row [ ] [ ] = new boolean [ n ] [ n ] ; boolean col [ ] [ ] = new boolean [ n ] [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { boolean isEndless = true ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( input [ i ] [ j ] == false ) isEndless = false ; col [ i ] [ j ] = isEndless ; } } for ( int i = 0 ; i < n ; i ++ ) { boolean isEndless = true ; for ( int j = n - 1 ; j >= 0 ; j -- ) { if ( input [ i ] [ j ] == false ) isEndless = false ; row [ i ] [ j ] = isEndless ; } } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 1 ; j < n ; j ++ ) if ( row [ i ] [ j ] && col [ i ] [ j ] ) ans ++ ; return ans ; }"
"public static int floorSqrt ( int x ) { if ( x == 0 || x == 1 ) return x ; int start = 1 , end = x , ans = 0 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( mid * mid == x ) return mid ; if ( mid * mid < x ) { start = mid + 1 ; ans = mid ; } else end = mid - 1 ; } return ans ; }"
"static int LCSubStr ( String X , String Y ) { int m = X . length ( ) ; int n = Y . length ( ) ; int result = 0 ; int [ ] [ ] len = new int [ 2 ] [ n ] ; int currRow = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == 0 || j == 0 ) { len [ currRow ] [ j ] = 0 ; } else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) { len [ currRow ] [ j ] = len [ ( 1 - currRow ) ] [ ( j - 1 ) ] + 1 ; result = Math . max ( result , len [ currRow ] [ j ] ) ; } else { len [ currRow ] [ j ] = 0 ; } } currRow = 1 - currRow ; } return result ; }"
"static int maxZeros ( int n ) { if ( n == 0 || ( n & ( n - 1 ) ) == 0 ) { return - 1 ; } byte b = 4 ; int setBit = 1 , prev = 0 , i ; for ( i = 1 ; i <= b * 8 ; i ++ ) { prev ++ ; if ( ( n & setBit ) == setBit ) { setBit = setBit << 1 ; break ; } setBit = setBit << 1 ; } int max0 = Integer . MIN_VALUE , cur = prev ; for ( int j = i + 1 ; j <= b * 8 ; j ++ ) { cur ++ ; if ( ( n & setBit ) == setBit ) { if ( max0 < ( cur - prev - 1 ) ) { max0 = cur - prev - 1 ; } prev = cur ; } setBit = setBit << 1 ; } return max0 ; }"
"static void factors ( int n , int i ) { if ( i <= n ) { if ( n % i == 0 ) { System . out . print ( i + "" "" ) ; } factors ( n , i + 1 ) ; } }"
static int countRect ( int n ) { int ans = 0 ; for ( int length = 1 ; length <= Math . sqrt ( n ) ; ++ length ) for ( int height = length ; height * length <= n ; ++ height ) ans ++ ; return ans ; }
static int findCount ( String str ) { int result = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( i == ( str . charAt ( i ) - 'a' ) || i == ( str . charAt ( i ) - 'A' ) ) { result ++ ; } } return result ; }
"static void FindRank ( int arr [ ] , int length ) { System . out . print ( ""1"" + "" "" ) ; for ( int i = 1 ; i < arr . length ; i ++ ) { int rank = 1 ; for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] > arr [ i ] ) rank ++ ; } System . out . print ( rank + "" "" ) ; } }"
"static String OctToBin ( String octnum ) { long i = 0 ; String binary = """" ; while ( i < octnum . length ( ) ) { char c = octnum . charAt ( ( int ) i ) ; switch ( c ) { case '0' : binary += ""000"" ; break ; case '1' : binary += ""001"" ; break ; case '2' : binary += ""010"" ; break ; case '3' : binary += ""011"" ; break ; case '4' : binary += ""100"" ; break ; case '5' : binary += ""101"" ; break ; case '6' : binary += ""110"" ; break ; case '7' : binary += ""111"" ; break ; default : System . out . println ( ""\nInvalid Octal Digit "" + octnum . charAt ( ( int ) i ) ) ; break ; } i ++ ; } return binary ; }"
"static void countWaysToJump ( int arr [ ] , int n ) { int count_jump [ ] = new int [ n ] ; Arrays . fill ( count_jump , 0 ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] >= n - i - 1 ) count_jump [ i ] ++ ; for ( int j = i + 1 ; j < n - 1 && j <= arr [ i ] + i ; j ++ ) if ( count_jump [ j ] != - 1 ) count_jump [ i ] += count_jump [ j ] ; if ( count_jump [ i ] == 0 ) count_jump [ i ] = - 1 ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( count_jump [ i ] + "" "" ) ; }"
"static int maxSumIS ( int arr [ ] , int n ) { int i , j , max = 0 ; int msis [ ] = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) msis [ i ] = arr [ i ] ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j ] + arr [ i ] ) msis [ i ] = msis [ j ] + arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( max < msis [ i ] ) max = msis [ i ] ; return max ; }"
"public static void findWord ( String c , int n ) { int co = 0 , i ; char s [ ] = new char [ n ] ; for ( i = 0 ; i < n ; i ++ ) { if ( i < n / 2 ) co ++ ; else co = n - i ; if ( ( c . charAt ( i ) + co ) <= 122 ) s [ i ] = ( char ) ( ( int ) c . charAt ( i ) + co ) ; else s [ i ] = ( char ) ( ( int ) c . charAt ( i ) + co - 26 ) ; } String str = Arrays . toString ( s ) ; System . out . println ( str ) ; }"
"static int countSubstrs ( String str , int i , int j , int n ) { if ( n == 1 ) return 1 ; if ( n <= 0 ) return 0 ; int res = countSubstrs ( str , i + 1 , j , n - 1 ) + countSubstrs ( str , i , j - 1 , n - 1 ) - countSubstrs ( str , i + 1 , j - 1 , n - 2 ) ; if ( str . charAt ( i ) == str . charAt ( j ) ) res ++ ; return res ; }"
"static int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) { l ++ ; r -- ; count ++ ; } else if ( ( arr1 [ l ] + arr2 [ r ] ) < x ) l ++ ; else r -- ; } return count ; }"
static boolean isPalindrome ( int n ) { if ( n % 11 == 0 ) { return true ; } return false ; }
"static int subsetPairNotDivisibleByK ( int arr [ ] , int N , int K ) { int f [ ] = new int [ K ] ; Arrays . fill ( f , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) f [ arr [ i ] % K ] ++ ; if ( K % 2 == 0 ) f [ K / 2 ] = Math . min ( f [ K / 2 ] , 1 ) ; int res = Math . min ( f [ 0 ] , 1 ) ; for ( int i = 1 ; i <= K / 2 ; i ++ ) res += Math . max ( f [ i ] , f [ K - i ] ) ; return res ; }"
"public static int subset ( int ar [ ] , int n ) { int res = 0 ; Arrays . sort ( ar ) ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; for ( ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) count ++ ; else break ; } res = Math . max ( res , count ) ; } return res ; }"
"static void checksum ( int n ) { if ( n % 5 == 0 ) System . out . println ( ( n / 5 - 2 ) + "" "" + ( n / 5 - 1 ) + "" "" + ( n / 5 ) + "" "" + ( n / 5 + 1 ) + "" "" + ( n / 5 + 2 ) ) ; else System . out . println ( ""-1"" ) ; }"
"static int findSum ( String str ) { String temp = """" ; int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; if ( Character . isDigit ( ch ) ) temp += ch ; else { sum += Integer . parseInt ( temp ) ; temp = ""0"" ; } } return sum + Integer . parseInt ( temp ) ; }"
"static void twoParts ( String str ) { int flag = 0 ; String a = """" ; char [ ] gfg = str . toCharArray ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( gfg [ i ] == '4' ) { gfg [ i ] = '3' ; a += '1' ; flag = 1 ; } else if ( flag != 0 ) a += '0' ; } str = new String ( gfg ) ; System . out . print ( str + "" "" + a ) ; }"
"static boolean isPerfectSquare ( int [ ] arr , int n ) { HashMap < Integer , Integer > umap = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( umap . containsKey ( arr [ i ] ) ) umap . put ( arr [ i ] , umap . get ( arr [ i ] ) + 1 ) ; else umap . put ( arr [ i ] , 1 ) ; } Iterator < Map . Entry < Integer , Integer >> iterator = umap . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < Integer , Integer > entry = iterator . next ( ) ; if ( entry . getValue ( ) % 2 == 1 ) return false ; } return true ; }"
public static int nobleInteger ( int arr [ ] ) { Arrays . sort ( arr ) ; int n = arr . length ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) continue ; if ( arr [ i ] == n - i - 1 ) return arr [ i ] ; } if ( arr [ n - 1 ] == 0 ) return arr [ n - 1 ] ; return - 1 ; }
"static void find ( int a [ ] , int n ) { int count_odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 != 0 ) { count_odd += 1 ; } } int result = ( int ) ( Math . pow ( 2 , n ) - 1 ) ; result -= ( Math . pow ( 2 , count_odd ) - 1 ) ; System . out . println ( result ) ; }"
"static int swapBits ( int x , int p1 , int p2 , int n ) { int set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) ; int set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) ; int xor = ( set1 ^ set2 ) ; xor = ( xor << p1 ) | ( xor << p2 ) ; int result = x ^ xor ; return result ; }"
"static int countNumbers ( int n ) { int c = 0 ; int limit = ( int ) Math . sqrt ( n ) ; int prime [ ] = new int [ limit + 1 ] ; for ( int i = 1 ; i <= limit ; i ++ ) { prime [ i ] = i ; } for ( int i = 2 ; i * i <= limit ; i ++ ) { if ( prime [ i ] == i ) { for ( int j = i * i ; j <= limit ; j += i ) { if ( prime [ j ] == j ) { prime [ j ] = i ; } } } } for ( int i = 2 ; i <= limit ; i ++ ) { int p = prime [ i ] ; int q = prime [ i / prime [ i ] ] ; if ( p * q == i && q != 1 && p != q ) { c += 1 ; } else if ( prime [ i ] == i ) { if ( Math . pow ( i , 8 ) <= n ) { c += 1 ; } } } return c ; }"
static void printRotatedString ( String str ) { int n = str . length ( ) ; StringBuffer sb = new StringBuffer ( str ) ; sb . append ( str ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j != n ; j ++ ) System . out . print ( sb . charAt ( i + j ) ) ; System . out . println ( ) ; } }
"static int minCost ( int arr [ ] , int cost [ ] , int n ) { int costThree = Integer . MAX_VALUE ; for ( int j = 0 ; j < n ; j ++ ) { int costI = Integer . MAX_VALUE ; int costK = Integer . MAX_VALUE ; for ( int i = 0 ; i < j ; i ++ ) { if ( arr [ i ] < arr [ j ] ) costI = Math . min ( costI , cost [ i ] ) ; } for ( int k = j + 1 ; k < n ; k ++ ) { if ( arr [ k ] > arr [ j ] ) costK = Math . min ( costK , cost [ k ] ) ; } if ( costI != Integer . MAX_VALUE && costK != Integer . MAX_VALUE ) { costThree = Math . min ( costThree , cost [ j ] + costI + costK ) ; } } if ( costThree == Integer . MAX_VALUE ) return - 1 ; return costThree ; }"
static long squareRoot ( int n ) { int x = n ; int y = 1 ; while ( x > y ) { x = ( x + y ) / 2 ; y = n / x ; } return ( long ) x ; }
"static int count ( int n ) { int table [ ] = new int [ n + 1 ] , i ; Arrays . fill ( table , 0 ) ; table [ 0 ] = 1 ; for ( i = 3 ; i <= n ; i ++ ) table [ i ] += table [ i - 3 ] ; for ( i = 5 ; i <= n ; i ++ ) table [ i ] += table [ i - 5 ] ; for ( i = 10 ; i <= n ; i ++ ) table [ i ] += table [ i - 10 ] ; return table [ n ] ; }"
"static int minSwaps ( int arr [ ] , int n ) { int numberOfOnes = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) numberOfOnes ++ ; } int x = numberOfOnes ; int count_ones = 0 , maxOnes ; for ( int i = 0 ; i < x ; i ++ ) { if ( arr [ i ] == 1 ) count_ones ++ ; } maxOnes = count_ones ; for ( int i = 1 ; i <= n - x ; i ++ ) { if ( arr [ i - 1 ] == 1 ) count_ones -- ; if ( arr [ i + x - 1 ] == 1 ) count_ones ++ ; if ( maxOnes < count_ones ) maxOnes = count_ones ; } int numberOfZeroes = x - maxOnes ; return numberOfZeroes ; }"
"static int modFact ( int n , int p ) { if ( n >= p ) return 0 ; int result = 1 ; for ( int i = 1 ; i <= n ; i ++ ) result = ( result * i ) % p ; return result ; }"
"static void findTangent ( int A , int x , int y ) { int dif = A - x * 2 ; if ( y == ( 2 * x - x * x ) ) { if ( dif < 0 ) System . out . println ( ""y = "" + dif + ""x"" + ( x * dif + y ) ) ; else if ( dif > 0 ) System . out . println ( ""y = "" + dif + ""x+"" + - x * dif + y ) ; else System . out . println ( ""Not possible"" ) ; } }"
"static int setallbitgivenrange ( int n , int l , int r ) { int range = ( ( ( 1 << ( l - 1 ) ) - 1 ) ^ ( ( 1 << ( r ) ) - 1 ) ) ; return ( n | range ) ; }"
"static void printIntersection ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) i ++ ; else if ( arr2 [ j ] < arr1 [ i ] ) j ++ ; else { System . out . print ( arr2 [ j ++ ] + "" "" ) ; i ++ ; } } }"
static double procal ( int n ) { return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) ; }
"static int maxAND ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) res = res > ( arr [ i ] & arr [ j ] ) ? res : ( arr [ i ] & arr [ j ] ) ; return res ; }"
"static int findElement ( int arr [ ] , int size ) { int right_mul = 1 , left_mul = 1 ; for ( int i = 1 ; i < size ; i ++ ) right_mul *= arr [ i ] ; for ( int i = 0 , j = 1 ; j < size ; i ++ , j ++ ) { right_mul /= arr [ j ] ; left_mul *= arr [ i ] ; if ( left_mul == right_mul ) return arr [ i + 1 ] ; } return - 1 ; }"
"static void max_element ( int a [ ] , int n ) { int [ ] pre = new int [ n ] ; pre [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) pre [ i ] = Math . max ( pre [ i - 1 ] , a [ i ] ) ; int [ ] suf = new int [ n ] ; suf [ n - 1 ] = a [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) suf [ i ] = Math . max ( suf [ i + 1 ] , a [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 ) System . out . print ( suf [ i + 1 ] + "" "" ) ; else if ( i == n - 1 ) System . out . print ( pre [ i - 1 ] + "" "" ) ; else System . out . print ( Math . max ( pre [ i - 1 ] , suf [ i + 1 ] ) + "" "" ) ; } }"
"static int maxProd ( int n ) { if ( n == 0 || n == 1 ) return 0 ; int max_val = 0 ; for ( int i = 1 ; i < n ; i ++ ) max_val = Math . max ( max_val , Math . max ( i * ( n - i ) , maxProd ( n - i ) * i ) ) ; return max_val ; }"
"static int MaximumHeight ( int a [ ] , int n ) { return ( int ) Math . floor ( ( - 1 + Math . sqrt ( 1 + ( 8 * n ) ) ) / 2 ) ; }"
"static boolean oppositeSigns ( int x , int y ) { return ( ( x ^ y ) < 0 ) ; }"
"static String even_or_odd ( String N ) { int len = N . length ( ) ; if ( N . charAt ( len - 1 ) == '0' || N . charAt ( len - 1 ) == '2' || N . charAt ( len - 1 ) == '4' || N . charAt ( len - 1 ) == '6' ) return ( ""Even"" ) ; else return ( ""Odd"" ) ; }"
"static double sumOfSeries ( int n ) { double res = 0.0 ; int sum = 0 , prod = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { sum += i ; prod *= i ; res += ( ( double ) sum / prod ) ; } return res ; }"
static int count9s ( String number ) { int count = 0 ; int n = number . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int sum = number . charAt ( i ) - '0' ; if ( number . charAt ( i ) == '9' ) count ++ ; for ( int j = i + 1 ; j < n ; j ++ ) { sum = ( sum + number . charAt ( j ) - '0' ) % 9 ; if ( sum == 0 ) count ++ ; } } return count ; }
"public static double calculateSum ( double n ) { return 2 * ( Math . pow ( n , 6 ) + 15 * Math . pow ( n , 4 ) + 15 * Math . pow ( n , 2 ) + 1 ) ; }"
"static void findNumbers ( int arr [ ] , int n ) { int sumN = ( n * ( n + 1 ) ) / 2 ; int sumSqN = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; int sum = 0 , sumSq = 0 , i ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; sumSq += Math . pow ( arr [ i ] , 2 ) ; } int B = ( ( ( sumSq - sumSqN ) / ( sum - sumN ) ) + sumN - sum ) / 2 ; int A = sum - sumN + B ; System . out . println ( ""A = "" + A + ""\nB = "" + B ) ; }"
"static void countPermutations ( int N , int B ) { int x = ( int ) Math . pow ( B , N ) ; int y = ( int ) Math . pow ( B , N - 1 ) ; System . out . println ( x - y ) ; }"
"static void removeChar ( String s , char c ) { int j , count = 0 , n = s . length ( ) ; char [ ] t = s . toCharArray ( ) ; for ( int i = j = 0 ; i < n ; i ++ ) { if ( t [ i ] != c ) t [ j ++ ] = t [ i ] ; else count ++ ; } while ( count > 0 ) { t [ j ++ ] = '\0' ; count -- ; } System . out . println ( t ) ; }"
"public static boolean isPalindrome ( String str ) { int start = 0 , end = str . length ( ) - 1 ; while ( start <= end ) { if ( str . charAt ( start ) != str . charAt ( end ) ) return false ; start += 1 ; end -- ; } return true ; }"
"static int longSubarrWthSumDivByK ( int arr [ ] , int n , int k ) { HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int mod_arr [ ] = new int [ n ] ; int max = 0 ; int curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_sum += arr [ i ] ; mod_arr [ i ] = ( ( curr_sum % k ) + k ) % k ; } for ( int i = 0 ; i < n ; i ++ ) { if ( mod_arr [ i ] == 0 ) max = i + 1 ; else if ( um . containsKey ( mod_arr [ i ] ) == false ) um . put ( mod_arr [ i ] , i ) ; else if ( max < ( i - um . get ( mod_arr [ i ] ) ) ) max = i - um . get ( mod_arr [ i ] ) ; } return max ; }"
"public static int findMinimumAngle ( int arr [ ] , int n ) { int l = 0 , sum = 0 , ans = 360 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; while ( sum >= 180 ) { ans = Math . min ( ans , 2 * Math . abs ( 180 - sum ) ) ; sum -= arr [ l ] ; l ++ ; } ans = Math . min ( ans , 2 * Math . abs ( 180 - sum ) ) ; } return ans ; }"
"static int calculate ( int x , int k , int m ) { int result = x ; k -- ; while ( k -- > 0 ) { result = ( int ) Math . pow ( result , x ) ; if ( result > m ) result %= m ; } return result ; }"
static boolean isPerfectSquare ( double x ) { double sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; }
"static int find_digit ( String s , int n ) { int first_digit = - 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s . charAt ( i ) < '0' || s . charAt ( i ) > '9' ) { first_digit = i ; break ; } } first_digit ++ ; int s_len = first_digit ; int num = 0 , pw = 1 ; int i = n - 1 ; while ( i >= 0 ) { if ( s . charAt ( i ) >= '0' && s . charAt ( i ) <= '9' ) { int digit = s . charAt ( i ) - '0' ; num = num + ( pw * digit ) ; if ( num >= s_len ) return - 1 ; pw = pw * 10 ; } i -- ; } num = num * 10 ; int req = s_len - num ; if ( req > 9 || req < 0 ) return - 1 ; return req ; }"
"static int numOfWhiteHats ( int arr [ ] , int n ) { int freq [ ] = new int [ n + 1 ] ; Arrays . fill ( freq , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= n ) return - 1 ; freq [ arr [ i ] ] ++ ; } int diffFreq = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) if ( freq [ i ] > 0 ) diffFreq ++ ; if ( diffFreq == 1 && freq [ n - 1 ] == n ) return n ; if ( diffFreq == 1 && freq [ 0 ] == n ) return 0 ; if ( diffFreq != 2 ) return - 1 ; int k ; for ( k = n - 1 ; k >= 1 ; k -- ) if ( freq [ k ] > 0 ) break ; if ( freq [ k - 1 ] == k && freq [ k ] + k == n ) return freq [ k - 1 ] ; else return - 1 ; }"
static int exactPrimeFactorCount ( int n ) { int count = 0 ; if ( n % 2 == 0 ) { count ++ ; while ( n % 2 == 0 ) n = n / 2 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { count ++ ; while ( n % i == 0 ) n = n / i ; } } if ( n > 2 ) count ++ ; return count ; }
"static void vowelOrConsonant ( char x ) { if ( x == 'a' || x == 'e' || x == 'i' || x == 'o' || x == 'u' || x == 'A' || x == 'E' || x == 'I' || x == 'O' || x == 'U' ) System . out . println ( ""Vowel"" ) ; else System . out . println ( ""Consonant"" ) ; }"
static int countNumberOfTriangles ( int n ) { return n * ( n - 1 ) * ( n - 2 ) / 6 ; }
"static int ceilSearch ( int arr [ ] , int low , int high , int x ) { int mid ; if ( x <= arr [ low ] ) return low ; if ( x > arr [ high ] ) return - 1 ; mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; else if ( arr [ mid ] < x ) { if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid + 1 ; else return ceilSearch ( arr , mid + 1 , high , x ) ; } else { if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid ; else return ceilSearch ( arr , low , mid - 1 , x ) ; } }"
"static int pow ( int a , int b ) { if ( b == 0 ) return 1 ; int answer = a ; int increment = a ; int i , j ; for ( i = 1 ; i < b ; i ++ ) { for ( j = 1 ; j < a ; j ++ ) { answer += increment ; } increment = answer ; } return answer ; }"
"static int sumBetweenTwoKth ( int arr [ ] , int k1 , int k2 ) { Arrays . sort ( arr ) ; int result = 0 ; for ( int i = k1 ; i < k2 - 1 ; i ++ ) result += arr [ i ] ; return result ; }"
static int longestPrefixSuffix ( String s ) { int n = s . length ( ) ; if ( n < 2 ) { return 0 ; } int len = 0 ; int i = n / 2 ; while ( i < n ) { if ( s . charAt ( i ) == s . charAt ( len ) ) { ++ len ; ++ i ; } else { if ( len == 0 ) { ++ i ; } else { -- len ; } } } return len ; }
"static void canMake ( int n , int ar [ ] ) { int sum = 0 , maxx = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum += ar [ i ] ; maxx = Math . max ( maxx , ar [ i ] ) ; } if ( n == 1 || sum % 2 == 1 || sum - maxx < maxx ) { System . out . print ( ""No\n"" ) ; } else { System . out . print ( ""Yes\n"" ) ; } }"
"static void printUncommon ( String str1 , String str2 ) { int a1 = 0 , a2 = 0 ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { int ch = ( str1 . charAt ( i ) ) - 'a' ; a1 = a1 | ( 1 << ch ) ; } for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) { int ch = ( str2 . charAt ( i ) ) - 'a' ; a2 = a2 | ( 1 << ch ) ; } int ans = a1 ^ a2 ; int i = 0 ; while ( i < 26 ) { if ( ans % 2 == 1 ) { System . out . print ( ( char ) ( 'a' + i ) ) ; } ans = ans / 2 ; i ++ ; } }"
"static void bubbleSort ( int arr [ ] , int n ) { int i , j , temp ; boolean swapped ; for ( i = 0 ; i < n - 1 ; i ++ ) { swapped = false ; for ( j = 0 ; j < n - i - 1 ; j ++ ) { if ( arr [ j ] > arr [ j + 1 ] ) { temp = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; swapped = true ; } } if ( swapped == false ) break ; } }"
"static int findElement ( int arr [ ] , int n ) { int [ ] prefixSum = new int [ n ] ; prefixSum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefixSum [ i ] = prefixSum [ i - 1 ] + arr [ i ] ; int [ ] suffixSum = new int [ n ] ; suffixSum [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) suffixSum [ i ] = suffixSum [ i + 1 ] + arr [ i ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) if ( prefixSum [ i ] == suffixSum [ i ] ) return arr [ i ] ; return - 1 ; }"
"static int product ( int N ) { int ans = 1 ; int val = ( int ) Math . pow ( 2 , N - 1 ) ; for ( int i = 1 ; i <= N ; i ++ ) { ans *= ( int ) Math . pow ( i , val ) ; } return ans ; }"
"static int kPrimeFactor ( int n , int k ) { while ( n % 2 == 0 ) { k -- ; n = n / 2 ; if ( k == 0 ) return 2 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { if ( k == 1 ) return i ; k -- ; n = n / i ; } } if ( n > 2 && k == 1 ) return n ; return - 1 ; }"
"static void unique ( int mat [ ] [ ] , int n , int m ) { int maximum = 0 , flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( maximum < mat [ i ] [ j ] ) maximum = mat [ i ] [ j ] ; int b [ ] = new int [ maximum + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) b [ mat [ i ] [ j ] ] ++ ; for ( int i = 1 ; i <= maximum ; i ++ ) if ( b [ i ] == 1 ) System . out . print ( i + "" "" ) ; flag = 1 ; if ( flag == 0 ) { System . out . println ( ""No unique element "" + ""in the matrix"" ) ; } }"
"static void checkIfPowerIsolated ( int num ) { int input = num ; int count = 0 ; int [ ] factor = new int [ num + 1 ] ; if ( num % 2 == 0 ) { while ( num % 2 == 0 ) { ++ count ; num /= 2 ; } factor [ 2 ] = count ; } for ( int i = 3 ; i * i <= num ; i += 2 ) { count = 0 ; while ( num % i == 0 ) { ++ count ; num /= i ; } if ( count > 0 ) factor [ i ] = count ; } if ( num > 1 ) factor [ num ] = 1 ; int product = 1 ; for ( int i = 0 ; i < num + 1 ; i ++ ) { if ( factor [ i ] > 0 ) product = product * factor [ i ] * i ; } if ( product == input ) System . out . print ( ""Power-isolated Integer\n"" ) ; else System . out . print ( ""Not a Power-isolated Integer\n"" ) ; }"
static int centered_pentagonal_Num ( int n ) { return ( 5 * n * n - 5 * n + 2 ) / 2 ; }
"static void printThreeParts ( int N ) { if ( N % 3 == 0 ) System . out . println ( ""x = 1, y = 1, z = "" + ( N - 2 ) ) ; else System . out . println ( "" x = 1, y = 2, z = "" + ( N - 3 ) ) ; }"
"static int sameSetBits ( int arr [ ] , int n ) { Vector < Integer > v = new Vector < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int count = Integer . bitCount ( arr [ i ] ) ; v . add ( count ) ; } int current_count = 1 , max_count = 1 ; for ( int i = 1 ; i < v . size ( ) - 1 ; i ++ ) { if ( v . get ( i + 1 ) == v . get ( i ) ) current_count ++ ; else current_count = 1 ; max_count = Math . max ( max_count , current_count ) ; } return max_count ; }"
"static void remove ( int arr [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( ( mp . containsKey ( arr [ i ] ) && mp . get ( arr [ i ] ) % 2 == 1 ) ) continue ; System . out . print ( arr [ i ] + "", "" ) ; } }"
"static int countNumbers ( int X , int Y , int N ) { int count = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( ( i % X == 0 ) && ( i % Y != 0 ) ) count ++ ; } return count ; }"
"static double printProbability ( int L , int n ) { int p = ( 1 << ( n - 1 ) ) ; return 1.0 - ( ( double ) n ) / ( ( double ) p ) ; }"
static int isPowerOfFour ( int n ) { if ( n == 0 ) return 0 ; while ( n != 1 ) { if ( n % 4 != 0 ) return 0 ; n = n / 4 ; } return 1 ; }
"static double arcLength ( double diameter , double angle ) { double pi = 22.0 / 7.0 ; double arc ; if ( angle >= 360 ) { System . out . println ( ""Angle cannot"" + "" be formed"" ) ; return 0 ; } else { arc = ( pi * diameter ) * ( angle / 360.0 ) ; return arc ; } }"
static int findNth ( int N ) { int b = 14 ; int i ; for ( i = 2 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) b = b * 2 ; else b = b - 8 ; } return b ; }
"static void findAngle ( int n ) { int interiorAngle , exteriorAngle ; interiorAngle = ( n - 2 ) * 180 / n ; exteriorAngle = 360 / n ; System . out . println ( ""Interior angle: "" + interiorAngle ) ; System . out . println ( ""Exterior angle: "" + exteriorAngle ) ; }"
"static boolean search ( int arr [ ] , int n , int x ) { int front = 0 , back = n - 1 ; while ( front <= back ) { if ( arr [ front ] == x || arr [ back ] == x ) return true ; front ++ ; back -- ; } return false ; }"
"static int maximumChars ( String str ) { int n = str . length ( ) ; int res = - 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( str . charAt ( i ) == str . charAt ( j ) ) res = Math . max ( res , Math . abs ( j - i - 1 ) ) ; return res ; }"
"static int countOccurrances ( int n , int d ) { int count = 0 ; while ( n > 0 ) { count = ( n % 10 == d ) ? count + 1 : count ; n = n / 10 ; } return count ; }"
"static int count_carry ( String a , String b ) { int carry = 0 ; int count = 0 ; int len_a = a . length ( ) , len_b = b . length ( ) ; while ( len_a != 0 || len_b != 0 ) { int x = 0 , y = 0 ; if ( len_a > 0 ) { x = a . charAt ( len_a - 1 ) - '0' ; len_a -- ; } if ( len_b > 0 ) { y = b . charAt ( len_b - 1 ) - '0' ; len_b -- ; } int sum = x + y + carry ; if ( sum >= 10 ) { carry = 1 ; count ++ ; } else carry = 0 ; } return count ; }"
"static void dist ( double x1 , double y1 , double x2 , double y2 , double r ) { System . out . println ( ""The shortest distance "" + ""between a point and a circle is "" + ( Math . sqrt ( ( Math . pow ( ( x2 - x1 ) , 2 ) ) + ( Math . pow ( ( y2 - y1 ) , 2 ) ) ) - r ) ) ; }"
"static int countSubSeq ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) { count ++ ; } } return ( int ) ( Math . pow ( 2 , count ) - 1 ) ; }"
"static int getNumToAdd ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int d = arr [ 1 ] - arr [ 0 ] ; int numToAdd = - 1 ; boolean numAdded = false ; for ( int i = 2 ; i < n ; i ++ ) { int diff = arr [ i ] - arr [ i - 1 ] ; if ( diff != d ) { if ( numAdded ) return - 1 ; if ( diff == 2 * d ) { numToAdd = arr [ i ] - d ; numAdded = true ; } else return - 1 ; } } if ( numToAdd == - 1 ) return ( arr [ n - 1 ] + d ) ; return numToAdd ; }"
"static int countDigit ( int n ) { boolean prime [ ] = new boolean [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) prime [ i ] = false ; prime [ 2 ] = prime [ 3 ] = true ; prime [ 5 ] = prime [ 7 ] = true ; int temp = n , count = 0 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 && prime [ d ] == true ) count ++ ; } return count ; }"
static int printCountRec ( int dist ) { if ( dist < 0 ) return 0 ; if ( dist == 0 ) return 1 ; return printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) ; }
static int findSum ( int n ) { int multiTerms = n * ( n + 1 ) / 2 ; int sum = multiTerms ; for ( int i = 2 ; i <= n ; i ++ ) { multiTerms = multiTerms - ( i - 1 ) ; sum = sum + multiTerms * i ; } return sum ; }
"static void printPrevGreater ( int [ ] arr , int n ) { TreeSet < Integer > ts = new TreeSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Integer c = ts . ceiling ( arr [ i ] ) ; if ( c == null ) System . out . print ( - 1 + "" "" ) ; else System . out . print ( c + "" "" ) ; ts . add ( arr [ i ] ) ; } }"
"static boolean checkIfAllTogether ( String s , char c ) { boolean oneSeen = false ; int i = 0 , n = s . length ( ) ; while ( i < n ) { if ( s . charAt ( i ) == c ) { if ( oneSeen == true ) return false ; while ( i < n && s . charAt ( i ) == c ) i ++ ; oneSeen = true ; } else i ++ ; } return true ; }"
"static void insertionSortRecursive ( int arr [ ] , int n ) { if ( n <= 1 ) return ; insertionSortRecursive ( arr , n - 1 ) ; int last = arr [ n - 1 ] ; int j = n - 2 ; while ( j >= 0 && arr [ j ] > last ) { arr [ j + 1 ] = arr [ j ] ; j -- ; } arr [ j + 1 ] = last ; }"
"static void bonacciseries ( int n , int m ) { int a [ ] = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) a [ i ] = 0 ; a [ n - 1 ] = 1 ; a [ n ] = 1 ; for ( int i = n + 1 ; i < m ; i ++ ) a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ] ; for ( int i = 0 ; i < m ; i ++ ) System . out . print ( a [ i ] + "" "" ) ; }"
"static void generateArr ( int [ ] arr , int n ) { if ( n <= 1 ) return ; int prev = arr [ 0 ] ; arr [ 0 ] = arr [ 0 ] & arr [ 1 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int curr = arr [ i ] ; arr [ i ] = prev & arr [ i + 1 ] ; prev = curr ; } arr [ n - 1 ] = prev & arr [ n - 1 ] ; }"
"static int maxvolume ( int s ) { int maxvalue = 0 ; for ( int i = 1 ; i <= s - 2 ; i ++ ) { for ( int j = 1 ; j <= s - 1 ; j ++ ) { int k = s - i - j ; maxvalue = Math . max ( maxvalue , i * j * k ) ; } } return maxvalue ; }"
static boolean isPowerOfTwo ( int n ) { if ( n == 0 ) return false ; while ( n != 1 ) { if ( n % 2 != 0 ) return false ; n = n / 2 ; } return true ; }
"static int leastValue ( int P , int A , int N , int a [ ] ) { int ans = - 1 ; float tmp = Float . MAX_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { float t = ( float ) ( P - a [ i ] * 0.006 ) ; if ( Math . abs ( t - A ) < tmp ) { tmp = Math . abs ( t - A ) ; ans = i ; } } return a [ ans ] ; }"
"static void survival ( int S , int N , int M ) { if ( ( ( N * 6 ) < ( M * 7 ) && S > 6 ) || M > N ) System . out . println ( ""No"" ) ; else { int days = ( M * S ) / N ; if ( ( ( M * S ) % N ) != 0 ) days ++ ; System . out . println ( ""Yes "" + days ) ; } }"
"static int gcd ( int a , int b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; int k ; for ( k = 0 ; ( ( a | b ) & 1 ) == 0 ; ++ k ) { a >>= 1 ; b >>= 1 ; } while ( ( a & 1 ) == 0 ) a >>= 1 ; do { while ( ( b & 1 ) == 0 ) b >>= 1 ; if ( a > b ) { int temp = a ; a = b ; b = temp ; } b = ( b - a ) ; } while ( b != 0 ) ; return a << k ; }"
"static boolean maxProduct ( int arr [ ] , int n , int p ) { int minVal = arr [ 0 ] ; int maxVal = arr [ 0 ] ; int maxProduct = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) { int temp = maxVal ; maxVal = minVal ; minVal = temp ; } maxVal = Math . max ( arr [ i ] , maxVal * arr [ i ] ) ; minVal = Math . min ( arr [ i ] , minVal * arr [ i ] ) ; if ( minVal == p || maxVal == p ) { return true ; } maxProduct = Math . max ( maxProduct , maxVal ) ; } return false ; }"
static int isMultipleOf3 ( int n ) { int odd_count = 0 ; int even_count = 0 ; if ( n < 0 ) n = - n ; if ( n == 0 ) return 1 ; if ( n == 1 ) return 0 ; while ( n != 0 ) { if ( ( n & 1 ) != 0 ) odd_count ++ ; if ( ( n & 2 ) != 0 ) even_count ++ ; n = n >> 2 ; } return isMultipleOf3 ( Math . abs ( odd_count - even_count ) ) ; }
"static int getPassingCars ( int A [ ] , int n ) { int countOne = 0 , result = 0 ; while ( n >= 1 ) { if ( A [ n - 1 ] == 1 ) countOne ++ ; else result += countOne ; n -- ; } return result ; }"
"static boolean isMember ( int a , int d , int x ) { if ( d == 0 ) return ( x == a ) ; return ( ( x - a ) % d == 0 && ( x - a ) / d >= 0 ) ; }"
"static void findpair ( int l , int r ) { int ans1 = l ; int ans2 = 2 * l ; System . out . println ( ans1 + "", "" + ans2 ) ; }"
"static void countPairs ( int arr [ ] , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } System . out . println ( ( even ) * ( n - 1 ) ) ; System . out . println ( ( odd ) * ( n - 1 ) ) ; }"
"static int findMaxDiff ( int arr [ ] , int n ) { if ( n < 2 ) { System . out . println ( ""Invalid "" ) ; return 0 ; } int min_val = Integer . MAX_VALUE , max_val = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] - i ) > max_val ) max_val = arr [ i ] - i ; if ( ( arr [ i ] - i ) < min_val ) min_val = arr [ i ] - i ; } return ( max_val - min_val ) ; }"
"static int costToPanagram ( String str , int cost [ ] ) { int i , n = str . length ( ) ; int occurrences [ ] = new int [ 26 ] ; for ( i = 0 ; i < n ; i ++ ) occurrences [ str . charAt ( i ) - 'a' ] ++ ; int gain = 0 ; for ( i = 0 ; i < 26 ; i ++ ) { if ( occurrences [ i ] == 0 ) gain -= ( 2 * cost [ i ] ) ; else if ( occurrences [ i ] > 1 ) gain += ( cost [ i ] * ( occurrences [ i ] - 1 ) ) ; } if ( gain >= 0 ) return 0 ; return ( gain * - 1 ) ; }"
"static int findRepeating ( int arr [ ] , int n ) { int missingElement = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int element = arr [ Math . abs ( arr [ i ] ) ] ; if ( element < 0 ) { missingElement = arr [ i ] ; break ; } arr [ Math . abs ( arr [ i ] ) ] = - arr [ Math . abs ( arr [ i ] ) ] ; } return Math . abs ( missingElement ) ; }"
"static int getMedian ( int ar1 [ ] , int ar2 [ ] , int n ) { int i = 0 ; int j = 0 ; int count ; int m1 = - 1 , m2 = - 1 ; for ( count = 0 ; count <= n ; count ++ ) { if ( i == n ) { m1 = m2 ; m2 = ar2 [ 0 ] ; break ; } else if ( j == n ) { m1 = m2 ; m2 = ar1 [ 0 ] ; break ; } if ( ar1 [ i ] < ar2 [ j ] ) { m1 = m2 ; m2 = ar1 [ i ] ; i ++ ; } else { m1 = m2 ; m2 = ar2 [ j ] ; j ++ ; } } return ( m1 + m2 ) / 2 ; }"
"static int findMaximumNum ( int arr [ ] , int n ) { for ( int i = n ; i >= 1 ; i -- ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( i <= arr [ j ] ) count ++ ; if ( count >= i ) return i ; } return 1 ; }"
"static void printCoins ( int arr [ ] , int n ) { int oddSum = 0 ; for ( int i = 0 ; i < n ; i += 2 ) oddSum += arr [ i ] ; int evenSum = 0 ; for ( int i = 1 ; i < n ; i += 2 ) evenSum += arr [ i ] ; int start = ( ( oddSum > evenSum ) ? 0 : 1 ) ; for ( int i = start ; i < n ; i += 2 ) System . out . print ( arr [ i ] + "" "" ) ; }"
"static int Add ( int x , int y ) { while ( y != 0 ) { int carry = x & y ; x = x ^ y ; y = carry << 1 ; } return x ; }"
"static double [ ] find_Centroid ( double v [ ] [ ] ) { double [ ] ans = new double [ 2 ] ; int n = v . length ; double signedArea = 0 ; for ( int i = 0 ; i < n ; i ++ ) { double x0 = v [ i ] [ 0 ] , y0 = v [ i ] [ 1 ] ; double x1 = v [ ( i + 1 ) % n ] [ 0 ] , y1 = v [ ( i + 1 ) % n ] [ 1 ] ; double A = ( x0 * y1 ) - ( x1 * y0 ) ; signedArea += A ; ans [ 0 ] += ( x0 + x1 ) * A ; ans [ 1 ] += ( y0 + y1 ) * A ; } signedArea *= 0.5 ; ans [ 0 ] = ( ans [ 0 ] ) / ( 6 * signedArea ) ; ans [ 1 ] = ( ans [ 1 ] ) / ( 6 * signedArea ) ; return ans ; }"
"static int maxRemoval ( int arr [ ] , int n ) { int count = 0 ; int cummulative_sum = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= cummulative_sum ) { count ++ ; cummulative_sum += arr [ i ] ; } } return count ; }"
"static double sum ( int x , int n ) { double i , total = 1.0 , multi = x ; for ( i = 1 ; i <= n ; i ++ ) { total = total + multi / i ; multi = multi * x ; } return total ; }"
static int countOnes ( int n ) { int count = 1 ; int rem = 1 ; while ( rem != 0 ) { rem = ( rem * 10 + 1 ) % n ; count ++ ; } return count ; }
"static int NthArmstrong ( int n ) { int count = 0 ; for ( int i = 1 ; i <= Integer . MAX_VALUE ; i ++ ) { int num = i , rem , digit = 0 , sum = 0 ; num = i ; digit = ( int ) Math . log10 ( num ) + 1 ; while ( num > 0 ) { rem = num % 10 ; sum = sum + ( int ) Math . pow ( rem , digit ) ; num = num / 10 ; } if ( i == sum ) count ++ ; if ( count == n ) return i ; } return n ; }"
"static float harmonicMean ( float arr [ ] , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + ( float ) 1 / arr [ i ] ; return ( float ) n / sum ; }"
"static int CntcontSubs ( int a [ ] , int n ) { int c = 0 , d = 0 , i , sum = 1 , j ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 != 0 || a [ i ] % 4 == 0 ) d ++ ; sum = a [ i ] ; for ( j = i + 1 ; j < n ; j ++ ) { sum = sum * a [ j ] ; if ( sum % 2 != 0 || sum % 4 == 0 ) c ++ ; } sum = 1 ; } return c + d ; }"
"static int maxOnesIndex ( int arr [ ] , int n ) { int max_count = 0 ; int max_index = 0 ; int prev_zero = - 1 ; int prev_prev_zero = - 1 ; for ( int curr = 0 ; curr < n ; ++ curr ) { if ( arr [ curr ] == 0 ) { if ( curr - prev_prev_zero > max_count ) { max_count = curr - prev_prev_zero ; max_index = prev_zero ; } prev_prev_zero = prev_zero ; prev_zero = curr ; } } if ( n - prev_prev_zero > max_count ) max_index = prev_zero ; return max_index ; }"
"static int turnOffK ( int n , int k ) { if ( k <= 0 ) return n ; return ( n & ~ ( 1 << ( k - 1 ) ) ) ; }"
"static void result ( int N ) { for ( int num = 0 ; num < N ; num ++ ) { if ( num % 3 == 0 && num % 5 == 0 ) System . out . print ( num + "" "" ) ; } }"
"static int findCountOfSolutions ( int n , int p ) { int ans = 0 ; for ( int x = 1 ; x < p ; x ++ ) { if ( ( x * x ) % p == 1 ) { int last = x + p * ( n / p ) ; if ( last > n ) last -= p ; ans += ( ( last - x ) / p + 1 ) ; } } return ans ; }"
"static int largestSubset ( int [ ] a , int n ) { Arrays . sort ( a ) ; int [ ] dp = new int [ n ] ; dp [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int mxm = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] % a [ i ] == 0 ) { mxm = Math . max ( mxm , dp [ j ] ) ; } } dp [ i ] = 1 + mxm ; } return Arrays . stream ( dp ) . max ( ) . getAsInt ( ) ; }"
"public static int getSum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { double sqrtCurrent = Math . sqrt ( arr [ i ] ) ; for ( int j = 0 ; j < n ; j ++ ) { double x = arr [ j ] ; if ( x == sqrtCurrent ) { sum += ( sqrtCurrent * sqrtCurrent ) ; break ; } } } return sum ; }"
"static int nDigitPalindromes ( int n ) { return ( 9 * ( int ) Math . pow ( 10 , ( n - 1 ) / 2 ) ) ; }"
"static int zigzag ( int n , int k ) { if ( n == 0 && k == 0 ) return 1 ; if ( k == 0 ) return 0 ; return zigzag ( n , k - 1 ) + zigzag ( n - 1 , n - k ) ; }"
"static boolean isSubset ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 , j = 0 ; if ( m < n ) return false ; Arrays . sort ( arr1 ) ; Arrays . sort ( arr2 ) ; while ( i < n && j < m ) { if ( arr1 [ j ] < arr2 [ i ] ) j ++ ; else if ( arr1 [ j ] == arr2 [ i ] ) { j ++ ; i ++ ; } else if ( arr1 [ j ] > arr2 [ i ] ) return false ; } if ( i < n ) return false ; else return true ; }"
"public static int minNumber ( int a [ ] , int n , int x ) { int l = 0 , h = 0 , e = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == x ) e ++ ; else if ( a [ i ] > x ) h ++ ; else if ( a [ i ] < x ) l ++ ; } int ans = 0 ; if ( l > h ) ans = l - h ; else if ( l < h ) ans = h - l - 1 ; return ans + 1 - e ; }"
"static String recursiveFun ( int n ) { if ( n == 1 ) return ""int"" ; return ""gcd(int, "" + recursiveFun ( n - 1 ) + "")"" ; }"
"static void printNonDivisible ( int [ ] A , int [ ] B , int n , int m ) { int maxB = 0 ; for ( int i = 0 ; i < m ; i ++ ) if ( B [ i ] > maxB ) maxB = B [ i ] ; int [ ] mark = new int [ maxB + 1 ] ; for ( int i = 0 ; i < maxB ; i ++ ) mark [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int x = A [ i ] ; x <= maxB ; x += A [ i ] ) mark [ x ] ++ ; for ( int i = 0 ; i < m ; i ++ ) if ( mark [ B [ i ] ] == 0 ) System . out . println ( B [ i ] ) ; }"
"static int lastKDigits ( int a [ ] , int n , int k ) { int num = ( int ) ( Math . pow ( 10 , k ) ) ; int mul = a [ 0 ] % num ; for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i ] % num ; mul = ( a [ i ] * mul ) % num ; } return mul ; }"
"static int maximumXor ( int arr [ ] , int n ) { Stack < Integer > sForward = new Stack < Integer > ( ) , sBackward = new Stack < Integer > ( ) ; int ans = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { while ( ! sForward . isEmpty ( ) && arr [ i ] < arr [ sForward . peek ( ) ] ) { ans = Math . max ( ans , arr [ i ] ^ arr [ sForward . peek ( ) ] ) ; sForward . pop ( ) ; } sForward . add ( i ) ; while ( ! sBackward . isEmpty ( ) && arr [ n - i - 1 ] < arr [ sBackward . peek ( ) ] ) { ans = Math . max ( ans , arr [ n - i - 1 ] ^ arr [ sBackward . peek ( ) ] ) ; sBackward . pop ( ) ; } sBackward . add ( n - i - 1 ) ; } return ans ; }"
"static double increaseInVol ( double l , double b , double h ) { double percentInc = ( 1 + ( l / 100 ) ) * ( 1 + ( b / 100 ) ) * ( 1 + ( h / 100 ) ) ; percentInc -= 1 ; percentInc *= 100 ; return percentInc ; }"
"static int minCost ( int N , int P , int Q ) { int cost = 0 ; while ( N > 0 ) { if ( ( N & 1 ) > 0 ) { cost += P ; N -- ; } else { int temp = N / 2 ; if ( temp * P > Q ) cost += Q ; else cost += P * temp ; N /= 2 ; } } return cost ; }"
"static int count_element ( int N , int K , int [ ] arr ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; ++ i ) if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } int answer = 0 ; for ( Map . Entry < Integer , Integer > i : mp . entrySet ( ) ) { if ( mp . containsKey ( i . getKey ( ) + K ) ) answer += i . getValue ( ) ; } return answer ; }"
"static int distinctCount ( int arr [ ] , int n ) { int count = n ; int i = 0 , j = n - 1 , sum = 0 ; while ( i < j ) { while ( i != j && arr [ i ] == arr [ i + 1 ] ) { count -- ; i ++ ; } while ( i != j && arr [ j ] == arr [ j - 1 ] ) { count -- ; j -- ; } if ( i == j ) break ; sum = arr [ i ] + arr [ j ] ; if ( sum == 0 ) { count -- ; i ++ ; j -- ; } else if ( sum < 0 ) i ++ ; else j -- ; } return count ; }"
static int countUnsetBits ( int n ) { int cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int temp = i ; while ( temp > 0 ) { if ( temp % 2 == 0 ) { cnt = cnt + 1 ; } temp = temp / 2 ; } } return cnt ; }
"static void findNumbers ( int n , int b ) { double even = 0 , odd = 0 ; if ( b % 2 == 0 ) { even = Math . pow ( b , n ) - 2 ; odd = Math . pow ( b , n ) - 1 ; } else { even = Math . pow ( b , n ) - 1 ; odd = Math . pow ( b , n ) - 2 ; } System . out . println ( ""Even Number = "" + ( int ) even ) ; System . out . print ( ""Odd Number = "" + ( int ) odd ) ; }"
"static int countRotations ( int arr [ ] , int n ) { int min = arr [ 0 ] , min_index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( min > arr [ i ] ) { min = arr [ i ] ; min_index = i ; } } return min_index ; }"
static int countNumbers ( int n ) { return n - n / 2 - n / 3 - n / 5 - n / 7 + n / 6 + n / 10 + n / 14 + n / 15 + n / 21 + n / 35 - n / 30 - n / 42 - n / 70 - n / 105 + n / 210 ; }
"static int MaxTotalRectangleArea ( int [ ] a , int n ) { Arrays . sort ( a ) ; int sum = 0 ; boolean flag = false ; int len = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && ! flag ) { flag = true ; len = a [ i + 1 ] ; i ++ ; } else if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && ( flag ) ) { sum = sum + a [ i + 1 ] * len ; flag = false ; i ++ ; } } return sum ; }"
public static int findMaxValue ( ) { int res = 2 ; long fact = 2 ; while ( true ) { if ( fact < 0 ) break ; res ++ ; fact = fact * res ; } return res - 1 ; }
static int findNthEvenDigitNumber ( int n ) { int count = 0 ; for ( int i = 0 ; ; i ++ ) { int curr = i ; boolean isCurrEvenDigit = true ; while ( curr != 0 ) { if ( curr % 10 == 1 || curr % 10 == 3 || curr % 10 == 5 || curr % 10 == 7 || curr % 10 == 9 ) isCurrEvenDigit = false ; curr = curr / 10 ; } if ( isCurrEvenDigit == true ) count ++ ; if ( count == n ) return i ; } }
static int Triplets ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = i ; j <= n ; ++ j ) { int x = i * i + j * j ; int y = ( int ) Math . sqrt ( x ) ; if ( y * y == x && y <= n ) ++ ans ; } } return ans ; }
"static boolean doesContainB ( int a , int b , int c ) { if ( a == b ) { return true ; } if ( ( b - a ) * c > 0 && ( b - a ) % c == 0 ) { return true ; } return false ; }"
"static void mySort ( Integer [ ] arr ) { int n = arr . length ; Arrays . sort ( arr , 0 , n / 2 ) ; Arrays . sort ( arr , n / 2 , n ) ; int low = n / 2 , high = n - 1 ; while ( low < high ) { Integer temp = arr [ low ] ; arr [ low ] = arr [ high ] ; arr [ high ] = temp ; low ++ ; high -- ; } }"
"static int nthTerm ( int n ) { return 2 * ( int ) Math . pow ( n , 2 ) + n - 3 ; }"
static int sumOfSeries ( int n ) { return ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 ; }
"static boolean check ( int arr [ ] , int N , int K ) { HashSet < Integer > unique = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) unique . add ( arr [ i ] ) ; if ( unique . size ( ) == K ) return true ; return false ; }"
"static int CountAllPairs ( int N , int K ) { int count = 0 ; if ( N > K ) { count = N - K ; for ( int i = K + 1 ; i <= N ; i ++ ) count = count + ( ( N - K ) / i ) ; } return count ; }"
"public static int findNumbers ( int N ) { ArrayList < Integer > v = new ArrayList < Integer > ( ) ; while ( N > 0 ) { int n = N , m = 0 , p = 1 ; while ( n > 0 ) { if ( n % 10 != 0 ) m += p ; n /= 10 ; p *= 10 ; } v . add ( m ) ; N -= m ; } for ( int i = 0 ; i < v . size ( ) ; i ++ ) System . out . print ( "" "" + v . get ( i ) ) ; return 0 ; }"
"static int getRemainder ( int num , int divisor ) { while ( num >= divisor ) num -= divisor ; return num ; }"
static int largestCoprime ( int N ) { if ( N == 6 ) return 1 ; else if ( N % 4 == 0 ) return ( N / 2 ) - 1 ; else if ( N % 2 == 0 ) return ( N / 2 ) - 2 ; else return ( ( N - 1 ) / 2 ) ; }
"static void query ( String s , int i , int j ) { int n = s . length ( ) ; i %= n ; j %= n ; if ( s . charAt ( i ) == s . charAt ( j ) ) System . out . println ( ""Yes"" ) ; else System . out . println ( ""No"" ) ; }"
"static void printPair ( int g , int l ) { System . out . print ( g + "" "" + l ) ; }"
"static void difference ( int arr [ ] , int n ) { int largest = arr [ 0 ] ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( largest < arr [ i ] ) largest = arr [ i ] ; } for ( i = 0 ; i < n ; i ++ ) arr [ i ] = largest - arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + "" "" ) ; }"
"static int FindMinNum ( int arr [ ] , int n ) { int pre [ ] = new int [ n ] ; pre [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) pre [ i ] = pre [ i - 1 ] + arr [ i ] ; int k = Integer . MAX_VALUE ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int rightSum = pre [ n - 1 ] - pre [ i ] ; if ( rightSum >= pre [ i ] ) k = Math . min ( k , rightSum - pre [ i ] ) ; } if ( k != Integer . MAX_VALUE ) return k ; return - 1 ; }"
"static int sumDivisibles ( int A , int B , int M ) { int sum = 0 ; for ( int i = A ; i <= B ; i ++ ) if ( i % M == 0 ) sum += i ; return sum ; }"
static int countCoins ( int n ) { int c = 0 ; if ( n < 10 ) { return n ; } if ( n > 9 && n < 25 ) { c = n / 10 + n % 10 ; return c ; } if ( n > 24 ) { c = n / 25 ; if ( n % 25 < 10 ) { c = c + n % 25 ; return c ; } if ( n % 25 > 9 ) { c = c + ( n % 25 ) / 10 + ( n % 25 ) % 10 ; return c ; } } return c ; }
"static int getRemainder ( int num , int divisor ) { if ( divisor == 0 ) { System . out . println ( ""Error: divisor "" + ""can't be zero \n"" ) ; return - 1 ; } if ( divisor < 0 ) divisor = - divisor ; if ( num < 0 ) num = - num ; int i = 1 ; int product = 0 ; while ( product <= num ) { product = divisor * i ; i ++ ; } return num - ( product - divisor ) ; }"
"static void checkTypeOfTriangle ( int a , int b , int c ) { int sqa = ( int ) Math . pow ( a , 2 ) ; int sqb = ( int ) Math . pow ( b , 2 ) ; int sqc = ( int ) Math . pow ( c , 2 ) ; if ( sqa == sqa + sqb || sqb == sqa + sqc || sqc == sqa + sqb ) { System . out . print ( ""Right-angled Triangle"" ) ; } else if ( sqa > sqc + sqb || sqb > sqa + sqc || sqc > sqa + sqb ) { System . out . print ( ""Obtuse-angled Triangle"" ) ; } else { System . out . print ( ""Acute-angled Triangle"" ) ; } }"
"static boolean canBeEqual ( char [ ] a , char [ ] b , int n ) { Vector < Character > A = new Vector < > ( ) ; Vector < Character > B = new Vector < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] != b [ i ] ) { A . add ( a [ i ] ) ; B . add ( b [ i ] ) ; } } if ( A . size ( ) == B . size ( ) && B . size ( ) == 0 ) return true ; if ( A . size ( ) == B . size ( ) && B . size ( ) == 2 ) { if ( A . get ( 0 ) == A . get ( 1 ) && B . get ( 0 ) == B . get ( 1 ) ) return true ; } return false ; }"
"static int maximumFixedPoints ( int a [ ] , int n ) { int i , count = 0 , swapped = 0 ; int pos [ ] = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) pos [ a [ i ] ] = i ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] == i ) count ++ ; else if ( swapped == 0 && pos [ i ] == a [ i ] ) { count += 2 ; swapped = 1 ; } } if ( swapped == 0 && count < n - 1 ) count ++ ; return count ; }"
"static int countPattern ( int n , String pat ) { int pattern_int = 0 ; int power_two = 1 ; int all_ones = 0 ; for ( int i = pat . length ( ) - 1 ; i >= 0 ; i -- ) { int current_bit = pat . charAt ( i ) - '0' ; pattern_int += ( power_two * current_bit ) ; all_ones = all_ones + power_two ; power_two = power_two * 2 ; } int count = 0 ; while ( n != 0 && n >= pattern_int ) { if ( ( n & all_ones ) == pattern_int ) { count ++ ; } n = n >> 1 ; } return count ; }"
"static int sumEqualProduct ( int a [ ] , int n ) { int zero = 0 , two = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { zero ++ ; } if ( a [ i ] == 2 ) { two ++ ; } } int cnt = ( zero * ( zero - 1 ) ) / 2 + ( two * ( two - 1 ) ) / 2 ; return cnt ; }"
"static String replace ( String s , char c1 , char c2 ) { int l = s . length ( ) ; char [ ] arr = s . toCharArray ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( arr [ i ] == c1 ) arr [ i ] = c2 ; else if ( arr [ i ] == c2 ) arr [ i ] = c1 ; } return String . valueOf ( arr ) ; }"
"static void printXYZ ( int n ) { if ( n == 1 ) System . out . println ( - 1 ) ; else { System . out . println ( ""x is "" + n ) ; System . out . println ( ""y is "" + ( n + 1 ) ) ; System . out . println ( ""z is "" + ( n * ( n + 1 ) ) ) ; } }"
public static long minPerimeter ( int n ) { int l = ( int ) Math . sqrt ( n ) ; int sq = l * l ; if ( sq == n ) return l * 4 ; else { long row = n / l ; long perimeter = 2 * ( l + row ) ; if ( n % l != 0 ) perimeter += 2 ; return perimeter ; } }
"static int nth_group ( int n ) { return n * ( 2 * ( int ) Math . pow ( n , 2 ) + 1 ) ; }"
"static boolean bitsAreInAltPatrnInGivenTRange ( int n , int l , int r ) { int num , prev , curr ; num = n >> ( l - 1 ) ; prev = num & 1 ; num = num >> 1 ; for ( int i = 1 ; i <= ( r - l ) ; i ++ ) { curr = num & 1 ; if ( curr == prev ) return false ; prev = curr ; num = num >> 1 ; } return true ; }"
static int sumofseries ( int n ) { int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) res += ( i ) * ( i + 1 ) * ( i + 2 ) ; return res ; }
"static int getTotalXorOfSubarrayXors ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int freq = ( i + 1 ) * ( N - i ) ; if ( freq % 2 == 1 ) res = res ^ arr [ i ] ; } return res ; }"
"static float Area ( float a , float b ) { if ( a < 0 && b < 0 ) return - 1 ; float h = ( float ) Math . sqrt ( ( ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) / ( Math . pow ( a , 2 ) * Math . pow ( b , 2 ) ) ) ) ; float A = ( float ) ( 0.70477 * Math . pow ( h , 2 ) ) ; return A ; }"
static int nonDecNums ( int n ) { int [ ] [ ] a = new int [ n + 1 ] [ 10 ] ; for ( int i = 0 ; i <= 9 ; i ++ ) a [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) a [ i ] [ 9 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 8 ; j >= 0 ; j -- ) a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] ; return a [ n ] [ 0 ] ; }
"static int isSubstring ( String s1 , String s2 ) { int M = s1 . length ( ) ; int N = s2 . length ( ) ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( s2 . charAt ( i + j ) != s1 . charAt ( j ) ) break ; if ( j == M ) return i ; } return - 1 ; }"
"static void printArray ( int N , int SUM , int K ) { int minSum = ( N * ( N + 1 ) ) / 2 ; int maxSum = ( N * K ) - ( N * ( N - 1 ) ) / 2 ; if ( minSum > SUM || maxSum < SUM ) { System . out . println ( ""Not Possible"" ) ; return ; } int arr [ ] = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) arr [ i ] = i ; int sum = minSum ; for ( int i = N ; i >= 1 ; i -- ) { int x = sum + ( K - i ) ; if ( x < SUM ) { sum = sum + ( K - i ) ; arr [ i ] = K ; K -- ; } else { arr [ i ] += ( SUM - sum ) ; sum = SUM ; break ; } } for ( int i = 1 ; i <= N ; i ++ ) System . out . print ( arr [ i ] + "" "" ) ; }"
"public static boolean checkcircle ( int r , int R , int r1 , int x1 , int y1 ) { int dis = ( int ) Math . sqrt ( x1 * x1 + y1 * y1 ) ; return ( dis - r1 >= R && dis + r1 <= r ) ; }"
"static void recaman ( int n ) { if ( n <= 0 ) return ; System . out . printf ( ""%d, "" , 0 ) ; HashSet < Integer > s = new HashSet < Integer > ( ) ; s . add ( 0 ) ; int prev = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int curr = prev - i ; if ( curr < 0 || s . contains ( curr ) ) curr = prev + i ; s . add ( curr ) ; System . out . printf ( ""%d, "" , curr ) ; prev = curr ; } }"
"static void subsequence ( char s [ ] , char t [ ] , int n , int k ) { int last = 0 , cnt = 0 , new_last = 0 , size = 0 ; for ( char ch = 'z' ; ch >= 'a' ; ch -- ) { cnt = 0 ; for ( int i = last ; i < n ; i ++ ) { if ( s [ i ] == ch ) cnt ++ ; } if ( cnt >= k ) { for ( int i = last ; i < n ; i ++ ) { if ( s [ i ] == ch ) { t [ size ++ ] = ch ; new_last = i ; } } last = new_last ; } } t [ size ] = '\0' ; }"
"static void longestString ( String str1 , String str2 ) { int count1 [ ] = new int [ 26 ] , count2 [ ] = new int [ 26 ] ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { count1 [ str1 . charAt ( i ) - 'a' ] ++ ; } for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) { count2 [ str2 . charAt ( i ) - 'a' ] ++ ; } String result = """" ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 1 ; j <= Math . min ( count1 [ i ] , count2 [ i ] ) ; j ++ ) { result += ( char ) ( 'a' + i ) ; } } System . out . println ( result ) ; }"
"static int countSquares ( int m , int n ) { if ( n < m ) { int temp = m ; m = n ; n = temp ; } return n * ( n + 1 ) * ( 3 * m - n + 1 ) / 6 ; }"
"void productArray ( int arr [ ] , int n ) { if ( n == 1 ) { System . out . print ( 0 ) ; return ; } int left [ ] = new int [ n ] ; int right [ ] = new int [ n ] ; int prod [ ] = new int [ n ] ; int i , j ; left [ 0 ] = 1 ; right [ n - 1 ] = 1 ; for ( i = 1 ; i < n ; i ++ ) left [ i ] = arr [ i - 1 ] * left [ i - 1 ] ; for ( j = n - 2 ; j >= 0 ; j -- ) right [ j ] = arr [ j + 1 ] * right [ j + 1 ] ; for ( i = 0 ; i < n ; i ++ ) prod [ i ] = left [ i ] * right [ i ] ; for ( i = 0 ; i < n ; i ++ ) System . out . print ( prod [ i ] + "" "" ) ; return ; }"
"static int gcd ( int a , int b ) { return ( b == 0 ) ? a : gcd ( b , a % b ) ; }"
"static int subarrayCount ( int arr [ ] , int n ) { int result = 0 ; int fast = 0 , slow = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] == 1 ) { fast ++ ; } else { int len = fast - slow + 1 ; result += len * ( len - 1 ) / 2 ; fast = i ; slow = i ; } } if ( fast != slow ) { int len = fast - slow + 1 ; result += len * ( len - 1 ) / 2 ; } return result ; }"
"static int maxRowDiff ( int mat [ ] [ ] , int m , int n ) { int rowSum [ ] = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) sum += mat [ i ] [ j ] ; rowSum [ i ] = sum ; } int max_diff = rowSum [ 1 ] - rowSum [ 0 ] ; int min_element = rowSum [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) { if ( rowSum [ i ] - min_element > max_diff ) max_diff = rowSum [ i ] - min_element ; if ( rowSum [ i ] < min_element ) min_element = rowSum [ i ] ; } return max_diff ; }"
static int swapBits ( int x ) { int even_bits = x & 0xAAAAAAAA ; int odd_bits = x & 0x55555555 ; even_bits >>= 1 ; odd_bits <<= 1 ; return ( even_bits | odd_bits ) ; }
"static int countOcc ( String s ) { int cnt = 0 ; for ( int i = 0 ; i < s . length ( ) - 3 ; i ++ ) { int c = 0 , l = 0 , a = 0 , p = 0 ; for ( int j = i ; j < i + 4 ; j ++ ) { switch ( s . charAt ( j ) ) { case 'c' : c ++ ; break ; case 'l' : l ++ ; break ; case 'a' : a ++ ; break ; case 'p' : p ++ ; break ; } } if ( c == 1 && l == 1 && a == 1 && p == 1 ) cnt ++ ; } return cnt ; }"
"private static boolean isValidString ( String str , int n ) { int index = str . indexOf ( ""b"" ) ; if ( index == 0 ) return false ; while ( index != - 1 ) { if ( str . charAt ( index - 1 ) != 'a' ) return false ; if ( index + 1 < n && str . charAt ( index + 1 ) != 'b' ) return false ; if ( index + 2 < n && str . charAt ( index + 2 ) == 'b' ) return false ; if ( index == n - 1 ) return false ; index = str . indexOf ( ""b"" , index + 2 ) ; } return true ; }"
"static int countInRange ( int arr [ ] , int n , int x , int y ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= x && arr [ i ] <= y ) count ++ ; } return count ; }"
"static int longest_substring ( String s , int k ) { int n = s . length ( ) ; if ( k > 1 ) { s += s ; n *= 2 ; } int ans = 0 ; int i = 0 ; while ( i < n ) { int x = 0 ; while ( i < n && s . charAt ( i ) == '0' ) { x ++ ; i ++ ; } ans = Math . max ( ans , x ) ; i ++ ; } if ( k == 1 || ans != n ) return ans ; else return ( ans / 2 ) * k ; }"
"static void bresenham ( int x1 , int y1 , int x2 , int y2 ) { int m_new = 2 * ( y2 - y1 ) ; int slope_error_new = m_new - ( x2 - x1 ) ; for ( int x = x1 , y = y1 ; x <= x2 ; x ++ ) { System . out . print ( ""("" + x + "","" + y + "")\n"" ) ; slope_error_new += m_new ; if ( slope_error_new >= 0 ) { y ++ ; slope_error_new -= 2 * ( x2 - x1 ) ; } } }"
"public static int countTotalDistinct ( String str ) { int cnt = 0 ; HashSet < String > items = new HashSet < > ( ) ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { String temp = """" ; HashSet < Character > ans = new HashSet < > ( ) ; for ( int j = i ; j < str . length ( ) ; ++ j ) { temp = temp + str . charAt ( j ) ; ans . add ( str . charAt ( j ) ) ; if ( ! items . contains ( temp ) ) { items . add ( temp ) ; cnt += ans . size ( ) ; } } } return cnt ; }"
static int maxGameByWinner ( int N ) { int [ ] dp = new int [ N ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 2 ; int i = 2 ; do { dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; } while ( dp [ i ++ ] <= N ) ; return ( i - 2 ) ; }
static int Centered_Trigunal_num ( int n ) { return ( 3 * n * n + 3 * n + 2 ) / 2 ; }
"int findSmallest ( int arr [ ] , int n ) { int res = 1 ; for ( int i = 0 ; i < n && arr [ i ] <= res ; i ++ ) res = res + arr [ i ] ; return res ; }"
"static boolean multipleOfThree ( int K , int dig0 , int dig1 ) { long sum = 0 ; int temp = ( dig0 + dig1 ) % 10 ; sum = dig0 + dig1 ; if ( K == 2 ) { if ( sum % 3 == 0 ) return true ; else return false ; } sum += temp ; long numberofGroups = ( K - 3 ) / 4 ; int remNumberofDigits = ( K - 3 ) % 4 ; sum += ( numberofGroups * 20 ) ; for ( int i = 0 ; i < remNumberofDigits ; i ++ ) { temp = ( 2 * temp ) % 10 ; sum += temp ; } if ( sum % 3 == 0 ) return true ; else return false ; }"
"static int findMaxNum ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int num = arr [ 0 ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { num = num * 10 + arr [ i ] ; } return num ; }"
"static int kth ( int arr1 [ ] , int arr2 [ ] , int m , int n , int k ) { int [ ] sorted1 = new int [ m + n ] ; int i = 0 , j = 0 , d = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; else sorted1 [ d ++ ] = arr2 [ j ++ ] ; } while ( i < m ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; while ( j < n ) sorted1 [ d ++ ] = arr2 [ j ++ ] ; return sorted1 [ k - 1 ] ; }"
"static int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = a [ 0 ] ; int curr_max = a [ 0 ] ; for ( int i = 1 ; i < size ; i ++ ) { curr_max = Math . max ( a [ i ] , curr_max + a [ i ] ) ; max_so_far = Math . max ( max_so_far , curr_max ) ; } return max_so_far ; }"
"static void farey ( int n ) { double x1 = 0 , y1 = 1 , x2 = 1 , y2 = n ; System . out . printf ( ""%.0f/%.0f %.0f/%.0f"" , x1 , y1 , x2 , y2 ) ; double x , y = 0 ; while ( y != 1.0 ) { x = Math . floor ( ( y1 + n ) / y2 ) * x2 - x1 ; y = Math . floor ( ( y1 + n ) / y2 ) * y2 - y1 ; System . out . printf ( "" %.0f/%.0f"" , x , y ) ; x1 = x2 ; x2 = x ; y1 = y2 ; y2 = y ; } }"
"static int findEqualPoint ( int arr [ ] , int n ) { int distArr [ ] = new int [ n ] ; int i = 0 , di = 0 ; while ( i < n ) { distArr [ di ++ ] = i ++ ; while ( i < n && arr [ i ] == arr [ i - 1 ] ) i ++ ; } return ( di & 1 ) != 0 ? distArr [ di >> 1 ] : - 1 ; }"
"static void printString ( char [ ] str , int n ) { int ones = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( str [ i ] == '1' ) ones ++ ; boolean used = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '2' && ! used ) { used = true ; for ( int j = 0 ; j < ones ; j ++ ) System . out . print ( ""1"" ) ; } if ( str [ i ] != '1' ) System . out . print ( str [ i ] ) ; } if ( ! used ) for ( int j = 0 ; j < ones ; j ++ ) System . out . print ( ""1"" ) ; }"
"static void shortestLength ( int n , int x [ ] , int y [ ] ) { int answer = 0 ; int i = 0 ; while ( n != 0 && i < x . length ) { if ( x [ i ] + y [ i ] > answer ) answer = x [ i ] + y [ i ] ; i ++ ; } System . out . println ( ""Length -> "" + answer ) ; System . out . println ( ""Path -> "" + ""( 1, "" + answer + "" )"" + ""and ( "" + answer + "", 1 )"" ) ; }"
"private static void solve ( int [ ] [ ] arr , int [ ] r , int [ ] c , int n , int m ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( r [ i ] == 0 && c [ j ] == 0 ) { count ++ ; r [ i ] = 1 ; c [ j ] = 1 ; } } } System . out . println ( count % 2 == 0 ? ""Vivek"" : ""Ashish"" ) ; }"
"static int maxProduct ( int a [ ] , int n ) { int [ ] product = new int [ n ] ; int maxA [ ] = new int [ n ] ; int maxProd = 0 ; int maxArr = 0 ; for ( int i = 0 ; i < n ; i ++ ) { product [ i ] = a [ ( i + 1 ) % n ] * a [ ( i + ( n - 1 ) ) % n ] ; if ( maxProd < product [ i ] ) { maxProd = product [ i ] ; } } return maxProd ; }"
"static float sph ( float r , float R , float h ) { if ( r < 0 && R < 0 && h < 0 ) return - 1 ; float x = r ; float V = ( float ) ( 4 * 3.14f * Math . pow ( r , 3 ) ) / 3 ; return V ; }"
static int nextPowerOf2 ( int n ) { n -- ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n ++ ; return n ; }
"static void findSubArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( Math . abs ( arr [ i ] - arr [ i + 1 ] ) >= 2 ) { System . out . print ( arr [ i ] + "" "" + arr [ i + 1 ] ) ; return ; } } System . out . print ( - 1 ) ; }"
public static int logicOfSequence ( int N ) { if ( N % 2 == 0 ) N = N * N ; else N = N * N * N ; return N ; }
"static int maxCount ( int A [ ] , int N , int K ) { int maximum = 0 ; int i = 0 , j = 0 ; int start = 0 ; int end = 0 ; Arrays . sort ( A ) ; for ( i = 0 ; i < N ; i ++ ) { while ( j < N && A [ j ] <= A [ i ] + K ) j ++ ; if ( maximum < ( j - i ) ) { maximum = ( j - i ) ; start = i ; end = j ; } } return maximum ; }"
static boolean check ( String s ) { int [ ] freq = new int [ 26 ] ; int n = s . length ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { freq [ ( s . charAt ( i ) ) - 97 ] += 1 ; } for ( int i = 0 ; i < freq . length ; i ++ ) { if ( freq [ i ] % 2 == 1 ) { return false ; } } return true ; }
"static void result ( String s , int n ) { HashSet < String > st = new HashSet < String > ( ) ; for ( int i = 0 ; i < ( int ) s . length ( ) ; i ++ ) { String ans = """" ; for ( int j = i ; j < ( int ) s . length ( ) ; j ++ ) { ans += s . charAt ( j ) ; if ( ans . length ( ) == n ) { st . add ( ans ) ; break ; } } } for ( String it : st ) System . out . print ( it + "" "" ) ; }"
"static void solve ( int A , int B ) { int count = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( ( A >> i ) & 1 ) != ( ( B >> i ) & 1 ) ) { count ++ ; } } System . out . println ( ""Number of different bits : "" + count ) ; }"
static int numberOfSolutions ( int n ) { int c = 0 ; for ( int x = 0 ; x <= n ; ++ x ) if ( n == x + ( n ^ x ) ) ++ c ; return c ; }
"static void findNums ( int arr [ ] , int n ) { int S = 0 , X = 0 ; for ( int i = 0 ; i < n ; i ++ ) { S += arr [ i ] ; X ^= arr [ i ] ; } System . out . println ( X + "" "" + ( X + S ) ) ; }"
"static long ProdOfPrimes ( int n ) { boolean prime [ ] = new boolean [ n + 1 ] ; Arrays . fill ( prime , true ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } long prod = 1 ; for ( int i = 2 ; i <= n ; i ++ ) if ( prime [ i ] ) prod *= i ; return prod ; }"
"static boolean possibleToReach ( int a , int b ) { int c = ( int ) Math . cbrt ( a * b ) ; int re1 = a / c ; int re2 = b / c ; if ( ( re1 * re1 * re2 == a ) && ( re2 * re2 * re1 == b ) ) return true ; else return false ; }"
"void printRepeating ( int arr [ ] , int size ) { int i , j ; System . out . println ( ""Repeated Elements are :"" ) ; for ( i = 0 ; i < size ; i ++ ) { for ( j = i + 1 ; j < size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) System . out . print ( arr [ i ] + "" "" ) ; } } }"
"static void divide ( int a , int b ) { for ( int i = 2 ; i <= Math . min ( a , b ) ; i ++ ) { while ( a % i == 0 && b % i == 0 ) { a = a / i ; b = b / i ; } } System . out . println ( ""A = "" + a + "", B = "" + b ) ; }"
"static void printOrder ( int [ ] arr , int n , int k ) { int len1 = k , len2 = n - k ; int [ ] arr1 = new int [ k ] ; int [ ] arr2 = new int [ n - k ] ; for ( int i = 0 ; i < k ; i ++ ) arr1 [ i ] = arr [ i ] ; for ( int i = k ; i < n ; i ++ ) arr2 [ i - k ] = arr [ i ] ; Arrays . sort ( arr1 , 0 , k ) ; Arrays . sort ( arr2 , k , n - k ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < k ) arr [ i ] = arr1 [ i ] ; else { arr [ i ] = arr2 [ len2 - 1 ] ; len2 -- ; } } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + "" "" ) ; } }"
static boolean isRectangle ( int m [ ] [ ] ) { int rows = m . length ; if ( rows == 0 ) return false ; int columns = m [ 0 ] . length ; for ( int y1 = 0 ; y1 < rows ; y1 ++ ) for ( int x1 = 0 ; x1 < columns ; x1 ++ ) if ( m [ y1 ] [ x1 ] == 1 ) for ( int y2 = y1 + 1 ; y2 < rows ; y2 ++ ) for ( int x2 = x1 + 1 ; x2 < columns ; x2 ++ ) if ( m [ y1 ] [ x2 ] == 1 && m [ y2 ] [ x1 ] == 1 && m [ y2 ] [ x2 ] == 1 ) return true ; return false ; }
"static void printNumberWithDR ( int k , int d ) { if ( d == 0 && k != 1 ) System . out . print ( ""-1"" ) ; else { System . out . print ( d ) ; k -- ; while ( k -- > 0 ) System . out . print ( ""0"" ) ; } }"
"static int countGreater ( int arr [ ] , int n , int k ) { int l = 0 ; int r = n - 1 ; int leftGreater = n ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( arr [ m ] > k ) { leftGreater = m ; r = m - 1 ; } else l = m + 1 ; } return ( n - leftGreater ) ; }"
"static int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; int radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return - 1 ; else return 0 ; }"
"static int findMin ( int arr [ ] , int n ) { int m = 0 ; for ( int i = 0 ; i < n ; i ++ ) m = Math . max ( m , arr [ i ] ) ; int cnt [ ] = new int [ m + 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 1 ; j * j <= arr [ i ] ; j ++ ) { if ( arr [ i ] % j == 0 ) { if ( j * j == arr [ i ] ) cnt [ j ] ++ ; else { cnt [ j ] ++ ; cnt [ arr [ i ] / j ] ++ ; } } } } for ( int i = 1 ; i <= m + 1 ; i ++ ) if ( cnt [ i ] == 0 ) { return i ; } return - 1 ; }"
"static float Area ( float a ) { if ( a < 0 ) return - 1 ; float x = 0.464f * a ; float A = 0.70477f * ( float ) Math . pow ( x , 2 ) ; return A ; }"
"static void modularEquation ( int a , int b ) { if ( a < b ) { System . out . println ( ""No solution possible "" ) ; return ; } if ( a == b ) { System . out . println ( ""Infinite Solution possible "" ) ; return ; } int count = 0 ; int n = a - b ; int y = ( int ) Math . sqrt ( a - b ) ; for ( int i = 1 ; i <= y ; ++ i ) { if ( n % i == 0 ) { if ( n / i > b ) count ++ ; if ( i > b ) count ++ ; } } if ( y * y == n && y > b ) count -- ; System . out . println ( count ) ; }"
public static int numberOfTriangles ( int n ) { int [ ] answer = new int [ n + 1 ] ; answer [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) answer [ i ] = answer [ i - 1 ] * 3 + 2 ; return answer [ n ] ; }
"static void printMinIndexChar ( String str , String patt ) { int minIndex = Integer . MAX_VALUE ; int m = str . length ( ) ; int n = patt . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( patt . charAt ( i ) == str . charAt ( j ) && j < minIndex ) { minIndex = j ; break ; } } } if ( minIndex != Integer . MAX_VALUE ) System . out . println ( ""Minimum Index Character = "" + str . charAt ( minIndex ) ) ; else System . out . println ( ""No character present"" ) ; }"
"public static void rearrange ( int [ ] arr ) { if ( arr == null || arr . length % 2 == 1 ) return ; int currIdx = ( arr . length - 1 ) / 2 ; while ( currIdx > 0 ) { int count = currIdx , swapIdx = currIdx ; while ( count -- > 0 ) { int temp = arr [ swapIdx + 1 ] ; arr [ swapIdx + 1 ] = arr [ swapIdx ] ; arr [ swapIdx ] = temp ; swapIdx ++ ; } currIdx -- ; } }"
static void sortString ( String str ) { char [ ] arr = str . toCharArray ( ) ; Arrays . sort ( arr ) ; System . out . print ( String . valueOf ( arr ) ) ; }
"static int magicIndex ( int arr [ ] , int start , int end ) { if ( start > end ) return - 1 ; int midIndex = ( start + end ) / 2 ; int midValue = arr [ midIndex ] ; if ( midIndex == midValue ) return midIndex ; int left = magicIndex ( arr , start , Math . min ( midValue , midIndex - 1 ) ) ; if ( left >= 0 ) return left ; return magicIndex ( arr , Math . max ( midValue , midIndex + 1 ) , end ) ; }"
"static void minRange ( int arr [ ] , int n , int k ) { int l = 0 , r = n ; for ( int i = 0 ; i < n ; i ++ ) { Set < Integer > s = new HashSet < Integer > ( ) ; int j ; for ( j = i ; j < n ; j ++ ) { s . add ( arr [ j ] ) ; if ( s . size ( ) == k ) { if ( ( j - i ) < ( r - l ) ) { r = j ; l = i ; } break ; } } if ( j == n ) break ; } if ( l == 0 && r == n ) System . out . println ( ""Invalid k"" ) ; else System . out . println ( l + "" "" + r ) ; }"
"static int find_maximum ( int a [ ] , int n , int k ) { HashMap < Integer , Integer > b = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; int d = Math . min ( 1 + i , n - i ) ; if ( ! b . containsKey ( x ) ) b . put ( x , d ) ; else { b . put ( x , Math . min ( d , b . get ( x ) ) ) ; } } int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; if ( x != k - x && b . containsKey ( k - x ) ) ans = Math . min ( Math . max ( b . get ( x ) , b . get ( k - x ) ) , ans ) ; } return ans ; }"
"static int countOp ( int arr [ ] , int n , int k ) { int operations = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( Math . abs ( arr [ i ] - arr [ i - 1 ] ) > k ) { int absDiff = Math . abs ( arr [ i ] - arr [ i - 1 ] ) ; int currOp = absDiff - k ; if ( arr [ i ] < arr [ i - 1 ] ) arr [ i ] += currOp ; else arr [ i ] -= currOp ; operations += currOp ; } } return operations ; }"
"static void NextFit ( int blockSize [ ] , int m , int processSize [ ] , int n ) { int allocation [ ] = new int [ n ] , j = 0 ; Arrays . fill ( allocation , - 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < m ) { if ( blockSize [ j ] >= processSize [ i ] ) { allocation [ i ] = j ; blockSize [ j ] -= processSize [ i ] ; break ; } j = ( j + 1 ) % m ; } } System . out . print ( ""\nProcess No.\tProcess Size\tBlock no.\n"" ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( i + 1 + ""\t\t"" + processSize [ i ] + ""\t\t"" ) ; if ( allocation [ i ] != - 1 ) { System . out . print ( allocation [ i ] + 1 ) ; } else { System . out . print ( ""Not Allocated"" ) ; } System . out . println ( """" ) ; } }"
"static String nextGreater ( String num ) { int l = num . length ( ) ; int i ; for ( i = l - 1 ; i >= 0 ; i -- ) { if ( num . charAt ( i ) == '0' ) { num = num . substring ( 0 , i ) + '1' + num . substring ( i + 1 ) ; break ; } else { num = num . substring ( 0 , i ) + '0' + num . substring ( i + 1 ) ; } } if ( i < 0 ) { num = ""1"" + num ; } return num ; }"
static boolean pairWiseConsecutive ( Stack < Integer > s ) { Stack < Integer > aux = new Stack < Integer > ( ) ; while ( ! s . isEmpty ( ) ) { aux . push ( s . peek ( ) ) ; s . pop ( ) ; } boolean result = true ; while ( aux . size ( ) > 1 ) { int x = aux . peek ( ) ; aux . pop ( ) ; int y = aux . peek ( ) ; aux . pop ( ) ; if ( Math . abs ( x - y ) != 1 ) result = false ; s . push ( x ) ; s . push ( y ) ; } if ( aux . size ( ) == 1 ) s . push ( aux . peek ( ) ) ; return result ; }
static int Sum ( int N ) { int SumOfPrimeDivisors [ ] = new int [ N + 1 ] ; for ( int i = 2 ; i <= N ; ++ i ) { if ( SumOfPrimeDivisors [ i ] == 0 ) { for ( int j = i ; j <= N ; j += i ) { SumOfPrimeDivisors [ j ] += i ; } } } return SumOfPrimeDivisors [ N ] ; }
"static int findMinDiff ( int arr [ ] , int n , int m ) { if ( m == 0 || n == 0 ) return 0 ; Arrays . sort ( arr ) ; if ( n < m ) return - 1 ; int min_diff = Integer . MAX_VALUE ; int first = 0 , last = 0 ; for ( int i = 0 ; i + m - 1 < n ; i ++ ) { int diff = arr [ i + m - 1 ] - arr [ i ] ; if ( diff < min_diff ) { min_diff = diff ; first = i ; last = i + m - 1 ; } } return ( arr [ last ] - arr [ first ] ) ; }"
"static int check ( int A [ ] , int B [ ] , int N ) { PriorityQueue < Integer > pq1 = new PriorityQueue < Integer > ( Collections . reverseOrder ( ) ) ; PriorityQueue < Integer > pq2 = new PriorityQueue < Integer > ( Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < N ; i ++ ) { pq1 . add ( A [ i ] ) ; } for ( int i = 0 ; i < N ; i ++ ) { pq2 . add ( B [ i ] ) ; } int c = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( pq1 . peek ( ) . compareTo ( pq2 . peek ( ) ) == 1 ) { c ++ ; pq1 . poll ( ) ; pq2 . poll ( ) ; } else { if ( pq2 . size ( ) == 0 ) { break ; } pq2 . poll ( ) ; } } return ( c ) ; }"
"static void printStrings ( String s , int l , int m ) { Set < String > c = new LinkedHashSet < > ( ) ; s = s + s ; for ( int i = 0 ; i < l ; i ++ ) { c . add ( s . substring ( i , i + m ) ) ; } Iterator itr = c . iterator ( ) ; while ( itr . hasNext ( ) ) { String a = ( String ) itr . next ( ) ; System . out . print ( a + "" "" ) ; } c . clear ( ) ; }"
"static void findNextWord ( char [ ] s , int m ) { m += 97 ; int n = s . length ; int i = s . length - 1 ; s [ i ] ++ ; while ( i >= 0 && i <= n - 1 ) { if ( s [ i ] >= m ) { s [ i ] = 'a' ; s [ -- i ] ++ ; } else if ( s [ i ] == s [ i - 1 ] || s [ i ] == s [ i - 2 ] ) { s [ i ] ++ ; } else { i ++ ; } } if ( i <= - 1 ) { System . out . println ( ""-1"" ) ; } else { System . out . println ( s ) ; } }"
"static void shuffle ( int N , int key ) { int NO_OF_BITS = N ; int reverse_num = 0 , temp ; for ( int i = 0 ; i < NO_OF_BITS ; i ++ ) { temp = ( key & ( 1 << i ) ) ; if ( temp > 0 ) reverse_num |= ( 1 << ( ( NO_OF_BITS - 1 ) - i ) ) ; } System . out . print ( reverse_num ) ; }"
static int countWords ( String str ) { int count = 1 ; for ( int i = 1 ; i < str . length ( ) - 1 ; i ++ ) { if ( str . charAt ( i ) >= 65 && str . charAt ( i ) <= 90 ) count ++ ; } return count ; }
"static int pairORSum ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { int k1 = 0 ; int k0 = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) != 0 ) k1 ++ ; else k0 ++ ; } ans = ans + ( 1 << i ) * ( k1 * ( k1 - 1 ) / 2 ) + ( 1 << i ) * ( k1 * k0 ) ; } return ans ; }"
static double find ( double p ) { return Math . ceil ( Math . sqrt ( 2 * 365 * Math . log ( 1 / ( 1 - p ) ) ) ) ; }
"static int MaxDotProduct ( int A [ ] , int B [ ] , int m , int n ) { int dp [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ; for ( int [ ] row : dp ) Arrays . fill ( row , 0 ) ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= m ; j ++ ) dp [ i ] [ j ] = Math . max ( ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ) , dp [ i ] [ j - 1 ] ) ; return dp [ n ] [ m ] ; }"
"static void isPrime ( int N ) { boolean isPrime = true ; int [ ] arr = { 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 }; if ( N < 2 ) { isPrime = false ; } if ( N % 2 == 0 || N % 3 == 0 || N % 5 == 0 ) { isPrime = false ; } for ( int i = 0 ; i < Math . sqrt ( N ) ; i += 30 ) { for ( int c : arr ) { if ( c > Math . sqrt ( N ) ) { break ; } else { if ( N % ( c + i ) == 0 ) { isPrime = false ; break ; } } if ( ! isPrime ) break ; } } if ( isPrime ) System . out . println ( ""Prime Number"" ) ; else System . out . println ( ""Not a Prime Number"" ) ; }"
"static void printRLE ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int count = 1 ; while ( i + 1 < s . length ( ) && s . charAt ( i ) == s . charAt ( i + 1 ) ) { i ++ ; count ++ ; } System . out . print ( s . charAt ( i ) + """" + count + "" "" ) ; } System . out . println ( ) ; }"
"static boolean sortedAfterSwap ( int A [ ] , boolean B [ ] , int n ) { int i , j ; for ( i = 0 ; i < n - 1 ; i ++ ) { if ( B [ i ] ) { j = i ; while ( B [ j ] ) { j ++ ; } Arrays . sort ( A , i , 1 + j ) ; i = j ; } } for ( i = 0 ; i < n ; i ++ ) { if ( A [ i ] != i + 1 ) { return false ; } } return true ; }"
"static void checkEVENodd ( int arr [ ] , int n , int l , int r ) { if ( arr [ r ] == 1 ) System . out . println ( ""odd"" ) ; else System . out . println ( ""even"" ) ; }"
static long answer ( int n ) { int dp [ ] [ ] = new int [ n + 1 ] [ 10 ] ; if ( n == 1 ) return 10 ; for ( int j = 0 ; j <= 9 ; j ++ ) dp [ 1 ] [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; else if ( j == 9 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ; } } long sum = 0 ; for ( int j = 1 ; j <= 9 ; j ++ ) sum += dp [ n ] [ j ] ; return sum ; }
"int minDist ( int arr [ ] , int n , int x , int y ) { int i = 0 ; int min_dist = Integer . MAX_VALUE ; int prev = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x || arr [ i ] == y ) { prev = i ; break ; } } for ( ; i < n ; i ++ ) { if ( arr [ i ] == x || arr [ i ] == y ) { if ( arr [ prev ] != arr [ i ] && ( i - prev ) < min_dist ) { min_dist = i - prev ; prev = i ; } else prev = i ; } } return min_dist ; }"
"public static boolean areEqual ( int arr1 [ ] , int arr2 [ ] ) { int n = arr1 . length ; int m = arr2 . length ; if ( n != m ) return false ; Arrays . sort ( arr1 ) ; Arrays . sort ( arr2 ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false ; return true ; }"
"static double distance ( int x1 , int y1 , int x2 , int y2 ) { return Math . sqrt ( Math . pow ( x2 - x1 , 2 ) + Math . pow ( y2 - y1 , 2 ) * 1.0 ) ; }"
"static float rhombusarea ( float l , float b ) { if ( l < 0 || b < 0 ) return - 1 ; return ( l * b ) / 2 ; }"
"static int findPairs ( int arr [ ] , int n , int x ) { int l = 0 , r = n - 1 ; int result = 0 ; while ( l < r ) { if ( arr [ l ] + arr [ r ] < x ) { result += ( r - l ) ; l ++ ; } else r -- ; } return result ; }"
"static void permutatedRows ( int mat [ ] [ ] , int m , int n , int r ) { LinkedHashSet < Integer > s = new LinkedHashSet < > ( ) ; for ( int j = 0 ; j < n ; j ++ ) s . add ( mat [ r ] [ j ] ) ; for ( int i = 0 ; i < m ; i ++ ) { if ( i == r ) continue ; int j ; for ( j = 0 ; j < n ; j ++ ) if ( ! s . contains ( mat [ i ] [ j ] ) ) break ; if ( j != n ) continue ; System . out . print ( i + "", "" ) ; } }"
"static int productAtKthLevel ( String tree , int k ) { int level = - 1 ; int product = 1 ; int n = tree . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( tree . charAt ( i ) == '(' ) level ++ ; else if ( tree . charAt ( i ) == ')' ) level -- ; else { if ( level == k ) product *= ( tree . charAt ( i ) - '0' ) ; } } return product ; }"
"static void checkSquare ( String s1 , String s2 ) { int c = Integer . valueOf ( s1 + s2 ) ; int d = ( int ) Math . sqrt ( c ) ; if ( d * d == c ) { System . out . println ( ""Yes"" ) ; } else { System . out . println ( ""No"" ) ; } }"
"static void findLIS ( int A [ ] , int n ) { Map < Integer , Integer > hash = new HashMap < Integer , Integer > ( ) ; int LIS_size = 1 ; int LIS_index = 0 ; hash . put ( A [ 0 ] , 1 ) ; for ( int i = 1 ; i < n ; i ++ ) { hash . put ( A [ i ] , hash . get ( A [ i ] - 1 ) == null ? 1 : hash . get ( A [ i ] - 1 ) + 1 ) ; if ( LIS_size < hash . get ( A [ i ] ) ) { LIS_size = hash . get ( A [ i ] ) ; LIS_index = A [ i ] ; } } System . out . println ( ""LIS_size = "" + LIS_size ) ; System . out . print ( ""LIS : "" ) ; int start = LIS_index - LIS_size + 1 ; while ( start <= LIS_index ) { System . out . print ( start + "" "" ) ; start ++ ; } }"
"static boolean canBeBalanced ( String s , int n ) { int count = 0 , count_1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '(' ) count ++ ; else count -- ; count_1 = Math . min ( count_1 , count ) ; } if ( count_1 >= - 1 && count == 0 ) return true ; return false ; }"
"static int findMinSwaps ( int arr [ ] , int n ) { int noOfZeroes [ ] = new int [ n ] ; int i , count = 0 ; noOfZeroes [ n - 1 ] = 1 - arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { noOfZeroes [ i ] = noOfZeroes [ i + 1 ] ; if ( arr [ i ] == 0 ) noOfZeroes [ i ] ++ ; } for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) count += noOfZeroes [ i ] ; } return count ; }"
"static int getMinCost ( int n , int m ) { int cost = ( n - 1 ) * m + ( m - 1 ) * n ; return cost ; }"
"static int number_of_digits ( int n ) { int i ; int res ; int sum = 0 ; for ( i = 4 , res = 1 ; ; i *= 4 , res ++ ) { sum += i ; if ( sum >= n ) break ; } return res ; }"
"static void myCopy ( char s1 [ ] , char s2 [ ] , int index ) { s2 [ index ] = s1 [ index ] ; if ( index == s1 . length - 1 ) { return ; } myCopy ( s1 , s2 , index + 1 ) ; }"
"static double minRevolutions ( double r , int x1 , int y1 , int x2 , int y2 ) { double d = Math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) ; return Math . ceil ( d / ( 2 * r ) ) ; }"
"static int negProdSubArr ( int arr [ ] , int n ) { int positive = 1 , negative = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) arr [ i ] = 1 ; else arr [ i ] = - 1 ; if ( i > 0 ) arr [ i ] *= arr [ i - 1 ] ; if ( arr [ i ] == 1 ) positive ++ ; else negative ++ ; } return ( positive * negative ) ; }"
"static void oddIntegers ( int n , int k ) { if ( n % 2 != k % 2 ) { System . out . println ( ""-1"" ) ; return ; } int sum = 0 ; int i = 1 ; int j = 1 ; while ( j < k ) { sum = sum + i ; System . out . print ( i + "" "" ) ; i = i + 2 ; j ++ ; } int finalOdd = n - sum ; System . out . println ( finalOdd ) ; }"
"static int kthOdd ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) k -- ; if ( k == 0 ) return arr [ i ] ; } return - 1 ; }"
"static int fib ( int n , int a , int b ) { if ( n == 0 ) return a ; if ( n == 1 ) return b ; return fib ( n - 1 , b , a + b ) ; }"
static float ellipsearea ( float r ) { if ( r < 0 ) return - 1 ; float a = ( float ) ( ( 3.14f * r * r ) / 4 ) ; return a ; }
"public static void findPair ( int [ ] arr , int n ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( Integer i : arr ) { s . add ( i ) ; } boolean found = false ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int sum = arr [ i ] + arr [ j ] ; if ( s . contains ( sum ) ) { found = true ; System . out . println ( arr [ i ] + "" "" + arr [ j ] ) ; } } } if ( found == false ) System . out . println ( ""Not Exist "" ) ; }"
"static int two_sets ( int a [ ] , int n ) { Arrays . sort ( a ) ; return a [ n / 2 ] - a [ ( n / 2 ) - 1 ] ; }"
"static void pattern ( int nos , int i , int space ) { char prt = '$' ; int s , j ; for ( s = nos ; s >= 1 ; s -- ) { System . out . print ( "" "" ) ; } for ( j = 1 ; j <= i ; j ++ ) { if ( space != 0 ) { if ( i == 9 && j == 1 ) { continue ; } } if ( i == 1 || i == 9 ) { System . out . print ( prt + """" ) ; } else if ( j == 1 || j == i ) { System . out . print ( prt + """" ) ; } else { System . out . print ( "" "" ) ; } } }"
"static int countNumbers ( int l , int r ) { return ( ( r / 6 ) - ( l - 1 ) / 6 ) ; }"
"static void interLeaveQueue ( Queue < Integer > q ) { if ( q . size ( ) % 2 != 0 ) System . out . println ( ""Input even number of integers."" ) ; Stack < Integer > s = new Stack < > ( ) ; int halfSize = q . size ( ) / 2 ; for ( int i = 0 ; i < halfSize ; i ++ ) { s . push ( q . peek ( ) ) ; q . poll ( ) ; } while ( ! s . empty ( ) ) { q . add ( s . peek ( ) ) ; s . pop ( ) ; } for ( int i = 0 ; i < halfSize ; i ++ ) { q . add ( q . peek ( ) ) ; q . poll ( ) ; } for ( int i = 0 ; i < halfSize ; i ++ ) { s . push ( q . peek ( ) ) ; q . poll ( ) ; } while ( ! s . empty ( ) ) { q . add ( s . peek ( ) ) ; s . pop ( ) ; q . add ( q . peek ( ) ) ; q . poll ( ) ; } }"
static int countBits ( int n ) { int count = 0 ; while ( n > 0 ) { count ++ ; n >>= 1 ; } return count ; }
"static int countways ( int n ) { if ( n == 1 ) return 0 ; else if ( n % 2 == 0 ) return 1 + countways ( n / 2 ) ; else return 1 + Math . min ( countways ( n - 1 ) , countways ( n + 1 ) ) ; }"
"static int countSubarrWithEqualZeroAndOne ( int arr [ ] , int n ) { Map < Integer , Integer > um = new HashMap < > ( ) ; int curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_sum += ( arr [ i ] == 0 ) ? - 1 : arr [ i ] ; um . put ( curr_sum , um . get ( curr_sum ) == null ? 1 : um . get ( curr_sum ) + 1 ) ; } int count = 0 ; for ( Map . Entry < Integer , Integer > itr : um . entrySet ( ) ) { if ( itr . getValue ( ) > 1 ) count += ( ( itr . getValue ( ) * ( itr . getValue ( ) - 1 ) ) / 2 ) ; } if ( um . containsKey ( 0 ) ) count += um . get ( 0 ) ; return count ; }"
"static void perfectCube ( int N ) { int cube ; for ( int i = 0 ; i <= N ; i ++ ) { cube = i * i * i ; if ( cube == N ) { System . out . println ( ""Yes"" ) ; return ; } else if ( cube > N ) { System . out . println ( ""NO"" ) ; return ; } } }"
static void solve ( long n ) { if ( n == 1 ) { System . out . println ( - 1 ) ; } else { int num = 2 ; for ( long i = 0 ; i < n - 1 ; i ++ ) { num = ( num * 10 ) + 3 ; } System . out . println ( num ) ; } }
"public static void findPairs ( int arr1 [ ] , int arr2 [ ] , int n , int m , int x ) { HashMap < Integer , Integer > s = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) s . put ( arr1 [ i ] , 0 ) ; for ( int j = 0 ; j < m ; j ++ ) if ( s . containsKey ( x - arr2 [ j ] ) ) System . out . println ( x - arr2 [ j ] + "" "" + arr2 [ j ] ) ; }"
"static int findArea ( Integer arr [ ] , int n ) { Arrays . sort ( arr , Collections . reverseOrder ( ) ) ; int [ ] dimension = { 0 , 0 }; for ( int i = 0 , j = 0 ; i < n - 1 && j < 2 ; i ++ ) if ( arr [ i ] == arr [ i + 1 ] ) dimension [ j ++ ] = arr [ i ++ ] ; return ( dimension [ 0 ] * dimension [ 1 ] ) ; }"
"static int minTime ( int n , int k , int a [ ] ) { int temp ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( a [ i ] < a [ j ] ) { temp = a [ i ] ; a [ i ] = a [ j ] ; a [ j ] = temp ; } } } int minTime = 0 ; for ( int i = 0 ; i < n ; i += k ) minTime += ( 2 * a [ i ] ) ; return minTime ; }"
"static StringBuilder findLeft ( StringBuilder str ) { int n = str . length ( ) ; while ( n > 0 ) { n -- ; if ( str . charAt ( n ) == 'd' ) { str . setCharAt ( n , 'c' ) ; break ; } if ( str . charAt ( n ) == 'b' ) { str . setCharAt ( n , 'a' ) ; break ; } if ( str . charAt ( n ) == 'a' ) str . setCharAt ( n , 'b' ) ; else if ( str . charAt ( n ) == 'c' ) str . setCharAt ( n , 'd' ) ; } return str ; }"
static int fact ( int n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; }
"static int maxTeams ( int N1 , int N2 ) { int count = 0 ; while ( N1 > 0 && N2 > 0 && N1 + N2 >= 3 ) { if ( N1 > N2 ) { N1 -= 2 ; N2 -= 1 ; } else { N1 -= 1 ; N2 -= 2 ; } count ++ ; } return count ; }"
"static int printUnion ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) System . out . print ( arr1 [ i ++ ] + "" "" ) ; else if ( arr2 [ j ] < arr1 [ i ] ) System . out . print ( arr2 [ j ++ ] + "" "" ) ; else { System . out . print ( arr2 [ j ++ ] + "" "" ) ; i ++ ; } } while ( i < m ) System . out . print ( arr1 [ i ++ ] + "" "" ) ; while ( j < n ) System . out . print ( arr2 [ j ++ ] + "" "" ) ; return 0 ; }"
static int findLength ( String str ) { int n = str . length ( ) ; int maxlen = 0 ; int sum [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) sum [ i ] [ i ] = str . charAt ( i ) - '0' ; for ( int len = 2 ; len <= n ; len ++ ) { for ( int i = 0 ; i < n - len + 1 ; i ++ ) { int j = i + len - 1 ; int k = len / 2 ; sum [ i ] [ j ] = sum [ i ] [ j - k ] + sum [ j - k + 1 ] [ j ] ; if ( len % 2 == 0 && sum [ i ] [ j - k ] == sum [ ( j - k + 1 ) ] [ j ] && len > maxlen ) maxlen = len ; } } return maxlen ; }
"static String toNegativeBase ( int n , int negBase ) { if ( n == 0 ) return ""0"" ; String converted = """" ; while ( n != 0 ) { int remainder = n % negBase ; n /= negBase ; if ( remainder < 0 ) { remainder += ( - negBase ) ; n += 1 ; } converted = String . valueOf ( remainder ) + converted ; } return converted ; }"
"public static int countDivisors ( int N , int a , int b ) { int count1 = N / a ; int count2 = N / b ; int count3 = ( N / ( a * b ) ) ; return count1 + count2 - count3 ; }"
"static long noOfTriples ( long arr [ ] , int n ) { Arrays . sort ( arr ) ; long count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == arr [ 2 ] ) count ++ ; if ( arr [ 0 ] == arr [ 2 ] ) return ( count - 2 ) * ( count - 1 ) * ( count ) / 6 ; else if ( arr [ 1 ] == arr [ 2 ] ) return ( count - 1 ) * ( count ) / 2 ; return count ; }"
"static void makePermutation ( int [ ] a , int n ) { HashMap < Integer , Integer > count = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( count . containsKey ( a [ i ] ) ) { count . put ( a [ i ] , count . get ( a [ i ] ) + 1 ) ; } else { count . put ( a [ i ] , 1 ) ; } } int next_missing = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( count . containsKey ( a [ i ] ) && count . get ( a [ i ] ) != 1 || a [ i ] > n || a [ i ] < 1 ) { count . put ( a [ i ] , count . get ( a [ i ] ) - 1 ) ; while ( count . containsKey ( next_missing ) ) next_missing ++ ; a [ i ] = next_missing ; count . put ( next_missing , 1 ) ; } } }"
"static String findString ( int n , int k ) { String res = """" ; for ( int i = 0 ; i < k ; i ++ ) res = res + ( char ) ( 'a' + i ) ; int count = 0 ; for ( int i = 0 ; i < n - k ; i ++ ) { res = res + ( char ) ( 'a' + count ) ; count ++ ; if ( count == k ) count = 0 ; } return res ; }"
"static boolean isValidNesbitt ( double a , double b , double c ) { double A = a / ( b + c ) ; double B = b / ( a + c ) ; double C = c / ( a + b ) ; double inequality = A + B + C ; return ( inequality >= 1.5 ) ; }"
"static int countCommon ( int mat [ ] [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) res ++ ; return res ; }"
"public static StringBuffer encrypt ( String text , int s ) { StringBuffer result = new StringBuffer ( ) ; for ( int i = 0 ; i < text . length ( ) ; i ++ ) { if ( Character . isUpperCase ( text . charAt ( i ) ) ) { char ch = ( char ) ( ( ( int ) text . charAt ( i ) + s - 65 ) % 26 + 65 ) ; result . append ( ch ) ; } else { char ch = ( char ) ( ( ( int ) text . charAt ( i ) + s - 97 ) % 26 + 97 ) ; result . append ( ch ) ; } } return result ; }"
"static int count ( int n , int x ) { int count = 0 ; for ( int i = 1 ; i <= n && i <= x ; i ++ ) { if ( x / i <= n && x % i == 0 ) count ++ ; } return count ; }"
"static String encryptString ( String str , int n ) { int i = 0 , cnt = 0 ; String encryptedStr = """" ; while ( i < n ) { cnt = i + 1 ; while ( cnt -- > 0 ) encryptedStr += str . charAt ( i ) ; i ++ ; } return encryptedStr ; }"
"static void getmax ( int arr [ ] , int n , int x ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s = s + arr [ i ] ; } System . out . print ( Math . min ( s , x ) ) ; }"
"static int NumberOfSolutions ( int a , int b , int c , int d ) { int ans = 0 ; for ( int i = a ; i <= b ; i ++ ) if ( d >= Math . max ( c , i + 1 ) ) ans += d - Math . max ( c , i + 1 ) + 1 ; return ans ; }"
public static boolean isMagic ( int n ) { int sum = 0 ; while ( n > 0 || sum > 9 ) { if ( n == 0 ) { n = sum ; sum = 0 ; } sum += n % 10 ; n /= 10 ; } return ( sum == 1 ) ; }
"static int sumAtKthLevel ( String tree , int k ) { int level = - 1 ; int sum = 0 ; int n = tree . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( tree . charAt ( i ) == '(' ) level ++ ; else if ( tree . charAt ( i ) == ')' ) level -- ; else { if ( level == k ) sum += ( tree . charAt ( i ) - '0' ) ; } } return sum ; }"
"public static final double heron ( double a , double b , double c ) { double s = ( a + b + c ) / 2 ; return Math . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ; }"
"static int findLargestd ( int [ ] S , int n ) { boolean found = false ; Arrays . sort ( S ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; for ( int k = j + 1 ; k < n ; k ++ ) { if ( i == k ) continue ; for ( int l = k + 1 ; l < n ; l ++ ) { if ( i == l ) continue ; if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) { found = true ; return S [ i ] ; } } } } } if ( found == false ) return Integer . MAX_VALUE ; return - 1 ; }"
"static void deleteElements ( int arr [ ] , int n , int k ) { Stack < Integer > s = new Stack < > ( ) ; s . push ( arr [ 0 ] ) ; int count = 0 ; for ( int i = 1 ; i < n ; i ++ ) { while ( ! s . empty ( ) && s . peek ( ) < arr [ i ] && count < k ) { s . pop ( ) ; count ++ ; } s . push ( arr [ i ] ) ; } int m = s . size ( ) ; Integer [ ] v = new Integer [ m ] ; while ( ! s . empty ( ) ) { v [ -- m ] = s . peek ( ) ; s . pop ( ) ; } for ( Integer x : v ) { System . out . print ( x + "" "" ) ; }; System . out . println ( """" ) ; }"
"static void countCharacterType ( String str ) { int vowels = 0 , consonant = 0 , specialChar = 0 , digit = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; if ( ( ch >= 'a' && ch <= 'z' ) || ( ch >= 'A' && ch <= 'Z' ) ) { ch = Character . toLowerCase ( ch ) ; ; if ( ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ) vowels ++ ; else consonant ++ ; } else if ( ch >= '0' && ch <= '9' ) digit ++ ; else specialChar ++ ; } System . out . println ( ""Vowels: "" + vowels ) ; System . out . println ( ""Consonant: "" + consonant ) ; System . out . println ( ""Digit: "" + digit ) ; System . out . println ( ""Special Character: "" + specialChar ) ; }"
"static int operations ( int op [ ] , int n , int k ) { int i , count = 0 ; int nVal = 0 ; int min = Integer . MAX_VALUE ; for ( i = 0 ; i < n ; i ++ ) { nVal += op [ i ] ; min = Math . min ( min , nVal ) ; if ( ( k + nVal ) <= 0 ) return ( i + 1 ) ; } if ( nVal >= 0 ) return - 1 ; int times = ( k - Math . abs ( min ) ) / Math . abs ( nVal ) ; k = ( k - ( times * Math . abs ( nVal ) ) ) ; count = ( times * n ) ; while ( k > 0 ) { for ( i = 0 ; i < n ; i ++ ) { k = k + op [ i ] ; count ++ ; if ( k <= 0 ) break ; } } return count ; }"
"static int solve ( int i , int x , int dp [ ] [ ] ) { if ( i < 0 ) { return x == 3 ? 1 : 0 ; } if ( dp [ i ] [ x ] != - 1 ) { return dp [ i ] [ x ] ; } dp [ i ] [ x ] = solve ( i - 1 , 0 , dp ) ; dp [ i ] [ x ] += solve ( i - 1 , x + 1 , dp ) ; return dp [ i ] [ x ] ; }"
"static int findOddPair ( int A [ ] , int N ) { int i , count = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) count ++ ; } return count * ( N - count ) ; }"
"public static void countFreq ( int arr [ ] , int n ) { boolean visited [ ] = new boolean [ n ] ; Arrays . fill ( visited , false ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( visited [ i ] == true ) continue ; int count = 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { visited [ j ] = true ; count ++ ; } } System . out . println ( arr [ i ] + "" "" + count ) ; } }"
"static int findSum ( int n , int a , int b ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( i % a == 0 || i % b == 0 ) sum += i ; return sum ; }"
"static boolean isPossible ( int a [ ] , int n ) { int k = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] != i + 1 ) k ++ ; } if ( k <= 2 ) return true ; return false ; }"
"static void printRect ( Integer X [ ] , Integer Y [ ] , int n ) { int Xmax = Collections . max ( Arrays . asList ( X ) ) ; int Xmin = Collections . min ( Arrays . asList ( X ) ) ; int Ymax = Collections . max ( Arrays . asList ( Y ) ) ; int Ymin = Collections . min ( Arrays . asList ( Y ) ) ; System . out . println ( ""{"" + Xmin + "", "" + Ymin + ""}"" ) ; System . out . println ( ""{"" + Xmin + "", "" + Ymax + ""}"" ) ; System . out . println ( ""{"" + Xmax + "", "" + Ymax + ""}"" ) ; System . out . println ( ""{"" + Xmax + "", "" + Ymin + ""}"" ) ; }"
static float Conversion ( float n ) { return ( n - 32.0f ) * 5.0f / 9.0f ; }
"static void findPairs ( int arr [ ] , int n ) { int cntEven = 0 , cntOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) cntEven ++ ; else cntOdd ++ ; } int evenPairs = 0 ; evenPairs += ( ( cntEven * ( cntEven - 1 ) ) / 2 ) ; evenPairs += ( ( cntOdd * ( cntOdd - 1 ) ) / 2 ) ; int oddPairs = 0 ; oddPairs += ( cntEven * cntOdd ) ; System . out . println ( ""Odd pairs = "" + oddPairs ) ; System . out . println ( ""Even pairs = "" + evenPairs ) ; }"
"int equilibrium ( int arr [ ] , int n ) { int sum = 0 ; int leftsum = 0 ; for ( int i = 0 ; i < n ; ++ i ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) { sum -= arr [ i ] ; if ( leftsum == sum ) return i ; leftsum += arr [ i ] ; } return - 1 ; }"
"static int toggleBitsFromLToR ( int n , int l , int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; return ( n ^ num ) ; }"
"static int nonFibonacci ( int n ) { int prevPrev = 1 , prev = 2 , curr = 3 ; while ( n > 0 ) { prevPrev = prev ; prev = curr ; curr = prevPrev + prev ; n = n - ( curr - prev - 1 ) ; } n = n + ( curr - prev - 1 ) ; return prev + n ; }"
"static int dealnnoy ( int n , int m ) { int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] ; return dp [ m ] [ n ] ; }"
"static void printPattern ( int n ) { int i , j ; for ( i = 1 ; i <= n ; i ++ ) { for ( j = 1 ; j < 2 * n ; j ++ ) { if ( j == ( n - i + 1 ) || j == ( n + i - 1 ) ) { System . out . print ( ""* "" ) ; } else if ( ( i >= 4 && i <= n - 4 ) && ( j == n - i + 4 || j == n + i - 4 ) ) { System . out . print ( ""* "" ) ; } else if ( i == n || ( i == n - 4 && j >= n - ( n - 2 * 4 ) && j <= n + n - 2 * 4 ) ) { System . out . print ( ""* "" ) ; } else { System . out . print ( "" "" + "" "" ) ; } } System . out . print ( ""\n"" ) ; } }"
"static void arrange ( int N ) { if ( N == 1 ) { System . out . println ( ""1"" ) ; return ; } if ( N == 2 || N == 3 ) { System . out . println ( ""-1"" ) ; return ; } int even = - 1 , odd = - 1 ; if ( N % 2 == 0 ) { even = N ; odd = N - 1 ; } else { odd = N ; even = N - 1 ; } while ( odd >= 1 ) { System . out . print ( odd ) ; System . out . print ( "" "" ) ; odd = odd - 2 ; } while ( even >= 2 ) { System . out . print ( even ) ; System . out . print ( "" "" ) ; even = even - 2 ; } }"
"static int minOperations ( int [ ] A , int n ) { if ( ( n & 1 ) > 0 ) return - 1 ; int zeros = 0 , consZeros = 0 , ones = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( A [ i ] == 0 ) zeros ++ ; else ones ++ ; if ( i + 1 < n ) { if ( A [ i ] == 0 && A [ i + 1 ] == 0 ) consZeros ++ ; } } if ( A [ 0 ] == A [ n - 1 ] && A [ 0 ] == 0 ) consZeros ++ ; if ( zeros == ones ) return consZeros ; else return - 1 ; }"
static boolean check ( String str ) { int n = str . length ( ) ; if ( ( str . charAt ( n - 1 ) - '0' ) % 2 != 0 ) return false ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str . charAt ( i ) - '0' ) ; return ( digitSum % 3 == 0 ) ; }
"public static boolean isNumBalanced ( int num ) { num = Math . abs ( num ) ; String str = num + """" ; char [ ] ch_arr = str . toCharArray ( ) ; HashSet < Character > hs = new HashSet < Character > ( ) ; for ( char ch : ch_arr ) { hs . add ( ch ) ; } int str_len = str . length ( ) ; int hs_len = hs . size ( ) ; if ( hs_len <= str_len / 2 || hs_len == str_len ) { return true ; } return false ; }"
"static void printDiamond ( int n ) { System . out . println ( ) ; int i , j = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i ; j < n ; j ++ ) System . out . print ( ""*"" ) ; for ( j = 0 ; j < 2 * i + 1 ; j ++ ) System . out . print ( "" "" ) ; for ( j = i ; j < n ; j ++ ) System . out . print ( ""*"" ) ; System . out . println ( ) ; } for ( i = 0 ; i < n - 1 ; i ++ ) { for ( j = 0 ; j < i + 2 ; j ++ ) System . out . print ( ""*"" ) ; for ( j = 0 ; j < 2 * ( n - 1 - i ) - 1 ; j ++ ) System . out . print ( "" "" ) ; for ( j = 0 ; j < i + 2 ; j ++ ) System . out . print ( ""*"" ) ; System . out . println ( ) ; } System . out . println ( ) ; }"
"static boolean isSubsetSum ( int set [ ] , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 && sum != 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }"
"static String K_String ( String s , int k ) { int n = s . length ( ) ; int fre [ ] = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) fre [ s . charAt ( i ) - 'a' ] ++ ; String str = """" ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( fre [ i ] % k == 0 ) { int x = fre [ i ] / k ; while ( x != 0 ) { str += ( char ) ( i + 'a' ) ; x -- ; } } else { return ""-1"" ; } } return str ; }"
"static void reArrange ( String words [ ] , int n ) { HashMap < String , Integer > freq = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { freq . put ( words [ i ] , ( i + 1 ) ) ; } Arrays . sort ( words ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( freq . get ( words [ i ] ) + "" "" ) ; }"
static int RSF ( int n ) { while ( n >= 10 ) { int x = n ; int l = 0 ; while ( n > 0 ) { n = n / 10 ; l ++ ; } int a [ ] = new int [ l ] ; int i = l - 1 ; while ( x > 0 ) { a [ i ] = x % 10 ; x = x / 10 ; i -- ; } for ( int j = 0 ; j < l - 1 ; j ++ ) { n = n * 10 + Math . abs ( a [ j ] - a [ j + 1 ] ) ; } } return n ; }
static boolean topsyTurvy ( char [ ] str ) { for ( int i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] == '2' || str [ i ] == '4' || str [ i ] == '5' || str [ i ] == '6' || str [ i ] == '7' || str [ i ] == '9' ) { return false ; } } return true ; }
"static String getCount ( int N ) { if ( N % 2 == 1 ) return ""0"" ; String result = ""9"" ; for ( int i = 1 ; i <= N / 2 - 1 ; i ++ ) result += ""0"" ; return result ; }"
"static String get_maximum ( char [ ] s , int a [ ] ) { int n = s . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] - '0' < a [ s [ i ] - '0' ] ) { int j = i ; while ( j < n && ( s [ j ] - '0' <= a [ s [ j ] - '0' ] ) ) { s [ j ] = ( char ) ( '0' + a [ s [ j ] - '0' ] ) ; j ++ ; } return String . valueOf ( s ) ; } } return String . valueOf ( s ) ; }"
"static long calculateSum ( int n , int k ) { long res = 1 ; long MOD = 1000000007 ; for ( int i = 0 ; i < k ; i ++ ) { res = ( res * n ) % MOD ; } return res ; }"
public static int nthTerm ( int N ) { return N * N + ( N + 1 ) * ( N + 1 ) ; }
"static void printDiagonalSums ( int [ ] [ ] mat , int n ) { int principal = 0 , secondary = 0 ; for ( int i = 0 ; i < n ; i ++ ) { principal += mat [ i ] [ i ] ; secondary += mat [ i ] [ n - i - 1 ] ; } System . out . println ( ""Principal Diagonal:"" + principal ) ; System . out . println ( ""Secondary Diagonal:"" + secondary ) ; }"
"static int longest_gap ( int N ) { int distance = 0 , count = 0 , first_1 = - 1 , last_1 = - 1 ; while ( N != 0 ) { count ++ ; int r = N & 1 ; if ( r == 1 ) { first_1 = first_1 == - 1 ? count : first_1 ; last_1 = count ; } N = N / 2 ; } if ( last_1 <= first_1 ) { return - 1 ; } else { distance = ( last_1 - first_1 - 1 ) ; return distance ; } }"
"static int largest ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; return arr [ n - 1 ] ; }"
"static boolean productDivisible ( int n , int k ) { int product = 1 , position = 1 ; while ( n > 0 ) { if ( position % 2 == 0 ) { product *= n % 10 ; } n = n / 10 ; position ++ ; } if ( product % k == 0 ) { return true ; } return false ; }"
static boolean isTwoAlter ( String s ) { for ( int i = 0 ; i < s . length ( ) - 2 ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( i + 2 ) ) { return false ; } } if ( s . charAt ( 0 ) == s . charAt ( 1 ) ) return false ; return true ; }
"static void fib ( int n ) { int a = 0 , b = 1 ; if ( n >= 0 ) System . out . print ( a + "" "" ) ; if ( n >= 1 ) System . out . print ( b + "" "" ) ; for ( int i = 2 ; i <= n ; i ++ ) { System . out . print ( a + b + "" "" ) ; b = a + b ; a = b - a ; } }"
static int countNumbers ( int n ) { return ( n / 2520 ) ; }
"static boolean isMajority ( int a [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( mp . containsKey ( a [ i ] ) ) mp . put ( a [ i ] , mp . get ( a [ i ] ) + 1 ) ; else mp . put ( a [ i ] , 1 ) ; for ( Map . Entry < Integer , Integer > x : mp . entrySet ( ) ) if ( x . getValue ( ) >= n / 2 ) return true ; return false ; }"
"static void findCombinations ( String str , int index , String out ) { if ( index == str . length ( ) ) System . out . println ( out ) ; for ( int i = index ; i < str . length ( ) ; i ++ ) findCombinations ( str , i + 1 , out + ""("" + str . substring ( index , i + 1 ) + "")"" ) ; }"
"static boolean productEqual ( int n ) { if ( n < 10 ) return false ; int prodOdd = 1 , prodEven = 1 ; while ( n > 0 ) { int digit = n % 10 ; prodOdd *= digit ; n /= 10 ; if ( n == 0 ) break ; digit = n % 10 ; prodEven *= digit ; n /= 10 ; } if ( prodEven == prodOdd ) return true ; return false ; }"
"static int minValue ( int A [ ] , int B [ ] , int n ) { Arrays . sort ( A ) ; Arrays . sort ( B ) ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += ( A [ i ] * B [ n - i - 1 ] ) ; return result ; }"
"static boolean isSubSequence ( String str1 , String str2 , int m , int n ) { if ( m == 0 ) return true ; if ( n == 0 ) return false ; if ( str1 . charAt ( m - 1 ) == str2 . charAt ( n - 1 ) ) return isSubSequence ( str1 , str2 , m - 1 , n - 1 ) ; return isSubSequence ( str1 , str2 , m , n - 1 ) ; }"
"static int minSum ( int arr [ ] , int n ) { int sum = arr [ 0 ] , prev = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] <= prev ) { prev = prev + 1 ; sum = sum + prev ; } else { sum = sum + arr [ i ] ; prev = arr [ i ] ; } } return sum ; }"
static int countSC ( int N ) { int res = ( int ) Math . sqrt ( N ) + ( int ) Math . cbrt ( N ) - ( int ) ( Math . sqrt ( Math . cbrt ( N ) ) ) ; return res ; }
"static long countSubstr ( String s , int k ) { int n = s . length ( ) ; int l = n - 1 ; int r = n - 1 ; int [ ] arr = new int [ n ] ; int last_indexof1 = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '1' ) { arr [ i ] = i ; last_indexof1 = i ; } else { arr [ i ] = last_indexof1 ; } } long no_of_substr = 0 ; for ( r = n - 1 ; r >= 0 ; r -- ) { l = r ; while ( l >= 0 && ( r - l + 1 ) <= 64 && Integer . valueOf ( s . substring ( l , r + 1 ) , 2 ) < k ) { l -- ; } if ( r - l + 1 <= 64 ) no_of_substr += l + 1 ; else { no_of_substr += arr [ l + 1 ] + 1 ; } } return no_of_substr ; }"
"static void CheckSubarray ( int arr [ ] , int N ) { int [ ] presum = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i += 1 ) { presum [ i ] = presum [ i - 1 ] + arr [ i - 1 ] ; } Vector < Integer > [ ] moduloclass = new Vector [ N ] ; for ( int i = 0 ; i < N ; i += 1 ) { moduloclass [ i ] = new Vector < > ( ) ; } for ( int i = 1 ; i <= N ; i += 1 ) { moduloclass [ presum [ i ] % N ] . add ( i - 1 ) ; } if ( moduloclass [ 0 ] . size ( ) > 0 ) { System . out . print ( 0 + "" "" + moduloclass [ 0 ] . get ( 0 ) ) ; return ; } for ( int i = 1 ; i < N ; i += 1 ) { if ( moduloclass [ i ] . size ( ) >= 2 ) { System . out . print ( moduloclass [ i ] . get ( 0 ) + 1 + "" "" + moduloclass [ i ] . get ( 1 ) ) ; return ; } } }"
"static int xorGivenSetBits ( int arr [ ] , int n , int k ) { Vector < Integer > v = new Vector < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( Integer . bitCount ( arr [ i ] ) == k ) { v . add ( arr [ i ] ) ; } } int result = v . get ( 0 ) ; for ( int i = 1 ; i < v . size ( ) ; i ++ ) { result = result ^ v . get ( i ) ; } return result ; }"
"static boolean areElementsContiguous ( int arr [ ] , int n ) { int max = Integer . MIN_VALUE ; int min = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { max = Math . max ( max , arr [ i ] ) ; min = Math . min ( min , arr [ i ] ) ; } int m = max - min + 1 ; if ( m > n ) return false ; boolean visited [ ] = new boolean [ n ] ; for ( int i = 0 ; i < n ; i ++ ) visited [ arr [ i ] - min ] = true ; for ( int i = 0 ; i < m ; i ++ ) if ( visited [ i ] == false ) return false ; return true ; }"
"static void findBalance ( int x , float bal ) { if ( x % 10 == 0 && ( ( float ) x + 1.50 ) <= bal ) { System . out . printf ( ""%.2f\n"" , bal - x - 1.50 ) ; } else { System . out . printf ( ""%.2f\n"" , bal ) ; } }"
"static void maxProductSum ( String str , int m ) { int n = str . length ( ) ; int maxProd = Integer . MIN_VALUE , maxSum = Integer . MIN_VALUE ; for ( int i = 0 ; i < n - m ; i ++ ) { int product = 1 , sum = 0 ; for ( int j = i ; j < m + i ; j ++ ) { product = product * ( str . charAt ( j ) - '0' ) ; sum = sum + ( str . charAt ( j ) - '0' ) ; } maxProd = Math . max ( maxProd , product ) ; maxSum = Math . max ( maxSum , sum ) ; } System . out . println ( ""Maximum Product = "" + maxProd ) ; System . out . print ( ""\nMaximum Sum = "" + maxSum ) ; }"
"static int max_sum ( int a [ ] , int n ) { int [ ] [ ] dp = new int [ n + 1 ] [ 2 ] ; dp [ 0 ] [ 0 ] = 0 ; dp [ 0 ] [ 1 ] = - 999999 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 0 ] + a [ i ] , dp [ i ] [ 1 ] - a [ i ] ) ; dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] - a [ i ] , dp [ i ] [ 1 ] + a [ i ] ) ; } return dp [ n ] [ 0 ] ; }"
"static int countPairs ( int arr [ ] , int k ) { Arrays . sort ( arr ) ; int pair = 0 ; int index = 0 ; while ( index < arr . length - 1 ) { if ( arr [ index + 1 ] - arr [ index ] <= k ) { pair += 1 ; index += 2 ; } else { index += 1 ; } } return pair ; }"
"static void solve ( long a , long b ) { if ( a > 0 && b > 0 ) { System . out . println ( ""Positive"" ) ; } else if ( a <= 0 && b >= 0 ) { System . out . println ( ""Zero"" ) ; } else { long n = Math . abs ( a - b ) + 1 ; if ( n % 2 == 0 ) { System . out . println ( ""Positive"" ) ; } else { System . out . println ( ""Negative"" ) ; } } }"
"static void createSorted ( int a [ ] , int n ) { Vector < Integer > b = new Vector < > ( ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( b . isEmpty ( ) ) b . add ( a [ j ] ) ; else { int start = 0 , end = b . size ( ) - 1 ; int pos = 0 ; while ( start <= end ) { int mid = start + ( end - start ) / 2 ; if ( b . get ( mid ) == a [ j ] ) { b . add ( ( Math . max ( 0 , mid + 1 ) ) , a [ j ] ) ; break ; } else if ( b . get ( mid ) > a [ j ] ) pos = end = mid - 1 ; else pos = start = mid + 1 ; if ( start > end ) { pos = start ; b . add ( Math . max ( 0 , pos ) , a [ j ] ) ; break ; } } } } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( b . get ( i ) + "" "" ) ; }"
"static int minRemove ( int arr [ ] , int n ) { int LIS [ ] = new int [ n ] ; int len = 0 ; for ( int i = 0 ; i < n ; i ++ ) LIS [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) LIS [ i ] = Math . max ( LIS [ i ] , LIS [ j ] + 1 ) ; } len = Math . max ( len , LIS [ i ] ) ; } return n - len ; }"
"static float Calculate_GST ( float org_cost , float N_price ) { return ( ( ( N_price - org_cost ) * 100 ) / org_cost ) ; }"
static int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }
"public static int power ( long x , long y , long mod ) { long ans = 1 ; while ( y > 0 ) { if ( y % 2 == 1 ) ans = ( ans * x ) % mod ; x = ( x * x ) % mod ; y /= 2 ; } return ( int ) ( ans ) ; }"
"static int xorOdd ( int arr [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } int xorArr = 0 ; for ( Map . Entry < Integer , Integer > it : mp . entrySet ( ) ) { if ( ( ( it . getValue ( ) ) % 2 ) == 1 ) { xorArr ^= it . getKey ( ) ; } } return xorArr ; }"
"static void find ( Vector < String > list1 , Vector < String > list2 ) { Vector < String > res = new Vector < > ( ) ; int max_possible_sum = list1 . size ( ) + list2 . size ( ) - 2 ; for ( int sum = 0 ; sum <= max_possible_sum ; sum ++ ) { for ( int i = 0 ; i <= sum ; i ++ ) if ( i < list1 . size ( ) && ( sum - i ) < list2 . size ( ) && list1 . get ( i ) == list2 . get ( sum - i ) ) res . add ( list1 . get ( i ) ) ; if ( res . size ( ) > 0 ) break ; } for ( int i = 0 ; i < res . size ( ) ; i ++ ) System . out . print ( res . get ( i ) + "" "" ) ; }"
public static int countDyckPaths ( int n ) { int res = 1 ; for ( int i = 0 ; i < n ; ++ i ) { res *= ( 2 * n - i ) ; res /= ( i + 1 ) ; } return res / ( n + 1 ) ; }
static boolean check ( int n ) { return 1162261467 % n == 0 ; }
"static boolean check ( int arr [ ] , int x , int n ) { long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { double y = Math . sqrt ( arr [ i ] ) ; if ( Math . floor ( y ) == Math . ceil ( y ) ) { sum += arr [ i ] ; } } if ( sum % x == 0 ) return true ; else return false ; }"
"static void printInSortedOrder ( String arr [ ] , int n ) { int index [ ] = new int [ n ] ; int i , j , min ; for ( i = 0 ; i < n ; i ++ ) { index [ i ] = i ; } for ( i = 0 ; i < n - 1 ; i ++ ) { min = i ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ index [ min ] ] . compareTo ( arr [ index [ j ] ] ) > 0 ) { min = j ; } } if ( min != i ) { int temp = index [ min ] ; index [ min ] = index [ i ] ; index [ i ] = temp ; } } for ( i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ index [ i ] ] + "" "" ) ; } }"
"static int findLength ( String str , int n ) { int sum [ ] = new int [ n + 1 ] ; sum [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum [ i ] = ( sum [ i - 1 ] + str . charAt ( i - 1 ) - '0' ) ; int ans = 0 ; for ( int len = 2 ; len <= n ; len += 2 ) { for ( int i = 0 ; i <= n - len ; i ++ ) { int j = i + len - 1 ; if ( sum [ i + len / 2 ] - sum [ i ] == sum [ i + len ] - sum [ i + len / 2 ] ) ans = Math . max ( ans , len ) ; } } return ans ; }"
"static void SectorArea ( double radius , double angle ) { if ( angle >= 360 ) System . out . println ( ""Angle not possible"" ) ; else { double sector = ( ( 22 * radius * radius ) / 7 ) * ( angle / 360 ) ; System . out . println ( sector ) ; } }"
"static int sumOfDigitsFrom1ToN ( int n ) { if ( n < 10 ) return ( n * ( n + 1 ) / 2 ) ; int d = ( int ) ( Math . log10 ( n ) ) ; int a [ ] = new int [ d + 1 ] ; a [ 0 ] = 0 ; a [ 1 ] = 45 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 10 + 45 * ( int ) ( Math . ceil ( Math . pow ( 10 , i - 1 ) ) ) ; int p = ( int ) ( Math . ceil ( Math . pow ( 10 , d ) ) ) ; int msd = n / p ; return ( msd * a [ d ] + ( msd * ( msd - 1 ) / 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToN ( n % p ) ) ; }"
"static int countDivisibles ( int A , int B , int M ) { if ( A % M == 0 ) return ( B / M ) - ( A / M ) + 1 ; return ( B / M ) - ( A / M ) ; }"
"static int totalSum ( int a [ ] , int n ) { int i , sum = 0 , sum1 = 0 , j ; for ( i = 0 ; i < n ; i ++ ) { sum1 = 0 ; for ( j = i ; j < n ; j ++ ) { sum1 = ( sum1 | a [ j ] ) ; sum = sum + sum1 ; } } return sum ; }"
"static int countSubstr ( String str , int n , char x , char y ) { int tot_count = 0 ; int count_x = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == x ) count_x ++ ; if ( str . charAt ( i ) == y ) tot_count += count_x ; } return tot_count ; }"
"static long findMinSum ( long a [ ] , long b [ ] , long n ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + Math . abs ( a [ i ] - b [ i ] ) ; return sum ; }"
"static int missingK ( int [ ] a , int k , int n ) { int difference = 0 , ans = 0 , count = k ; boolean flag = false ; for ( int i = 0 ; i < n - 1 ; i ++ ) { difference = 0 ; if ( ( a [ i ] + 1 ) != a [ i + 1 ] ) { difference += ( a [ i + 1 ] - a [ i ] ) - 1 ; if ( difference >= count ) { ans = a [ i ] + count ; flag = true ; break ; } else count -= difference ; } } if ( flag ) return ans ; else return - 1 ; }"
"static int findNum ( int div [ ] , int rem [ ] , int N ) { int num = rem [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { num = num * div [ i ] + rem [ i ] ; } return num ; }"
"static int minTimeForWritingChars ( int N , int insert , int remove , int copy ) { if ( N == 0 ) return 0 ; if ( N == 1 ) return insert ; int dp [ ] = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) dp [ i ] = Math . min ( dp [ i - 1 ] + insert , dp [ i / 2 ] + copy ) ; else dp [ i ] = Math . min ( dp [ i - 1 ] + insert , dp [ ( i + 1 ) / 2 ] + copy + remove ) ; } return dp [ N ] ; }"
"static int search ( int arr [ ] , int n , int x ) { int i = 0 ; while ( i < n ) { if ( arr [ i ] == x ) return i ; i = i + Math . abs ( arr [ i ] - x ) ; } System . out . println ( ""number is not"" + "" present!"" ) ; return - 1 ; }"
"public static void floorAndCeil ( int arr [ ] , int x ) { int n = arr . length ; int fInd = - 1 , cInd = - 1 ; int fDist = Integer . MAX_VALUE , cDist = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= x && cDist > ( arr [ i ] - x ) ) { cInd = i ; cDist = arr [ i ] - x ; } if ( arr [ i ] <= x && fDist > ( x - arr [ i ] ) ) { fInd = i ; fDist = x - arr [ i ] ; } } if ( fDist == Integer . MAX_VALUE ) System . out . println ( ""Floor doesn't exist "" ) ; else System . out . println ( ""Floor is "" + arr [ fInd ] ) ; if ( cDist == Integer . MAX_VALUE ) System . out . println ( ""Ceil doesn't exist "" ) ; else System . out . println ( ""Ceil is "" + arr [ cInd ] ) ; }"
"static int cntWays ( String str , int n ) { int x = n + 1 ; int ways = x * x * ( x * x - 1 ) / 12 ; return ways ; }"
"static char encodedChar ( String str , int k ) { String expand = """" ; String temp = """" ; int freq = 0 ; for ( int i = 0 ; i < str . length ( ) ; ) { temp = """" ; freq = 0 ; while ( i < str . length ( ) && str . charAt ( i ) >= 'a' && str . charAt ( i ) <= 'z' ) { temp += str . charAt ( i ) ; i ++ ; } while ( i < str . length ( ) && str . charAt ( i ) >= '1' && str . charAt ( i ) <= '9' ) { freq = freq * 10 + str . charAt ( i ) - '0' ; i ++ ; } for ( int j = 1 ; j <= freq ; j ++ ) expand += temp ; } if ( freq == 0 ) expand += temp ; return expand . charAt ( k - 1 ) ; }"
"static void findDivisors ( int n ) { int [ ] div = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j * i <= n ; j ++ ) div [ i * j ] ++ ; } for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( div [ i ] + "" "" ) ; }"
static boolean canBeSumofConsec ( int n ) { return ( ( ( n & ( n - 1 ) ) != 0 ) && n != 0 ) ; }
"static int numberofterm ( int digit , int number ) { int firstnum = ( int ) Math . pow ( 10 , digit - 1 ) ; int lastnum = ( int ) Math . pow ( 10 , digit ) ; firstnum = ( firstnum - firstnum % number ) + number ; lastnum = ( lastnum - lastnum % number ) ; return ( ( lastnum - firstnum ) / number + 1 ) ; }"
"static int averageOdd ( int n ) { if ( n % 2 == 0 ) { System . out . println ( ""Invalid Input"" ) ; return - 1 ; } return ( n + 1 ) / 2 ; }"
static int countWays ( int n ) { int counter = 0 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) for ( int k = j ; k < n ; k ++ ) for ( int l = k ; l < n ; l ++ ) if ( i + j + k + l == n ) counter ++ ; return counter ; }
"static void find_set ( int n ) { if ( n <= 2 ) { System . out . println ( ""-1"" ) ; return ; } int sum1 = ( n * ( n - 1 ) ) / 2 ; int sum2 = n ; System . out . println ( sum1 + "" "" + sum2 ) ; }"
"static void checkIfSortRotated ( int arr [ ] , int n ) { int minEle = Integer . MAX_VALUE ; int maxEle = Integer . MIN_VALUE ; int minIndex = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < minEle ) { minEle = arr [ i ] ; minIndex = i ; } } boolean flag1 = true ; for ( int i = 1 ; i < minIndex ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { flag1 = false ; break ; } } boolean flag2 = true ; for ( int i = minIndex + 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { flag2 = false ; break ; } } if ( minIndex == 0 ) { System . out . print ( ""NO"" ) ; return ; } if ( flag1 && flag2 && ( arr [ n - 1 ] < arr [ minIndex - 1 ] ) ) System . out . println ( ""YES"" ) ; else System . out . print ( ""NO"" ) ; }"
"static double vol_of_dodecahedron ( int side ) { return ( ( ( 15 + ( 7 * ( Math . sqrt ( 5 ) ) ) ) / 4 ) * ( Math . pow ( side , 3 ) ) ) ; }"
"static void printbinomial ( int max ) { for ( int m = 0 ; m <= max ; m ++ ) { System . out . print ( m + "" "" ) ; int binom = 1 ; for ( int x = 0 ; x <= m ; x ++ ) { if ( m != 0 && x != 0 ) binom = binom * ( m - x + 1 ) / x ; System . out . print ( binom + "" "" ) ; } System . out . println ( ) ; } }"
"static void printSeriesSum ( int N ) { double sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 1 ) { sum += ( double ) i / ( i + 1 ) ; } else { sum -= ( double ) i / ( i + 1 ) ; } } System . out . print ( sum + ""\n"" ) ; }"
"static int avoidObstacles ( int [ ] obs ) { HashSet < Integer > hs = new HashSet < Integer > ( ) ; int max = obs [ 0 ] ; for ( int i = 0 ; i < obs . length ; i ++ ) { hs . add ( obs [ i ] ) ; max = Math . max ( max , obs [ i ] ) ; } for ( int i = 1 ; i <= max ; i ++ ) { int j ; for ( j = i ; j <= max ; j = j + i ) { if ( hs . contains ( j ) ) break ; } if ( j > max ) return i ; } return max + 1 ; }"
static int nthTerm ( int N ) { return ( 2 * N + 3 ) * ( 2 * N + 3 ) - 2 * N ; }
"static void swap ( int xp , int yp ) { if ( xp == yp ) return ; xp = xp + yp ; yp = xp - yp ; xp = xp - yp ; }"
"static int minimunMoves ( String arr [ ] , int n ) { int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int curr_count = 0 ; String tmp = """" ; for ( int j = 0 ; j < n ; j ++ ) { tmp = arr [ j ] + arr [ j ] ; int index = tmp . indexOf ( arr [ i ] ) ; if ( index == arr [ i ] . length ( ) ) return - 1 ; curr_count += index ; } ans = Math . min ( curr_count , ans ) ; } return ans ; }"
"static int maxRevenue ( int m , int [ ] x , int [ ] revenue , int n , int t ) { int [ ] maxRev = new int [ m + 1 ] ; for ( int i = 0 ; i < m + 1 ; i ++ ) maxRev [ i ] = 0 ; int nxtbb = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { if ( nxtbb < n ) { if ( x [ nxtbb ] != i ) maxRev [ i ] = maxRev [ i - 1 ] ; else { if ( i <= t ) maxRev [ i ] = Math . max ( maxRev [ i - 1 ] , revenue [ nxtbb ] ) ; else maxRev [ i ] = Math . max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) ; nxtbb ++ ; } } else maxRev [ i ] = maxRev [ i - 1 ] ; } return maxRev [ m ] ; }"
static boolean check ( String str ) { int n = str . length ( ) ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str . charAt ( i ) - '0' ) ; return ( digitSum % 9 == 0 ) ; }
"static int distancesum ( int x [ ] , int y [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) sum += ( Math . abs ( x [ i ] - x [ j ] ) + Math . abs ( y [ i ] - y [ j ] ) ) ; return sum ; }"
"static boolean canMakeAllSame ( String str ) { int zeros = 0 , ones = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; if ( ch == '0' ) ++ zeros ; else ++ ones ; } return ( zeros == 1 || ones == 1 ) ; }"
"static int sumKRepeating ( int arr [ ] , int n , int k ) { int sum = 0 ; HashMap < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! mp . containsKey ( arr [ i ] ) ) mp . put ( arr [ i ] , 0 ) ; mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } for ( Integer x : mp . keySet ( ) ) if ( mp . get ( x ) == k ) sum += x ; return sum ; }"
static boolean findPattern ( int n ) { int prev = n % 2 ; n = n / 2 ; while ( n > 0 ) { int curr = n % 2 ; if ( curr == prev ) return false ; prev = curr ; n = n / 2 ; } return true ; }
"static void remove_row_col ( int arr [ ] [ ] , int n , int x ) { for ( int i = x ; i < n ; i ++ ) { for ( int j = x ; j < n ; j ++ ) { System . out . print ( arr [ i ] [ j ] + "" "" ) ; } System . out . println ( ) ; } }"
"static int maxProd ( int N ) { if ( N == 0 ) return 1 ; if ( N < 10 ) return N ; return Math . max ( maxProd ( N / 10 ) * ( N % 10 ) , maxProd ( N / 10 - 1 ) * 9 ) ; }"
"static boolean check ( int degree [ ] , int n ) { int deg_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { deg_sum += degree [ i ] ; } return ( 2 * ( n - 1 ) == deg_sum ) ; }"
"static double average ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; return sum / n ; }"
"static long countPairs ( int arr [ ] , int n ) { int countZero = 0 ; int countTwo = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) countZero ++ ; else if ( arr [ i ] == 2 ) countTwo ++ ; } long pair0 = ( countZero * ( countZero - 1 ) ) / 2 ; long pair2 = ( countTwo * ( countTwo - 1 ) ) / 2 ; return pair0 + pair2 ; }"
"public static long rectCount ( int n , int m ) { return ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 ; }"
"static void solve ( String s ) { HashMap < Character , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( m . containsKey ( s . charAt ( i ) ) ) m . put ( s . charAt ( i ) , m . get ( s . charAt ( i ) ) + 1 ) ; else m . put ( s . charAt ( i ) , 1 ) ; } String new_string = """" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( m . get ( s . charAt ( i ) ) % 2 == 0 ) continue ; new_string = new_string + s . charAt ( i ) ; } System . out . println ( new_string ) ; }"
public static int bubble_sort ( int [ ] dat ) { int num = 0 ; for ( int i = 0 ; i < dat . length ; ++ i ) { for ( int j = 1 ; j < dat . length - i ; ++ j ) { if ( dat [ j - 1 ] > dat [ j ] ) { ++ num ; int t = dat [ j - 1 ] ; dat [ j - 1 ] = dat [ j ] ; dat [ j ] = t ; } } } return num ; }
"static int LowerInsertionPoint ( int arr [ ] , int n , int X ) { if ( X < arr [ 0 ] ) return 0 ; else if ( X > arr [ n - 1 ] ) return n ; int lowerPnt = 0 ; int i = 1 ; while ( i < n && arr [ i ] < X ) { lowerPnt = i ; i = i * 2 ; } while ( lowerPnt < n && arr [ lowerPnt ] < X ) lowerPnt ++ ; return lowerPnt ; }"
static void segregate0and1 ( int arr [ ] ) { int type0 = 0 ; int type1 = arr . length - 1 ; while ( type0 < type1 ) { if ( arr [ type0 ] == 1 ) { arr [ type1 ] = arr [ type1 ] + arr [ type0 ] ; arr [ type0 ] = arr [ type1 ] - arr [ type0 ] ; arr [ type1 ] = arr [ type1 ] - arr [ type0 ] ; type1 -- ; } else { type0 ++ ; } } }
public static int summation ( int n ) { return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; }
"static int countIntervals ( int [ ] [ ] arr , int V , int N ) { int count = 0 ; int li , ri ; for ( int i = 0 ; i < N ; i ++ ) { li = arr [ i ] [ 0 ] ; ri = arr [ i ] [ 1 ] ; if ( V >= li && V <= ri ) count ++ ; } return count ; }"
"static void printPrevSmaller ( int arr [ ] , int n ) { Stack < Integer > S = new Stack < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( ! S . empty ( ) && S . peek ( ) >= arr [ i ] ) { S . pop ( ) ; } if ( S . empty ( ) ) { System . out . print ( ""_, "" ) ; } else { System . out . print ( S . peek ( ) + "", "" ) ; } S . push ( arr [ i ] ) ; } }"
"static boolean isPrime ( int p ) { double checkNumber = Math . pow ( 2 , p ) - 1 ; double nextval = 4 % checkNumber ; for ( int i = 1 ; i < p - 1 ; i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ; return ( nextval == 0 ) ; }"
"public static int find ( int n , int k ) { if ( n + 1 >= k ) return ( k - 1 ) ; else return ( 2 * n + 1 - k ) ; }"
static int longestPrefixSuffix ( String s ) { int n = s . length ( ) ; int lps [ ] = new int [ n ] ; lps [ 0 ] = 0 ; int len = 0 ; int i = 1 ; while ( i < n ) { if ( s . charAt ( i ) == s . charAt ( len ) ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) { len = lps [ len - 1 ] ; } else { lps [ i ] = 0 ; i ++ ; } } } int res = lps [ n - 1 ] ; return ( res > n / 2 ) ? n / 2 : res ; }
static int binaryToDecimal ( String n ) { String num = n ; int dec_value = 0 ; int base = 1 ; int len = num . length ( ) ; for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( num . charAt ( i ) == '1' ) dec_value += base ; base = base * 2 ; } return dec_value ; }
"static boolean checkUnimodal ( int arr [ ] , int n ) { int i = 1 ; while ( i < n && arr [ i ] > arr [ i - 1 ] ) ++ i ; while ( i < n && arr [ i ] == arr [ i - 1 ] ) ++ i ; while ( i < n && arr [ i ] < arr [ i - 1 ] ) ++ i ; return ( i == n ) ; }"
static int octalToDecimal ( int n ) { int num = n ; int dec_value = 0 ; int base = 1 ; int temp = num ; while ( temp > 0 ) { int last_digit = temp % 10 ; temp = temp / 10 ; dec_value += last_digit * base ; base = base * 8 ; } return dec_value ; }
static void decToHexa ( int n ) { char [ ] hexaDeciNum = new char [ 100 ] ; int i = 0 ; while ( n != 0 ) { int temp = 0 ; temp = n % 16 ; if ( temp < 10 ) { hexaDeciNum [ i ] = ( char ) ( temp + 48 ) ; i ++ ; } else { hexaDeciNum [ i ] = ( char ) ( temp + 55 ) ; i ++ ; } n = n / 16 ; } for ( int j = i - 1 ; j >= 0 ; j -- ) System . out . print ( hexaDeciNum [ j ] ) ; }
"static int product ( int a [ ] , int n ) { int ans = 1 ; int val = ( int ) Math . pow ( 2 , n - 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { ans *= ( int ) Math . pow ( a [ i ] , val ) ; } return ans ; }"
"static void count_unique ( HashSet < Integer > s , int n ) { if ( s . contains ( n ) ) return ; s . add ( n ) ; n += 1 ; while ( n % 10 == 0 ) { n = n / 10 ; } count_unique ( s , n ) ; }"
static int chordCnt ( int A ) { int n = 2 * A ; int [ ] dpArray = new int [ n + 1 ] ; dpArray [ 0 ] = 1 ; dpArray [ 2 ] = 1 ; for ( int i = 4 ; i <= n ; i += 2 ) { for ( int j = 0 ; j < i - 1 ; j += 2 ) { dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 - j ] ) ; } } return dpArray [ n ] ; }
"static long getNthTerm ( long N ) { return ( 7 * ( int ) Math . pow ( N , 2 ) - 19 * N + 15 ) ; }"
"static void pattern ( int n ) { int p , k = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { p = k ; for ( int j = 1 ; j <= i ; j ++ ) { System . out . print ( p ) ; System . out . print ( "" "" ) ; p = p - ( n + j - i ) ; } System . out . println ( ) ; k = k + 1 + n - i ; } }"
static boolean isDivisibleBy10 ( String bin ) { int n = bin . length ( ) ; if ( bin . charAt ( n - 1 ) == '1' ) return false ; int sum = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( bin . charAt ( i ) == '1' ) { int posFromRight = n - i - 1 ; if ( posFromRight % 4 == 1 ) sum = sum + 2 ; else if ( posFromRight % 4 == 2 ) sum = sum + 4 ; else if ( posFromRight % 4 == 3 ) sum = sum + 8 ; else if ( posFromRight % 4 == 0 ) sum = sum + 6 ; } } if ( sum % 10 == 0 ) return true ; return false ; }
"static void substringConversions ( String str , int k , int b ) { for ( int i = 0 ; i + k <= str . length ( ) ; i ++ ) { String sub = str . substring ( i , i + k ) ; int sum = 0 , counter = 0 ; for ( int j = sub . length ( ) - 1 ; j >= 0 ; j -- ) { sum = ( int ) ( sum + ( ( sub . charAt ( j ) - '0' ) * Math . pow ( b , counter ) ) ) ; counter ++ ; } System . out . print ( sum + "" "" ) ; } }"
"static boolean isProduct ( int arr [ ] , int n , int x ) { HashSet < Integer > hset = new HashSet < > ( ) ; if ( n < 2 ) return false ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { if ( x == 0 ) return true ; else continue ; } if ( x % arr [ i ] == 0 ) { if ( hset . contains ( x / arr [ i ] ) ) return true ; hset . add ( arr [ i ] ) ; } } return false ; }"
"static boolean isPossible ( int l , int m , int x , int y ) { if ( l * m == x + y ) return true ; return false ; }"
"static long calc ( long n , long factor ) { long answer = n ; while ( n / factor > 0 ) { answer += n / factor ; n /= factor ; } return answer ; }"
"static int countPaths ( int n , int m ) { int dp [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; return dp [ n ] [ m ] ; }"
"public static int solve ( int [ ] [ ] dp , int wt , int K , int M , int used ) { if ( wt < 0 ) { return 0 ; } if ( wt == 0 ) { if ( used == 1 ) { return 1 ; } return 0 ; } if ( dp [ wt ] [ used ] != - 1 ) { return dp [ wt ] [ used ] ; } int ans = 0 ; for ( int i = 1 ; i <= K ; i ++ ) { if ( i >= M ) { ans += solve ( dp , wt - i , K , M , used | 1 ) ; } else { ans += solve ( dp , wt - i , K , M , used ) ; } } return dp [ wt ] [ used ] = ans ; }"
"static int evenFibSum ( int limit ) { if ( limit < 2 ) return 0 ; long ef1 = 0 , ef2 = 2 ; long sum = ef1 + ef2 ; while ( ef2 <= limit ) { long ef3 = 4 * ef2 + ef1 ; if ( ef3 > limit ) break ; ef1 = ef2 ; ef2 = ef3 ; sum += ef2 ; } return ( int ) sum ; }"
static boolean isDivisiblePalindrome ( int n ) { int hash [ ] = new int [ 10 ] ; int digitSum = 0 ; while ( n != 0 ) { digitSum += n % 10 ; hash [ n % 10 ] ++ ; n /= 10 ; } if ( digitSum % 3 != 0 ) return false ; int oddCount = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( hash [ i ] % 2 != 0 ) oddCount ++ ; } if ( oddCount > 1 ) return false ; else return true ; }
static int TrialDivision ( int N ) { int i = 2 ; int k = ( int ) Math . ceil ( Math . sqrt ( N ) ) ; while ( i <= k ) { if ( N % i == 0 ) return 0 ; i += 1 ; } return 1 ; }
"static int findGreatest ( int [ ] arr , int n ) { int result = - 1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ j ] * arr [ k ] == arr [ i ] ) result = Math . max ( result , arr [ i ] ) ; return result ; }"
"public static int indexOfFirstOne ( int arr [ ] , int low , int high ) { while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( arr [ mid ] == 1 && ( mid == 0 || arr [ mid - 1 ] == 0 ) ) return mid ; else if ( arr [ mid ] == 1 ) high = mid - 1 ; else low = mid + 1 ; } return - 1 ; }"
"public static void antiSpiralTraversal ( int m , int n , int a [ ] [ ] ) { int i , k = 0 , l = 0 ; Stack < Integer > stk = new Stack < Integer > ( ) ; while ( k <= m && l <= n ) { for ( i = l ; i <= n ; ++ i ) stk . push ( a [ k ] [ i ] ) ; k ++ ; for ( i = k ; i <= m ; ++ i ) stk . push ( a [ i ] [ n ] ) ; n -- ; if ( k <= m ) { for ( i = n ; i >= l ; -- i ) stk . push ( a [ m ] [ i ] ) ; m -- ; } if ( l <= n ) { for ( i = m ; i >= k ; -- i ) stk . push ( a [ i ] [ l ] ) ; l ++ ; } } while ( ! stk . empty ( ) ) { System . out . print ( stk . peek ( ) + "" "" ) ; stk . pop ( ) ; } }"
"static boolean isPrime ( int a [ ] , int lower , int upper ) { int n = 0 ; for ( int i = lower - 1 ; i <= upper - 1 ; i ++ ) n += a [ i ] ; if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }"
static int count ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i >= 1 && i <= 3 ) dp [ i ] = 1 ; else if ( i == 4 ) dp [ i ] = 2 ; else { dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] ; } } return dp [ n ] ; }
"static int maxTripletSum ( int arr [ ] , int n ) { int maxA = - 100000000 , maxB = - 100000000 ; int maxC = - 100000000 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > maxA ) { maxC = maxB ; maxB = maxA ; maxA = arr [ i ] ; } else if ( arr [ i ] > maxB ) { maxC = maxB ; maxB = arr [ i ] ; } else if ( arr [ i ] > maxC ) maxC = arr [ i ] ; } return ( maxA + maxB + maxC ) ; }"
"static int minSwaps ( String s1 , String s2 ) { int c0 = 0 , c1 = 0 ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { if ( s1 . charAt ( i ) == '0' && s2 . charAt ( i ) == '1' ) { c0 ++ ; } else if ( s1 . charAt ( i ) == '1' && s2 . charAt ( i ) == '0' ) { c1 ++ ; } } int ans = c0 / 2 + c1 / 2 ; if ( c0 % 2 == 0 && c1 % 2 == 0 ) { return ans ; } else if ( ( c0 + c1 ) % 2 == 0 ) { return ans + 2 ; } else { return - 1 ; } }"
"static boolean checkEqualNo ( int m , int n , int a , int b ) { if ( m <= n ) { if ( ( n - m ) % ( a + b ) == 0 ) { return true ; } else { return false ; } } else { return false ; } }"
"public static int kthdigit ( int a , int b , int k ) { int p = ( int ) Math . pow ( a , b ) ; int count = 0 ; while ( p > 0 && count < k ) { int rem = p % 10 ; count ++ ; if ( count == k ) return rem ; p = p / 10 ; } return 0 ; }"
"static int findDelta ( int a , int b , int c , int d ) { return ( b * c - a * d ) / ( d - c ) ; }"
static boolean checkPalindrome ( String str ) { int n = str . length ( ) ; int count = 0 ; for ( int i = 0 ; i < n / 2 ; ++ i ) if ( str . charAt ( i ) != str . charAt ( n - i - 1 ) ) ++ count ; return ( count <= 1 ) ; }
"static float findRadiusOfcircumcircle ( float l , float b ) { if ( l < 0 || b < 0 ) return - 1 ; float radius = ( float ) Math . sqrt ( Math . pow ( l , 2 ) + Math . pow ( b , 2 ) ) / 2 ; return radius ; }"
static boolean allCharactersSame ( String s ) { int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) if ( s . charAt ( i ) != s . charAt ( 0 ) ) return false ; return true ; }
"static int calculateSum ( int n ) { return n * ( int ) ( Math . pow ( n , 2 ) + 3 * n + 5 ) / 3 ; }"
"static int countDivisibleSubseq ( String str , int n ) { int len = str . length ( ) ; int dp [ ] [ ] = new int [ len ] [ n ] ; dp [ 0 ] [ ( str . charAt ( 0 ) - '0' ) % n ] ++ ; for ( int i = 1 ; i < len ; i ++ ) { dp [ i ] [ ( str . charAt ( i ) - '0' ) % n ] ++ ; for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; dp [ i ] [ ( j * 10 + ( str . charAt ( i ) - '0' ) ) % n ] += dp [ i - 1 ] [ j ] ; } } return dp [ len - 1 ] [ 0 ] ; }"
"static long LCM ( int arr [ ] , int n ) { int max_num = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( max_num < arr [ i ] ) { max_num = arr [ i ] ; } } long res = 1 ; int x = 2 ; while ( x <= max_num ) { Vector < Integer > indexes = new Vector < > ( ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] % x == 0 ) { indexes . add ( indexes . size ( ) , j ) ; } } if ( indexes . size ( ) >= 2 ) { for ( int j = 0 ; j < indexes . size ( ) ; j ++ ) { arr [ indexes . get ( j ) ] = arr [ indexes . get ( j ) ] / x ; } res = res * x ; } else { x ++ ; } } for ( int i = 0 ; i < n ; i ++ ) { res = res * arr [ i ] ; } return res ; }"
"static void Divide ( int a , int b ) { long dividend = ( long ) a ; long divisor = ( long ) b ; long sign = ( dividend < 0 ) ^ ( divisor < 0 ) ? - 1 : 1 ; dividend = Math . abs ( dividend ) ; divisor = Math . abs ( divisor ) ; if ( divisor == 0 ) { System . out . println ( ""Cannot Divide by 0"" ) ; return ; } if ( dividend == 0 ) { System . out . println ( a + "" / "" + b + "" is equal to : "" + 0 ) ; return ; } if ( divisor == 1 ) { System . out . println ( a + "" / "" + b + "" is equal to : "" + sign * dividend ) ; return ; } System . out . println ( a + "" / "" + b + "" is equal to : "" + Math . floor ( sign * ( Math . exp ( Math . log ( dividend ) - Math . log ( divisor ) ) ) ) ) ; }"
"static void powerSet ( String str , int index , String curr ) { int n = str . length ( ) ; if ( index == n ) { System . out . println ( curr ) ; return ; } powerSet ( str , index + 1 , curr + str . charAt ( index ) ) ; powerSet ( str , index + 1 , curr ) ; }"
"public static void leastPrimeFactor ( int n ) { int [ ] least_prime = new int [ n + 1 ] ; least_prime [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( least_prime [ i ] == 0 ) { least_prime [ i ] = i ; for ( int j = 2 * i ; j <= n ; j += i ) if ( least_prime [ j ] == 0 ) least_prime [ j ] = i ; } } for ( int i = 1 ; i <= n ; i ++ ) System . out . println ( ""Least Prime factor of "" + + i + "": "" + least_prime [ i ] ) ; }"
"static int minRotation ( int input , int unlock_code ) { int rotation = 0 ; int input_digit , code_digit ; while ( input > 0 || unlock_code > 0 ) { input_digit = input % 10 ; code_digit = unlock_code % 10 ; rotation += Math . min ( Math . abs ( input_digit - code_digit ) , 10 - Math . abs ( input_digit - code_digit ) ) ; input /= 10 ; unlock_code /= 10 ; } return rotation ; }"
"static int getMaxGold ( int gold [ ] [ ] , int m , int n ) { int goldTable [ ] [ ] = new int [ m ] [ n ] ; for ( int [ ] rows : goldTable ) Arrays . fill ( rows , 0 ) ; for ( int col = n - 1 ; col >= 0 ; col -- ) { for ( int row = 0 ; row < m ; row ++ ) { int right = ( col == n - 1 ) ? 0 : goldTable [ row ] [ col + 1 ] ; int right_up = ( row == 0 || col == n - 1 ) ? 0 : goldTable [ row - 1 ] [ col + 1 ] ; int right_down = ( row == m - 1 || col == n - 1 ) ? 0 : goldTable [ row + 1 ] [ col + 1 ] ; goldTable [ row ] [ col ] = gold [ row ] [ col ] + Math . max ( right , Math . max ( right_up , right_down ) ) ; ; } } int res = goldTable [ 0 ] [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) res = Math . max ( res , goldTable [ i ] [ 0 ] ) ; return res ; }"
"static int calculateSum ( int n ) { int r1 = 2 , r2 = 3 ; int a1 = 1 , a2 = 1 ; return ( int ) ( a1 * ( Math . pow ( r1 , n ) - 1 ) / ( r1 - 1 ) + a2 * ( Math . pow ( r2 , n ) - 1 ) / ( r2 - 1 ) ) ; }"
"static int findCountOfPairs ( int a , int b , int n ) { int ans = 0 ; ans += n * ( a / n ) * ( b / n ) ; ans += ( a / n ) * ( b % n ) ; ans += ( a % n ) * ( b / n ) ; ans += ( ( a % n ) + ( b % n ) ) / n ; return ans ; }"
static int getPeriod ( int n ) { int rem = 1 ; for ( int i = 1 ; i <= n + 1 ; i ++ ) rem = ( 10 * rem ) % n ; int d = rem ; int count = 0 ; do { rem = ( 10 * rem ) % n ; count ++ ; } while ( rem != d ) ; return count ; }
"static void printDistinct ( int arr [ ] ) { HashSet < Integer > set = new HashSet < > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( ! set . contains ( arr [ i ] ) ) { set . add ( arr [ i ] ) ; System . out . print ( arr [ i ] + "" "" ) ; } } }"
"static int findExtra ( int arr1 [ ] , int arr2 [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return i ; return n ; }"
"static float geometricMean ( int [ ] arr , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + ( float ) Math . log ( arr [ i ] ) ; sum = sum / n ; return ( float ) Math . exp ( sum ) ; }"
static int countNumber ( int n ) { int result = 0 ; for ( int i = 1 ; i <= 9 ; i ++ ) { Stack < Integer > s = new Stack < > ( ) ; if ( i <= n ) { s . push ( i ) ; result ++ ; } while ( ! s . empty ( ) ) { int tp = s . peek ( ) ; s . pop ( ) ; for ( int j = tp % 10 ; j <= 9 ; j ++ ) { int x = tp * 10 + j ; if ( x <= n ) { s . push ( x ) ; result ++ ; } } } } return result ; }
"static int minimumMoves ( int k , int l , int r ) { int count = r - l + 1 ; if ( count % k == 0 ) return 0 ; return ( k - ( count % k ) ) ; }"
"static boolean checkConcurrent ( int a1 , int b1 , int c1 , int a2 , int b2 , int c2 , int a3 , int b3 , int c3 ) { return ( a3 * ( b1 * c2 - b2 * c1 ) + b3 * ( c1 * a2 - c2 * a1 ) + c3 * ( a1 * b2 - a2 * b1 ) == 0 ) ; }"
"static void kSmallestPair ( int arr1 [ ] , int n1 , int arr2 [ ] , int n2 , int k ) { if ( k > n1 * n2 ) { System . out . print ( ""k pairs don't exist"" ) ; return ; } int index2 [ ] = new int [ n1 ] ; while ( k > 0 ) { int min_sum = Integer . MAX_VALUE ; int min_index = 0 ; for ( int i1 = 0 ; i1 < n1 ; i1 ++ ) { if ( index2 [ i1 ] < n2 && arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] < min_sum ) { min_index = i1 ; min_sum = arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] ; } } System . out . print ( ""("" + arr1 [ min_index ] + "", "" + arr2 [ index2 [ min_index ] ] + "") "" ) ; index2 [ min_index ] ++ ; k -- ; } }"
"static int Series ( int Arr [ ] , int N , int K ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( Arr [ i ] == 1 ) count ++ ; if ( K >= ( N - count ) ) return 1 ; else return 0 ; }"
static float trianglearea ( float r ) { if ( r < 0 ) return - 1 ; return r * r ; }
"static int missingNum ( int arr [ ] , int n ) { List < Integer > list = new ArrayList < > ( arr . length ) ; for ( int i : arr ) { list . add ( Integer . valueOf ( i ) ) ; } int minvalue = Collections . min ( list ) ; ; int xornum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xornum ^= ( minvalue ) ^ arr [ i ] ; minvalue ++ ; } return xornum ^ minvalue ; }"
"static int countSeq ( int n ) { int nCr = 1 , res = 1 ; for ( int r = 1 ; r <= n ; r ++ ) { nCr = ( nCr * ( n + 1 - r ) ) / r ; res += nCr * nCr ; } return res ; }"
static int countIntegralSolutions ( int n ) { return ( ( n + 1 ) * ( n + 2 ) ) / 2 ; }
"static int minimumX ( int n , int k ) { int mini = Integer . MAX_VALUE ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { int fir = i ; int sec = n / i ; int num1 = fir * k + sec ; int res = ( num1 / k ) * ( num1 % k ) ; if ( res == n ) mini = Math . min ( num1 , mini ) ; int num2 = sec * k + fir ; res = ( num2 / k ) * ( num2 % k ) ; if ( res == n ) mini = Math . min ( num2 , mini ) ; } } return mini ; }"
"static void printRepeating ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int index = arr [ i ] % n ; arr [ index ] += n ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] / n ) > 1 ) System . out . println ( i + "" "" ) ; } }"
"static int distribution ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int count = 1 ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) count ++ ; return Math . min ( count , n / 2 ) ; }"
static int multiplyWith4 ( int n ) { return ( n << 2 ) ; }
"public static int Largercount ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int count = 0 ; HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < m ; i ++ ) { int key = arr1 [ i ] ; if ( mp . containsKey ( key ) ) { int freq = mp . get ( key ) ; freq ++ ; mp . put ( key , freq ) ; } else mp . put ( key , 1 ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( arr2 [ i ] ) && mp . get ( arr2 [ i ] ) != 0 ) { int freq = mp . get ( arr2 [ i ] ) ; freq -- ; mp . put ( arr2 [ i ] , freq ) ; } } for ( int i = 0 ; i < m ; i ++ ) { if ( mp . get ( arr1 [ i ] ) != 0 ) { count ++ ; mp . put ( arr1 [ i ] , 0 ) ; } } return count ; }"
"public static void cycleSort ( int arr [ ] , int n ) { int writes = 0 ; for ( int cycle_start = 0 ; cycle_start <= n - 2 ; cycle_start ++ ) { int item = arr [ cycle_start ] ; int pos = cycle_start ; for ( int i = cycle_start + 1 ; i < n ; i ++ ) if ( arr [ i ] < item ) pos ++ ; if ( pos == cycle_start ) continue ; while ( item == arr [ pos ] ) pos += 1 ; if ( pos != cycle_start ) { int temp = item ; item = arr [ pos ] ; arr [ pos ] = temp ; writes ++ ; } while ( pos != cycle_start ) { pos = cycle_start ; for ( int i = cycle_start + 1 ; i < n ; i ++ ) if ( arr [ i ] < item ) pos += 1 ; while ( item == arr [ pos ] ) pos += 1 ; if ( item != arr [ pos ] ) { int temp = item ; item = arr [ pos ] ; arr [ pos ] = temp ; writes ++ ; } } } }"
"static int maxOperations ( String str ) { int i , g , gk , gks ; i = g = gk = gks = 0 ; for ( i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == 'g' ) { g ++ ; } else if ( str . charAt ( i ) == 'k' ) { if ( g > 0 ) { g -- ; gk ++ ; } } else if ( str . charAt ( i ) == 's' ) { if ( gk > 0 ) { gk -- ; gks ++ ; } } } return gks ; }"
public static int kthgroupsum ( int k ) { return k * k * k ; }
"static void solve ( int n , ArrayList < Integer > data ) { ArrayList < Integer > max = new ArrayList < Integer > ( ) ; max . add ( data . get ( 0 ) ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( max . get ( i - 1 ) > 0 ) max . add ( max . get ( i - 1 ) + data . get ( i ) ) ; else max . add ( data . get ( i ) ) ; } System . out . println ( Collections . max ( max ) ) ; }"
"static int uniqueNumbers ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int freq [ ] = new int [ n + 2 ] ; for ( int i = 0 ; i < n + 2 ; i ++ ) freq [ i ] = 0 ; for ( int x = 0 ; x < n ; x ++ ) { if ( freq [ arr [ x ] - 1 ] == 0 ) { freq [ arr [ x ] - 1 ] ++ ; } else if ( freq [ arr [ x ] ] == 0 ) { freq [ arr [ x ] ] ++ ; } else { freq [ arr [ x ] + 1 ] ++ ; } } int unique = 0 ; for ( int x = 0 ; x <= n + 1 ; x ++ ) { if ( freq [ x ] != 0 ) { unique ++ ; } } return unique ; }"
"static double Probability ( double p [ ] , int n ) { double [ ] [ ] dp = new double [ n + 1 ] [ n + 1 ] ; dp [ 0 ] [ 0 ] = 1.0 ; for ( int i = 1 ; i <= n ; i += 1 ) { for ( int j = 0 ; j <= i ; j += 1 ) { if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] * ( 1.0 - p [ i ] ) ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] * ( 1.0 - p [ i ] ) + dp [ i - 1 ] [ j - 1 ] * p [ i ] ; } } double ans = 0.0 ; for ( int i = ( n + 1 ) / 2 ; i <= n ; i += 1 ) ans += dp [ n ] [ i ] ; return ans ; }"
"static int max_intersection ( int center [ ] , int length , int k ) { Arrays . sort ( center ) ; if ( center [ 2 ] - center [ 0 ] >= 2 * k + length ) { return 0 ; } else if ( center [ 2 ] - center [ 0 ] >= 2 * k ) { return ( 2 * k - ( center [ 2 ] - center [ 0 ] - length ) ) ; } else return length ; }"
"static int countMinimalReplacements ( char [ ] s ) { int n = s . length ; int cnt = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { cnt += 1 ; if ( i != ( n - 1 ) ) { for ( char it : ""012"" . toCharArray ( ) ) { if ( it != s [ i + 1 ] && it != s [ i - 1 ] ) { s [ i ] = it ; break ; } } } else { for ( char it : ""012"" . toCharArray ( ) ) { if ( it != s [ i - 1 ] ) { s [ i ] = it ; break ; } } } } } return cnt ; }"
"static int floorSqrt ( int x ) { if ( x == 0 || x == 1 ) return x ; int i = 1 , result = 1 ; while ( result <= x ) { i ++ ; result = i * i ; } return i - 1 ; }"
"static int maxZeros ( int N ) { int maxm = - 1 ; int cnt = 0 ; while ( N != 0 ) { if ( ( N & 1 ) == 0 ) { cnt ++ ; N >>= 1 ; maxm = Math . max ( maxm , cnt ) ; } else { maxm = Math . max ( maxm , cnt ) ; cnt = 0 ; N >>= 1 ; } } return maxm ; }"
"static int minSwap ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) if ( arr [ i ] <= k ) ++ count ; int bad = 0 ; for ( int i = 0 ; i < count ; ++ i ) if ( arr [ i ] > k ) ++ bad ; int ans = bad ; for ( int i = 0 , j = count ; j < n ; ++ i , ++ j ) { if ( arr [ i ] > k ) -- bad ; if ( arr [ j ] > k ) ++ bad ; ans = Math . min ( ans , bad ) ; } return ans ; }"
"static boolean isSubsetSum ( int arr [ ] , int n , int sum ) { boolean subset [ ] [ ] = new boolean [ 2 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= sum ; j ++ ) { if ( j == 0 ) subset [ i % 2 ] [ j ] = true ; else if ( i == 0 ) subset [ i % 2 ] [ j ] = false ; else if ( arr [ i - 1 ] <= j ) subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] || subset [ ( i + 1 ) % 2 ] [ j ] ; else subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] ; } } return subset [ n % 2 ] [ sum ] ; }"
"static int findSubsequenceCount ( String S , String T ) { int m = T . length ( ) ; int n = S . length ( ) ; if ( m > n ) return 0 ; int mat [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) mat [ i ] [ 0 ] = 0 ; for ( int j = 0 ; j <= n ; j ++ ) mat [ 0 ] [ j ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( T . charAt ( i - 1 ) != S . charAt ( j - 1 ) ) mat [ i ] [ j ] = mat [ i ] [ j - 1 ] ; else mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ; } } return mat [ m ] [ n ] ; }"
"static int nthTerm ( int n ) { return ( int ) Math . pow ( n , 2 ) - 2 * n + 2 ; }"
"static boolean isTriangular ( int num ) { if ( num < 0 ) return false ; int c = ( - 2 * num ) ; int b = 1 , a = 1 ; int d = ( b * b ) - ( 4 * a * c ) ; if ( d < 0 ) return false ; float root1 = ( - b + ( float ) Math . sqrt ( d ) ) / ( 2 * a ) ; float root2 = ( - b - ( float ) Math . sqrt ( d ) ) / ( 2 * a ) ; if ( root1 > 0 && Math . floor ( root1 ) == root1 ) return true ; if ( root2 > 0 && Math . floor ( root2 ) == root2 ) return true ; return false ; }"
"public static int middleOfThree ( int a , int b , int c ) { int x = a - b ; int y = b - c ; int z = a - c ; if ( x * y > 0 ) return b ; else if ( x * z > 0 ) return c ; else return a ; }"
"static void CountingEvenOdd ( int arr [ ] , int arr_size ) { int even_count = 0 ; int odd_count = 0 ; for ( int i = 0 ; i < arr_size ; i ++ ) { if ( ( arr [ i ] & 1 ) == 1 ) odd_count ++ ; else even_count ++ ; } System . out . println ( ""Number of even"" + "" elements = "" + even_count + "" Number of odd elements = "" + odd_count ) ; }"
"static int maxSquareSubsetSum ( int [ ] A , int N ) { int sub1 = 0 , sub2 = 0 ; Arrays . sort ( A ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( i < ( N / 2 ) - 1 ) sub1 += A [ i ] ; else sub2 += A [ i ] ; } return sub1 * sub1 + sub2 * sub2 ; }"
"static Vector < Integer > Diffs ( int [ ] a , int k ) { Vector < Integer > out = new Vector < Integer > ( ) ; int [ ] inc , dec ; inc = new int [ a . length ] ; dec = new int [ a . length ] ; int inc_sum = 0 ; int dec_sum = 0 ; for ( int i = 0 ; i < a . length ; ++ i ) { for ( int j = i - 1 ; j >= 0 && j > i - k && a [ j + 1 ] > a [ j ] ; -- j ) { ++ inc [ j ] ; ++ inc_sum ; } for ( int j = i - 1 ; j >= 0 && j > i - k && a [ j + 1 ] < a [ j ] ; -- j ) { ++ dec [ j ] ; ++ dec_sum ; } if ( i >= k - 1 ) { if ( i >= k ) { inc_sum -= inc [ i - k ] ; dec_sum -= dec [ i - k ] ; } out . add ( inc_sum - dec_sum ) ; } } return out ; }"
"static String removeDuplicate ( char str [ ] , int n ) { int index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < i ; j ++ ) { if ( str [ i ] == str [ j ] ) { break ; } } if ( j == i ) { str [ index ++ ] = str [ i ] ; } } return String . valueOf ( Arrays . copyOf ( str , index ) ) ; }"
int hexagonalNum ( int n ) { return n * ( 2 * n - 1 ) ; }
static int setBitNumber ( int n ) { if ( n == 0 ) return 0 ; int msb = 0 ; while ( n != 0 ) { n = n / 2 ; msb ++ ; } return ( 1 << msb ) ; }
"static void TwentyoneMatchstick ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i += 1 ) { System . out . print ( 5 - arr [ i ] + "" "" ) ; } System . out . println ( ) ; }"
"static boolean arraySortedOrNot ( int arr [ ] , int n ) { if ( n == 0 || n == 1 ) return true ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ; return true ; }"
"static int maxSumWO3Consec ( int arr [ ] , int n ) { int sum [ ] = new int [ n ] ; if ( n >= 1 ) sum [ 0 ] = arr [ 0 ] ; if ( n >= 2 ) sum [ 1 ] = arr [ 0 ] + arr [ 1 ] ; if ( n > 2 ) sum [ 2 ] = Math . max ( sum [ 1 ] , Math . max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) ; for ( int i = 3 ; i < n ; i ++ ) sum [ i ] = Math . max ( Math . max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) ; return sum [ n - 1 ] ; }"
"static long findSum ( int n ) { long sum2 , sum5 , sum10 ; sum2 = ( ( n / 2 ) * ( 4 + ( n / 2 - 1 ) * 2 ) ) / 2 ; sum5 = ( ( n / 5 ) * ( 10 + ( n / 5 - 1 ) * 5 ) ) / 2 ; sum10 = ( ( n / 10 ) * ( 20 + ( n / 10 - 1 ) * 10 ) ) / 2 ; return sum2 + sum5 - sum10 ; }"
static boolean isAnyNotPalindrome ( String s ) { Set < Character > unique = new HashSet < Character > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) unique . add ( s . charAt ( i ) ) ; if ( unique . size ( ) > 1 ) return true ; else return false ; }
"static int Count_subarray ( int arr [ ] , int n ) { int total_sum = 0 , subarray_sum , remaining_sum , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { total_sum += arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { subarray_sum = 0 ; for ( int j = i ; j < n ; j ++ ) { subarray_sum += arr [ j ] ; remaining_sum = total_sum - subarray_sum ; if ( subarray_sum > remaining_sum ) { count += 1 ; } } } return count ; }"
"void printRepeating ( int arr [ ] , int size ) { int xor = arr [ 0 ] ; int set_bit_no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor ^= arr [ i ] ; for ( i = 1 ; i <= n ; i ++ ) xor ^= i ; set_bit_no = ( xor & ~ ( xor - 1 ) ) ; for ( i = 0 ; i < size ; i ++ ) { int a = arr [ i ] & set_bit_no ; if ( a != 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } for ( i = 1 ; i <= n ; i ++ ) { int a = i & set_bit_no ; if ( a != 0 ) x = x ^ i ; else y = y ^ i ; } System . out . println ( ""The two reppeated elements are :"" ) ; System . out . println ( x + "" "" + y ) ; }"
static int intersection ( int n ) { return n * ( n - 1 ) ; }
"static int countWays ( int N ) { if ( N == 1 ) return 4 ; int countB = 1 , countS = 1 , prev_countB , prev_countS ; for ( int i = 2 ; i <= N ; i ++ ) { prev_countB = countB ; prev_countS = countS ; countS = prev_countB + prev_countS ; countB = prev_countS ; } int result = countS + countB ; return ( result * result ) ; }"
"static int pairAndSum ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] & arr [ j ] ; return ans ; }"
"static int minXOR ( int arr [ ] , int n ) { int min_xor = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) min_xor = Math . min ( min_xor , arr [ i ] ^ arr [ j ] ) ; return min_xor ; }"
"static void section ( double x1 , double x2 , double y1 , double y2 , double m , double n ) { double x = ( ( n * x1 ) + ( m * x2 ) ) / ( m + n ) ; double y = ( ( n * y1 ) + ( m * y2 ) ) / ( m + n ) ; System . out . println ( ""("" + x + "", "" + y + "")"" ) ; }"
"static int maxOR ( int arr [ ] , int n ) { int maxVal = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) { maxVal = Math . max ( maxVal , arr [ i ] | arr [ j ] ) ; } return maxVal ; }"
"static void generateSequence ( int n , int g ) { for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( i * g + "" "" ) ; ; }"
"static void squareRoot ( int n , int p ) { n = n % p ; for ( int x = 2 ; x < p ; x ++ ) { if ( ( x * x ) % p == n ) { System . out . println ( ""Square "" + ""root is "" + x ) ; return ; } } System . out . println ( ""Square root "" + ""doesn't exist"" ) ; }"
static int checkSparse ( int n ) { if ( ( n & ( n >> 1 ) ) >= 1 ) return 0 ; return 1 ; }
"static int GetMinSubarrayLength ( int a [ ] , int n ) { int ans = Math . max ( a [ 0 ] , a [ n - 1 ] ) ; int lo = 0 , hi = n - 1 ; while ( lo < n && a [ lo ] % ans == 0 ) lo ++ ; while ( hi > lo && a [ hi ] % ans == 0 ) hi -- ; return ( hi - lo + 1 ) ; }"
static void translate ( char str [ ] ) { int len = str . length ; if ( len < 2 ) return ; int i = 0 ; int j = 0 ; while ( j < len - 1 ) { if ( str [ j ] == 'A' && str [ j + 1 ] == 'B' ) { j = j + 2 ; str [ i ++ ] = 'C' ; continue ; } str [ i ++ ] = str [ j ++ ] ; } if ( j == len - 1 ) str [ i ++ ] = str [ j ] ; str [ i ] = ' ' ; str [ len - 1 ] = ' ' ; }
"static void printIndex ( String str , String s ) { boolean flag = false ; for ( int i = 0 ; i < str . length ( ) - s . length ( ) + 1 ; i ++ ) { if ( str . substring ( i , i + s . length ( ) ) . equals ( s ) ) { System . out . print ( i + "" "" ) ; flag = true ; } } if ( flag == false ) { System . out . println ( ""NONE"" ) ; } }"
"static float area ( float a , float b ) { if ( a < 0 || b < 0 ) return - 1 ; float A = a * b ; return A ; }"
"static int longestSubarray ( int a [ ] , int n ) { int hash [ ] [ ] = new int [ n ] [ 10 ] ; for ( int i = 0 ; i < n ; i ++ ) { int num = a [ i ] ; while ( num != 0 ) { hash [ i ] [ num % 10 ] = 1 ; num /= 10 ; } } int longest = Integer . MIN_VALUE ; int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int j ; for ( j = 0 ; j < 10 ; j ++ ) { if ( hash [ i ] [ j ] == 1 & hash [ i + 1 ] [ j ] == 1 ) { count ++ ; break ; } } if ( j == 10 ) { longest = Math . max ( longest , count + 1 ) ; count = 0 ; } } longest = Math . max ( longest , count + 1 ) ; return longest ; }"
"static int maxSumBitonicSubArr ( int arr [ ] , int n ) { int [ ] msis = new int [ n ] ; int [ ] msds = new int [ n ] ; int max_sum = Integer . MIN_VALUE ; msis [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) msis [ i ] = msis [ i - 1 ] + arr [ i ] ; else msis [ i ] = arr [ i ] ; msds [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) if ( arr [ i ] > arr [ i + 1 ] ) msds [ i ] = msds [ i + 1 ] + arr [ i ] ; else msds [ i ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) max_sum = msis [ i ] + msds [ i ] - arr [ i ] ; return max_sum ; }"
"static long minimumMoves ( int a [ ] , int n ) { long operations = 0 ; Arrays . sort ( a ) ; for ( int i = 0 ; i < n ; i ++ ) operations += ( long ) Math . abs ( a [ i ] - ( i + 1 ) ) ; return operations ; }"
"static int countMinimumMoves ( int arr [ ] , int n , int k ) { int i ; for ( i = k - 1 ; i < n ; i ++ ) if ( arr [ i ] != arr [ k - 1 ] ) return - 1 ; for ( i = k - 1 ; i >= 0 ; i -- ) if ( arr [ i ] != arr [ k - 1 ] ) return i + 1 ; return 0 ; }"
"static int pad ( int n ) { int pPrevPrev = 1 , pPrev = 1 , pCurr = 1 , pNext = 1 ; for ( int i = 3 ; i <= n ; i ++ ) { pNext = pPrevPrev + pPrev ; pPrevPrev = pPrev ; pPrev = pCurr ; pCurr = pNext ; } return pNext ; }"
"public static long SubArraySum ( int arr [ ] , int n ) { long result = 0 , temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { temp = 0 ; for ( int j = i ; j < n ; j ++ ) { temp += arr [ j ] ; result += temp ; } } return result ; }"
"static int maxSelectionCount ( int a [ ] , int n ) { int res = 0 ; Arrays . sort ( a ) ; int select = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= select ) { res ++ ; select ++ ; } } return res ; }"
static boolean isDivisible ( long n ) { while ( n / 100 > 0 ) { long d = n % 10 ; n /= 10 ; n += d * 2 ; } return ( n % 19 == 0 ) ; }
"static int countNonIncreasing ( int arr [ ] , int n ) { int cnt = 0 ; int len = 1 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( arr [ i + 1 ] >= arr [ i ] ) len ++ ; else { cnt += ( ( ( len + 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += ( ( ( len - 1 ) * len ) / 2 ) ; return cnt ; }"
"public static void oddEvenSort ( int arr [ ] , int n ) { boolean isSorted = false ; while ( ! isSorted ) { isSorted = true ; int temp = 0 ; for ( int i = 1 ; i <= n - 2 ; i = i + 2 ) { if ( arr [ i ] > arr [ i + 1 ] ) { temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; isSorted = false ; } } for ( int i = 0 ; i <= n - 2 ; i = i + 2 ) { if ( arr [ i ] > arr [ i + 1 ] ) { temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; isSorted = false ; } } } return ; }"
"static String smallest ( String s ) { int l = s . length ( ) ; String ans = """" ; for ( int i = 0 ; i < l - 1 ; i ++ ) { if ( s . charAt ( i ) > s . charAt ( i + 1 ) ) { for ( int j = 0 ; j < l ; j ++ ) { if ( i != j ) { ans += s . charAt ( j ) ; } } return ans ; } } ans = s . substring ( 0 , l - 1 ) ; return ans ; }"
static boolean isTriangular ( int num ) { if ( num < 0 ) return false ; int sum = 0 ; for ( int n = 1 ; sum <= num ; n ++ ) { sum = sum + n ; if ( sum == num ) return true ; } return false ; }
"static void countPair ( int arr [ ] , int n , int k ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = ( arr [ i ] + k ) % k ; } int hash [ ] = new int [ k ] ; for ( int i = 0 ; i < n ; i ++ ) { hash [ arr [ i ] ] ++ ; } for ( int i = 0 ; i < k ; i ++ ) { cnt += ( hash [ i ] * ( hash [ i ] - 1 ) ) / 2 ; } System . out . print ( cnt + ""\n"" ) ; }"
"static int unitDigitXRaisedY ( int x , int y ) { int res = 1 ; for ( int i = 0 ; i < y ; i ++ ) res = ( res * x ) % 10 ; return res ; }"
static boolean isBinary ( int number ) { while ( number > 0 ) { int digit = number % 10 ; if ( digit > 1 ) return false ; number /= 10 ; } return true ; }
static int findNthOddDigitNumber ( int n ) { int count = 0 ; for ( int i = 1 ; ; i ++ ) { int num = i ; boolean isMadeOfOdd = true ; while ( num != 0 ) { if ( num % 10 == 0 || num % 10 == 2 || num % 10 == 4 || num % 10 == 6 || num % 10 == 8 ) { isMadeOfOdd = false ; break ; } num = num / 10 ; } if ( isMadeOfOdd == true ) count ++ ; if ( count == n ) return i ; } }
static double square ( double a ) { if ( a < 0 ) return - 1 ; double x = 0.464 * a ; return x ; }
"public static int minRemove ( int a [ ] , int b [ ] , int n , int m ) { HashMap < Integer , Integer > countA = new HashMap < Integer , Integer > ( ) ; HashMap < Integer , Integer > countB = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( countA . containsKey ( a [ i ] ) ) countA . put ( a [ i ] , countA . get ( a [ i ] ) + 1 ) ; else countA . put ( a [ i ] , 1 ) ; } for ( int i = 0 ; i < m ; i ++ ) { if ( countB . containsKey ( b [ i ] ) ) countB . put ( b [ i ] , countB . get ( b [ i ] ) + 1 ) ; else countB . put ( b [ i ] , 1 ) ; } int res = 0 ; Set < Integer > s = countA . keySet ( ) ; for ( int x : s ) if ( countB . containsKey ( x ) ) res += Math . min ( countB . get ( x ) , countA . get ( x ) ) ; return res ; }"
"static double maxArea ( double a , double b , double c , double d ) { double semiperimeter = ( a + b + c + d ) / 2 ; return Math . sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) ; }"
"static void reverse ( int [ ] a , int n , int k ) { if ( k > n ) { System . out . println ( ""Invalid k"" ) ; return ; } for ( int i = 0 ; i < k / 2 ; i ++ ) { int tempswap = a [ i ] ; a [ i ] = a [ k - i - 1 ] ; a [ k - i - 1 ] = tempswap ; } }"
"static void modularInverse ( int n , int prime ) { int dp [ ] = new int [ n + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = dp [ prime % i ] * ( prime - prime / i ) % prime ; for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( dp [ i ] + "" "" ) ; }"
"static int getCount ( int arr [ ] , int n , int num1 , int num2 ) { int i = 0 ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == num1 ) break ; if ( i >= n - 1 ) return 0 ; int j ; for ( j = n - 1 ; j >= i + 1 ; j -- ) if ( arr [ j ] == num2 ) break ; if ( j == i ) return 0 ; return ( j - i - 1 ) ; }"
"static void countFreq ( int arr [ ] , int n ) { Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) == null ? 1 : mp . get ( arr [ i ] ) + 1 ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( mp . get ( arr [ i ] ) != - 1 ) { System . out . println ( arr [ i ] + "" "" + mp . get ( arr [ i ] ) ) ; mp . put ( arr [ i ] , - 1 ) ; } } }"
"static void gnomeSort ( int arr [ ] , int n ) { int index = 0 ; while ( index < n ) { if ( index == 0 ) index ++ ; if ( arr [ index ] >= arr [ index - 1 ] ) index ++ ; else { int temp = 0 ; temp = arr [ index ] ; arr [ index ] = arr [ index - 1 ] ; arr [ index - 1 ] = temp ; index -- ; } } return ; }"
"static void printCount ( int a [ ] [ ] , int n , int m , int z [ ] , int l ) { for ( int i = 0 ; i < n ; i ++ ) { Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int j = 0 ; j < m ; j ++ ) mp . put ( a [ i ] [ j ] , 1 ) ; int count = 0 ; for ( int j = 0 ; j < l ; j ++ ) { if ( mp . containsKey ( z [ j ] ) ) count += 1 ; } System . out . println ( ""row"" + ( i + 1 ) + "" = "" + count ) ; } }"
"static void reverse ( String k ) { Stack < String > s = new Stack < > ( ) ; String [ ] token = k . split ( "" "" ) ; for ( int i = 0 ; i < token . length ; i ++ ) { s . push ( token [ i ] ) ; } while ( ! s . empty ( ) ) { System . out . print ( s . peek ( ) + "" "" ) ; s . pop ( ) ; } }"
"static int maxSumArrangement ( int A [ ] , int R [ ] [ ] , int N , int M ) { int count [ ] = new int [ N ] ; int i ; for ( i = 0 ; i < M ; ++ i ) { int l = R [ i ] [ 0 ] , r = R [ i ] [ 1 ] + 1 ; l -- ; r -- ; count [ l ] ++ ; if ( r < N ) count [ r ] -- ; } for ( i = 1 ; i < N ; ++ i ) { count [ i ] += count [ i - 1 ] ; } int ans = 0 ; Arrays . sort ( count ) ; Arrays . sort ( A ) ; for ( i = N - 1 ; i >= 0 ; -- i ) { ans += A [ i ] * count [ i ] ; } return ans ; }"
"static void tower ( int n , char sourcePole , char destinationPole , char auxiliaryPole ) { if ( 0 == n ) return ; tower ( n - 1 , sourcePole , auxiliaryPole , destinationPole ) ; System . out . printf ( ""Move the disk %d from %c to %c\n"" , n , sourcePole , destinationPole ) ; tower ( n - 1 , auxiliaryPole , destinationPole , sourcePole ) ; }"
"static void solve ( int arr [ ] , int n , int k ) { HashMap < Integer , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! m . containsKey ( arr [ i ] ) ) m . put ( arr [ i ] , 0 ) ; m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; } int max = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( m . get ( arr [ i ] ) == k && max == Integer . MIN_VALUE ) { max = arr [ i ] ; } else if ( m . get ( arr [ i ] ) == k && max < arr [ i ] ) { max = arr [ i ] ; } } if ( max == Integer . MIN_VALUE ) System . out . println ( ""No such element"" ) ; else System . out . println ( max ) ; }"
"static int maxSquare ( int b , int m ) { return ( b / m - 1 ) * ( b / m ) / 2 ; }"
"static int optimalStrategyOfGame ( int arr [ ] , int n ) { int table [ ] [ ] = new int [ n ] [ n ] ; int gap , i , j , x , y , z ; for ( gap = 0 ; gap < n ; ++ gap ) { for ( i = 0 , j = gap ; j < n ; ++ i , ++ j ) { x = ( ( i + 2 ) <= j ) ? table [ i + 2 ] [ j ] : 0 ; y = ( ( i + 1 ) <= ( j - 1 ) ) ? table [ i + 1 ] [ j - 1 ] : 0 ; z = ( i <= ( j - 2 ) ) ? table [ i ] [ j - 2 ] : 0 ; table [ i ] [ j ] = Math . max ( arr [ i ] + Math . min ( x , y ) , arr [ j ] + Math . min ( y , z ) ) ; } } return table [ 0 ] [ n - 1 ] ; }"
"static int discreteLogarithm ( int a , int b , int m ) { int n = ( int ) ( Math . sqrt ( m ) + 1 ) ; int an = 1 ; for ( int i = 0 ; i < n ; ++ i ) an = ( an * a ) % m ; int [ ] value = new int [ m ] ; for ( int i = 1 , cur = an ; i <= n ; ++ i ) { if ( value [ cur ] == 0 ) value [ cur ] = i ; cur = ( cur * an ) % m ; } for ( int i = 0 , cur = b ; i <= n ; ++ i ) { if ( value [ cur ] > 0 ) { int ans = value [ cur ] * n - i ; if ( ans < m ) return ans ; } cur = ( cur * a ) % m ; } return - 1 ; }"
"static void maxLengthArr ( int x , int y ) { boolean [ ] ex = new boolean [ ( 1 << x ) ] ; ex [ 0 ] = true ; Vector < Integer > pre = new Vector < Integer > ( ) ; pre . add ( 0 ) ; for ( int i = 1 ; i < ( 1 << x ) ; i ++ ) { if ( ex [ i ^ y ] ) continue ; pre . add ( i ) ; ex [ i ] = true ; } if ( pre . size ( ) == 1 ) { System . out . print ( ""-1"" ) ; return ; } for ( int i = 1 ; i < pre . size ( ) ; i ++ ) System . out . print ( ( pre . get ( i ) ^ pre . get ( i - 1 ) ) + "" "" ) ; }"
"int subArraySum ( int arr [ ] , int n , int sum ) { int curr_sum , i , j ; for ( i = 0 ; i < n ; i ++ ) { curr_sum = arr [ i ] ; for ( j = i + 1 ; j <= n ; j ++ ) { if ( curr_sum == sum ) { int p = j - 1 ; System . out . println ( ""Sum found between indexes "" + i + "" and "" + p ) ; return 1 ; } if ( curr_sum > sum || j == n ) break ; curr_sum = curr_sum + arr [ j ] ; } } System . out . println ( ""No subarray found"" ) ; return 0 ; }"
static void findTriangles ( int n ) { int num ; num = n * ( n - 4 ) ; System . out . println ( num ) ; }
"static int solve ( String X , String Y , int N , int K ) { int [ ] count = new int [ N + 1 ] ; int sol = 0 ; count [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { count [ i ] = count [ i - 1 ] + Math . abs ( X . charAt ( i - 1 ) - Y . charAt ( i - 1 ) ) ; } int j = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { while ( ( count [ i ] - count [ j ] ) > K ) { j ++ ; } sol = Math . max ( sol , i - j ) ; } return sol ; }"
"static void findSumPairs ( int a [ ] , int n ) { Map < Integer , Integer > mpp = new HashMap < > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { mpp . put ( a [ i ] + a [ j ] , mpp . get ( a [ i ] + a [ j ] ) == null ? 1 : mpp . get ( a [ i ] + a [ j ] ) + 1 ) ; } } int occur = 0 ; for ( Map . Entry < Integer , Integer > entry : mpp . entrySet ( ) ) { if ( entry . getValue ( ) > occur ) { occur = entry . getValue ( ) ; } } for ( Map . Entry < Integer , Integer > entry : mpp . entrySet ( ) ) { if ( entry . getValue ( ) == occur ) System . out . println ( entry . getKey ( ) ) ; } }"
public static int nthTerm ( int N ) { int nth = 0 ; nth = ( N * N * ( N + 1 ) ) / 2 ; return nth ; }
"static int getMinVal ( int p , int q ) { if ( q % p == 0 ) return p ; return - 1 ; }"
"static int count ( int N ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += 7 * Math . pow ( 8 , i - 1 ) ; } return sum ; }"
static int findDigits ( int n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double digits = 0 ; for ( int i = 2 ; i <= n ; i ++ ) digits += Math . log10 ( i ) ; return ( int ) ( Math . floor ( digits ) ) + 1 ; }
"static float squareRoot ( int number , int precision ) { int start = 0 , end = number ; int mid ; double ans = 0.0 ; while ( start <= end ) { mid = ( start + end ) / 2 ; if ( mid * mid == number ) { ans = mid ; break ; } if ( mid * mid < number ) { start = mid + 1 ; ans = mid ; } else { end = mid - 1 ; } } double increment = 0.1 ; for ( int i = 0 ; i < precision ; i ++ ) { while ( ans * ans <= number ) { ans += increment ; } ans = ans - increment ; increment = increment / 10 ; } return ( float ) ans ; }"
"public static int stopping_station ( int p , int n ) { int num = 1 , dem = 1 , s = p ; while ( p != 1 ) { dem *= p ; p -- ; } int t = n - s + 1 ; while ( t != ( n - 2 * s + 1 ) ) { num *= t ; t -- ; } if ( ( n - s + 1 ) >= s ) System . out . print ( num / dem ) ; else System . out . print ( ""not possible"" ) ; return 0 ; }"
"static int cntSubArrays ( int [ ] arr , int n , int k ) { int res = 0 ; int i = 0 ; while ( i < n ) { int j = i + 1 ; while ( j < n && arr [ j ] >= arr [ j - 1 ] ) j ++ ; res += Math . max ( j - i - k + 1 , 0 ) ; i = j ; } return res ; }"
static int countUnmarked ( int N ) { if ( N % 2 == 0 ) return N / 2 ; else return N / 2 + 1 ; }
"static boolean isPossible ( char [ ] str ) { Map < Character , Integer > freq = new HashMap < > ( ) ; int max_freq = 0 ; for ( int j = 0 ; j < ( str . length ) ; j ++ ) { if ( freq . containsKey ( str [ j ] ) ) { freq . put ( str [ j ] , freq . get ( str [ j ] ) + 1 ) ; if ( freq . get ( str [ j ] ) > max_freq ) max_freq = freq . get ( str [ j ] ) ; } else { freq . put ( str [ j ] , 1 ) ; if ( freq . get ( str [ j ] ) > max_freq ) max_freq = freq . get ( str [ j ] ) ; } } if ( max_freq <= ( str . length - max_freq + 1 ) ) return true ; return false ; }"
"static int totalWays ( int N , int M , int X ) { int dp [ ] [ ] = new int [ N + 1 ] [ 2 ] ; if ( X == 1 ) { dp [ 0 ] [ 0 ] = 1 ; } else { dp [ 0 ] [ 1 ] = 0 ; } if ( X == 1 ) { dp [ 1 ] [ 0 ] = 0 ; dp [ 1 ] [ 1 ] = M - 1 ; } else { dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = ( M - 2 ) ; } for ( int i = 2 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] * ( M - 1 ) + dp [ i - 1 ] [ 1 ] * ( M - 2 ) ; } return dp [ N - 1 ] [ 0 ] ; }"
"public static int countDigits ( int a , int b ) { if ( a == 0 || b == 0 ) return 1 ; return ( int ) Math . floor ( Math . log10 ( Math . abs ( a ) ) + Math . log10 ( Math . abs ( b ) ) ) + 1 ; }"
"static boolean find ( String s1 , String s2 ) { int len = s1 . length ( ) , len_1 = s2 . length ( ) ; if ( len != len_1 ) { return false ; } int d [ ] = new int [ len ] ; d [ 0 ] = s2 . charAt ( 0 ) - s1 . charAt ( 0 ) ; for ( int i = 1 ; i < len ; i ++ ) { if ( s1 . charAt ( i ) > s2 . charAt ( i ) ) { return false ; } else { d [ i ] = s2 . charAt ( i ) - s1 . charAt ( i ) ; } } for ( int i = 0 ; i < len - 1 ; i ++ ) { if ( d [ i ] < d [ i + 1 ] ) { return false ; } } return true ; }"
"static void lexicoSmallestPermuatation ( int arr [ ] , int n ) { int cnt [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; ++ i ) { ++ cnt [ arr [ i ] ] ; } int ele = 1 , replacement = 0 ; boolean vis [ ] = new boolean [ n + 1 ] ; for ( int i = 0 ; i < n ; ++ i ) { if ( cnt [ arr [ i ] ] == 1 ) { continue ; } while ( cnt [ ele ] > 0 ) { ++ ele ; } if ( ele > arr [ i ] && ! vis [ arr [ i ] ] ) { vis [ arr [ i ] ] = true ; } else { -- cnt [ arr [ i ] ] ; arr [ i ] = ele ; ++ replacement ; ++ ele ; } } System . out . print ( replacement + ""\n"" ) ; for ( int i = 0 ; i < n ; ++ i ) { System . out . print ( arr [ i ] + "" "" ) ; } }"
static int stepRequired ( int n ) { return Integer . bitCount ( n - 1 ) ; }
"static int getCount ( int l , int r , int p ) { int cnt = 0 ; int val = p ; while ( true ) { int a = r / val ; int b = ( l - 1 ) / val ; val *= p ; if ( ( a - b ) > 0 ) { cnt += ( a - b ) ; } else break ; } return cnt ; }"
"static void EvenOddAbsoluteDifference ( int arr [ ] , int n ) { int even = 0 ; int odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) even = Math . abs ( even - arr [ i ] ) ; else odd = Math . abs ( odd - arr [ i ] ) ; } System . out . println ( ""Even Index absolute difference : "" + even ) ; System . out . println ( ""Odd Index absolute difference : "" + odd ) ; }"
"static int findLongestConseqSubseq ( int arr [ ] , int n ) { HashSet < Integer > S = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) S . add ( arr [ i ] ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( S . contains ( arr [ i ] ) ) { int j = arr [ i ] ; while ( S . contains ( j ) ) j ++ ; ans = Math . max ( ans , j - arr [ i ] ) ; } } return ans ; }"
public static int findNth ( int n ) { int count = 0 ; for ( int curr = 19 ; ; curr += 9 ) { int sum = 0 ; for ( int x = curr ; x > 0 ; x = x / 10 ) sum = sum + x % 10 ; if ( sum == 10 ) count ++ ; if ( count == n ) return curr ; } }
public static int findStep ( int n ) { if ( n == 1 || n == 0 ) return 1 ; else if ( n == 2 ) return 2 ; else return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 ) ; }
"static int findMaxAverage ( int arr [ ] , int n , int k ) { if ( k > n ) return - 1 ; int sum = arr [ 0 ] ; for ( int i = 1 ; i < k ; i ++ ) sum += arr [ i ] ; int max_sum = sum , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { sum = sum + arr [ i ] - arr [ i - k ] ; if ( sum > max_sum ) { max_sum = sum ; max_end = i ; } } return max_end - k + 1 ; }"
static void printSumSeries ( int N ) { float sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += 1.0 / ( 2 * i - 1 ) ; } System . out . println ( sum ) ; }
"static int XorSum ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 != 0 ) result += arr [ i ] ; } return result ; }"
static int areaSquare ( int side ) { int area = side * side ; return area ; }
"static void ReplaceElementsByFrequency ( int arr [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( mp . get ( arr [ i ] ) == null ) { mp . put ( arr [ i ] , 1 ) ; } else { mp . put ( arr [ i ] , ( mp . get ( arr [ i ] ) + 1 ) ) ; } } for ( int i = 0 ; i < n ; ++ i ) { if ( mp . get ( arr [ i ] ) != null ) { arr [ i ] = mp . get ( arr [ i ] ) ; } } }"
"static int countSubstring ( String S , int n ) { int ans = 0 ; int i = 0 ; while ( i < n ) { int cnt0 = 0 , cnt1 = 0 ; if ( S . charAt ( i ) == '0' ) { while ( i < n && S . charAt ( i ) == '0' ) { cnt0 ++ ; i ++ ; } int j = i ; while ( j < n && S . charAt ( j ) == '1' ) { cnt1 ++ ; j ++ ; } } else { while ( i < n && S . charAt ( i ) == '1' ) { cnt1 ++ ; i ++ ; } int j = i ; while ( j < n && S . charAt ( j ) == '0' ) { cnt0 ++ ; j ++ ; } } ans += Math . min ( cnt0 , cnt1 ) ; } return ans ; }"
"static boolean ispalindrome ( String s ) { int l = s . length ( ) ; for ( int i = 0 , j = l - 1 ; i <= j ; i ++ , j -- ) { if ( s . charAt ( i ) != s . charAt ( j ) ) { return false ; } } return true ; }"
"static int max_sum ( int arr [ ] , int n , int k ) { int dp [ ] = new int [ n ] ; dp [ 0 ] = Math . max ( 0 , arr [ 0 ] ) ; int i = 1 ; while ( i < k ) { dp [ i ] = Math . max ( dp [ i - 1 ] , arr [ i ] ) ; i ++ ; } i = k ; while ( i < n ) { dp [ i ] = Math . max ( dp [ i - 1 ] , arr [ i ] + dp [ i - k ] ) ; i ++ ; } return dp [ n - 1 ] ; }"
"static double haversine ( double lat1 , double lon1 , double lat2 , double lon2 ) { double dLat = Math . toRadians ( lat2 - lat1 ) ; double dLon = Math . toRadians ( lon2 - lon1 ) ; lat1 = Math . toRadians ( lat1 ) ; lat2 = Math . toRadians ( lat2 ) ; double a = Math . pow ( Math . sin ( dLat / 2 ) , 2 ) + Math . pow ( Math . sin ( dLon / 2 ) , 2 ) * Math . cos ( lat1 ) * Math . cos ( lat2 ) ; double rad = 6371 ; double c = 2 * Math . asin ( Math . sqrt ( a ) ) ; return rad * c ; }"
"static void printPattern ( int r ) { r = r / 2 ; int count = r ; for ( int i = 0 ; i < r ; i ++ ) { for ( int j = r ; j > i ; j -- ) { if ( j != r ) { System . out . print ( ""*"" + count ) ; } else { System . out . print ( count ) ; } } count -- ; System . out . print ( ""\n"" ) ; } count ++ ; for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( j != 0 ) { System . out . print ( ""*"" + count ) ; } else { System . out . print ( count ) ; } } count ++ ; System . out . print ( ""\n"" ) ; } }"
"static int MinOperation ( int a [ ] , int b [ ] , int n ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( a [ i ] > b [ i ] ) result = result + Math . abs ( a [ i ] - b [ i ] ) ; else if ( a [ i ] < b [ i ] ) result = result + Math . abs ( a [ i ] - b [ i ] ) ; } return result ; }"
"static int maximumNumberDistinctPrimeRange ( int m , int n ) { long factorCount [ ] = new long [ n + 1 ] ; boolean prime [ ] = new boolean [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { factorCount [ i ] = 0 ; prime [ i ] = true ; } for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] == true ) { factorCount [ i ] = 1 ; for ( int j = i * 2 ; j <= n ; j += i ) { factorCount [ j ] ++ ; prime [ j ] = false ; } } } int max = ( int ) factorCount [ m ] ; int num = m ; for ( int i = m ; i <= n ; i ++ ) { if ( factorCount [ i ] > max ) { max = ( int ) factorCount [ i ] ; num = i ; } } return num ; }"
"static String even_or_odd ( String N ) { int len = N . length ( ) ; if ( N . charAt ( len - 1 ) == '0' || N . charAt ( len - 1 ) == '2' || N . charAt ( len - 1 ) == '4' || N . charAt ( len - 1 ) == '6' || N . charAt ( len - 1 ) == '8' || N . charAt ( len - 1 ) == 'A' || N . charAt ( len - 1 ) == 'C' || N . charAt ( len - 1 ) == 'E' ) return ( ""Even"" ) ; else return ( ""Odd"" ) ; }"
"static void convertOpposite ( StringBuffer str ) { int ln = str . length ( ) ; for ( int i = 0 ; i < ln ; i ++ ) { Character c = str . charAt ( i ) ; if ( Character . isLowerCase ( c ) ) str . replace ( i , i + 1 , Character . toUpperCase ( c ) + """" ) ; else str . replace ( i , i + 1 , Character . toLowerCase ( c ) + """" ) ; } }"
"static int minCoins ( int coins [ ] , int m , int V ) { int table [ ] = new int [ V + 1 ] ; table [ 0 ] = 0 ; for ( int i = 1 ; i <= V ; i ++ ) table [ i ] = Integer . MAX_VALUE ; for ( int i = 1 ; i <= V ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) if ( coins [ j ] <= i ) { int sub_res = table [ i - coins [ j ] ] ; if ( sub_res != Integer . MAX_VALUE && sub_res + 1 < table [ i ] ) table [ i ] = sub_res + 1 ; } } return table [ V ] ; }"
static int findMax ( int num ) { byte size_of_int = 4 ; int num_copy = num ; int j = size_of_int * 8 - 1 ; int i = 0 ; while ( i < j ) { int m = ( num_copy >> i ) & 1 ; int n = ( num_copy >> j ) & 1 ; if ( m > n ) { int x = ( 1 << i | 1 << j ) ; num = num ^ x ; } i ++ ; j -- ; } return num ; }
"static void convert ( int n , String a , String b ) { int [ ] l = new int [ n ] ; int i ; for ( i = 0 ; i < n ; i ++ ) l [ i ] = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a . charAt ( i ) != b . charAt ( i ) ) l [ i ] = 1 ; } int cc = 0 ; int vl = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( l [ i ] == 0 ) { if ( vl != 0 ) cc += 1 ; vl = 0 ; } else vl += 1 ; } if ( vl != 0 ) cc += 1 ; System . out . println ( cc ) ; }"
"static int coin ( int totalRupees , int X , int Y , int Z ) { float one = 0 , fifty = 0 , twentyfive = 0 , result = 0 , total = 0 ; one = X * 1 ; fifty = ( ( Y * 1 ) / 2 ) ; twentyfive = ( ( Z * 1 ) / 4 ) ; total = one + fifty + twentyfive ; result = ( ( totalRupees ) / total ) ; return ( int ) result ; }"
static int multiplyWith3Point5 ( int x ) { return ( x << 1 ) + x + ( x >> 1 ) ; }
"static int k_sum ( int a [ ] , int n , int k ) { int r = 0 , sum = 0 ; int ans = 0 ; for ( int l = 0 ; l < n ; l ++ ) { while ( sum < k ) { if ( r == n ) break ; else { sum += a [ r ] ; r ++ ; } } if ( sum < k ) break ; ans += n - r + 1 ; sum -= a [ l ] ; } return ans ; }"
static boolean isAlphabaticOrder ( String s ) { int n = s . length ( ) ; char c [ ] = new char [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { c [ i ] = s . charAt ( i ) ; } Arrays . sort ( c ) ; for ( int i = 0 ; i < n ; i ++ ) if ( c [ i ] != s . charAt ( i ) ) return false ; return true ; }
"static int minProductSubset ( int a [ ] , int n ) { if ( n == 1 ) return a [ 0 ] ; int negmax = Integer . MIN_VALUE ; int posmin = Integer . MAX_VALUE ; int count_neg = 0 , count_zero = 0 ; int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count_zero ++ ; continue ; } if ( a [ i ] < 0 ) { count_neg ++ ; negmax = Math . max ( negmax , a [ i ] ) ; } if ( a [ i ] > 0 && a [ i ] < posmin ) posmin = a [ i ] ; product *= a [ i ] ; } if ( count_zero == n || ( count_neg == 0 && count_zero > 0 ) ) return 0 ; if ( count_neg == 0 ) return posmin ; if ( count_neg % 2 == 0 && count_neg != 0 ) { product = product / negmax ; } return product ; }"
"static int minCost ( int A [ ] , int n ) { int cost = 0 ; Arrays . sort ( A ) ; int K = A [ n / 2 ] ; for ( int i = 0 ; i < n ; ++ i ) cost += Math . abs ( A [ i ] - K ) ; if ( n % 2 == 0 ) { int tempCost = 0 ; K = A [ ( n / 2 ) - 1 ] ; for ( int i = 0 ; i < n ; ++ i ) tempCost += Math . abs ( A [ i ] - K ) ; cost = Math . min ( cost , tempCost ) ; } return cost ; }"
"public static int maxUniqueNum ( int arr [ ] , int N , int M ) { int maxUnique = 0 ; for ( int i = 0 ; i < N - M ; i ++ ) { int currentUnique = 0 ; HashMap < Integer , Integer > map = new HashMap < Integer , Integer > ( ) ; for ( int k = i ; k < i + M ; k ++ ) { if ( ! map . containsKey ( arr [ k ] ) ) { map . put ( arr [ i ] , 1 ) ; currentUnique ++ ; continue ; } } if ( currentUnique > maxUnique ) maxUnique = currentUnique ; } return maxUnique ; }"
"static int countPairs ( String s1 , int n1 , String s2 , int n2 ) { int [ ] freq1 = new int [ 26 ] ; int [ ] freq2 = new int [ 26 ] ; Arrays . fill ( freq1 , 0 ) ; Arrays . fill ( freq2 , 0 ) ; int i , count = 0 ; for ( i = 0 ; i < n1 ; i ++ ) freq1 [ s1 . charAt ( i ) - 'a' ] ++ ; for ( i = 0 ; i < n2 ; i ++ ) freq2 [ s2 . charAt ( i ) - 'a' ] ++ ; for ( i = 0 ; i < 26 ; i ++ ) count += ( Math . min ( freq1 [ i ] , freq2 [ i ] ) ) ; return count ; }"
"static int calculateSum ( int n ) { int a1 = 1 , a2 = 2 ; int r = 2 ; int d = 1 ; return ( n ) * ( 2 * a1 + ( n - 1 ) * d ) / 2 + a2 * ( int ) ( Math . pow ( r , n ) - 1 ) / ( r - 1 ) ; }"
"static int countStrings ( int n , int k ) { int dp [ ] [ ] [ ] = new int [ n + 1 ] [ k + 1 ] [ 2 ] ; dp [ 1 ] [ 0 ] [ 0 ] = 1 ; dp [ 1 ] [ 0 ] [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j < i && j < k + 1 ; j ++ ) { dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ; dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] ; if ( j - 1 >= 0 ) { dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] ; } } } return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] ; }"
"public static void splitArr ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < k ; i ++ ) { int x = arr [ 0 ] ; for ( int j = 0 ; j < n - 1 ; ++ j ) arr [ j ] = arr [ j + 1 ] ; arr [ n - 1 ] = x ; } }"
"static int findMaximum ( int l , int p , int q , int r ) { int dp [ ] = new int [ l + 1 ] ; for ( int i = 0 ; i < l + 1 ; i ++ ) dp [ i ] = - 1 ; dp [ 0 ] = 0 ; for ( int i = 0 ; i <= l ; i ++ ) { if ( dp [ i ] == - 1 ) continue ; if ( i + p <= l ) dp [ i + p ] = Math . max ( dp [ i + p ] , dp [ i ] + 1 ) ; if ( i + q <= l ) dp [ i + q ] = Math . max ( dp [ i + q ] , dp [ i ] + 1 ) ; if ( i + r <= l ) dp [ i + r ] = Math . max ( dp [ i + r ] , dp [ i ] + 1 ) ; } return dp [ l ] ; }"
"static void pattern ( int n ) { int i , j ; for ( i = n - 1 ; i >= 0 ; i -- ) { for ( j = n - 1 ; j > i ; j -- ) { System . out . print ( "" "" ) ; } System . out . print ( ( char ) ( i + 65 ) ) ; for ( j = 1 ; j < ( i * 2 ) ; j ++ ) System . out . print ( "" "" ) ; if ( i >= 1 ) System . out . print ( ( char ) ( i + 65 ) ) ; System . out . print ( ""\n"" ) ; } }"
static double decdiagonal ( double a ) { if ( a < 0 ) return - 1 ; double d = 1.902 * a ; return d ; }
public static int numberOfSticks ( int x ) { return ( 3 * x * ( x + 1 ) ) / 2 ; }
"static void diagonalsquare ( int mat [ ] [ ] , int row , int column ) { System . out . print ( "" Diagonal one : "" ) ; for ( int i = 0 ; i < row ; i ++ ) { System . out . print ( mat [ i ] [ i ] * mat [ i ] [ i ] + "" "" ) ; } System . out . println ( ) ; System . out . print ( "" Diagonal two : "" ) ; for ( int i = 0 ; i < row ; i ++ ) { System . out . print ( mat [ i ] [ row - i - 1 ] * mat [ i ] [ row - i - 1 ] + "" "" ) ; } }"
"static boolean isKAlternating ( String s , int k ) { if ( s . length ( ) < k ) return false ; int checker = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int bitAtIndex = s . charAt ( i ) - 'a' ; if ( ( checker & ( 1 << bitAtIndex ) ) > 0 ) { return false ; } checker = checker | ( 1 << bitAtIndex ) ; } for ( int i = k ; i < s . length ( ) ; i ++ ) if ( s . charAt ( i - k ) != s . charAt ( i ) ) return false ; return true ; }"
static int countPaths ( int n ) { int zB = 1 ; int zADC = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int nzB = zADC * 3 ; int nzADC = ( zADC * 2 + zB ) ; zB = nzB ; zADC = nzADC ; } return zB ; }
"static void check ( int arr [ ] , int N ) { int even = 0 ; int odd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 1 ) { odd ++ ; } else { even ++ ; } } if ( even == N || odd == N ) System . out . print ( ""Yes"" ) ; else System . out . print ( ""No"" ) ; }"
"static double area_of_circle ( int m , int n ) { int square_of_radius = ( m * n ) / 4 ; double area = ( 3.141 * square_of_radius ) ; return area ; }"
"static void newvol ( double x ) { System . out . print ( ""percentage increase in the"" + "" volume of the sphere is "" + ( Math . pow ( x , 3 ) / 10000 + 3 * x + ( 3 * Math . pow ( x , 2 ) ) / 100 ) + ""%"" ) ; }"
"static void printOrder ( Integer [ ] arr , int k ) { int n = arr . length ; Arrays . sort ( arr , 0 , k ) ; Arrays . sort ( arr , k , n , Collections . reverseOrder ( ) ) ; }"
"static int findElement ( int arr [ ] , int n ) { int prefixMul [ ] = new int [ n ] ; prefixMul [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefixMul [ i ] = prefixMul [ i - 1 ] * arr [ i ] ; int suffixMul [ ] = new int [ n ] ; suffixMul [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) suffixMul [ i ] = suffixMul [ i + 1 ] * arr [ i ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) if ( prefixMul [ i ] == suffixMul [ i ] ) return arr [ i ] ; return - 1 ; }"
"public static int findremainder ( int arr [ ] , int len , int n ) { int mul = 1 ; for ( int i = 0 ; i < len ; i ++ ) mul = ( mul * ( arr [ i ] % n ) ) % n ; return mul % n ; }"
"static void isHalfReducible ( int arr [ ] , int n , int m ) { int frequencyHash [ ] = new int [ m + 1 ] ; int i ; for ( i = 0 ; i < frequencyHash . length ; i ++ ) frequencyHash [ i ] = 0 ; for ( i = 0 ; i < n ; i ++ ) { frequencyHash [ arr [ i ] % ( m + 1 ) ] ++ ; } for ( i = 0 ; i <= m ; i ++ ) { if ( frequencyHash [ i ] >= n / 2 ) break ; } if ( i <= m ) System . out . println ( ""Yes"" ) ; else System . out . println ( ""No"" ) ; }"
static int countStrings ( int n ) { int a [ ] = new int [ n ] ; int b [ ] = new int [ n ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } return a [ n - 1 ] + b [ n - 1 ] ; }
"static void findMaxNum ( int arr [ ] , int n ) { int [ ] hash = new int [ 10 ] ; for ( int i = 0 ; i < n ; i ++ ) { hash [ arr [ i ] ] ++ ; } for ( int i = 9 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < hash [ i ] ; j ++ ) System . out . print ( i ) ; } }"
public static int squareFree ( int n ) { int cnt = 0 ; for ( int i = 1 ; ; i ++ ) { boolean isSqFree = true ; for ( int j = 2 ; j * j <= i ; j ++ ) { if ( i % ( j * j ) == 0 ) { isSqFree = false ; break ; } } if ( isSqFree == true ) { cnt ++ ; if ( cnt == n ) return i ; } } }
static int doublefactorial ( int n ) { int res = 1 ; for ( int i = n ; i >= 0 ; i = i - 2 ) { if ( i == 0 || i == 1 ) return res ; else res *= i ; } return res ; }
"static int minSwaps ( int arr [ ] , int n ) { int noOfOnes = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) noOfOnes ++ ; } int x = noOfOnes ; int maxOnes = Integer . MIN_VALUE ; int preCompute [ ] = new int [ n ] ; if ( arr [ 0 ] == 1 ) preCompute [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) { preCompute [ i ] = preCompute [ i - 1 ] + 1 ; } else preCompute [ i ] = preCompute [ i - 1 ] ; } for ( int i = x - 1 ; i < n ; i ++ ) { if ( i == ( x - 1 ) ) noOfOnes = preCompute [ i ] ; else noOfOnes = preCompute [ i ] - preCompute [ i - x ] ; if ( maxOnes < noOfOnes ) maxOnes = noOfOnes ; } int noOfZeroes = x - maxOnes ; return noOfZeroes ; }"
static int findMaximumPieces ( int n ) { return 1 + n * ( n + 1 ) / 2 ; }
static double nthHarmonic ( int N ) { float harmonic = 1 ; for ( int i = 2 ; i <= N ; i ++ ) { harmonic += ( float ) 1 / i ; } return harmonic ; }
"static void printNumber ( int holes ) { if ( holes == 0 ) System . out . print ( ""1"" ) ; else if ( holes == 1 ) System . out . print ( ""0"" ) ; else { int rem = 0 , quo = 0 ; rem = holes % 2 ; quo = holes / 2 ; if ( rem == 1 ) System . out . print ( ""4"" ) ; for ( int i = 0 ; i < quo ; i ++ ) System . out . print ( ""8"" ) ; } }"
"static void min_visible_bottles ( int [ ] arr , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } ans = Math . max ( ans , mp . get ( arr [ i ] ) ) ; } System . out . print ( ""Minimum number of "" + ""Visible Bottles are: "" + ans + ""\n"" ) ; }"
static int calculateLeaps ( int n ) { if ( n == 0 ) return 1 ; return ( 1 << ( n - 1 ) ) ; }
"static int getMaxLength ( int arr [ ] , int n ) { int start = 0 ; int preCnt = 0 ; while ( start < n && arr [ start ] == 1 ) { preCnt ++ ; start ++ ; } int end = n - 1 ; int suffCnt = 0 ; while ( end >= 0 && arr [ end ] == 1 ) { suffCnt ++ ; end -- ; } if ( start > end ) return n ; int midCnt = 0 ; int result = 0 ; for ( int i = start ; i <= end ; i ++ ) { if ( arr [ i ] == 1 ) { midCnt ++ ; result = Math . max ( result , midCnt ) ; } else { midCnt = 0 ; } } return Math . max ( result , preCnt + suffCnt ) ; }"
"public static void balancedString ( String str ) { int count = 0 , i ; int n = str . length ( ) ; for ( i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == '(' ) { System . out . print ( str . charAt ( i ) ) ; count ++ ; } else if ( str . charAt ( i ) == ')' && count != 0 ) { System . out . print ( str . charAt ( i ) ) ; count -- ; } else if ( str . charAt ( i ) != ')' ) System . out . print ( str . charAt ( i ) ) ; } if ( count != 0 ) for ( i = 0 ; i < count ; i ++ ) System . out . print ( "")"" ) ; }"
"static int evenSum ( int n ) { int C [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int sum = 0 ; for ( i = 0 ; i <= n ; i += 2 ) sum += C [ n ] [ i ] ; return sum ; }"
"static void assign ( int a [ ] , int n ) { Arrays . sort ( a ) ; int ans [ ] = new int [ n ] ; int p = 0 , q = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( i + 1 ) % 2 == 0 ) ans [ i ] = a [ q -- ] ; else ans [ i ] = a [ p ++ ] ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( ans [ i ] + "" "" ) ; }"
"static int findSmallestDifference ( int A [ ] , int B [ ] , int m , int n ) { Arrays . sort ( A ) ; Arrays . sort ( B ) ; int a = 0 , b = 0 ; int result = Integer . MAX_VALUE ; while ( a < m && b < n ) { if ( Math . abs ( A [ a ] - B [ b ] ) < result ) result = Math . abs ( A [ a ] - B [ b ] ) ; if ( A [ a ] < B [ b ] ) a ++ ; else b ++ ; } return result ; }"
"static void findString ( String str , int n , int k ) { if ( k == 0 ) { System . out . println ( str ) ; ; return ; } String str2 = str ; int p = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str2 . charAt ( i ) != 'a' ) { str2 = str2 . substring ( 0 , i ) + 'a' + str2 . substring ( i + 1 ) ; p ++ ; if ( p == k ) break ; } } if ( p < k ) { for ( int i = n - 1 ; i >= 0 ; i -- ) if ( str . charAt ( i ) == 'a' ) { str2 = str2 . substring ( 0 , i ) + 'b' + str2 . substring ( i + 1 ) ; p ++ ; if ( p == k ) break ; } } System . out . println ( str2 ) ; }"
public static int kthgroupsum ( int k ) { int cur = ( k * ( k - 1 ) ) + 1 ; int sum = 0 ; while ( k -- > 0 ) { sum += cur ; cur += 2 ; } return sum ; }
"static boolean isPermutedMatrix ( int mat [ ] [ ] , int n ) { String str_cat = """" ; for ( int i = 0 ; i < n ; i ++ ) { str_cat = str_cat + ""-"" + String . valueOf ( mat [ 0 ] [ i ] ) ; } str_cat = str_cat + str_cat ; for ( int i = 1 ; i < n ; i ++ ) { String curr_str = """" ; for ( int j = 0 ; j < n ; j ++ ) { curr_str = curr_str + ""-"" + String . valueOf ( mat [ i ] [ j ] ) ; } if ( str_cat . contentEquals ( curr_str ) ) { return false ; } } return true ; }"
"static String maxNumber ( String str , int n ) { int [ ] freq = new int [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == 'z' ) freq [ 0 ] ++ ; else if ( str . charAt ( i ) == 'n' ) freq [ 1 ] ++ ; } String num = """" ; for ( int i = 0 ; i < freq [ 1 ] ; i ++ ) num += '1' ; for ( int i = 0 ; i < freq [ 0 ] ; i ++ ) num += '0' ; return num ; }"
"static int calcNodes ( int N , int I ) { int result = 0 ; result = I * ( N - 1 ) + 1 ; return result ; }"
"static int countFriendsPairings ( int n ) { int a = 1 , b = 2 , c = 0 ; if ( n <= 2 ) { return n ; } for ( int i = 3 ; i <= n ; i ++ ) { c = b + ( i - 1 ) * a ; a = b ; b = c ; } return c ; }"
"static int slopeOfNum ( String num , int n ) { int slope = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( num . charAt ( i ) > num . charAt ( i - 1 ) && num . charAt ( i ) > num . charAt ( i + 1 ) ) slope ++ ; else if ( num . charAt ( i ) < num . charAt ( i - 1 ) && num . charAt ( i ) < num . charAt ( i + 1 ) ) slope ++ ; } return slope ; }"
"public static int findMissing ( int arr [ ] , int n ) { int l = 0 , h = n - 1 ; int mid ; while ( h > l ) { mid = l + ( h - l ) / 2 ; if ( arr [ mid ] - mid == arr [ 0 ] ) { if ( arr [ mid + 1 ] - arr [ mid ] > 1 ) return arr [ mid ] + 1 ; else { l = mid + 1 ; } } else { if ( arr [ mid ] - arr [ mid - 1 ] > 1 ) return arr [ mid ] - 1 ; else { h = mid - 1 ; } } } return - 1 ; }"
"static void ReplaceElements ( int arr [ ] , int n ) { int X = 0 ; for ( int i = 0 ; i < n ; ++ i ) { X ^= arr [ i ] ; } for ( int i = 0 ; i < n ; ++ i ) { arr [ i ] = X ^ arr [ i ] ; } }"
"static void findPoint ( int x1 , int y1 , int x2 , int y2 ) { System . out . println ( ""("" + ( int ) ( 2 * x2 - x1 ) + "","" + ( int ) ( 2 * y2 - y1 ) + "" )"" ) ; }"
static int isSumDivides ( int N ) { int temp = N ; int sum = 0 ; while ( temp > 0 ) { sum += temp % 10 ; temp /= 10 ; } if ( N % sum == 0 ) return 1 ; else return 0 ; }
static int highestPowerOf2 ( int n ) { return ( n & ( ~ ( n - 1 ) ) ) ; }
"private static void findCount ( int n , int sum ) { int start = ( int ) Math . pow ( 10 , n - 1 ) ; int end = ( int ) Math . pow ( 10 , n ) - 1 ; int count = 0 ; int i = start ; while ( i < end ) { int cur = 0 ; int temp = i ; while ( temp != 0 ) { cur += temp % 10 ; temp = temp / 10 ; } if ( cur == sum ) { count ++ ; i += 9 ; } else i ++ ; } System . out . println ( count ) ; }"
static int countStr ( int n ) { return 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) / 2 ) ; }
"static void findMaximumBefore ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int currAns = - 1 ; for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ j ] > currAns && arr [ j ] < arr [ i ] ) { currAns = arr [ j ] ; } } System . out . print ( currAns + "" "" ) ; } }"
"static int minimumBox ( int [ ] arr , int n ) { Queue < Integer > q = new LinkedList < > ( ) ; Arrays . sort ( arr ) ; q . add ( arr [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { int now = q . element ( ) ; if ( arr [ i ] >= 2 * now ) q . remove ( ) ; q . add ( arr [ i ] ) ; } return q . size ( ) ; }"
"static int FindMinimumCost ( int ind , int a [ ] , int n , int k , int dp [ ] ) { if ( ind == ( n - 1 ) ) return 0 ; else if ( dp [ ind ] != - 1 ) return dp [ ind ] ; else { int ans = Integer . MAX_VALUE ; for ( int i = 1 ; i <= k ; i ++ ) { if ( ind + i < n ) ans = Math . min ( ans , Math . abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) ; else break ; } return dp [ ind ] = ans ; } }"
"static int countSquares ( int m , int n ) { if ( n < m ) { int temp = m ; m = n ; n = temp ; } return m * ( m + 1 ) * ( 2 * m + 1 ) / 6 + ( n - m ) * m * ( m + 1 ) / 2 ; }"
"static void getAverageCountArray ( int [ ] a , int x , int N ) { HashMap < Integer , Integer > map = new HashMap < Integer , Integer > ( ) ; int [ ] avg = new int [ N ] ; int val , av ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! map . containsKey ( a [ i ] ) ) { map . put ( a [ i ] , 1 ) ; } else { val = map . get ( a [ i ] ) ; val ++ ; map . remove ( a [ i ] ) ; map . put ( a [ i ] , val ) ; } } for ( int i = 0 ; i < N ; i ++ ) { av = ( a [ i ] + x ) / 2 ; if ( map . containsKey ( av ) ) { val = map . get ( av ) ; avg [ i ] = val ; } } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( avg [ i ] + "" "" ) ; } }"
static void decToOctal ( int n ) { int [ ] octalNum = new int [ 100 ] ; int i = 0 ; while ( n != 0 ) { octalNum [ i ] = n % 8 ; n = n / 8 ; i ++ ; } for ( int j = i - 1 ; j >= 0 ; j -- ) System . out . print ( octalNum [ j ] ) ; }
"static int countMinSwaps ( String st ) { int min_swaps = 0 ; int odd_0 = 0 , even_0 = 0 ; int odd_1 = 0 , even_1 = 0 ; int n = st . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { if ( st . charAt ( i ) == '1' ) even_1 ++ ; else even_0 ++ ; } else { if ( st . charAt ( i ) == '1' ) odd_1 ++ ; else odd_0 ++ ; } } int cnt_swaps_1 = Math . min ( even_0 , odd_1 ) ; int cnt_swaps_2 = Math . min ( even_1 , odd_0 ) ; return Math . min ( cnt_swaps_1 , cnt_swaps_2 ) ; }"
"static int remainderWith7 ( String num ) { int series [ ] = { 1 , 3 , 2 , - 1 , - 3 , - 2 }; int series_index = 0 ; int result = 0 ; for ( int i = num . length ( ) - 1 ; i >= 0 ; i -- ) { int digit = num . charAt ( i ) - '0' ; result += digit * series [ series_index ] ; series_index = ( series_index + 1 ) % 6 ; result %= 7 ; } if ( result < 0 ) result = ( result + 7 ) % 7 ; return result ; }"
"static int binarySearch ( int arr [ ] , int low , int high ) { if ( high >= low ) { int mid = ( low + high ) / 2 ; if ( mid == arr [ mid ] ) return mid ; if ( mid > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high ) ; else return binarySearch ( arr , low , ( mid - 1 ) ) ; } return - 1 ; }"
"static void findTriplets ( int arr [ ] , int n ) { boolean found = false ; for ( int i = 0 ; i < n - 1 ; i ++ ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int j = i + 1 ; j < n ; j ++ ) { int x = - ( arr [ i ] + arr [ j ] ) ; if ( s . contains ( x ) ) { System . out . printf ( ""%d %d %d\n"" , x , arr [ i ] , arr [ j ] ) ; found = true ; } else { s . add ( arr [ j ] ) ; } } } if ( found == false ) { System . out . printf ( "" No Triplet Found\n"" ) ; } }"
"static int findLength ( int [ ] arr , int n ) { int x = 0 ; for ( int i = 0 ; i < n ; i ++ ) x = Math . max ( x , arr [ i ] ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != x ) continue ; int j = i ; while ( arr [ j ] == x ) { j ++ ; if ( j >= n ) break ; } ans = Math . max ( ans , j - i ) ; } return ans ; }"
"int findSubArray ( int arr [ ] , int n ) { int sum = 0 ; int maxsize = - 1 , startindex = 0 ; int endindex = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? - 1 : 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] == 0 ) sum += - 1 ; else sum += 1 ; if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; startindex = i ; } } } endindex = startindex + maxsize - 1 ; if ( maxsize == - 1 ) System . out . println ( ""No such subarray"" ) ; else System . out . println ( startindex + "" to "" + endindex ) ; return maxsize ; }"
"static String printLargestString ( String s , int l , int r ) { int freq [ ] = new int [ 26 ] ; l -- ; r -- ; for ( int i = Math . min ( l , r ) ; i <= Math . max ( l , r ) ; i ++ ) { freq [ s . charAt ( i ) - 'a' ] ++ ; } String ans = """" ; for ( int i = 25 ; i >= 0 ; i -- ) { while ( freq [ i ] > 0 ) { ans += ( char ) ( 'a' + i ) ; freq [ i ] -- ; } } return ans ; }"
"static int maximumSum ( int arr [ ] , int n , int k ) { for ( int i = 1 ; i <= k ; i ++ ) { int min = + 2147483647 ; int index = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] < min ) { min = arr [ j ] ; index = j ; } } if ( min == 0 ) break ; arr [ index ] = - arr [ index ] ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; }"
"static int printPermutation ( int n ) { if ( n % 2 != 0 ) { System . out . println ( ""-1"" ) ; } else for ( int i = 1 ; i <= n / 2 ; i ++ ) { System . out . print ( 2 * i + "" "" + ( ( 2 * i ) - 1 ) + "" "" ) ; } return n ; }"
"static int findMinimumX ( int a [ ] , int n ) { Set < Integer > st = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) st . add ( a [ i ] ) ; if ( st . size ( ) == 1 ) return 0 ; if ( st . size ( ) == 2 ) { Iterator < Integer > it = st . iterator ( ) ; int el1 = it . next ( ) ; int el2 = it . next ( ) ; if ( ( el2 - el1 ) % 2 == 0 ) return ( el2 - el1 ) / 2 ; else return ( el2 - el1 ) ; } if ( st . size ( ) == 3 ) { Iterator < Integer > it = st . iterator ( ) ; int el1 = it . next ( ) ; int el2 = it . next ( ) ; int el3 = it . next ( ) ; if ( ( el2 - el1 ) == ( el3 - el2 ) ) return el2 - el1 ; else return - 1 ; } return - 1 ; }"
"public static int doMatch ( String A , String B ) { for ( int i = 0 ; i < A . length ( ) ; i ++ ) { if ( A . charAt ( i ) != '*' && B . charAt ( i ) != '*' ) { if ( A . charAt ( i ) != B . charAt ( i ) ) return 0 ; } } return 1 ; }"
"static int getTotalXorOfSubarrayXors ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i ; j < N ; j ++ ) for ( int k = i ; k <= j ; k ++ ) res = res ^ arr [ k ] ; return res ; }"
"static void print_result ( int a [ ] , int n , int k , int m ) { Vector < Vector < Integer >> v = new Vector < Vector < Integer >> ( m ) ; for ( int i = 0 ; i < m ; i ++ ) v . add ( new Vector < Integer > ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { int rem = a [ i ] % m ; v . get ( rem ) . add ( a [ i ] ) ; if ( v . get ( rem ) . size ( ) == k ) { for ( int j = 0 ; j < k ; j ++ ) System . out . print ( v . get ( rem ) . get ( j ) + "" "" ) ; return ; } } System . out . print ( ""-1"" ) ; }"
"static int cntSplits ( String s ) { if ( s . charAt ( s . length ( ) - 1 ) == '1' ) return 0 ; int c_zero = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) c_zero += ( s . charAt ( i ) == '0' ) ? 1 : 0 ; return ( int ) Math . pow ( 2 , c_zero - 1 ) ; }"
"static boolean isDivisible ( int arr [ ] , int n ) { int lastDigit = arr [ n - 1 ] % 10 ; if ( lastDigit == 0 ) return true ; return false ; }"
static int sum_series ( int n ) { int nSquare = n * n ; return nSquare * ( nSquare - 1 ) / 4 ; }
"static void circle_equation ( double x1 , double y1 , double r ) { double a = - 2 * x1 ; double b = - 2 * y1 ; double c = ( r * r ) - ( x1 * x1 ) - ( y1 * y1 ) ; System . out . print ( ""x^2 + ("" + a + "" x) + "" ) ; System . out . print ( ""y^2 + ("" + b + "" y) = "" ) ; System . out . println ( c + ""."" ) ; }"
"static int findSumofEle ( int [ ] arr1 , int m , int [ ] arr2 , int n , int k ) { float arraySum = 0 ; for ( int i = 0 ; i < n ; i ++ ) arraySum += arr2 [ i ] ; float mean = arraySum / n ; int sumOfElements = 0 ; float difference = 0 ; for ( int i = 0 ; i < m ; i ++ ) { difference = arr1 [ i ] - mean ; if ( ( difference < 0 ) && ( k > ( - 1 ) * difference ) ) { sumOfElements += arr1 [ i ] ; } if ( ( difference >= 0 ) && ( k > difference ) ) { sumOfElements += arr1 [ i ] ; } } return sumOfElements ; }"
"static void substringConversions ( String str , int k , int b ) { int i = 0 , sum = 0 , counter = k - 1 ; for ( i = 0 ; i < k ; i ++ ) { sum = ( int ) ( sum + ( ( str . charAt ( i ) - '0' ) * Math . pow ( b , counter ) ) ) ; counter -- ; } System . out . print ( sum + "" "" ) ; int prev = sum ; sum = 0 ; counter = 0 ; for ( ; i < str . length ( ) ; i ++ ) { sum = ( int ) ( prev - ( ( str . charAt ( i - k ) - '0' ) * Math . pow ( b , k - 1 ) ) ) ; sum = sum * b ; sum = sum + ( str . charAt ( i ) - '0' ) ; System . out . print ( sum + "" "" ) ; prev = sum ; counter ++ ; } }"
"private static long gcd ( long a , long b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }"
"static float cone ( float a ) { if ( a < 0 ) return - 1 ; float r = ( float ) ( a * Math . sqrt ( 2 ) ) / 3 ; float h = ( 2 * a ) / 3 ; float V = ( float ) ( 3.14 * Math . pow ( r , 2 ) * h ) ; return V ; }"
"static int countWords ( String str [ ] , int n ) { HashMap < String , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( m . containsKey ( str [ i ] ) ) { int get = m . get ( str [ i ] ) ; m . put ( str [ i ] , get + 1 ) ; } else { m . put ( str [ i ] , 1 ) ; } } int res = 0 ; for ( Map . Entry < String , Integer > it : m . entrySet ( ) ) { if ( it . getValue ( ) == 2 ) res ++ ; } return res ; }"
"static int findEvenPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( ( ! ( ( A [ i ] & 1 ) > 0 ) ) ) count ++ ; return count * ( count - 1 ) / 2 ; }"
"public static int maxCost ( int mat [ ] [ ] , int N ) { int dp [ ] [ ] = new int [ N ] [ N ] ; dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j < i + 1 && j < N ; j ++ ) dp [ i ] [ j ] = mat [ i ] [ j ] + Math . max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; int result = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( result < dp [ N - 1 ] [ i ] ) result = dp [ N - 1 ] [ i ] ; return result ; }"
static int bellNumber ( int n ) { int [ ] [ ] bell = new int [ n + 1 ] [ n + 1 ] ; bell [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { bell [ i ] [ 0 ] = bell [ i - 1 ] [ i - 1 ] ; for ( int j = 1 ; j <= i ; j ++ ) bell [ i ] [ j ] = bell [ i - 1 ] [ j - 1 ] + bell [ i ] [ j - 1 ] ; } return bell [ n ] [ 0 ] ; }
"static void printPattern ( int n ) { if ( n == 0 || n < 0 ) { System . out . print ( n + "" "" ) ; return ; } System . out . print ( n + "" "" ) ; printPattern ( n - 5 ) ; System . out . print ( n + "" "" ) ; }"
"static int nextGreater ( int N ) { int power_of_2 = 1 , shift_count = 0 ; while ( true ) { if ( ( ( N >> shift_count ) & 1 ) % 2 == 0 ) break ; shift_count ++ ; power_of_2 = power_of_2 * 2 ; } return ( N + power_of_2 ) ; }"
"static int closetAND ( int arr [ ] , int n , int k ) { int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int X = arr [ i ] ; for ( int j = i ; j < n ; j ++ ) { X &= arr [ j ] ; ans = Math . min ( ans , Math . abs ( k - X ) ) ; if ( X <= k ) break ; } } return ans ; }"
"static void calcSum ( int arr [ ] , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum += arr [ i ] ; System . out . print ( sum + "" "" ) ; for ( int i = k ; i < n ; i ++ ) { sum = ( sum - arr [ i - k ] ) + arr [ i ] ; System . out . print ( sum + "" "" ) ; } }"
"static boolean isPlusPossible ( int arr [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } boolean foundModOne = false ; for ( Map . Entry < Integer , Integer > x : mp . entrySet ( ) ) { int element = x . getKey ( ) ; int frequency = x . getValue ( ) ; if ( frequency % 4 == 0 ) continue ; if ( frequency % 4 == 1 ) { if ( foundModOne ) return false ; foundModOne = true ; } else return false ; } return true ; }"
"static int exponentMod ( int A , int B , int C ) { if ( A == 0 ) return 0 ; if ( B == 0 ) return 1 ; long y ; if ( B % 2 == 0 ) { y = exponentMod ( A , B / 2 , C ) ; y = ( y * y ) % C ; } else { y = A % C ; y = ( y * exponentMod ( A , B - 1 , C ) % C ) % C ; } return ( int ) ( ( y + C ) % C ) ; }"
"static float slope ( float x1 , float y1 , float x2 , float y2 ) { return ( y2 - y1 ) / ( x2 - x1 ) ; }"
"public static String fibWord ( int n ) { String Sn_1 = ""0"" ; String Sn = ""01"" ; String tmp ; for ( int i = 2 ; i <= n ; i ++ ) { tmp = Sn ; Sn += Sn_1 ; Sn_1 = tmp ; } return Sn ; }"
"static int numberOfSolutions ( int n ) { int c = 0 ; while ( n > 0 ) { c += n % 2 ; n /= 2 ; } return ( int ) Math . pow ( 2 , c ) ; }"
"static void findMax ( int [ ] a , int n ) { int dp [ ] [ ] = new int [ n ] [ 2 ] ; int i , j ; for ( i = 0 ; i < n ; i ++ ) for ( j = 0 ; j < 2 ; j ++ ) dp [ i ] [ j ] = 0 ; dp [ 0 ] [ 0 ] = a [ 0 ] + a [ 1 ] ; dp [ 0 ] [ 1 ] = a [ 0 ] * a [ 1 ] ; for ( i = 1 ; i <= n - 2 ; i ++ ) { dp [ i ] [ 0 ] = Math . max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + a [ i + 1 ] ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] - a [ i ] + a [ i ] * a [ i + 1 ] ; } System . out . println ( Math . max ( dp [ n - 2 ] [ 0 ] , dp [ n - 2 ] [ 1 ] ) ) ; }"
"static int findQuadruples ( int a [ ] , int b [ ] , int c [ ] , int d [ ] , int x , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) for ( int k = 0 ; k < n ; k ++ ) for ( int l = 0 ; l < n ; l ++ ) if ( ( a [ i ] ^ b [ j ] ^ c [ k ] ^ d [ l ] ) == x ) count ++ ; return count ; }"
"static ArrayList < Integer > addToArrayForm ( ArrayList < Integer > A , int K ) { ArrayList < Integer > v = new ArrayList < Integer > ( ) ; ArrayList < Integer > ans = new ArrayList < Integer > ( ) ; int rem = 0 ; int i = 0 ; for ( i = A . size ( ) - 1 ; i >= 0 ; i -- ) { int my = A . get ( i ) + K % 10 + rem ; if ( my > 9 ) { rem = 1 ; v . add ( my % 10 ) ; } else { v . add ( my ) ; rem = 0 ; } K = K / 10 ; } while ( K > 0 ) { int my = K % 10 + rem ; v . add ( my % 10 ) ; if ( my / 10 > 0 ) rem = 1 ; else rem = 0 ; K = K / 10 ; } if ( rem > 0 ) v . add ( rem ) ; for ( int j = v . size ( ) - 1 ; j >= 0 ; j -- ) ans . add ( v . get ( j ) ) ; return ans ; }"
"static void shufleArray ( int [ ] a , int n ) { int temp ; n = n / 2 ; for ( int start = n + 1 , j = n + 1 , done = 0 , i ; done < 2 * n - 2 ; done ++ ) { if ( start == j ) { start -- ; j -- ; } i = j > n ? j - n : j ; j = j > n ? 2 * i : 2 * i - 1 ; temp = a [ start ] ; a [ start ] = a [ j ] ; a [ j ] = temp ; } }"
"static int calculateSum ( int n ) { return ( int ) Math . pow ( n * ( n + 1 ) / 2 , 2 ) ; }"
"static long andOperator ( long a , long b ) { while ( a < b ) { b -= ( b & - b ) ; } return b ; }"
"static int maxProductSubset ( int a [ ] , int n ) { if ( n == 1 ) { return a [ 0 ] ; } int max_neg = Integer . MIN_VALUE ; int count_neg = 0 , count_zero = 0 ; int prod = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count_zero ++ ; continue ; } if ( a [ i ] < 0 ) { count_neg ++ ; max_neg = Math . max ( max_neg , a [ i ] ) ; } prod = prod * a [ i ] ; } if ( count_zero == n ) { return 0 ; } if ( count_neg % 2 == 1 ) { if ( count_neg == 1 && count_zero > 0 && count_zero + count_neg == n ) { return 0 ; } prod = prod / max_neg ; } return prod ; }"
"static int nthTerm ( int n ) { return ( int ) Math . pow ( n , 2 ) + 4 * n ; }"
"static int printMinimumProduct ( int arr [ ] , int n ) { int first_min = Math . min ( arr [ 0 ] , arr [ 1 ] ) ; int second_min = Math . max ( arr [ 0 ] , arr [ 1 ] ) ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] < first_min ) { second_min = first_min ; first_min = arr [ i ] ; } else if ( arr [ i ] < second_min ) second_min = arr [ i ] ; } return first_min * second_min ; }"
"static float cyl ( float r , float R , float h ) { if ( h < 0 && r < 0 && R < 0 ) return - 1 ; float r1 = r ; float h1 = h ; float V = ( float ) ( 3.14 * Math . pow ( r1 , 2 ) * h1 ) ; return V ; }"
"public static int smallestX ( int n ) { int [ ] temp = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) temp [ i ] = 0 ; if ( n == 0 ) return - 1 ; int count = 0 , x = 0 ; for ( x = 1 ; count < 10 ; x ++ ) { int y = x * n ; while ( y > 0 ) { if ( temp [ y % 10 ] == 0 ) { count ++ ; temp [ y % 10 ] = 1 ; } y /= 10 ; } } return x - 1 ; }"
public static boolean possible ( int n ) { if ( n > 3 ) { int sum = ( n * ( n + 1 ) ) / 2 ; if ( sum % 3 == 0 ) { return true ; } } return false ; }
"static boolean checkPair ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } if ( sum % 2 != 0 ) { return false ; } sum = sum / 2 ; HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int val = sum - arr [ i ] ; if ( s . contains ( val ) && val == ( int ) s . toArray ( ) [ s . size ( ) - 1 ] ) { System . out . printf ( ""Pair elements are %d and %d\n"" , arr [ i ] , val ) ; return true ; } s . add ( arr [ i ] ) ; } return false ; }"
"static int findSum ( int N , int K ) { int ans = 0 ; int y = N / K ; int x = N % K ; ans = ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ; return ans ; }"
static int countReduce ( String str ) { int n = str . length ( ) ; int res = 0 ; for ( int i = 0 ; i < n / 2 ; i ++ ) res += Math . abs ( str . charAt ( i ) - str . charAt ( n - i - 1 ) ) ; return res ; }
"static int nthTerm ( int N ) { int nth = 0 , first_term = 4 ; int pi = 1 , po = 1 ; int n = N ; while ( n > 1 ) { pi *= n - 1 ; n -- ; po *= 2 ; } nth = ( first_term * pi ) / po ; return nth ; }"
static int f ( int x ) { if ( x % 2 == 0 ) { return x / 2 ; } else { return ( x * 3 + 1 ) ; } }
"static void printPalindrome ( int n ) { if ( n == 1 ) { System . out . println ( ""Smallest Palindrome: 0"" ) ; System . out . println ( ""Largest Palindrome: 9"" ) ; } else { System . out . println ( ""Smallest Palindrome: "" + ( int ) ( Math . pow ( 10 , n - 1 ) ) + 1 ) ; System . out . println ( ""Largest Palindrome: "" + ( ( int ) ( Math . pow ( 10 , n ) ) - 1 ) ) ; } }"
"static float power ( float x , int y ) { float temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else { if ( y > 0 ) return x * temp * temp ; else return ( temp * temp ) / x ; } }"
"static int maxLevel ( int [ ] boxes , int n ) { Arrays . sort ( boxes ) ; int ans = 1 ; int prev_width = boxes [ 0 ] ; int prev_count = 1 ; int curr_count = 0 ; int curr_width = 0 ; for ( int i = 1 ; i < n ; i ++ ) { curr_width += boxes [ i ] ; curr_count += 1 ; if ( curr_width > prev_width && curr_count > prev_count ) { prev_width = curr_width ; prev_count = curr_count ; curr_count = 0 ; curr_width = 0 ; ans ++ ; } } return ans ; }"
static boolean isDivisible ( int n ) { int d ; while ( ( n / 100 ) > 0 ) { d = n % 10 ; n /= 10 ; n = Math . abs ( n - ( d * 3 ) ) ; } return ( n % 31 == 0 ) ; }
static int minimumSwaps ( int [ ] arr ) { int count = 0 ; int i = 0 ; while ( i < arr . length ) { if ( arr [ i ] != i + 1 ) { while ( arr [ i ] != i + 1 ) { int temp = 0 ; temp = arr [ arr [ i ] - 1 ] ; arr [ arr [ i ] - 1 ] = arr [ i ] ; arr [ i ] = temp ; count ++ ; } } i ++ ; } return count ; }
"static void find_composite_nos ( int n ) { System . out . println ( 9 * n + "" "" + 8 * n ) ; }"
"static String canMake ( String s ) { int o = 0 , z = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) - '0' == 1 ) o ++ ; else z ++ ; } if ( o % 2 == 1 && z % 2 == 1 ) return ""NO"" ; else return ""YES"" ; }"
"static void pairSum ( int mat [ ] [ ] , int n , int sum ) { for ( int i = 0 ; i < n ; i ++ ) Arrays . sort ( mat [ i ] ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int left = 0 , right = n - 1 ; while ( left < n && right >= 0 ) { if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum ) { System . out . print ( ""("" + mat [ i ] [ left ] + "", "" + mat [ j ] [ right ] + ""), "" ) ; left ++ ; right -- ; } else { if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum ) left ++ ; else right -- ; } } } } }"
"static double sum ( int x , int n ) { double total = 1.0 ; double previous = 1.0 ; for ( int i = 1 ; i <= n ; i ++ ) { previous = ( previous * x ) / ( i + 1 ) ; total = total + previous ; } return total ; }"
static int odd_digits ( int n ) { if ( n < 10 ) return n ; else if ( n / 10 < 10 ) return 9 ; else if ( n / 100 < 10 ) return 9 + n - 99 ; else if ( n / 1000 < 10 ) return 9 + 900 ; else if ( n / 10000 < 10 ) return 909 + n - 9999 ; else return 90909 ; }
"static int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] - arr [ j ] == k || arr [ j ] - arr [ i ] == k ) count ++ ; } return count ; }"
"static int sumOfLargePrimeFactor ( int n ) { int prime [ ] = new int [ n + 1 ] , sum = 0 ; Arrays . fill ( prime , 0 ) ; int max = n / 2 ; for ( int p = 2 ; p <= max ; p ++ ) { if ( prime [ p ] == 0 ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = p ; } } for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] != 0 ) sum += prime [ p ] ; else sum += p ; } return sum ; }"
"public static int countP ( int n , int k ) { if ( n == 0 || k == 0 || k > n ) return 0 ; if ( k == 1 || k == n ) return 1 ; return ( k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) ) ; }"
"static String solve ( String a ) { int len = a . length ( ) ; if ( ( len & 1 ) == 1 ) { return a ; } String s1 = solve ( a . substring ( 0 , len / 2 ) ) ; String s2 = solve ( a . substring ( len / 2 , len ) ) ; if ( s1 . compareTo ( s2 ) <= 0 ) { return s1 + s2 ; } else { return s2 + s1 ; } }"
"static void printSorted ( int a [ ] , int n ) { int front = - 1 , back = - 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] < a [ i - 1 ] ) { front = i - 1 ; break ; } } for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( a [ i ] > a [ i + 1 ] ) { back = i + 1 ; break ; } } if ( front == - 1 && back == - 1 ) { for ( int i = 0 ; i < n ; i ++ ) System . out . println ( a [ i ] + "" "" ) ; return ; } while ( front <= back ) { int temp = a [ front ] ; a [ front ] = a [ back ] ; a [ back ] = temp ; front ++ ; back -- ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( a [ i ] + "" "" ) ; }"
"static int xorZero ( String s ) { int one_count = 0 , zero_count = 0 ; char [ ] str = s . toCharArray ( ) ; int n = str . length ; for ( int i = 0 ; i < n ; i ++ ) if ( str [ i ] == '1' ) one_count ++ ; else zero_count ++ ; if ( one_count % 2 == 0 ) return zero_count ; return one_count ; }"
"static int findOnBulbs ( int numberOfBulbs ) { int onBulbs = 0 ; int bulb = 1 ; int person = 1 ; for ( bulb = 1 ; bulb <= numberOfBulbs ; bulb ++ ) { int factors = 0 ; for ( person = 1 ; person * person <= numberOfBulbs ; person ++ ) { if ( bulb % person == 0 ) { factors ++ ; if ( bulb / person != person ) { factors ++ ; } } } if ( factors % 2 == 1 ) { System . out . println ( ""Light bulb "" + bulb + "" will be on"" ) ; onBulbs ++ ; } } return onBulbs ; }"
"static void CountTriangles ( int [ ] A ) { int n = A . length ; Arrays . sort ( A ) ; int count = 0 ; for ( int i = n - 1 ; i >= 1 ; i -- ) { int l = 0 , r = i - 1 ; while ( l < r ) { if ( A [ l ] + A [ r ] > A [ i ] ) { count += r - l ; r -- ; } else { l ++ ; } } } System . out . print ( ""No of possible solutions: "" + count ) ; }"
"static boolean isSubsetSum ( int set [ ] , int n , int sum ) { boolean subset [ ] [ ] = new boolean [ sum + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) subset [ 0 ] [ i ] = true ; for ( int i = 1 ; i <= sum ; i ++ ) subset [ i ] [ 0 ] = false ; for ( int i = 1 ; i <= sum ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { subset [ i ] [ j ] = subset [ i ] [ j - 1 ] ; if ( i >= set [ j - 1 ] ) subset [ i ] [ j ] = subset [ i ] [ j ] || subset [ i - set [ j - 1 ] ] [ j - 1 ] ; } } return subset [ sum ] [ n ] ; }"
"static boolean isHeap ( int arr [ ] , int n ) { for ( int i = 0 ; i <= ( n - 2 ) / 2 ; i ++ ) { if ( arr [ 2 * i + 1 ] > arr [ i ] ) { return false ; } if ( 2 * i + 2 < n && arr [ 2 * i + 2 ] > arr [ i ] ) { return false ; } } return true ; }"
"public static void printPascal ( int n ) { int [ ] [ ] arr = new int [ n ] [ n ] ; for ( int line = 0 ; line < n ; line ++ ) { for ( int i = 0 ; i <= line ; i ++ ) { if ( line == i || i == 0 ) arr [ line ] [ i ] = 1 ; else arr [ line ] [ i ] = arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ; System . out . print ( arr [ line ] [ i ] ) ; } System . out . println ( """" ) ; } }"
"static String censor ( String text , String word ) { String [ ] word_list = text . split ( ""\\s+"" ) ; String result = """" ; String stars = """" ; for ( int i = 0 ; i < word . length ( ) ; i ++ ) stars += '*' ; int index = 0 ; for ( String i : word_list ) { if ( i . compareTo ( word ) == 0 ) word_list [ index ] = stars ; index ++ ; } for ( String i : word_list ) result += i + ' ' ; return result ; }"
static long f ( long n ) { if ( n < 0 ) { return 0 ; } if ( n % 4 == 0 ) { return n ; } else if ( n % 4 == 1 ) { return 1 ; } else if ( n % 4 == 2 ) { return 1 ^ n ; } else { return 0 ; } }
"static int findMissing ( int arr [ ] , int n , int k , int avg ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int num = ( avg * ( n + k ) ) - sum ; int den = k ; if ( num % den != 0 ) return - 1 ; return ( int ) ( num / den ) ; }"
static int countStrings ( String s ) { int sum = 1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( i % 2 == 0 && s . charAt ( i ) == '$' ) sum *= 21 ; else if ( s . charAt ( i ) == '$' ) sum *= 5 ; } return sum ; }
"static boolean isInGivenBase ( String str , int base ) { if ( base > 16 ) return false ; else if ( base <= 10 ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( ! ( str . charAt ( i ) >= '0' && str . charAt ( i ) < ( '0' + base ) ) ) return false ; } else { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( ! ( ( str . charAt ( i ) >= '0' && str . charAt ( i ) < ( '0' + base ) ) || ( str . charAt ( i ) >= 'A' && str . charAt ( i ) < ( 'A' + base - 10 ) ) ) ) return false ; } return true ; }"
"static String check ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) count ++ ; } if ( ( count & 1 ) != 0 ) return ""Odd"" ; else return ""Even"" ; }"
"static int mostFrequent ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int max_count = 1 , res = arr [ 0 ] ; int curr_count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) curr_count ++ ; else { if ( curr_count > max_count ) { max_count = curr_count ; res = arr [ i - 1 ] ; } curr_count = 1 ; } } if ( curr_count > max_count ) { max_count = curr_count ; res = arr [ n - 1 ] ; } return res ; }"
"static boolean checkForElement ( int array [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += array [ i ] ; if ( sum % 2 > 0 ) return false ; sum /= 2 ; int start = 0 ; int end = n - 1 ; while ( start <= end ) { int mid = start + ( end - start ) / 2 ; if ( array [ mid ] == sum ) return true ; else if ( array [ mid ] > sum ) end = mid - 1 ; else start = mid + 1 ; } return false ; }"
"static void printMatrix ( int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) System . out . print ( k + "" "" ) ; else System . out . print ( ""0 "" ) ; } System . out . print ( ""\n"" ) ; } }"
"static int modInverse ( int a , int m ) { int m0 = m ; int y = 0 , x = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { int q = a / m ; int t = m ; m = a % m ; a = t ; t = y ; y = x - q * y ; x = t ; } if ( x < 0 ) x += m0 ; return x ; }"
"static void subsetBitwiseORk ( int arr [ ] , int n , int k ) { ArrayList < Integer > v = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] | k ) == k ) { v . add ( arr [ i ] ) ; } } int ans = 0 ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) ans = ans | v . get ( i ) ; if ( ans != k ) { System . out . println ( ""Subset does"" + "" not exist"" ) ; return ; } for ( int i = 0 ; i < v . size ( ) ; i ++ ) System . out . print ( v . get ( i ) + "" "" ) ; }"
"public static int productSubSeqCount ( ArrayList < Integer > arr , int k ) { int n = arr . size ( ) ; int dp [ ] [ ] = new int [ k + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= k ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; if ( arr . get ( j - 1 ) <= i && arr . get ( j - 1 ) > 0 ) dp [ i ] [ j ] += dp [ i / arr . get ( j - 1 ) ] [ j - 1 ] + 1 ; } } return dp [ k ] [ n ] ; }"
"static void CountSegments ( int N , int a [ ] ) { int frequency [ ] = new int [ 10001 ] ; int c = 0 ; for ( int i = 0 ; i < N ; i ++ ) { frequency [ a [ i ] ] ++ ; } for ( int i = 0 ; i <= 10000 ; i ++ ) c = Math . max ( c , frequency [ i ] ) ; System . out . println ( c ) ; }"
"static void charCheck ( char input_char ) { if ( ( input_char >= 65 && input_char <= 90 ) || ( input_char >= 97 && input_char <= 122 ) ) System . out . println ( "" Alphabet "" ) ; else if ( input_char >= 48 && input_char <= 57 ) System . out . println ( "" Digit "" ) ; else System . out . println ( "" Special Character "" ) ; }"
"static int countSubArrays ( int arr [ ] , int n , int x ) { int len = 0 ; int count = 0 ; int binaryArr [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] <= x ) binaryArr [ i ] = 1 ; else binaryArr [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( binaryArr [ i ] == 1 ) { int j ; for ( j = i + 1 ; j < n ; j ++ ) if ( binaryArr [ j ] != 1 ) break ; len = j - i ; count += ( len ) * ( len + 1 ) / 2 ; i = j ; } } return count ; }"
"public static void printLogestIncSubArr ( int arr [ ] , int n ) { int max = 1 , len = 1 , maxIndex = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] ) len ++ ; else { if ( max < len ) { max = len ; maxIndex = i - max ; } len = 1 ; } } if ( max < len ) { max = len ; maxIndex = n - max ; } for ( int i = maxIndex ; i < max + maxIndex ; i ++ ) System . out . print ( arr [ i ] + "" "" ) ; }"
"static char first ( String str , int i ) { if ( str . charAt ( i ) == '\0' ) return 0 ; if ( Character . isUpperCase ( str . charAt ( i ) ) ) return str . charAt ( i ) ; return first ( str , i + 1 ) ; }"
"static int no_of_ways ( String s ) { int n = s . length ( ) ; int count_left = 0 , count_right = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( s . charAt ( i ) == s . charAt ( 0 ) ) { ++ count_left ; } else break ; } for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( s . charAt ( i ) == s . charAt ( n - 1 ) ) { ++ count_right ; } else break ; } if ( s . charAt ( 0 ) == s . charAt ( n - 1 ) ) return ( ( count_left + 1 ) * ( count_right + 1 ) ) ; else return ( count_left + count_right + 1 ) ; }"
"static int minDiff ( int n , int x , int A [ ] ) { int mn = A [ 0 ] , mx = A [ 0 ] ; for ( int i = 0 ; i < n ; ++ i ) { mn = Math . min ( mn , A [ i ] ) ; mx = Math . max ( mx , A [ i ] ) ; } return Math . max ( 0 , mx - mn - 2 * x ) ; }"
static int leonardo ( int n ) { int dp [ ] = new int [ n + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + 1 ; return dp [ n ] ; }
"static boolean isDDM ( int m [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) sum += Math . abs ( m [ i ] [ j ] ) ; sum -= Math . abs ( m [ i ] [ i ] ) ; if ( Math . abs ( m [ i ] [ i ] ) < sum ) return false ; } return true ; }"
"private static int next ( int [ ] arr , int target ) { int start = 0 , end = arr . length - 1 ; int ans = - 1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( arr [ mid ] <= target ) { start = mid + 1 ; } else { ans = mid ; end = mid - 1 ; } } return ans ; }"
"static int calculate ( int a [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int r = i + 1 ; for ( int j = r ; j < n ; j ++ ) { if ( a [ i ] == a [ j ] ) r += 1 ; else break ; } int d = r - i ; ans += ( d * ( d + 1 ) / 2 ) ; i = r - 1 ; } return ans ; }"
"static int findKHCF ( int x , int y , int k ) { int small = Math . min ( x , y ) ; int count = 1 ; for ( int i = 2 ; i <= small ; i ++ ) { if ( x % i == 0 && y % i == 0 ) count ++ ; if ( count == k ) return i ; } return - 1 ; }"
"static void printGreater ( int x , int y ) { double X = y * Math . log ( x ) ; double Y = x * Math . log ( y ) ; if ( Math . abs ( X - Y ) < 1e-9 ) { System . out . println ( ""Equal"" ) ; } else if ( X > Y ) { System . out . println ( x + ""^"" + y ) ; } else { System . out . println ( y + ""^"" + x ) ; } }"
"static int minSubarray ( int A [ ] , int n ) { int minValue = A [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( A [ i ] < minValue ) minValue = A [ i ] ; } int maxValue = A [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( A [ i ] > maxValue ) maxValue = A [ i ] ; } int pos_min = - 1 , pos_max = - 1 , ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] == minValue ) pos_min = i ; if ( A [ i ] == maxValue ) pos_max = i ; if ( pos_max != - 1 && pos_min != - 1 ) ans = Math . min ( ans , Math . abs ( pos_min - pos_max ) + 1 ) ; } return ans ; }"
"static void findGeometricTriplets ( int arr [ ] , int n ) { for ( int j = 1 ; j < n - 1 ; j ++ ) { int i = j - 1 , k = j + 1 ; while ( i >= 0 && k <= n - 1 ) { while ( i >= 0 && arr [ j ] % arr [ i ] == 0 && arr [ k ] % arr [ j ] == 0 && arr [ j ] / arr [ i ] == arr [ k ] / arr [ j ] ) { System . out . println ( arr [ i ] + "" "" + arr [ j ] + "" "" + arr [ k ] ) ; k ++ ; i -- ; } if ( i >= 0 && arr [ j ] % arr [ i ] == 0 && arr [ k ] % arr [ j ] == 0 ) { if ( i >= 0 && arr [ j ] / arr [ i ] < arr [ k ] / arr [ j ] ) i -- ; else k ++ ; } else if ( i >= 0 && arr [ j ] % arr [ i ] == 0 ) k ++ ; else i -- ; } } }"
"public static void dfs ( LinkedList < Integer > list [ ] , int node , int arrival ) { System . out . println ( node ) ; for ( int i = 0 ; i < list [ node ] . size ( ) ; i ++ ) { if ( list [ node ] . get ( i ) != arrival ) dfs ( list , list [ node ] . get ( i ) , node ) ; } }"
"int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( mid > l && arr [ mid - 1 ] == x ) return ( mid - 1 ) ; if ( mid < r && arr [ mid + 1 ] == x ) return ( mid + 1 ) ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 2 , x ) ; return binarySearch ( arr , mid + 2 , r , x ) ; } return - 1 ; }"
"static void maxProductSum ( String str , int m ) { int n = str . length ( ) ; int product = 1 , sum = 0 ; for ( int i = 0 ; i < m ; i ++ ) { sum += ( str . charAt ( i ) - '0' ) ; product *= ( str . charAt ( i ) - '0' ) ; } int maxProd = product ; int maxSum = sum ; for ( int i = m ; i < n ; i ++ ) { product = product * ( str . charAt ( i ) - '0' ) / ( ( str . charAt ( i - m ) ) - '0' ) ; sum = sum + ( str . charAt ( i ) - '0' ) - ( ( str . charAt ( i - m ) ) - '0' ) ; maxProd = Math . max ( maxProd , product ) ; maxSum = Math . max ( maxSum , sum ) ; } System . out . println ( ""Maximum Product = "" + maxProd ) ; System . out . println ( ""\nMaximum Sum = "" + maxSum ) ; }"
"static void findMostOccurringChar ( Vector < String > str ) { int [ ] hash = new int [ 26 ] ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) { for ( int j = 0 ; j < str . get ( i ) . length ( ) ; j ++ ) { hash [ str . get ( i ) . charAt ( j ) - 97 ] ++ ; } } int max = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { max = hash [ i ] > hash [ max ] ? i : max ; } System . out . print ( ( char ) ( max + 97 ) + ""\n"" ) ; }"
"static int getSteps ( int arr [ ] , int n ) { int count = 0 ; int modulus [ ] = new int [ 4 ] ; int sum = 0 ; int i ; for ( i = 0 ; i < n ; i ++ ) { int mod = arr [ i ] % 4 ; sum += mod ; modulus [ mod ] ++ ; } if ( sum % 4 != 0 ) { return - 1 ; } else { if ( modulus [ 1 ] > modulus [ 3 ] ) { count += modulus [ 3 ] ; } else { count += modulus [ 1 ] ; } modulus [ 1 ] -= count ; modulus [ 3 ] -= count ; modulus [ 2 ] += modulus [ 1 ] / 2 ; modulus [ 2 ] += modulus [ 3 ] / 2 ; count += modulus [ 1 ] / 2 ; count += modulus [ 3 ] / 2 ; count += modulus [ 2 ] / 2 ; return count ; } }"
"static int minSteps ( int arr [ ] , int n ) { boolean [ ] v = new boolean [ n ] ; Queue < Integer > q = new LinkedList < > ( ) ; q . add ( 0 ) ; int depth = 0 ; while ( q . size ( ) > 0 ) { int x = q . size ( ) ; while ( x -- > 0 ) { int i = q . peek ( ) ; q . poll ( ) ; if ( v [ i ] ) continue ; if ( i == n - 1 ) return depth ; v [ i ] = true ; if ( i + arr [ i ] < n ) q . add ( i + arr [ i ] ) ; if ( i - arr [ i ] >= 0 ) q . add ( i - arr [ i ] ) ; } depth ++ ; } return - 1 ; }"
static int minCost ( char [ ] s ) { boolean alphabets [ ] = new boolean [ 26 ] ; for ( int i = 0 ; i < s . length ; i ++ ) { alphabets [ ( int ) s [ i ] - 97 ] = true ; } int count = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( alphabets [ i ] ) { count ++ ; } } return count ; }
"static int subsetCount ( int arr [ ] , int n ) { return 1 << n ; }"
"static void printSubstrings ( int n ) { int s = ( int ) Math . log10 ( n ) ; int d = ( int ) ( Math . pow ( 10 , s ) + 0.5 ) ; int k = d ; while ( n > 0 ) { while ( d > 0 ) { System . out . println ( n / d ) ; d = d / 10 ; } n = n % k ; k = k / 10 ; d = k ; } }"
static int onesComplement ( int n ) { int number_of_bits = ( int ) ( Math . floor ( Math . log ( n ) / Math . log ( 2 ) ) ) + 1 ; return ( ( 1 << number_of_bits ) - 1 ) ^ n ; }
static int sumofproduct ( int n ) { int ans = 0 ; for ( int x = 1 ; x <= n ; x ++ ) { int y = n / x ; ans += ( y * x ) ; } return ans ; }
"static boolean checkPermutation ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int [ ] prefix = new int [ n + 1 ] ; Arrays . fill ( prefix , 0 ) ; prefix [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix [ i ] = prefix [ i - 1 ] + arr [ i ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int lsum = prefix [ i ] ; int rsum = sum - prefix [ i ] ; int l_len = i + 1 , r_len = n - i - 1 ; if ( ( ( 2 * lsum ) == ( l_len * ( l_len + 1 ) ) ) && ( ( 2 * rsum ) == ( r_len * ( r_len + 1 ) ) ) ) return true ; } return false ; }"
"static int MinimumX ( int a , int b , int c , int k ) { int x = Integer . MAX_VALUE ; if ( k <= c ) return 0 ; int h = k - c ; int l = 0 ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( ( a * m * m ) + ( b * m ) > ( k - c ) ) { x = Math . min ( x , m ) ; h = m - 1 ; } else if ( ( a * m * m ) + ( b * m ) < ( k - c ) ) l = m + 1 ; else return m ; } return x ; }"
"static boolean pointIsOnLine ( int m , int c , int x , int y ) { if ( y == ( ( m * x ) + c ) ) return true ; return false ; }"
"static void rearrange ( int a [ ] , int size ) { int positive = 0 , negative = 1 , temp ; while ( true ) { while ( positive < size && a [ positive ] >= 0 ) positive += 2 ; while ( negative < size && a [ negative ] <= 0 ) negative += 2 ; if ( positive < size && negative < size ) { temp = a [ positive ] ; a [ positive ] = a [ negative ] ; a [ negative ] = temp ; } else break ; } }"
static void manipulateString ( String str ) { char [ ] str1 = str . toCharArray ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int asc = str1 [ i ] ; int rem = asc - ( 26 - ( str1 [ i ] - 97 ) ) ; int m = rem % 26 ; str1 [ i ] = ( char ) ( m + 'a' ) ; } String str2 = String . valueOf ( str1 ) ; System . out . println ( str2 ) ; }
"static int getMin ( int arr [ ] , int n ) { int minVal = Arrays . stream ( arr ) . min ( ) . getAsInt ( ) ; return minVal ; }"
static void decToBinary ( int n ) { int [ ] binaryNum = new int [ 32 ] ; int i = 0 ; while ( n > 0 ) { binaryNum [ i ] = n % 2 ; n = n / 2 ; i ++ ; } for ( int j = i - 1 ; j >= 0 ; j -- ) System . out . print ( binaryNum [ j ] ) ; }
"static void printSeries ( int N ) { int ith_term = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { ith_term = i % 2 == 0 ? 2 * i * i + 1 : 2 * i * i - 1 ; System . out . print ( ith_term + "", "" ) ; } }"
"static void Alphabet_N_Pattern ( int N ) { int index , side_index , size ; int Right = 1 , Left = 1 , Diagonal = 2 ; for ( index = 0 ; index < N ; index ++ ) { System . out . print ( Left ++ ) ; for ( side_index = 0 ; side_index < 2 * ( index ) ; side_index ++ ) System . out . print ( "" "" ) ; if ( index != 0 && index != N - 1 ) System . out . print ( Diagonal ++ ) ; else System . out . print ( "" "" ) ; for ( side_index = 0 ; side_index < 2 * ( N - index - 1 ) ; side_index ++ ) System . out . print ( "" "" ) ; System . out . print ( Right ++ ) ; System . out . println ( ) ; } }"
"static void printString ( String str , char ch , int count ) { int occ = 0 , i ; if ( count == 0 ) { System . out . println ( str ) ; return ; } for ( i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ch ) occ ++ ; if ( occ == count ) break ; } if ( i < str . length ( ) - 1 ) System . out . println ( str . substring ( i + 1 ) ) ; else System . out . println ( ""Empty string"" ) ; }"
"static int possibleStrings ( int n , int r , int b , int g ) { int fact [ ] = new int [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; int left = n - ( r + g + b ) ; int sum = 0 ; for ( int i = 0 ; i <= left ; i ++ ) { for ( int j = 0 ; j <= left - i ; j ++ ) { int k = left - ( i + j ) ; sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ; } } return sum ; }"
"static void printPattern ( int n ) { int j , k = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 != 0 ) { for ( j = k + 1 ; j < k + i ; j ++ ) System . out . print ( j + ""*"" ) ; System . out . println ( j ++ ) ; k = j ; } else { k = k + i - 1 ; for ( j = k ; j > k - i + 1 ; j -- ) System . out . print ( j + ""*"" ) ; System . out . println ( j ) ; } } }"
static long smallestNumber ( int n ) { if ( n >= 0 && n <= 9 ) { return n ; } Stack < Integer > digits = new Stack < > ( ) ; for ( int i = 9 ; i >= 2 && n > 1 ; i -- ) { while ( n % i == 0 ) { digits . push ( i ) ; n = n / i ; } } if ( n != 1 ) { return - 1 ; } long k = 0 ; while ( ! digits . empty ( ) ) { k = k * 10 + digits . peek ( ) ; digits . pop ( ) ; } return k ; }
static boolean isPalindrome ( String str ) { int l = 0 ; int h = str . length ( ) - 1 ; while ( h > l ) if ( str . charAt ( l ++ ) != str . charAt ( h -- ) ) return false ; return true ; }
"static int noOfDeletions ( String str , char k ) { int ans = 0 , cnt = 0 , pos = 0 ; while ( pos < str . length ( ) && str . charAt ( pos ) != k ) { pos ++ ; } int i = pos ; while ( i < str . length ( ) ) { while ( i < str . length ( ) && str . charAt ( i ) == k ) { i = i + 1 ; } ans = ans + cnt ; cnt = 0 ; while ( i < str . length ( ) && str . charAt ( i ) != k ) { i = i + 1 ; cnt = cnt + 1 ; } } return ans ; }"
static boolean isDivisibleby17 ( int n ) { if ( n == 0 || n == 17 ) return true ; if ( n < 17 ) return false ; return isDivisibleby17 ( ( int ) ( n >> 4 ) - ( int ) ( n & 15 ) ) ; }
"static String replaceConsonants ( String str ) { String res = """" ; int i = 0 , count = 0 ; while ( i < str . length ( ) ) { if ( str . charAt ( i ) != 'a' && str . charAt ( i ) != 'e' && str . charAt ( i ) != 'i' && str . charAt ( i ) != 'o' && str . charAt ( i ) != 'u' ) { i ++ ; count ++ ; } else { if ( count > 0 ) res += count ; res += str . charAt ( i ) ; i ++ ; count = 0 ; } } if ( count > 0 ) res += count ; return res ; }"
"static int getMaxLength ( boolean arr [ ] , int n ) { int count = 0 ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == false ) count = 0 ; else { count ++ ; result = Math . max ( result , count ) ; } } return result ; }"
"static int maxProfit ( int price [ ] , int n , int k ) { int profit [ ] [ ] = new int [ k + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= k ; i ++ ) profit [ i ] [ 0 ] = 0 ; for ( int j = 0 ; j <= n ; j ++ ) profit [ 0 ] [ j ] = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { int prevDiff = Integer . MIN_VALUE ; for ( int j = 1 ; j < n ; j ++ ) { prevDiff = Math . max ( prevDiff , profit [ i - 1 ] [ j - 1 ] - price [ j - 1 ] ) ; profit [ i ] [ j ] = Math . max ( profit [ i ] [ j - 1 ] , price [ j ] + prevDiff ) ; } } return profit [ k ] [ n - 1 ] ; }"
"static int calculateSum ( int n ) { return n * ( n + 1 ) / 2 + ( int ) Math . pow ( ( n * ( n + 1 ) / 2 ) , 2 ) ; }"
"static int maxXOR ( int mat [ ] [ ] , int N ) { int r_xor , c_xor ; int max_xor = 0 ; for ( int i = 0 ; i < N ; i ++ ) { r_xor = 0 ; c_xor = 0 ; for ( int j = 0 ; j < N ; j ++ ) { r_xor = r_xor ^ mat [ i ] [ j ] ; c_xor = c_xor ^ mat [ j ] [ i ] ; } if ( max_xor < Math . max ( r_xor , c_xor ) ) max_xor = Math . max ( r_xor , c_xor ) ; } return max_xor ; }"
"static void dupLastIndex ( int arr [ ] , int n ) { if ( arr == null || n <= 0 ) return ; for ( int i = n - 1 ; i > 0 ; i -- ) { if ( arr [ i ] == arr [ i - 1 ] ) { System . out . println ( ""Last index:"" + i ) ; System . out . println ( ""Last duplicate item: "" + arr [ i ] ) ; return ; } } System . out . print ( ""no duplicate found"" ) ; }"
"static int findMissingNo ( int [ ] arr , int n ) { int val ; int nextval ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] <= 0 || arr [ i ] > n ) continue ; val = arr [ i ] ; while ( arr [ val - 1 ] != val ) { nextval = arr [ val - 1 ] ; arr [ val - 1 ] = val ; val = nextval ; if ( val <= 0 || val > n ) break ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != i + 1 ) { return i + 1 ; } } return n + 1 ; }"
"static int maxOR ( int L , int R ) { int maximum = Integer . MIN_VALUE ; for ( int i = L ; i < R ; i ++ ) for ( int j = i + 1 ; j <= R ; j ++ ) maximum = Math . max ( maximum , ( i | j ) ) ; return maximum ; }"
static float circlearea ( float R ) { if ( R < 0 ) return - 1 ; float a = ( float ) ( ( 3.14 * R * R ) / 4 ) ; return a ; }
"static int minDifferenceAmongMaxMin ( int arr [ ] , int N , int K ) { Arrays . sort ( arr ) ; int res = 2147483647 ; for ( int i = 0 ; i <= ( N - K ) ; i ++ ) { int curSeqDiff = arr [ i + K - 1 ] - arr [ i ] ; res = Math . min ( res , curSeqDiff ) ; } return res ; }"
"static void partSort ( int [ ] arr , int N , int a , int b ) { int l = Math . min ( a , b ) ; int r = Math . max ( a , b ) ; int [ ] temp = new int [ r - l + 1 ] ; int j = 0 ; for ( int i = l ; i <= r ; i ++ ) { temp [ j ] = arr [ i ] ; j ++ ; } Arrays . sort ( temp ) ; j = 0 ; for ( int i = l ; i <= r ; i ++ ) { arr [ i ] = temp [ j ] ; j ++ ; } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( arr [ i ] + "" "" ) ; } }"
static long productAscii ( String str ) { long prod = 1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { prod *= str . charAt ( i ) ; } return prod ; }
"static int count_greater ( int arr [ ] , int n ) { int min = Integer . MAX_VALUE ; int counter = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] > min ) { counter ++ ; } if ( arr [ i ] <= min ) { min = arr [ i ] ; } } return counter ; }"
"public static int composite_factors ( int n ) { int count = 0 ; int i , j ; int [ ] a = new int [ n + 1 ] ; for ( i = 0 ; i < n ; i ++ ) { a [ i ] = 0 ; } for ( i = 1 ; i <= n ; ++ i ) { if ( n % i == 0 ) { a [ i ] = i ; } } for ( i = 2 ; i <= n ; i ++ ) { j = 2 ; int p = 1 ; while ( j < a [ i ] ) { if ( a [ i ] % j == 0 ) { p = 0 ; break ; } j ++ ; } if ( p == 0 && a [ i ] != 0 ) { count ++ ; } } return count ; }"
static int countDigits ( int n ) { double ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += Math . log10 ( i ) ; ans = ans * n ; return 1 + ( int ) Math . floor ( ans ) ; }
"static int replaceDigit ( int x , int d1 , int d2 ) { int result = 0 , multiply = 1 ; while ( x % 10 > 0 ) { int remainder = x % 10 ; if ( remainder == d1 ) result = result + d2 * multiply ; else result = result + remainder * multiply ; multiply *= 10 ; x = x / 10 ; } return result ; }"
"static void minCost ( int [ ] arr , int n ) { int cost = Integer . MAX_VALUE ; int element = 0 ; int XOR = 0 ; for ( int i = 0 ; i < n ; i ++ ) XOR ^= arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( cost > Math . abs ( ( XOR ^ arr [ i ] ) - arr [ i ] ) ) { cost = Math . abs ( ( XOR ^ arr [ i ] ) - arr [ i ] ) ; element = arr [ i ] ; } } System . out . println ( ""Element = "" + element ) ; System . out . println ( ""Operation required = "" + Math . abs ( cost ) ) ; }"
static int minAbsDiff ( int n ) { int mod = n % 4 ; if ( mod == 0 || mod == 3 ) { return 0 ; } return 1 ; }
"static int find_difference ( int arr [ ] , int n , int m ) { int max = 0 , min = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 , j = n - 1 ; i < m ; i ++ , j -- ) { min += arr [ i ] ; max += arr [ j ] ; } return ( max - min ) ; }"
static int isPowerOfFour ( int n ) { int count = 0 ; int x = n & ( n - 1 ) ; if ( n > 0 && x == 0 ) { while ( n > 1 ) { n >>= 1 ; count += 1 ; } return ( count % 2 == 0 ) ? 1 : 0 ; } return 0 ; }
"static void fitOrNotFit ( int R , int r , int x , int y , int rad ) { double val = Math . sqrt ( Math . pow ( x , 2 ) + Math . pow ( y , 2 ) ) ; if ( val + rad <= R && val - rad >= R - r ) System . out . println ( ""Fits"" ) ; else System . out . println ( ""Doesn't Fit"" ) ; }"
"static int largestNumber ( int n ) { String s = """" ; int duplicate = n ; while ( n > 0 ) { s = ( char ) ( n % 10 + 48 ) + s ; n /= 10 ; } int index = - 1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ( ( int ) ( s . charAt ( i ) - '0' ) % 2 & 1 ) == 0 ) { index = i ; break ; } } if ( index == - 1 ) return duplicate ; int num = 0 ; for ( int i = 0 ; i < index ; i ++ ) num = num * 10 + ( int ) ( s . charAt ( i ) - '0' ) ; num = num * 10 + ( ( int ) s . charAt ( index ) - ( int ) ( '0' ) - 1 ) ; for ( int i = index + 1 ; i < s . length ( ) ; i ++ ) num = num * 10 + 9 ; return num ; }"
static int countSolutions ( int n ) { int res = 0 ; for ( int x = 0 ; x * x < n ; x ++ ) for ( int y = 0 ; x * x + y * y < n ; y ++ ) res ++ ; return res ; }
"static long countWays ( int n , int k ) { long total = k ; int mod = 1000000007 ; int same = 0 , diff = k ; for ( int i = 2 ; i <= n ; i ++ ) { same = diff ; diff = ( int ) total * ( k - 1 ) ; diff = diff % mod ; total = ( same + diff ) % mod ; } return total ; }"
"static int waysToArrange ( int N , int K , int [ ] k ) { int [ ] [ ] C = new int [ N + 1 ] [ N + 1 ] ; int i , j ; for ( i = 0 ; i <= N ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) { if ( j == 0 || j == i ) { C [ i ] [ j ] = 1 ; } else { C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; } } } int [ ] dp = new int [ K + 1 ] ; int count = 0 ; dp [ 0 ] = 1 ; for ( i = 0 ; i < K ; i ++ ) { dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] [ k [ i ] - 1 ] ) ; count += k [ i ] ; } return dp [ K ] ; }"
"static void alphabetPattern ( int N ) { int left = 0 , middle = N - 1 , right = N + 1 ; for ( int row = 0 ; row < 2 * N - 1 ; row ++ ) { if ( row < N ) System . out . print ( ++ left ) ; else System . out . print ( -- left ) ; for ( int col = 1 ; col < N - 1 ; col ++ ) { if ( row != N - 1 ) System . out . print ( "" "" ) ; else System . out . print ( "" "" + middle -- ) ; } if ( row < N ) System . out . print ( "" "" + -- right ) ; else System . out . print ( "" "" + ++ right ) ; System . out . println ( ) ; } }"
"static boolean modularSum ( int arr [ ] , int n , int m ) { if ( n > m ) return true ; boolean DP [ ] = new boolean [ m ] ; Arrays . fill ( DP , false ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( DP [ 0 ] ) return true ; boolean temp [ ] = new boolean [ m ] ; Arrays . fill ( temp , false ) ; for ( int j = 0 ; j < m ; j ++ ) { if ( DP [ j ] == true ) { if ( DP [ ( j + arr [ i ] ) % m ] == false ) temp [ ( j + arr [ i ] ) % m ] = true ; } } for ( int j = 0 ; j < m ; j ++ ) if ( temp [ j ] ) DP [ j ] = true ; DP [ arr [ i ] % m ] = true ; } return DP [ 0 ] ; }"
"static void swapOperations ( char [ ] a , char [ ] b , char [ ] c ) { int l = a . length ; int i = 0 ; int total_swaps = 0 ; char temp ; for ( i = 0 ; i < l ; i ++ ) { if ( a [ i ] == b [ i ] ) continue ; if ( a [ i ] == c [ i ] ) { temp = b [ i ] ; b [ i ] = c [ i ] ; c [ i ] = temp ; total_swaps ++ ; continue ; } if ( b [ i ] == c [ i ] ) { temp = a [ i ] ; a [ i ] = c [ i ] ; c [ i ] = temp ; total_swaps ++ ; continue ; } break ; } if ( i == l ) System . out . println ( total_swaps ) ; else System . out . println ( - 1 ) ; }"
static int countRectangles ( int radius ) { int rectangles = 0 ; int diameter = 2 * radius ; int diameterSquare = diameter * diameter ; for ( int a = 1 ; a < 2 * radius ; a ++ ) { for ( int b = 1 ; b < 2 * radius ; b ++ ) { int diagnalLengthSquare = ( a * a + b * b ) ; if ( diagnalLengthSquare <= diameterSquare ) { rectangles ++ ; } } } return rectangles ; }
"static int solve ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int a = 0 , b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 != 0 ) a = a * 10 + arr [ i ] ; else b = b * 10 + arr [ i ] ; } return a + b ; }"
"static void generate ( Set < String > st , String s ) { if ( s . length ( ) == 0 ) { return ; } if ( ! st . contains ( s ) ) { st . add ( s ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { String t = s ; t = t . substring ( 0 , i ) + t . substring ( i + 1 ) ; generate ( st , t ) ; } } return ; }"
static int countPairs ( int n ) { int count = 0 ; for ( int x = 1 ; x < n ; x ++ ) { for ( int y = x + 1 ; y <= n ; y ++ ) { if ( ( y + x ) % ( y ^ x ) == 0 ) count ++ ; } } return count ; }
"static int countNums ( int n , int x , int y ) { boolean [ ] arr = new boolean [ n + 1 ] ; if ( x <= n ) arr [ x ] = true ; if ( y <= n ) arr [ y ] = true ; int result = 0 ; for ( int i = Math . min ( x , y ) ; i <= n ; i ++ ) { if ( arr [ i ] ) { if ( i + x <= n ) arr [ i + x ] = true ; if ( i + y <= n ) arr [ i + y ] = true ; result ++ ; } } return result ; }"
"public static void printSmall ( int arr [ ] , int n , int k ) { for ( int i = k ; i < n ; ++ i ) { int max_var = arr [ k - 1 ] ; int pos = k - 1 ; for ( int j = k - 2 ; j >= 0 ; j -- ) { if ( arr [ j ] > max_var ) { max_var = arr [ j ] ; pos = j ; } } if ( max_var > arr [ i ] ) { int j = pos ; while ( j < k - 1 ) { arr [ j ] = arr [ j + 1 ] ; j ++ ; } arr [ k - 1 ] = arr [ i ] ; } } for ( int i = 0 ; i < k ; i ++ ) System . out . print ( arr [ i ] + "" "" ) ; }"
"static int CalculateMax ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int min_sum = arr [ 0 ] + arr [ 1 ] ; int max_sum = arr [ n - 1 ] + arr [ n - 2 ] ; return ( Math . abs ( max_sum - min_sum ) ) ; }"
"int getInvCount ( int arr [ ] , int n ) { int invcount = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( arr [ j ] > arr [ k ] ) invcount ++ ; } } } } return invcount ; }"
"static void getXandYintercept ( int P [ ] , int Q [ ] ) { int a = P [ 1 ] - Q [ 1 ] ; int b = P [ 0 ] - Q [ 0 ] ; if ( b == 0 ) { System . out . println ( P [ 0 ] ) ; System . out . println ( ""infinity"" ) ; return ; } if ( a == 0 ) { System . out . println ( ""infinity"" ) ; System . out . println ( P [ 1 ] ) ; return ; } double m = a / ( b * 1.0 ) ; int x = P [ 0 ] ; int y = P [ 1 ] ; double c = y - m * x ; y = 0 ; double r = ( y - c ) / ( m * 1.0 ) ; System . out . println ( r ) ; x = 0 ; y = ( int ) ( m * x + c ) ; System . out . print ( c ) ; }"
"static int maxProfit ( int profitA [ ] , int profitB [ ] , int n ) { int preSum [ ] = new int [ n ] ; preSum [ 0 ] = profitA [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { preSum [ i ] = preSum [ i - 1 ] + profitA [ i ] ; } int suffSum [ ] = new int [ n ] ; suffSum [ n - 1 ] = profitB [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { suffSum [ i ] = suffSum [ i + 1 ] + profitB [ i ] ; } int res = preSum [ n - 1 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { res = Math . max ( res , preSum [ i ] + suffSum [ i + 1 ] ) ; } res = Math . max ( res , suffSum [ 0 ] ) ; return res ; }"
"static void fib ( int n ) { int a = 0 , b = 1 , c ; if ( n >= 0 ) System . out . print ( a + "" "" ) ; if ( n >= 1 ) System . out . print ( b + "" "" ) ; for ( int i = 2 ; i <= n ; i ++ ) { c = a + b ; System . out . print ( c + "" "" ) ; a = b ; b = c ; } }"
static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
static double hexDiagonal ( float a ) { if ( a < 0 ) return - 1 ; double d = ( double ) 1.73 * a ; return d ; }
"static int count ( int arr [ ] , int N , int K ) { int count = 0 , ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == K ) { count = count + 1 ; } else { ans += ( count * ( count + 1 ) ) / 2 ; count = 0 ; } } ans = ans + ( count * ( count + 1 ) ) / 2 ; return ans ; }"
"static int items ( int n , int a [ ] ) { Arrays . sort ( a ) ; int z = a [ n - 1 ] ; int x = 1 ; int s = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { s += a [ i ] ; if ( s <= z ) x += 1 ; else break ; } return x ; }"
static int bitwiseAndOdd ( int n ) { int result = 1 ; for ( int i = 3 ; i <= n ; i = i + 2 ) { result = ( result & i ) ; } return result ; }
"static int evenDecimalValue ( String str , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == '0' ) { result += ( n - i ) ; } } return result ; }"
"static double vol_tetra ( int side ) { double volume = ( Math . pow ( side , 3 ) / ( 6 * Math . sqrt ( 2 ) ) ) ; return volume ; }"
"static void makeAP ( int arr [ ] , int n ) { int initial_term , common_difference ; if ( n == 3 ) { common_difference = arr [ 2 ] - arr [ 1 ] ; initial_term = arr [ 1 ] - common_difference ; } else if ( ( arr [ 1 ] - arr [ 0 ] ) == arr [ 2 ] - arr [ 1 ] ) { initial_term = arr [ 0 ] ; common_difference = arr [ 1 ] - arr [ 0 ] ; } else if ( ( arr [ 2 ] - arr [ 1 ] ) == ( arr [ 3 ] - arr [ 2 ] ) ) { common_difference = arr [ 2 ] - arr [ 1 ] ; initial_term = arr [ 1 ] - common_difference ; } else { common_difference = ( arr [ 3 ] - arr [ 0 ] ) / 3 ; initial_term = arr [ 0 ] ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( initial_term + ( i * common_difference ) + "" "" ) ; System . out . println ( ) ; }"
"static void findWeights ( int X ) { int sum = 0 ; int power = 0 ; int number = 3 ; while ( sum < X ) { sum = number - 1 ; sum /= 2 ; power ++ ; number *= 3 ; } int ans = 1 ; for ( int i = 1 ; i <= power ; i ++ ) { System . out . print ( ans + "" "" ) ; ans = ans * 3 ; } }"
"static int solve ( int [ ] a , int d ) { int result = a [ 0 ] ; for ( int i = 1 ; i < a . length ; ++ i ) { int additive = Math . min ( a [ i ] , d / i ) ; result += additive ; d -= additive * i ; } return result ; }"
"static void findTriangles ( int n ) { int num = n ; System . out . print ( num + "" "" ) ; System . out . print ( num * ( num - 4 ) * ( num - 5 ) / 6 ) ; }"
"static int CountTheElements ( int arr [ ] , int n , int k ) { int counter = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) counter ++ ; } return counter ; }"
"static String printSequence ( String arr [ ] , String input ) { String output = """" ; int n = input . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( input . charAt ( i ) == ' ' ) output = output + ""0"" ; else { int position = input . charAt ( i ) - 'A' ; output = output + arr [ position ] ; } } return output ; }"
static int countDer ( int n ) { if ( n == 1 ) return 0 ; if ( n == 0 ) return 1 ; if ( n == 2 ) return 1 ; return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) ) ; }
"static float CalculateRatio ( float m , float n ) { return ( 2 * m - 1 ) / ( 2 * n - 1 ) ; }"
"int countkDist ( String str , int k ) { int res = 0 ; int n = str . length ( ) ; int cnt [ ] = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { int dist_count = 0 ; Arrays . fill ( cnt , 0 ) ; for ( int j = i ; j < n ; j ++ ) { if ( cnt [ str . charAt ( j ) - 'a' ] == 0 ) dist_count ++ ; cnt [ str . charAt ( j ) - 'a' ] ++ ; if ( dist_count == k ) res ++ ; } } return res ; }"
"static int findMaximum ( int arr [ ] , int low , int high ) { if ( low == high ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] >= arr [ high ] ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] < arr [ high ] ) return arr [ high ] ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ mid - 1 ] ) return findMaximum ( arr , low , mid - 1 ) ; else return findMaximum ( arr , mid + 1 , high ) ; }"
"static void printDuplicates ( int arr [ ] , int n ) { int i ; int fl = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ arr [ i ] % n ] >= n ) { if ( arr [ arr [ i ] % n ] < 2 * n ) { System . out . print ( arr [ i ] % n + "" "" ) ; fl = 1 ; } } arr [ arr [ i ] % n ] += n ; } if ( ! ( fl > 0 ) ) System . out . println ( ""-1"" ) ; }"
"static void printPermutation ( int n , int k ) { int i , mx = n ; for ( i = 1 ; i <= k ; i ++ ) { System . out . print ( mx + "" "" ) ; mx -- ; } for ( i = 1 ; i <= mx ; i ++ ) System . out . print ( i + "" "" ) ; }"
"public static int minMaxProduct ( int arr1 [ ] , int arr2 [ ] , int n1 , int n2 ) { int max = arr1 [ 0 ] ; int min = arr2 [ 0 ] ; int i ; for ( i = 1 ; i < n1 && i < n2 ; ++ i ) { if ( arr1 [ i ] > max ) max = arr1 [ i ] ; if ( arr2 [ i ] < min ) min = arr2 [ i ] ; } while ( i < n1 ) { if ( arr1 [ i ] > max ) max = arr1 [ i ] ; i ++ ; } while ( i < n2 ) { if ( arr2 [ i ] < min ) min = arr2 [ i ] ; i ++ ; } return max * min ; }"
"static boolean check ( String s , int l ) { Vector < Integer > pos = new Vector < Integer > ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( s . charAt ( i ) == '1' ) pos . add ( i ) ; } int t = pos . size ( ) ; for ( int i = 1 ; i < t ; i ++ ) { if ( ( pos . get ( i ) - pos . get ( i - 1 ) ) != ( pos . get ( 1 ) - pos . get ( 0 ) ) ) return false ; } return true ; }"
"static void removeSpecialCharacter ( String str ) { char [ ] s = str . toCharArray ( ) ; int j = 0 ; for ( int i = 0 ; i < s . length ; i ++ ) { if ( ( s [ i ] >= 'A' && s [ i ] <= 'Z' ) || ( s [ i ] >= 'a' && s [ i ] <= 'z' ) ) { s [ j ] = s [ i ] ; j ++ ; } } System . out . println ( String . valueOf ( s ) . substring ( 0 , j ) ) ; }"
"static int count_pairs ( int a [ ] , int b [ ] , int n , int m ) { int odd1 = 0 , even1 = 0 ; int odd2 = 0 , even2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) { odd1 ++ ; } else { even1 ++ ; } } for ( int i = 0 ; i < m ; i ++ ) { if ( b [ i ] % 2 == 1 ) { odd2 ++ ; } else { even2 ++ ; } } int pairs = Math . min ( odd1 , even2 ) + Math . min ( odd2 , even1 ) ; return pairs ; }"
"public static int stirlingFactorial ( double n ) { if ( n == 1 ) return 1 ; double z ; double e = 2.71 ; z = Math . sqrt ( 2 * 3.14 * n ) * Math . pow ( ( n / e ) , n ) ; return ( int ) ( z ) ; }"
"static int LCSubStr ( char X [ ] , char Y [ ] , int m , int n ) { int LCStuff [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; int result = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 || j == 0 ) LCStuff [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) { LCStuff [ i ] [ j ] = LCStuff [ i - 1 ] [ j - 1 ] + 1 ; result = Integer . max ( result , LCStuff [ i ] [ j ] ) ; } else LCStuff [ i ] [ j ] = 0 ; } } return result ; }"
static int countDer ( int n ) { int der [ ] = new int [ n + 1 ] ; der [ 0 ] = 1 ; der [ 1 ] = 0 ; der [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; ++ i ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) ; return der [ n ] ; }
"static void printSorted ( int a , int b , int c ) { int get_max = Math . max ( a , Math . max ( b , c ) ) ; int get_min = - Math . max ( - a , Math . max ( - b , - c ) ) ; int get_mid = ( a + b + c ) - ( get_max + get_min ) ; System . out . print ( get_min + "" "" + get_mid + "" "" + get_max ) ; }"
static boolean isValidISBN ( String isbn ) { int n = isbn . length ( ) ; if ( n != 10 ) return false ; int sum = 0 ; for ( int i = 0 ; i < 9 ; i ++ ) { int digit = isbn . charAt ( i ) - '0' ; if ( 0 > digit || 9 < digit ) return false ; sum += ( digit * ( 10 - i ) ) ; } char last = isbn . charAt ( 9 ) ; if ( last != 'X' && ( last < '0' || last > '9' ) ) return false ; sum += ( ( last == 'X' ) ? 10 : ( last - '0' ) ) ; return ( sum % 11 == 0 ) ; }
"static int numberOfPaths ( int m , int n ) { int count [ ] [ ] = new int [ m ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) count [ i ] [ 0 ] = 1 ; for ( int j = 0 ; j < n ; j ++ ) count [ 0 ] [ j ] = 1 ; for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] ; } return count [ m - 1 ] [ n - 1 ] ; }"
"static int findNthTerm ( int x , int y , int n ) { int [ ] f = new int [ 6 ] ; f [ 0 ] = x ; f [ 1 ] = y ; for ( int i = 2 ; i <= 5 ; i ++ ) f [ i ] = f [ i - 1 ] - f [ i - 2 ] ; return f [ n % 6 ] ; }"
"static void findAllSequences ( int diff , char out [ ] , int start , int end ) { if ( Math . abs ( diff ) > ( end - start + 1 ) / 2 ) return ; if ( start > end ) { if ( diff == 0 ) { System . out . print ( out ) ; System . out . print ( "" "" ) ; } return ; } out [ start ] = '0' ; out [ end ] = '1' ; findAllSequences ( diff + 1 , out , start + 1 , end - 1 ) ; out [ start ] = out [ end ] = '1' ; findAllSequences ( diff , out , start + 1 , end - 1 ) ; out [ start ] = out [ end ] = '0' ; findAllSequences ( diff , out , start + 1 , end - 1 ) ; out [ start ] = '1' ; out [ end ] = '0' ; findAllSequences ( diff - 1 , out , start + 1 , end - 1 ) ; }"
"static int no_of_ways ( int a [ ] , int n ) { int count_0 = 0 , count_1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) count_0 ++ ; else count_1 ++ ; } if ( count_1 % 2 == 0 ) return count_0 ; else return count_1 ; }"
"static int smallestNumber ( int n ) { int num = 0 ; String s = """" ; int duplicate = n ; while ( n > 0 ) { s = ( char ) ( n % 10 + 48 ) + s ; n /= 10 ; } int index = - 1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int digit = s . charAt ( i ) - '0' ; if ( ( digit & 1 ) == 0 ) { index = i ; break ; } } if ( index == - 1 ) { return duplicate ; } for ( int i = 0 ; i < index ; i ++ ) { num = num * 10 + ( s . charAt ( i ) - '0' ) ; } num = num * 10 + ( s . charAt ( index ) - '0' + 1 ) ; for ( int i = index + 1 ; i < s . length ( ) ; i ++ ) { num = num * 10 + 1 ; } return num ; }"
static int powerNumbers ( int n ) { HashSet < Integer > v = new HashSet < Integer > ( ) ; v . add ( 1 ) ; for ( int i = 2 ; i * i <= n ; i ++ ) { int j = i * i ; v . add ( j ) ; while ( j * i <= n ) { v . add ( j * i ) ; j = j * i ; } } return v . size ( ) ; }
"static int findCount ( String s , int n , int a , int b ) { int res = 0 ; char [ ] s1 = s . toCharArray ( ) ; for ( int i = 0 ; i < b ; i ++ ) { if ( i == a ) { if ( s1 [ n - i - 1 ] != '1' ) res += 1 ; } else { if ( s1 [ n - i - 1 ] != '0' ) res += 1 ; } } return res ; }"
"static void printNumbers ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int A = arr [ n - 1 ] , B = - 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( A % arr [ i ] != 0 ) { B = arr [ i ] ; break ; } if ( i - 1 >= 0 && arr [ i ] == arr [ i - 1 ] ) { B = arr [ i ] ; break ; } } System . out . print ( ""A = "" + A + "", B = "" + B ) ; }"
"static int trailing_zeros ( int N ) { int count_of_two = 0 , count_of_five = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { int val = i ; while ( val % 2 == 0 && val > 0 ) { val /= 2 ; count_of_two += i ; } while ( val % 5 == 0 && val > 0 ) { val /= 5 ; count_of_five += i ; } } int ans = Math . min ( count_of_two , count_of_five ) ; return ans ; }"
static int countX ( int n ) { int count = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( n - i == ( n ^ i ) ) count ++ ; } return count ; }
public static double maxEdges ( double N ) { double edges = 0 ; edges = Math . floor ( ( N * N ) / 4 ) ; return edges ; }
static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 || n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
"static int compute_average ( int a , int b ) { return ( a / 2 ) + ( b / 2 ) + ( ( a % 2 + b % 2 ) / 2 ) ; }"
static int totalDigits ( int n ) { int number_of_digits = 0 ; for ( int i = 1 ; i <= n ; i *= 10 ) number_of_digits += ( n - i + 1 ) ; return number_of_digits ; }
"static void findSmallest ( int m , int s ) { if ( s == 0 ) { System . out . print ( m == 1 ? ""Smallest number is 0"" : ""Not possible"" ) ; return ; } if ( s > 9 * m ) { System . out . println ( ""Not possible"" ) ; return ; } int [ ] res = new int [ m ] ; s -= 1 ; for ( int i = m - 1 ; i > 0 ; i -- ) { if ( s > 9 ) { res [ i ] = 9 ; s -= 9 ; } else { res [ i ] = s ; s = 0 ; } } res [ 0 ] = s + 1 ; System . out . print ( ""Smallest number is "" ) ; for ( int i = 0 ; i < m ; i ++ ) System . out . print ( res [ i ] ) ; }"
"static void prefix ( char [ ] str ) { int k = 1 , j ; int n = str . length ; Vector < Integer > g = new Vector < > ( ) ; int flag = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( str [ i ] == str [ 0 ] ) { g . add ( i ) ; flag = 1 ; } } if ( flag == 0 ) { System . out . println ( String . valueOf ( str ) ) ; } else { int len = g . size ( ) ; while ( k < g . get ( 0 ) ) { int cnt = 0 ; for ( j = 0 ; j < len ; j ++ ) { if ( ( g . get ( j ) + k ) < n && str [ g . get ( j ) + k ] == str [ k ] ) { cnt ++ ; } } if ( cnt == len ) { k ++ ; } else { break ; } } for ( int i = 0 ; i < k ; i ++ ) { System . out . print ( str [ i ] ) ; } System . out . println ( ) ; } }"
"static void print_max ( int a [ ] , int n , int k ) { int [ ] max_upto = new int [ n ] ; Stack < Integer > s = new Stack < > ( ) ; s . push ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { while ( ! s . empty ( ) && a [ s . peek ( ) ] < a [ i ] ) { max_upto [ s . peek ( ) ] = i - 1 ; s . pop ( ) ; } s . push ( i ) ; } while ( ! s . empty ( ) ) { max_upto [ s . peek ( ) ] = n - 1 ; s . pop ( ) ; } int j = 0 ; for ( int i = 0 ; i <= n - k ; i ++ ) { while ( j < i || max_upto [ j ] < i + k - 1 ) { j ++ ; } System . out . print ( a [ j ] + "" "" ) ; } System . out . println ( ) ; }"
"public static int countKdivPairs ( int A [ ] , int n , int K ) { int freq [ ] = new int [ K ] ; for ( int i = 0 ; i < n ; i ++ ) ++ freq [ A [ i ] % K ] ; int sum = freq [ 0 ] * ( freq [ 0 ] - 1 ) / 2 ; for ( int i = 1 ; i <= K / 2 && i != ( K - i ) ; i ++ ) sum += freq [ i ] * freq [ K - i ] ; if ( K % 2 == 0 ) sum += ( freq [ K / 2 ] * ( freq [ K / 2 ] - 1 ) / 2 ) ; return sum ; }"
static int countSubstr ( String s ) { int n = s . length ( ) ; int [ ] auxArr = new int [ n ] ; if ( s . charAt ( 0 ) == '1' ) auxArr [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '1' ) auxArr [ i ] = auxArr [ i - 1 ] + 1 ; else auxArr [ i ] = auxArr [ i - 1 ] ; } int count = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) if ( s . charAt ( i ) == '1' ) count += auxArr [ i ] ; return count ; }
"static void rearrangeArray ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int [ ] tempArr = new int [ n ] ; int ArrIndex = 0 ; for ( int i = 0 , j = n - 1 ; i <= n / 2 || j > n / 2 ; i ++ , j -- ) { if ( ArrIndex < n ) { tempArr [ ArrIndex ] = arr [ i ] ; ArrIndex ++ ; } if ( ArrIndex < n ) { tempArr [ ArrIndex ] = arr [ j ] ; ArrIndex ++ ; } } for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = tempArr [ i ] ; }"
"static boolean checkIsAP ( int arr [ ] , int n ) { if ( n == 1 ) return true ; Arrays . sort ( arr ) ; int d = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; }"
"static int distinctCount ( int arr [ ] , int n ) { Set < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) s . add ( Math . abs ( arr [ i ] ) ) ; return s . size ( ) ; }"
"static void printPattern ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) System . out . print ( i ) ; System . out . print ( ""\n"" ) ; } for ( int i = n - 1 ; i > 0 ; i -- ) { for ( int j = i ; j > 0 ; j -- ) System . out . print ( i ) ; System . out . print ( ""\n"" ) ; } }"
"static int smallest ( int x , int y , int z ) { int c = 0 ; while ( x != 0 && y != 0 && z != 0 ) { x -- ; y -- ; z -- ; c ++ ; } return c ; }"
static boolean isEven ( int n ) { if ( ( n ^ 1 ) == n + 1 ) return true ; else return false ; }
"static int binarySearchCount ( int arr [ ] , int n , int key ) { int left = 0 ; int right = n - 1 ; int count = 0 ; while ( left <= right ) { int mid = ( right + left ) / 2 ; if ( arr [ mid ] <= key ) { count = mid + 1 ; left = mid + 1 ; } else right = mid - 1 ; } return count ; }"
"static int nthTerm ( int n ) { return 2 * ( int ) Math . pow ( n , 3 ) + ( int ) Math . pow ( n , 2 ) ; }"
"static void alphabetPattern ( int N ) { int index , side_index ; int Top = 1 , Bottom = 1 , Diagonal = N - 1 ; for ( index = 0 ; index < N ; index ++ ) System . out . print ( Top ++ + "" "" ) ; System . out . println ( ) ; for ( index = 1 ; index < N - 1 ; index ++ ) { for ( side_index = 0 ; side_index < 2 * ( N - index - 1 ) ; side_index ++ ) System . out . print ( "" "" ) ; System . out . print ( Diagonal -- ) ; System . out . println ( ) ; } for ( index = 0 ; index < N ; index ++ ) System . out . print ( Bottom ++ + "" "" ) ; }"
"static int cntSubSeq ( int arr [ ] , int n ) { int pos_count = 0 ; int neg_count = 0 ; int result ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) pos_count ++ ; if ( arr [ i ] < 0 ) neg_count ++ ; } result = ( int ) Math . pow ( 2 , pos_count ) ; if ( neg_count > 0 ) result *= Math . pow ( 2 , neg_count - 1 ) ; else result = 0 ; return result ; }"
"static int mod ( String num , int a ) { int res = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) res = ( res * 10 + ( int ) num . charAt ( i ) - '0' ) % a ; return res ; }"
"static void printBracketNumber ( String exp , int n ) { int left_bnum = 1 ; Stack < Integer > right_bnum = new Stack < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( exp . charAt ( i ) == '(' ) { System . out . print ( left_bnum + "" "" ) ; right_bnum . push ( left_bnum ) ; left_bnum ++ ; } else if ( exp . charAt ( i ) == ')' ) { System . out . print ( right_bnum . peek ( ) + "" "" ) ; right_bnum . pop ( ) ; } } }"
"static void modify ( int arr [ ] , int n ) { if ( n <= 1 ) return ; int prev = arr [ 0 ] ; arr [ 0 ] = arr [ 0 ] * arr [ 1 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int curr = arr [ i ] ; arr [ i ] = prev * arr [ i + 1 ] ; prev = curr ; } arr [ n - 1 ] = prev * arr [ n - 1 ] ; }"
"static void countSubarraysof1and0 ( int a [ ] , int n ) { int count1 = 0 , count0 = 0 ; int number1 = 0 , number0 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) { count1 += 1 ; } else { number1 += ( count1 ) * ( count1 + 1 ) / 2 ; count1 = 0 ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count0 += 1 ; } else { number0 += ( count0 ) * ( count0 + 1 ) / 2 ; count0 = 0 ; } } if ( count1 > 0 ) number1 += ( count1 ) * ( count1 + 1 ) / 2 ; if ( count0 > 0 ) number0 += ( count0 ) * ( count0 + 1 ) / 2 ; System . out . println ( ""Count of subarrays of 0 only: "" + number0 ) ; System . out . println ( ""\nCount of subarrays of 1 only: "" + number1 ) ; }"
"static int floorSearch ( int arr [ ] , int low , int high , int x ) { if ( low > high ) return - 1 ; if ( x >= arr [ high ] ) return high ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( mid > 0 && arr [ mid - 1 ] <= x && x < arr [ mid ] ) return mid - 1 ; if ( x < arr [ mid ] ) return floorSearch ( arr , low , mid - 1 , x ) ; return floorSearch ( arr , mid + 1 , high , x ) ; }"
"public static String findstem ( String arr [ ] ) { int n = arr . length ; String s = arr [ 0 ] ; int len = s . length ( ) ; String res = """" ; for ( int i = 0 ; i < len ; i ++ ) { for ( int j = i + 1 ; j <= len ; j ++ ) { String stem = s . substring ( i , j ) ; int k = 1 ; for ( k = 1 ; k < n ; k ++ ) if ( ! arr [ k ] . contains ( stem ) ) break ; if ( k == n && res . length ( ) < stem . length ( ) ) res = stem ; } } return res ; }"
"static int distinct ( int [ ] arr , int n ) { int count = 0 ; if ( n == 1 ) return 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( i == 0 ) { if ( arr [ i ] != arr [ i + 1 ] ) count += 1 ; } else { if ( arr [ i ] != arr [ i + 1 ] || arr [ i ] != arr [ i - 1 ] ) count += 1 ; } } if ( arr [ n - 1 ] != arr [ n - 2 ] ) count += 1 ; return count ; }"
"public static int partition ( int [ ] arr , int p , int r ) { int x = arr [ r ] ; int i = p - 1 ; for ( int j = p ; j < r ; j ++ ) { if ( arr [ j ] <= x ) { int a = arr [ ++ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = a ; } } int a = arr [ i + 1 ] ; arr [ i + 1 ] = arr [ r ] ; arr [ r ] = a ; return i + 1 ; }"
"static int maxDiff ( int arr [ ] , int n ) { int maxDiff = - 1 ; int maxRight = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > maxRight ) maxRight = arr [ i ] ; else { int diff = maxRight - arr [ i ] ; if ( diff > maxDiff ) { maxDiff = diff ; } } } return maxDiff ; }"
"static int minOperations ( int n , int m ) { if ( m % n != 0 ) return - 1 ; int minOperations = 0 ; int q = m / n ; while ( q % 2 == 0 ) { q = q / 2 ; minOperations ++ ; } while ( q % 3 == 0 ) { q = q / 3 ; minOperations ++ ; } if ( q == 1 ) return minOperations ; return - 1 ; }"
"static void rgb_to_hsv ( double r , double g , double b ) { r = r / 255.0 ; g = g / 255.0 ; b = b / 255.0 ; double cmax = Math . max ( r , Math . max ( g , b ) ) ; double cmin = Math . min ( r , Math . min ( g , b ) ) ; double diff = cmax - cmin ; double h = - 1 , s = - 1 ; if ( cmax == cmin ) h = 0 ; else if ( cmax == r ) h = ( 60 * ( ( g - b ) / diff ) + 360 ) % 360 ; else if ( cmax == g ) h = ( 60 * ( ( b - r ) / diff ) + 120 ) % 360 ; else if ( cmax == b ) h = ( 60 * ( ( r - g ) / diff ) + 240 ) % 360 ; if ( cmax == 0 ) s = 0 ; else s = ( diff / cmax ) * 100 ; double v = cmax * 100 ; System . out . println ( ""("" + h + "" "" + s + "" "" + v + "")"" ) ; }"
"static int findlargestAfterDel ( int arr [ ] , int m , int del [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( mp . containsKey ( del [ i ] ) ) { mp . put ( del [ i ] , mp . get ( del [ i ] ) + 1 ) ; } else { mp . put ( del [ i ] , 1 ) ; } } int largestElement = Integer . MIN_VALUE ; for ( int i = 0 ; i < m ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) - 1 ) ; if ( mp . get ( arr [ i ] ) == 0 ) mp . remove ( arr [ i ] ) ; } else largestElement = Math . max ( largestElement , arr [ i ] ) ; } return largestElement ; }"
"static int getLargestSum ( int N ) { int max_sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = i + 1 ; j <= N ; j ++ ) { if ( i * j % ( i + j ) == 0 ) max_sum = Math . max ( max_sum , i + j ) ; } } return max_sum ; }"
"static void printPermutation ( int n , int k ) { for ( int i = 1 ; i <= n ; i ++ ) { int x = 2 * i - 1 ; int y = 2 * i ; if ( i <= k ) System . out . print ( y + "" "" + x + "" "" ) ; else System . out . print ( x + "" "" + y + "" "" ) ; } }"
"static void series ( int A , int X , int n ) { int term = ( int ) Math . pow ( A , n ) ; System . out . print ( term + "" "" ) ; for ( int i = 1 ; i <= n ; i ++ ) { term = term * X * ( n - i + 1 ) / ( i * A ) ; System . out . print ( term + "" "" ) ; } }"
static String balancedBrackets ( String str ) { int dep = 0 ; int minDep = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == '(' ) dep ++ ; else dep -- ; if ( minDep > dep ) minDep = dep ; } if ( minDep < 0 ) { for ( int i = 0 ; i < Math . abs ( minDep ) ; i ++ ) str = '(' + str ; } dep = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == '(' ) dep ++ ; else dep -- ; } if ( dep != 0 ) { for ( int i = 0 ; i < dep ; i ++ ) str = str + ')' ; } return str ; }
"static void bonacciseries ( int n , int m ) { int [ ] a = new int [ m ] ; a [ n - 1 ] = 1 ; for ( int i = n ; i < m ; i ++ ) for ( int j = i - n ; j < i ; j ++ ) a [ i ] += a [ j ] ; for ( int i = 0 ; i < m ; i ++ ) System . out . print ( a [ i ] + "" "" ) ; }"
"static String wordReverse ( String str ) { int i = str . length ( ) - 1 ; int start , end = i + 1 ; String result = """" ; while ( i >= 0 ) { if ( str . charAt ( i ) == ' ' ) { start = i + 1 ; while ( start != end ) result += str . charAt ( start ++ ) ; result += ' ' ; end = i ; } i -- ; } start = 0 ; while ( start != end ) result += str . charAt ( start ++ ) ; return result ; }"
"static boolean LiesInsieRectangle ( int a , int b , int x , int y ) { if ( x - y - b <= 0 && x - y + b >= 0 && x + y - 2 * a + b <= 0 && x + y - b >= 0 ) return true ; return false ; }"
"static void printKMax ( int a [ ] , int n , int k ) { if ( k == 1 ) { for ( int i = 0 ; i < n ; i += 1 ) System . out . print ( a [ i ] + "" "" ) ; return ; } int p = 0 , q = k - 1 , t = p , max = a [ k - 1 ] ; while ( q <= n - 1 ) { if ( a [ p ] > max ) max = a [ p ] ; p += 1 ; if ( q == p && p != n ) { System . out . print ( max + "" "" ) ; q ++ ; p = ++ t ; if ( q < n ) max = a [ q ] ; } } }"
"static int calcAngle ( double h , double m ) { if ( h < 0 || m < 0 || h > 12 || m > 60 ) System . out . println ( ""Wrong input"" ) ; if ( h == 12 ) h = 0 ; if ( m == 60 ) m = 0 ; int hour_angle = ( int ) ( 0.5 * ( h * 60 + m ) ) ; int minute_angle = ( int ) ( 6 * m ) ; int angle = Math . abs ( hour_angle - minute_angle ) ; angle = Math . min ( 360 - angle , angle ) ; return angle ; }"
static double surface_area_octahedron ( double side ) { return ( 2 * ( Math . sqrt ( 3 ) ) * ( side * side ) ) ; }
"static String minLexRotation ( String str ) { int n = str . length ( ) ; String arr [ ] = new String [ n ] ; String concat = str + str ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = concat . substring ( i , i + n ) ; } Arrays . sort ( arr ) ; return arr [ 0 ] ; }"
"public static double maxAverageOfPath ( int cost [ ] [ ] , int N ) { int dp [ ] [ ] = new int [ N + 1 ] [ N + 1 ] ; dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( int j = 1 ; j < N ; j ++ ) dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j < N ; j ++ ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return ( double ) dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) ; }"
static int digSum ( int n ) { int sum = 0 ; while ( n > 0 || sum > 9 ) { if ( n == 0 ) { n = sum ; sum = 0 ; } sum += n % 10 ; n /= 10 ; } return sum ; }
"static int findElement ( int [ ] arr , int [ ] [ ] ranges , int rotations , int index ) { for ( int i = rotations - 1 ; i >= 0 ; i -- ) { int left = ranges [ i ] [ 0 ] ; int right = ranges [ i ] [ 1 ] ; if ( left <= index && right >= index ) { if ( index == left ) index = right ; else index -- ; } } return arr [ index ] ; }"
"static boolean right ( int arr [ ] ) { double x [ ] = new double [ 3 ] ; x [ 0 ] = Math . pow ( arr [ 0 ] - arr [ 2 ] , 2 ) + Math . pow ( arr [ 1 ] - arr [ 3 ] , 2 ) ; x [ 1 ] = Math . pow ( arr [ 0 ] - arr [ 4 ] , 2 ) + Math . pow ( arr [ 1 ] - arr [ 5 ] , 2 ) ; x [ 2 ] = Math . pow ( arr [ 4 ] - arr [ 2 ] , 2 ) + Math . pow ( arr [ 5 ] - arr [ 3 ] , 2 ) ; Arrays . sort ( x ) ; if ( x [ 0 ] + x [ 1 ] == x [ 2 ] && x [ 1 ] != 0 && x [ 0 ] != 0 && x [ 2 ] != 0 ) return true ; return false ; }"
"static void CheckSubarray ( int arr [ ] , int N ) { int presum [ ] = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i += 1 ) { presum [ i ] = presum [ i - 1 ] + arr [ i - 1 ] ; } for ( int i = 1 ; i <= N ; i += 1 ) { for ( int j = i ; j <= N ; j += 1 ) { if ( ( presum [ j ] - presum [ i - 1 ] ) % N == 0 ) { System . out . print ( ( i - 1 ) + "" "" + ( j - 1 ) ) ; return ; } } } System . out . print ( - 1 ) ; }"
"static void reverse ( String str , int x ) { int n = ( str . length ( ) - x ) / 2 ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( str . charAt ( i ) ) ; for ( int i = n + x - 1 ; i >= n ; i -- ) System . out . print ( str . charAt ( i ) ) ; for ( int i = n + x ; i < str . length ( ) ; i ++ ) System . out . print ( str . charAt ( i ) ) ; }"
"static int findPlatform ( int arr [ ] , int dep [ ] , int n ) { Arrays . sort ( arr ) ; Arrays . sort ( dep ) ; int plat_needed = 1 , result = 1 ; int i = 1 , j = 0 ; while ( i < n && j < n ) { if ( arr [ i ] <= dep [ j ] ) { plat_needed ++ ; i ++ ; if ( plat_needed > result ) result = plat_needed ; } else { plat_needed -- ; j ++ ; } } return result ; }"
public static int nthTerm ( int N ) { return Math . abs ( N * ( ( N - 1 ) * ( N - 3 ) * ( N - 5 ) ) ) ; }
"public static void search ( String txt , String pat ) { int M = pat . length ( ) ; int N = txt . length ( ) ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt . charAt ( i + j ) != pat . charAt ( j ) ) break ; if ( j == M ) System . out . println ( ""Pattern found at index "" + i ) ; } }"
"static boolean Check_is_possible ( int l , int r , int k ) { int div_count = ( r / k ) - ( l / k ) ; if ( l % k == 0 ) { div_count ++ ; } return ( div_count > 1 ) ; }"
"static void printRepeating ( Integer [ ] arr , int size ) { SortedSet < Integer > s = new TreeSet < > ( ) ; Collections . addAll ( s , arr ) ; System . out . print ( s ) ; }"
"static int multiply ( int x , int y ) { if ( y == 0 ) return 0 ; if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ; if ( y < 0 ) return - multiply ( x , - y ) ; return - 1 ; }"
"static int countManipulations ( String s1 , String s2 ) { int count = 0 ; int char_count [ ] = new int [ 26 ] ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) char_count [ s1 . charAt ( i ) - 'a' ] ++ ; for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) if ( char_count [ s2 . charAt ( i ) - 'a' ] -- <= 0 ) count ++ ; return count ; }"
"static int numberOfPaths ( int m , int n ) { if ( m == 1 || n == 1 ) return 1 ; return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) ; }"
"public static int findLength ( String str , int n ) { int current_sum = 0 ; int max_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { current_sum += ( str . charAt ( i ) == '0' ? 1 : - 1 ) ; if ( current_sum < 0 ) current_sum = 0 ; max_sum = Math . max ( current_sum , max_sum ) ; } return max_sum == 0 ? - 1 : max_sum ; }"
public static int countPairs ( int n ) { int num = ( ( n / 2 ) + 1 ) ; int max = n % num ; int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { int val = ( ( n % i ) % j ) % n ; if ( val == max ) count ++ ; } } return count ; }
"static void middleProduct ( int mat [ ] [ ] , int n ) { int row_prod = 1 , col_prod = 1 ; for ( int i = 0 ; i < n ; i ++ ) { row_prod *= mat [ n / 2 ] [ i ] ; col_prod *= mat [ i ] [ n / 2 ] ; } System . out . print ( ""Product of middle row = "" + row_prod ) ; System . out . print ( ""Product of middle column = "" + col_prod ) ; }"
"static String printString ( int n , String str ) { String str2 = """" ; int extraChar = n % 26 ; if ( extraChar >= 1 ) { for ( int i = 26 - ( extraChar + 1 ) ; i <= 25 ; i ++ ) { str2 += str . charAt ( i ) ; } } int countOfStr = n / 26 ; for ( int i = 1 ; i <= countOfStr ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) { str2 += str . charAt ( j ) ; } } return str2 ; }"
"static void findsolution ( long n , long x , long y ) { if ( ( y - n + 1 ) * ( y - n + 1 ) + n - 1 < x || y < n ) { System . out . println ( ""No solution"" ) ; return ; } System . out . println ( y - n + 1 ) ; while ( n -- > 1 ) System . out . println ( ""1"" ) ; }"
"static void findSeries ( int num , int first , int sec ) { System . out . print ( first + "" "" + sec + "" "" ) ; int counter = 0 , sum ; while ( counter < num - 2 ) { sum = first + sec ; System . out . print ( sum + "" "" ) ; first = sec ; sec = sum ; counter ++ ; } }"
"static int findCount ( int d ) { return 9 * ( ( int ) ( Math . pow ( 10 , d - 1 ) ) - ( int ) ( Math . pow ( 9 , d - 1 ) ) ) ; }"
static int binaryToDecimal ( int n ) { int num = n ; int dec_value = 0 ; int base = 1 ; int temp = num ; while ( temp > 0 ) { int last_digit = temp % 10 ; temp = temp / 10 ; dec_value += last_digit * base ; base = base * 2 ; } return dec_value ; }
static boolean isBinary ( int number ) { Set < Integer > set = new HashSet < > ( ) ; while ( number > 0 ) { int digit = number % 10 ; set . add ( digit ) ; number /= 10 ; } set . remove ( 0 ) ; set . remove ( 1 ) ; if ( set . size ( ) == 0 ) { return true ; } return false ; }
static int countWays ( int num ) { int [ ] dp = new int [ num + 1 ] ; int MOD = ( int ) 1E9 + 7 ; dp [ 1 ] = 2 ; for ( int i = 2 ; i <= num ; ++ i ) { dp [ i ] = 0 ; for ( int j = 1 ; j <= 3 ; ++ j ) { if ( i - j == 0 ) dp [ i ] += 1 ; else if ( j == 1 ) dp [ i ] += dp [ i - j ] * 2 ; else if ( i - j > 0 ) dp [ i ] += dp [ i - j ] ; if ( dp [ i ] >= MOD ) dp [ i ] %= MOD ; } } return dp [ num ] ; }
static int minLettersNeeded ( int n ) { if ( n % 26 == 0 ) return ( n / 26 ) ; else return ( ( n / 26 ) + 1 ) ; }
static int countPS ( String str ) { int N = str . length ( ) ; int [ ] [ ] cps = new int [ N + 1 ] [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) cps [ i ] [ i ] = 1 ; for ( int L = 2 ; L <= N ; L ++ ) { for ( int i = 0 ; i < N ; i ++ ) { int k = L + i - 1 ; if ( k < N ) { if ( str . charAt ( i ) == str . charAt ( k ) ) cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 ; else cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] ; } } } return cps [ 0 ] [ N - 1 ] ; }
"static int findSum ( int arr [ ] , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) { sum += arr [ i ] ; } } return sum ; }"
"static int countRotations ( String n ) { int len = n . length ( ) ; if ( len == 1 ) { int oneDigit = n . charAt ( 0 ) - '0' ; if ( oneDigit % 4 == 0 ) return 1 ; return 0 ; } int twoDigit , count = 0 ; for ( int i = 0 ; i < ( len - 1 ) ; i ++ ) { twoDigit = ( n . charAt ( i ) - '0' ) * 10 + ( n . charAt ( i + 1 ) - '0' ) ; if ( twoDigit % 4 == 0 ) count ++ ; } twoDigit = ( n . charAt ( len - 1 ) - '0' ) * 10 + ( n . charAt ( 0 ) - '0' ) ; if ( twoDigit % 4 == 0 ) count ++ ; return count ; }"
"static int lcs ( int [ ] [ ] [ ] dp , int [ ] arr1 , int n , int [ ] arr2 , int m , int k ) { if ( k < 0 ) return - 10000000 ; if ( n < 0 || m < 0 ) return 0 ; int ans = dp [ n ] [ m ] [ k ] ; if ( ans != - 1 ) return ans ; try { ans = Math . max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) ; if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) ans = Math . max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) ; ans = Math . max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) ; } catch ( Exception e ) { } return ans ; }"
"static void printAllAPTriplets ( int [ ] arr , int n ) { ArrayList < Integer > s = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int diff = arr [ j ] - arr [ i ] ; boolean exists = s . contains ( arr [ i ] - diff ) ; if ( exists ) System . out . println ( arr [ i ] - diff + "" "" + arr [ i ] + "" "" + arr [ j ] ) ; } s . add ( arr [ i ] ) ; } }"
static boolean checkMarkov ( double m [ ] [ ] ) { for ( int i = 0 ; i < m . length ; i ++ ) { double sum = 0 ; for ( int j = 0 ; j < m [ i ] . length ; j ++ ) sum = sum + m [ i ] [ j ] ; if ( sum != 1 ) return false ; } return true ; }
"static boolean checkPairs ( int l , int r ) { if ( ( l - r ) % 2 == 0 ) return false ; return true ; }"
"static int nthTerm ( int n ) { return 3 * ( int ) Math . pow ( n , 2 ) + n - 2 ; }"
"static int countWays ( int A , int B , int C ) { int minAddA = Math . max ( 0 , ( C + B - A + 2 ) / 2 ) ; int count_ways = Math . max ( C - minAddA + 1 , 0 ) ; return count_ways ; }"
"public static int fibonacciArray ( int [ ] arr , int n ) { Set < Integer > s = new HashSet < Integer > ( ) ; int a = 1 , b = 1 ; int c ; s . add ( a ) ; if ( n > 2 ) s . add ( b ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) { c = a + b ; s . add ( c ) ; a = b ; b = c ; } for ( int i = 0 ; i < n ; i ++ ) { if ( s . contains ( arr [ i ] ) ) s . remove ( arr [ i ] ) ; } return s . size ( ) ; }"
"public static void printPascal ( int n ) { for ( int line = 1 ; line <= n ; line ++ ) { int C = 1 ; for ( int i = 1 ; i <= line ; i ++ ) { System . out . print ( C + "" "" ) ; C = C * ( line - i ) / i ; } System . out . println ( ) ; } }"
static long countStrs ( int n ) { long [ ] [ ] dp = new long [ n + 1 ] [ 27 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < 27 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( int i = 0 ; i <= 25 ; i ++ ) { dp [ 1 ] [ i ] = 1 ; } for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 25 ; j ++ ) { if ( j == 0 ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; } else { dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) ; } } } long sum = 0 ; for ( int i = 0 ; i <= 25 ; i ++ ) { sum = ( sum + dp [ n ] [ i ] ) ; } return sum ; }
"static void radius ( double n , double d ) { System . out . print ( ""The side of each square is "" + d / ( ( n - 1 ) * Math . sqrt ( 2 ) ) ) ; }"
"static int maxLength ( String s , int n ) { int invalidOpenBraces = 0 ; int invalidCloseBraces = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '(' ) { invalidOpenBraces ++ ; } else { if ( invalidOpenBraces == 0 ) { invalidCloseBraces ++ ; } else { invalidOpenBraces -- ; } } } return ( n - ( invalidOpenBraces + invalidCloseBraces ) ) ; }"
static int calculateSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ ] = new int [ n + 1 ] ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; int sum = fibo [ 0 ] + fibo [ 1 ] ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += fibo [ i ] ; } return sum ; }
static boolean isTriPerfect ( int n ) { int sum = 1 + n ; int i = 2 ; while ( i * i <= n ) { if ( n % i == 0 ) { if ( n / i == i ) sum = sum + i ; else sum = sum + i + n / i ; } i += 1 ; } if ( sum == 3 * n & n != 1 ) return true ; else return false ; }
public static int sumOfSeries ( int n ) { int x ; if ( n % 2 == 0 ) x = ( n / 2 ) * ( n + 1 ) ; else x = ( ( n + 1 ) / 2 ) * n ; return x * x ; }
"static int sumOfDivisblePowers ( int L , int R , int P ) { int res = 0 ; for ( int i = L ; i <= R ; i ++ ) { int x = i ; while ( x % P == 0 ) { res ++ ; x /= P ; } } return res ; }"
"static int missingNumber ( int arr1 [ ] , int arr2 [ ] , int n ) { int mnum = 0 ; for ( int i = 0 ; i < n ; i ++ ) mnum = mnum ^ arr1 [ i ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) mnum = mnum ^ arr2 [ i ] ; return mnum ; }"
"static int countNumbers ( int N ) { return ( int ) ( Math . pow ( 10 , N ) - Math . pow ( 8 , N ) ) / 2 ; }"
"static void findNumbers ( int n ) { int odd = ( int ) Math . pow ( 10 , n ) - 1 ; int even = odd - 1 ; System . out . println ( ""Even = "" + even ) ; System . out . print ( ""Odd = "" + odd ) ; }"
"static int maxPrimefactorNum ( int N ) { boolean arr [ ] = new boolean [ N + 5 ] ; for ( int i = 3 ; i * i <= N ; i += 2 ) { if ( ! arr [ i ] ) { for ( int j = i * i ; j <= N ; j += i ) { arr [ j ] = true ; } } } Vector < Integer > prime = new Vector < > ( ) ; prime . add ( prime . size ( ) , 2 ) ; for ( int i = 3 ; i <= N ; i += 2 ) { if ( ! arr [ i ] ) { prime . add ( prime . size ( ) , i ) ; } } int i = 0 , ans = 1 ; while ( ans * prime . get ( i ) <= N && i < prime . size ( ) ) { ans *= prime . get ( i ) ; i ++ ; } return ans ; }"
"public static void longestAlternating ( int arr [ ] , int n ) { int [ ] count = new int [ n ] ; count [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] * arr [ i + 1 ] < 0 ) count [ i ] = count [ i + 1 ] + 1 ; else count [ i ] = 1 ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( count [ i ] + "" "" ) ; }"
"static int countSol ( int coeff [ ] , int start , int end , int rhs ) { if ( rhs == 0 ) return 1 ; int result = 0 ; for ( int i = start ; i <= end ; i ++ ) if ( coeff [ i ] <= rhs ) result += countSol ( coeff , i , end , rhs - coeff [ i ] ) ; return result ; }"
"public static int minimumOperations ( int [ ] a , int n ) { HashMap < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . get ( a [ i ] ) != null ) { int x = mp . get ( a [ i ] ) ; mp . put ( a [ i ] , ++ x ) ; } else mp . put ( a [ i ] , 1 ) ; } int count = 0 ; for ( HashMap . Entry < Integer , Integer > entry : mp . entrySet ( ) ) { if ( entry . getValue ( ) > 1 ) { count += ( entry . getValue ( ) - 1 ) ; } } return count ; }"
"static void angleextcycquad ( int z ) { System . out . print ( ""The exterior angle of the"" + "" cyclic quadrilateral is "" + z + "" degrees"" ) ; }"
static long findF_N ( long n ) { long ans = 0 ; for ( long i = 0 ; i < n ; ++ i ) ans += ( i + 1 ) * ( n - i - 1 ) ; return ans ; }
"public static int lcs ( String X , String Y ) { int m = X . length ( ) , n = Y . length ( ) ; int L [ ] [ ] = new int [ 2 ] [ n + 1 ] ; int bi = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { bi = i & 1 ; for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 || j == 0 ) L [ bi ] [ j ] = 0 ; else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 ; else L [ bi ] [ j ] = Math . max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) ; } } return L [ bi ] [ n ] ; }"
"static boolean checkReverse ( int arr [ ] , int n ) { int temp [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { temp [ i ] = arr [ i ] ; } Arrays . sort ( temp ) ; int front ; for ( front = 0 ; front < n ; front ++ ) { if ( temp [ front ] != arr [ front ] ) { break ; } } int back ; for ( back = n - 1 ; back >= 0 ; back -- ) { if ( temp [ back ] != arr [ back ] ) { break ; } } if ( front >= back ) { return true ; } do { front ++ ; if ( arr [ front - 1 ] < arr [ front ] ) { return false ; } } while ( front != back ) ; return true ; }"
"static int minMovesToSort ( int arr [ ] , int n ) { int moves = 0 ; int i , mn = arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > mn ) moves += arr [ i ] - mn ; mn = arr [ i ] ; } return moves ; }"
"static double calculateAlternateSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ ] = new int [ n + 1 ] ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; double sum = Math . pow ( fibo [ 0 ] , 2 ) + Math . pow ( fibo [ 1 ] , 2 ) ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; if ( i % 2 == 0 ) sum -= fibo [ i ] ; else sum += fibo [ i ] ; } return sum ; }"
"static Boolean isPentagonal ( int N ) { int i = 1 , M ; do { M = ( 3 * i * i - i ) / 2 ; i += 1 ; } while ( M < N ) ; return ( M == N ) ; }"
"static void printKPFNums ( int A , int B , int K ) { boolean prime [ ] = new boolean [ B + 1 ] ; Arrays . fill ( prime , true ) ; int p_factors [ ] = new int [ B + 1 ] ; Arrays . fill ( p_factors , 0 ) ; for ( int p = 2 ; p <= B ; p ++ ) if ( p_factors [ p ] == 0 ) for ( int i = p ; i <= B ; i += p ) p_factors [ i ] ++ ; for ( int i = A ; i <= B ; i ++ ) if ( p_factors [ i ] == K ) System . out . print ( i + "" "" ) ; }"
"static void pairwiseProduct ( int [ ] arr , int n ) { int prod = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { prod = arr [ i ] * arr [ i + 1 ] ; System . out . print ( prod + "" "" ) ; } }"
"static int countPairs ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int product = arr [ i ] * arr [ j ] ; for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ k ] == product ) { result ++ ; break ; } } } } return result ; }"
"static void anglequichord ( int z ) { System . out . println ( ""The angle is "" + z + "" degrees"" ) ; }"
static int spiralDiaSum ( int n ) { if ( n == 1 ) return 1 ; return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) ; }
"static void expressDigit ( int arr [ ] , int n ) { int min = 9 , index = 0 , temp = 0 ; temp = arr [ 0 ] ; for ( int i = 1 ; i < 10 ; i ++ ) { if ( arr [ i ] < min ) { min = arr [ i ] ; index = i ; } } if ( temp < min ) { System . out . print ( 1 ) ; for ( int i = 1 ; i <= temp + 1 ; i ++ ) System . out . print ( 0 ) ; } else { for ( int i = 0 ; i < min ; i ++ ) System . out . print ( index ) ; System . out . print ( index ) ; } }"
"static int NoofTriplets ( int N , int K ) { int [ ] cnt = new int [ K ] ; Arrays . fill ( cnt , 0 , cnt . length , 0 ) ; for ( int i = 1 ; i <= N ; i += 1 ) { cnt [ i % K ] += 1 ; } if ( ( K & 1 ) != 0 ) { return cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] ; } else { return ( cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] + cnt [ K / 2 ] * cnt [ K / 2 ] * cnt [ K / 2 ] ) ; } }"
"static void sub_segments ( String str , int n ) { int l = str . length ( ) ; for ( int x = 0 ; x < l ; x += n ) { String newlist = str . substring ( x , x + n ) ; List < Character > arr = new ArrayList < Character > ( ) ; for ( char y : newlist . toCharArray ( ) ) { if ( ! arr . contains ( y ) ) arr . add ( y ) ; } for ( char y : arr ) System . out . print ( y ) ; System . out . println ( ) ; } }"
"static int maxDifference ( int arr [ ] , int N , int k ) { int M , S = 0 , S1 = 0 , max_difference = 0 ; for ( int i = 0 ; i < N ; i ++ ) S += arr [ i ] ; int temp ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } } } M = Math . max ( k , N - k ) ; for ( int i = 0 ; i < M ; i ++ ) S1 += arr [ i ] ; max_difference = S1 - ( S - S1 ) ; return max_difference ; }"
static int check_duck ( String num ) { int len = num . length ( ) ; int count_zero = 0 ; char ch ; for ( int i = 1 ; i < len ; i ++ ) { ch = num . charAt ( i ) ; if ( ch == '0' ) count_zero ++ ; } return count_zero ; }
static boolean isAMultipleOf4 ( int n ) { if ( ( n & 3 ) == 0 ) return true ; return false ; }
"static void reverse ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n ; i += k ) { int left = i ; int right = Math . min ( i + k - 1 , n - 1 ) ; int temp ; while ( left < right ) { temp = arr [ left ] ; arr [ left ] = arr [ right ] ; arr [ right ] = temp ; left += 1 ; right -= 1 ; } } }"
"static boolean match_words ( String dictionary [ ] , String sentence [ ] , int n , int m ) { Map < String , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( dictionary [ i ] ) ) { mp . put ( dictionary [ i ] , mp . get ( dictionary [ i ] ) + 1 ) ; } else { mp . put ( dictionary [ i ] , 1 ) ; } } for ( int i = 0 ; i < m ; i ++ ) { if ( mp . containsKey ( sentence [ i ] ) ) mp . put ( sentence [ i ] , mp . get ( sentence [ i ] ) - 1 ) ; else return false ; } return true ; }"
"static int countSubString ( String s , char c , int k ) { int leftCount = 0 , rightCount = 0 ; int left = 0 , right = 0 ; int freq = 0 ; int result = 0 , len = s . length ( ) ; while ( s . charAt ( left ) != c && left < len ) { left ++ ; leftCount ++ ; } right = left + 1 ; while ( freq != ( k - 1 ) && ( right - 1 ) < len ) { if ( s . charAt ( right ) == c ) { freq ++ ; } right ++ ; } while ( left < len && ( right - 1 ) < len ) { while ( s . charAt ( left ) != c && left < len ) { left ++ ; leftCount ++ ; } while ( right < len && s . charAt ( right ) != c ) { if ( s . charAt ( right ) == c ) { freq ++ ; } right ++ ; rightCount ++ ; } result = result + ( leftCount + 1 ) * ( rightCount + 1 ) ; freq = k - 1 ; leftCount = 0 ; rightCount = 0 ; left ++ ; right ++ ; } return result ; }"
"static int countWays ( int n , int arr [ ] , int len ) { if ( n == 0 ) return 1 ; int no_ways = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( n - arr [ i ] >= 0 ) { no_ways += countWays ( n - arr [ i ] , arr , len ) ; } } return no_ways ; }"
"static void anglechordtang ( int z ) { System . out . print ( ""The angle between tangent"" + "" and the chord is "" + z + "" degrees"" ) ; }"
"static boolean checkCentrosymmetricted ( int n , int m [ ] [ ] ) { int mid_row ; if ( ( n & 1 ) > 0 ) mid_row = n / 2 + 1 ; else mid_row = n / 2 ; for ( int i = 0 ; i < mid_row ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( m [ i ] [ j ] != m [ n - i - 1 ] [ n - j - 1 ] ) return false ; } } return true ; }"
static int isPowerOf2 ( String s ) { char [ ] str = s . toCharArray ( ) ; int len_str = s . length ( ) ; int num = 0 ; if ( len_str == 1 && str [ len_str - 1 ] == '1' ) return 0 ; while ( len_str != 1 || str [ len_str - 1 ] != '1' ) { if ( ( str [ len_str - 1 ] - '0' ) % 2 == 1 ) return 0 ; int j = 0 ; for ( int i = 0 ; i < len_str ; i ++ ) { num = num * 10 + ( int ) str [ i ] - ( int ) '0' ; if ( num < 2 ) { if ( i != 0 ) str [ j ++ ] = '0' ; continue ; } str [ j ++ ] = ( char ) ( ( int ) ( num / 2 ) + ( int ) '0' ) ; num = ( num ) - ( num / 2 ) * 2 ; } str [ j ] = '\0' ; len_str = j ; } return 1 ; }
"static void NicomachuTheorum_sum ( int n ) { int sum = 0 ; for ( int k = 1 ; k <= n ; k ++ ) sum += k * k * k ; int triNo = n * ( n + 1 ) / 2 ; if ( sum == triNo * triNo ) System . out . println ( ""Yes"" ) ; else System . out . println ( ""No"" ) ; }"
"static void farthest_min ( int [ ] a , int n ) { int [ ] suffix_min = new int [ n ] ; suffix_min [ n - 1 ] = a [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { suffix_min [ i ] = Math . min ( suffix_min [ i + 1 ] , a [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { int low = i + 1 , high = n - 1 , ans = - 1 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( suffix_min [ mid ] < a [ i ] ) { ans = mid ; low = mid + 1 ; } else high = mid - 1 ; } System . out . print ( ans + "" "" ) ; } }"
"static long sumXOR ( int arr [ ] , int n ) { long sum = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { int zc = 0 , oc = 0 ; long idsum = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] % 2 == 0 ) zc ++ ; else oc ++ ; arr [ j ] /= 2 ; } idsum = oc * zc * ( 1 << i ) ; sum += idsum ; } return sum ; }"
"static void ReplaceElements ( int arr [ ] , int n ) { int prod = 1 ; for ( int i = 0 ; i < n ; ++ i ) { prod *= arr [ i ] ; } for ( int i = 0 ; i < n ; ++ i ) { arr [ i ] = prod / arr [ i ] ; } }"
"static int getTotalNumberOfSequences ( int m , int n ) { if ( m < n ) return 0 ; if ( n == 0 ) return 1 ; return getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m / 2 , n - 1 ) ; }"
"static int calculate ( int a [ ] , int n ) { Arrays . sort ( a ) ; int count = 1 ; int answer = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) { count += 1 ; } else { answer = answer + ( count * ( count - 1 ) ) / 2 ; count = 1 ; } } answer = answer + ( count * ( count - 1 ) ) / 2 ; return answer ; }"
static void printSeriesSum ( int N ) { double sum = 0 ; int a = 1 ; int cnt = 0 ; boolean flag = true ; sum += a ; while ( cnt < N ) { int nextElement ; if ( flag == true ) { nextElement = a * 2 ; sum += nextElement ; flag = ! flag ; } else { nextElement = a * 3 / 2 ; sum += nextElement ; flag = ! flag ; } a = nextElement ; cnt ++ ; } System . out . println ( sum ) ; }
static int count_minimum_operations ( long n ) { int count = 0 ; while ( n > 1 ) { if ( n % 3 == 0 ) n /= 3 ; else if ( n % 3 == 1 ) n -- ; else { if ( n == 2 ) n -- ; else n ++ ; } count ++ ; } return count ; }
"static int findNumbers ( int n , int w ) { int x = 0 , sum = 0 ; if ( w >= 0 && w <= 8 ) { x = 9 - w ; } else if ( w >= - 9 && w <= - 1 ) { x = 10 + w ; } sum = ( int ) Math . pow ( 10 , n - 2 ) ; sum = ( x * sum ) ; return sum ; }"
static int countUnsetBits ( int n ) { int x = n ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return Integer . bitCount ( x ^ n ) ; }
"static int xorOfArray ( int arr [ ] , int n ) { int xor_arr = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xor_arr = xor_arr ^ arr [ i ] ; } return xor_arr ; }"
"static int minSum ( int a [ ] , int n ) { Arrays . sort ( a ) ; int num1 = 0 ; int num2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) num1 = num1 * 10 + a [ i ] ; else num2 = num2 * 10 + a [ i ] ; } return num2 + num1 ; }"
"static int numbers ( int n , int arr [ ] , int m ) { int isZero = 0 , isFive = 0 ; int result = 0 ; if ( m < n ) { return - 1 ; } for ( int i = 0 ; i < m ; i ++ ) { if ( arr [ i ] == 0 ) { isZero = 1 ; } if ( arr [ i ] == 5 ) { isFive = 1 ; } } if ( isZero == 1 && isFive == 1 ) { result = 2 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { result = result * ( -- m ) ; } } else if ( isZero == 1 || isFive == 1 ) { result = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { result = result * ( -- m ) ; } } else { result = - 1 ; } return result ; }"
"static boolean isInside ( int circle_x , int circle_y , int rad , int x , int y ) { if ( ( x - circle_x ) * ( x - circle_x ) + ( y - circle_y ) * ( y - circle_y ) <= rad * rad ) return true ; else return false ; }"
"public static void printTaxicab2 ( int N ) { int i = 1 , count = 0 ; while ( count < N ) { int int_count = 0 ; for ( int j = 1 ; j <= Math . pow ( i , 1.0 / 3 ) ; j ++ ) for ( int k = j + 1 ; k <= Math . pow ( i , 1.0 / 3 ) ; k ++ ) if ( j * j * j + k * k * k == i ) int_count ++ ; if ( int_count == 2 ) { count ++ ; System . out . println ( count + "" "" + i ) ; } i ++ ; } }"
"static int singleNumber ( int a [ ] , int n ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i : a ) { s . add ( i ) ; } int arr_sum = 0 ; for ( int i : a ) { arr_sum += i ; } int set_sum = 0 ; for ( int i : s ) { set_sum += i ; } return ( 3 * set_sum - arr_sum ) / 2 ; }"
"static long kBitDifferencePairs ( int arr [ ] , int n , int k ) { int MAX = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; long [ ] count = new long [ MAX + 1 ] ; Arrays . fill ( count , 0 ) ; for ( int i = 0 ; i < n ; ++ i ) ++ count [ arr [ i ] ] ; long ans = 0 ; if ( k == 0 ) { for ( int i = 0 ; i <= MAX ; ++ i ) ans += ( count [ i ] * ( count [ i ] - 1 ) ) / 2 ; return ans ; } for ( int i = 0 ; i <= MAX ; ++ i ) { if ( count [ i ] == 0 ) continue ; for ( int j = i + 1 ; j <= MAX ; ++ j ) { if ( Integer . bitCount ( i ^ j ) == k ) ans += count [ i ] * count [ j ] ; } } return ans ; }"
static int countNonEmptySubstr ( String str ) { int n = str . length ( ) ; return n * ( n + 1 ) / 2 ; }
"static void generateGrayarr ( int n ) { if ( n <= 0 ) return ; ArrayList < String > arr = new ArrayList < String > ( ) ; arr . add ( ""0"" ) ; arr . add ( ""1"" ) ; int i , j ; for ( i = 2 ; i < ( 1 << n ) ; i = i << 1 ) { for ( j = i - 1 ; j >= 0 ; j -- ) arr . add ( arr . get ( j ) ) ; for ( j = 0 ; j < i ; j ++ ) arr . set ( j , ""0"" + arr . get ( j ) ) ; for ( j = i ; j < 2 * i ; j ++ ) arr . set ( j , ""1"" + arr . get ( j ) ) ; } for ( i = 0 ; i < arr . size ( ) ; i ++ ) System . out . println ( arr . get ( i ) ) ; }"
"static void pattern ( int N ) { int i , j , k = 0 , space = 1 , rows = N ; for ( i = rows ; i >= 1 ; i -- ) { for ( j = 1 ; j <= i ; j ++ ) { System . out . print ( ""*"" ) ; } if ( i != rows ) { for ( k = 1 ; k <= space ; k ++ ) { System . out . print ( "" "" ) ; } space = space + 2 ; } for ( j = i ; j >= 1 ; j -- ) { if ( j != rows ) System . out . print ( ""*"" ) ; } System . out . print ( ""\n"" ) ; } System . out . print ( ""\n"" ) ; }"
"public static int difference ( int arr [ ] [ ] , int n ) { int d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) d1 += arr [ i ] [ j ] ; if ( i == n - j - 1 ) d2 += arr [ i ] [ j ] ; } } return Math . abs ( d1 - d2 ) ; }"
"static void alternateSort ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int i = 0 , j = n - 1 ; while ( i < j ) { System . out . print ( arr [ j -- ] + "" "" ) ; System . out . print ( arr [ i ++ ] + "" "" ) ; } if ( n % 2 != 0 ) System . out . print ( arr [ i ] ) ; }"
"static float sumOfSeries ( int x , int k ) { float y = ( float ) ( ( ( float ) ( x ) / 81 ) * ( 9 * k - 1 + Math . pow ( 10 , ( - 1 ) * k ) ) ) ; return y ; }"
static int getMaximumSumWithLCMN ( int N ) { int sum = 0 ; int LIM = ( int ) Math . sqrt ( N ) ; for ( int i = 1 ; i <= LIM ; i ++ ) { if ( N % i == 0 ) { if ( i == ( N / i ) ) sum += i ; else sum += ( i + N / i ) ; } } return sum ; }
"static int getElement ( int a [ ] , int n , int S ) { Arrays . sort ( a ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( sum + ( a [ i ] * ( n - i ) ) == S ) return a [ i ] ; sum += a [ i ] ; } return - 1 ; }"
static boolean isDvisibleBy12 ( String num ) { if ( num . length ( ) >= 3 ) { int d1 = ( int ) num . charAt ( num . length ( ) - 1 ) ; if ( d1 % 2 != 0 ) return false ; int d2 = ( int ) num . charAt ( num . length ( ) - 2 ) ; int sum = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) sum += num . charAt ( i ) ; return ( sum % 3 == 0 && ( d2 * 10 + d1 ) % 4 == 0 ) ; } else { int number = Integer . parseInt ( num ) ; return ( number % 12 == 0 ) ; } }
"static int getSum ( int n ) { int sum ; for ( sum = 0 ; n > 0 ; sum += n % 10 , n /= 10 ) ; return sum ; }"
public static int countIdenticalRows ( int mat [ ] [ ] ) { int count = 0 ; for ( int i = 0 ; i < mat . length ; i ++ ) { int first = mat [ i ] [ 0 ] ; boolean allSame = true ; for ( int j = 1 ; j < mat [ i ] . length ; j ++ ) { if ( mat [ i ] [ j ] != first ) { allSame = false ; break ; } } if ( allSame ) count ++ ; } return count ; }
"static void mul_table ( int N , int i ) { if ( i > 10 ) return ; System . out . println ( N + "" * "" + i + "" = "" + N * i ) ; mul_table ( N , i + 1 ) ; }"
"static int lenOfLongSubarr ( int arr [ ] , int n ) { HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int sum = 0 , maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] == 0 ? - 1 : 1 ; if ( sum == 1 ) maxLen = i + 1 ; else if ( ! um . containsKey ( sum ) ) um . put ( sum , i ) ; if ( um . containsKey ( sum - 1 ) ) { if ( maxLen < ( i - um . get ( sum - 1 ) ) ) maxLen = i - um . get ( sum - 1 ) ; } } return maxLen ; }"
"public static int maxLenSub ( int arr [ ] , int n ) { int mls [ ] = new int [ n ] , max = 0 ; for ( int i = 0 ; i < n ; i ++ ) mls [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( Math . abs ( arr [ i ] - arr [ j ] ) <= 1 && mls [ i ] < mls [ j ] + 1 ) mls [ i ] = mls [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( max < mls [ i ] ) max = mls [ i ] ; return max ; }"
"static int maxPathSum ( int tri [ ] [ ] , int m , int n ) { for ( int i = m - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] ; } } return tri [ 0 ] [ 0 ] ; }"
"static int getIndex ( int a [ ] , int n ) { if ( n == 1 ) return 0 ; int ptrL = 0 , ptrR = n - 1 , sumL = a [ 0 ] , sumR = a [ n - 1 ] ; while ( ptrR - ptrL > 1 ) { if ( sumL < sumR ) { ptrL ++ ; sumL += a [ ptrL ] ; } else if ( sumL > sumR ) { ptrR -- ; sumR += a [ ptrR ] ; } else { break ; } } return ptrL ; }"
void bubbleSort ( int arr [ ] ) { int n = arr . length ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = 0 ; j < n - i - 1 ; j ++ ) if ( arr [ j ] > arr [ j + 1 ] ) { int temp = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; } }
"static void shortestDistance ( String S , char X ) { int prev = Integer . MAX_VALUE ; Vector < Integer > ans = new Vector < > ( ) ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { if ( S . charAt ( i ) == X ) prev = i ; ans . add ( i - prev ) ; } prev = Integer . MAX_VALUE ; for ( int i = S . length ( ) - 1 ; i >= 0 ; i -- ) { if ( S . charAt ( i ) == X ) prev = i ; ans . set ( i , Math . min ( ans . get ( i ) , prev - i ) ) ; } for ( Integer val : ans ) System . out . print ( val + "" "" ) ; }"
"static int nthDigit ( int a , int n , int b ) { for ( int i = 1 ; i < n ; i ++ ) a = a / b ; return a % b ; }"
"static void printGroups ( int n , int a [ ] ) { int ct [ ] = new int [ 7 ] , grps = n / 3 , i ; for ( i = 0 ; i < n ; i ++ ) { ct [ a [ i ] ] ++ ; } if ( ct [ 1 ] != grps || ( ct [ 4 ] + ct [ 6 ] ) != grps || ( ct [ 2 ] + ct [ 3 ] ) != grps || ct [ 4 ] > ct [ 2 ] ) { System . out . print ( - 1 ) ; return ; } for ( i = 0 ; i < ct [ 4 ] ; i ++ ) { System . out . print ( ""1 2 4\n"" ) ; } for ( i = 0 ; i < ct [ 2 ] - ct [ 4 ] ; i ++ ) { System . out . print ( ""1 2 6\n"" ) ; } for ( i = 0 ; i < ct [ 3 ] ; i ++ ) { System . out . print ( ""1 3 6\n"" ) ; } }"
"static int minsteps ( int n , int m ) { if ( m > n ) { return - 1 ; } else { return ( ( n + 1 ) / 2 + m - 1 ) / m * m ; } }"
"static int minOperations ( String str , int n ) { int i , lastUpper = - 1 , firstLower = - 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( Character . isUpperCase ( str . charAt ( i ) ) ) { lastUpper = i ; break ; } } for ( i = 0 ; i < n ; i ++ ) { if ( Character . isLowerCase ( str . charAt ( i ) ) ) { firstLower = i ; break ; } } if ( lastUpper == - 1 || firstLower == - 1 ) return 0 ; int countUpper = 0 ; for ( i = firstLower ; i < n ; i ++ ) { if ( Character . isUpperCase ( str . charAt ( i ) ) ) { countUpper ++ ; } } int countLower = 0 ; for ( i = 0 ; i < lastUpper ; i ++ ) { if ( Character . isLowerCase ( str . charAt ( i ) ) ) { countLower ++ ; } } return Math . min ( countLower , countUpper ) ; }"
"static int findCount ( int N ) { Vector list = new Vector ( ) ; int sum = 0 ; int i ; for ( i = 0 ; i < 20 ; i ++ ) { sum += Math . pow ( 2 , i ) ; list . add ( sum ) ; } for ( i = 0 ; i < 20 ; i ++ ) { if ( ( int ) list . get ( i ) > N ) return ( list . indexOf ( list . get ( i ) ) + 1 ) ; } return 0 ; }"
"static int answerQuery ( int a [ ] , int n , int l , int r ) { int count = 0 ; l = l - 1 ; for ( int i = l ; i < r ; i ++ ) { int element = a [ i ] ; int divisors = 0 ; for ( int j = l ; j < r ; j ++ ) { if ( a [ j ] % a [ i ] == 0 ) divisors ++ ; else break ; } if ( divisors == ( r - l ) ) count ++ ; } return count ; }"
"static boolean func ( int a [ ] , int k ) { for ( int i = 0 ; i < a . length ; i ++ ) if ( a [ i ] % k == 0 ) return true ; return false ; }"
"static int NumberofTimes ( String str ) { int temporary_sum = 0 , count = 0 ; while ( str . length ( ) > 1 ) { temporary_sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) temporary_sum += ( str . charAt ( i ) - '0' ) ; str = temporary_sum + """" ; count ++ ; } return count ; }"
"static int findSubarraySum ( int [ ] arr , int n ) { int res = 0 ; HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = i ; j < n ; j ++ ) { sum += arr [ j ] ; if ( m . containsKey ( sum ) ) { m . put ( sum , m . get ( sum ) + 1 ) ; } else { m . put ( sum , 1 ) ; } } } for ( Map . Entry < Integer , Integer > x : m . entrySet ( ) ) if ( x . getValue ( ) == 1 ) res += x . getKey ( ) ; return res ; }"
"static boolean isFrequencyEqual ( int arr [ ] , int len ) { if ( len % 2 == 1 ) { System . out . print ( ""No Such Element"" ) ; return false ; } HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < len ; i ++ ) if ( freq . containsKey ( arr [ i ] ) ) { freq . put ( arr [ i ] , freq . get ( arr [ i ] ) + 1 ) ; } else { freq . put ( arr [ i ] , 1 ) ; } for ( int i = 0 ; i < len ; i ++ ) { if ( freq . containsKey ( arr [ i ] ) && freq . get ( arr [ i ] ) == len / 2 ) { System . out . print ( arr [ i ] + ""\n"" ) ; return true ; } } System . out . print ( ""No such element"" ) ; return false ; }"
static double seriesSum ( int n ) { int i = 1 ; double res = 0.0 ; boolean sign = true ; while ( n > 0 ) { n -- ; if ( sign ) { sign = ! sign ; res = res + ( double ) ++ i / ++ i ; } else { sign = ! sign ; res = res - ( double ) ++ i / ++ i ; } } return res ; }
"static void alternateFib ( int n ) { if ( n < 0 ) return ; int f1 = 0 ; int f2 = 1 ; System . out . print ( f1 + "" "" ) ; for ( int i = 2 ; i <= n ; i ++ ) { int f3 = f2 + f1 ; if ( i % 2 == 0 ) System . out . print ( f3 + "" "" ) ; f1 = f2 ; f2 = f3 ; } }"
"static void getLongestSeq ( int a [ ] , int n ) { int maxIdx = 0 , maxLen = 0 , currLen = 0 , currIdx = 0 ; for ( int k = 0 ; k < n ; k ++ ) { if ( a [ k ] > 0 ) { currLen ++ ; if ( currLen == 1 ) currIdx = k ; } else { if ( currLen > maxLen ) { maxLen = currLen ; maxIdx = currIdx ; } currLen = 0 ; } } if ( maxLen > 0 ) { System . out . print ( ""Length "" + maxLen ) ; System . out . print ( "",starting index "" + maxIdx ) ; } else System . out . println ( ""No positive sequence detected."" ) ; return ; }"
"static int pairORSum ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] ^ arr [ j ] ; return ans ; }"
"static float squarearea ( float a , float b ) { if ( a < 0 || b < 0 ) return - 1 ; float area = 4 * ( float ) ( ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) / ( Math . pow ( a , 2 ) * Math . pow ( b , 2 ) ) ) ; return area ; }"
"static void printArray ( int arr [ ] , int len ) { int i ; for ( i = 0 ; i < len ; i ++ ) { System . out . printf ( ""%d "" , arr [ i ] ) ; } }"
"static int countPairs ( int arr [ ] , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( ( arr [ i ] | arr [ j ] ) <= Math . max ( arr [ i ] , arr [ j ] ) ) cnt ++ ; return cnt ; }"
"static int numberOfPaths ( int m , int n ) { int [ ] dp = new int [ n ] ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { dp [ j ] += dp [ j - 1 ] ; } } return dp [ n - 1 ] ; }"
"static double minHeight ( double base , double area ) { double d = ( 2 * area ) / base ; return Math . ceil ( d ) ; }"
"static double innerCirclearea ( double radius ) { if ( radius < 0 ) { return - 1 ; } double r = radius / 2 ; double Area = ( 3.14 * Math . pow ( r , 2 ) ) ; return Area ; }"
"public static int atMostSum ( int arr [ ] , int n , int k ) { int sum = 0 ; int cnt = 0 , maxcnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( sum + arr [ i ] ) <= k ) { sum += arr [ i ] ; cnt ++ ; } else if ( sum != 0 ) { sum = sum - arr [ i - cnt ] + arr [ i ] ; } maxcnt = Math . max ( cnt , maxcnt ) ; } return maxcnt ; }"
"static void divisibilityCheck ( List < Integer > arr , int n ) { List < Integer > s = new ArrayList < Integer > ( ) ; int max_ele = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { s . add ( arr . get ( i ) ) ; max_ele = Math . max ( max_ele , arr . get ( i ) ) ; } LinkedHashSet < Integer > res = new LinkedHashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr . get ( i ) != 0 ) for ( int j = arr . get ( i ) * 2 ; j <= max_ele ; j += arr . get ( i ) ) { if ( s . contains ( j ) ) res . add ( j ) ; } } List < Integer > list = new ArrayList < Integer > ( res ) ; Collections . reverse ( list ) ; for ( Integer temp : list ) System . out . print ( temp + "" "" ) ; }"
static boolean validate ( long n ) { for ( int i = 0 ; i < 10 ; i ++ ) { long temp = n ; int count = 0 ; while ( temp > 0 ) { if ( temp % 10 == i ) count ++ ; if ( count > i ) return false ; temp /= 10 ; } } return true ; }
"static int count ( String a , String b ) { int m = a . length ( ) ; int n = b . length ( ) ; int lookup [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; ++ i ) lookup [ 0 ] [ i ] = 0 ; for ( int i = 0 ; i <= m ; ++ i ) lookup [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( a . charAt ( i - 1 ) == b . charAt ( j - 1 ) ) lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ] ; else lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ] ; } } return lookup [ m ] [ n ] ; }"
"static int subset ( int arr [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) mp . put ( arr [ i ] , mp . get ( arr [ i ] ) == null ? 1 : mp . get ( arr [ i ] ) + 1 ) ; int res = 0 ; for ( Map . Entry < Integer , Integer > entry : mp . entrySet ( ) ) res = Math . max ( res , entry . getValue ( ) ) ; return res ; }"
"static boolean checkReverse ( int arr [ ] , int n ) { if ( n == 1 ) { return true ; } int i ; for ( i = 1 ; arr [ i - 1 ] < arr [ i ] && i < n ; i ++ ) ; if ( i == n ) { return true ; } int j = i ++ ; while ( arr [ j ] < arr [ j - 1 ] ) { if ( i > 1 && arr [ j ] < arr [ i - 2 ] ) { return false ; } j ++ ; } if ( j == n ) { return true ; } int k = j ; if ( arr [ k ] < arr [ i - 1 ] ) { return false ; } while ( k > 1 && k < n ) { if ( arr [ k ] < arr [ k - 1 ] ) { return false ; } k ++ ; } return true ; }"
"static void EvenOddProduct ( int arr [ ] , int n ) { int even = 1 ; int odd = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) even *= arr [ i ] ; else odd *= arr [ i ] ; } System . out . println ( ""Even Index Product : "" + even ) ; System . out . println ( ""Odd Index Product : "" + odd ) ; }"
"static boolean isRotated ( String str1 , String str2 ) { if ( str1 . length ( ) != str2 . length ( ) ) return false ; String clock_rot = """" ; String anticlock_rot = """" ; int len = str2 . length ( ) ; anticlock_rot = anticlock_rot + str2 . substring ( len - 2 , len ) + str2 . substring ( 0 , len - 2 ) ; clock_rot = clock_rot + str2 . substring ( 2 ) + str2 . substring ( 0 , 2 ) ; return ( str1 . equals ( clock_rot ) || str1 . equals ( anticlock_rot ) ) ; }"
"static int minflip ( int [ ] arr1 , int [ ] arr2 , int [ ] arr3 , int p , int q , int n ) { int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] > 0 ^ arr2 [ i ] > 0 != arr3 [ i ] > 0 ) flip ++ ; return ( flip <= p + q ) ? flip : - 1 ; }"
"static void findNumbers ( int n ) { int i = 1 ; while ( i <= n ) { System . out . print ( ( 3 * i * ( i - 1 ) + 1 ) + "" "" ) ; i ++ ; } }"
"static int countTriplets ( int arr [ ] , int n , int m ) { int count = 0 ; Arrays . sort ( arr ) ; int end , start , mid ; for ( end = n - 1 ; end >= 2 ; end -- ) { start = 0 ; mid = end - 1 ; while ( start < mid ) { long prod = arr [ end ] * arr [ start ] * arr [ mid ] ; if ( prod > m ) mid -- ; else if ( prod < m ) start ++ ; else if ( prod == m ) { count ++ ; mid -- ; start ++ ; } } } return count ; }"
"static void printNonSquare ( int n ) { int curr_count = 2 , num = 2 , count = 0 ; while ( count < n ) { for ( int i = 0 ; i < curr_count && count < n ; i ++ ) { System . out . print ( num + "" "" ) ; count ++ ; num ++ ; } num ++ ; curr_count += 2 ; } }"
"public static float circlearea ( double a , double b ) { if ( a < 0 || b < 0 ) return - 1 ; float A = ( float ) ( ( 3.14 * Math . pow ( a , 2 ) * Math . pow ( b , 2 ) ) / ( 4 * ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) ) ) ; return A ; }"
"static float [ ] XandYandZintercept ( float A , float B , float C , float D ) { float rslt [ ] = new float [ 3 ] ; float x = - D / A ; float y = - D / B ; float z = - D / C ; rslt [ 0 ] = x ; rslt [ 1 ] = y ; rslt [ 2 ] = z ; return rslt ; }"
"static int findMod4 ( String s , int n ) { int k ; if ( n == 1 ) k = s . charAt ( 0 ) - '0' ; else k = ( s . charAt ( n - 2 ) - '0' ) * 10 + s . charAt ( n - 1 ) - '0' ; return ( k % 4 ) ; }"
static int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; }
static int findTrailingZeros ( int n ) { if ( ( n & 1 ) == 1 ) return 0 ; else { int ans = 0 ; n /= 2 ; while ( n != 0 ) { ans += n / 5 ; n /= 5 ; } return ans ; } }
static int minSum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += ( n % 10 ) ; n /= 10 ; } if ( sum == 1 ) return 10 ; return sum ; }
"static double countdigits ( int n , int k ) { if ( n == 0 ) return 0 ; int digit = n % 10 ; if ( digit == k ) return 1 + countdigits ( n / 10 , k ) ; return countdigits ( n / 10 , k ) ; }"
"static void countFreq ( int arr [ ] , int n ) { Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } for ( Map . Entry < Integer , Integer > entry : mp . entrySet ( ) ) { System . out . println ( entry . getKey ( ) + "" "" + entry . getValue ( ) ) ; } }"
"static Boolean areElementsContiguous ( int arr [ ] , int n ) { HashSet < Integer > us = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) us . add ( arr [ i ] ) ; int count = 1 ; int curr_ele = arr [ 0 ] - 1 ; while ( us . contains ( curr_ele ) == true ) { count ++ ; curr_ele -- ; } curr_ele = arr [ 0 ] + 1 ; while ( us . contains ( curr_ele ) == true ) { count ++ ; curr_ele ++ ; } return ( count == ( us . size ( ) ) ) ; }"
"static void freq ( int ar [ ] [ ] , int m , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( ( ar [ i ] [ j ] % 2 ) == 0 ) ++ even ; else ++ odd ; } } System . out . print ( "" Frequency of odd number ="" + odd + "" \n"" ) ; System . out . print ( "" Frequency of even number = "" + even + "" \n"" ) ; }"
"static void twistedTOH ( int n , char first , char middle , char last ) { if ( n == 1 ) { System . out . println ( ""Move disk "" + n + "" from rod "" + first + "" to "" + middle + "" and then to "" + last ) ; return ; } twistedTOH ( n - 1 , first , middle , last ) ; System . out . println ( ""Move disk "" + n + "" from rod "" + first + "" to "" + middle ) ; twistedTOH ( n - 1 , last , middle , first ) ; System . out . println ( ""Move disk "" + n + "" from rod "" + middle + "" to "" + last ) ; twistedTOH ( n - 1 , first , middle , last ) ; }"
static boolean check ( String str ) { int n = str . length ( ) ; if ( n == 0 ) return false ; if ( n == 1 ) return ( ( str . charAt ( 0 ) - '0' ) % 4 == 0 ) ; int last = str . charAt ( n - 1 ) - '0' ; int second_last = str . charAt ( n - 2 ) - '0' ; return ( ( second_last * 10 + last ) % 4 == 0 ) ; }
"static int maxXORInRange ( int L , int R ) { int LXR = L ^ R ; int msbPos = 0 ; while ( LXR > 0 ) { msbPos ++ ; LXR >>= 1 ; } int maxXOR = 0 ; int two = 1 ; while ( msbPos -- > 0 ) { maxXOR += two ; two <<= 1 ; } return maxXOR ; }"
"private static void findMajority ( int [ ] arr ) { HashMap < Integer , Integer > map = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( map . containsKey ( arr [ i ] ) ) { int count = map . get ( arr [ i ] ) + 1 ; if ( count > arr . length / 2 ) { System . out . println ( ""Majority found :- "" + arr [ i ] ) ; return ; } else map . put ( arr [ i ] , count ) ; } else map . put ( arr [ i ] , 1 ) ; } System . out . println ( "" No Majority element"" ) ; }"
static String toggleCase ( char [ ] a ) { for ( int i = 0 ; i < a . length ; i ++ ) { a [ i ] ^= 32 ; } return new String ( a ) ; }
"static Vector < Integer > find_idx ( int ar [ ] , int n ) { Vector < Integer > answer = new Vector < Integer > ( ) ; int sum = ar [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( sum == ar [ i ] ) { answer . add ( i + 1 ) ; } sum += ar [ i ] ; } return answer ; }"
"static int Max_Sum ( int a [ ] , int n ) { int [ ] b = new int [ n ] ; int S = 0 ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { b [ i ] = res ; res += a [ i ] ; S += a [ i ] ; res = Math . max ( res , - S ) ; } int ans = S ; ans = Math . max ( ans , res ) ; int g = 0 ; for ( int i = n - 1 ; i >= 0 ; -- i ) { g -= a [ i ] ; ans = Math . max ( ans , g + b [ i ] ) ; } return ans ; }"
"static void findpair ( int l , int r ) { int c = 0 ; for ( int i = l ; i <= r ; i ++ ) { for ( int j = i + 1 ; j <= r ; j ++ ) { if ( j % i == 0 && j != i ) { System . out . println ( i + "", "" + j ) ; c = 1 ; break ; } } if ( c == 1 ) break ; } }"
"static void recaman ( int n ) { int arr [ ] = new int [ n ] ; arr [ 0 ] = 0 ; System . out . print ( arr [ 0 ] + "" ,"" ) ; for ( int i = 1 ; i < n ; i ++ ) { int curr = arr [ i - 1 ] - i ; int j ; for ( j = 0 ; j < i ; j ++ ) { if ( ( arr [ j ] == curr ) || curr < 0 ) { curr = arr [ i - 1 ] + i ; break ; } } arr [ i ] = curr ; System . out . print ( arr [ i ] + "", "" ) ; } }"
static boolean isToOne ( int n ) { return ( n > 0 ) ; }
"static boolean isEven ( int arr [ ] , int n , int r ) { if ( r % 2 == 0 ) { if ( arr [ n - 1 ] % 2 == 0 ) return true ; } else { int oddCount = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( arr [ i ] % 2 != 0 ) oddCount ++ ; } if ( oddCount % 2 == 0 ) return true ; } return false ; }"
"static int maxSubseq ( int [ ] vec , int n ) { int suffix = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( vec [ i ] == 1 ) { suffix ++ ; vec [ i ] = suffix ; } } int res = 0 ; int zero = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( vec [ i ] == 0 ) zero ++ ; if ( vec [ i ] > 0 ) res = Math . max ( res , zero + vec [ i ] ) ; } return Math . max ( res , zero ) ; }"
"static float noOfYears ( int t1 , int n1 , int t2 ) { float years = ( ( t2 - 1 ) * n1 / ( float ) ( t1 - 1 ) ) ; return years ; }"
static int nextPowerOf2 ( int n ) { int p = 1 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( p < n ) p <<= 1 ; return p ; }
static boolean bit_check ( int n ) { if ( ( n & ( n - 1 ) ) == 0 ) return true ; return false ; }
"static void multiple ( int a , int b , int x ) { if ( b < 0 ) { if ( a == 1 && x == 1 ) System . out . println ( ""1"" ) ; else System . out . println ( ""0"" ) ; } int mul = ( int ) Math . pow ( a , b ) ; int ans = mul / x ; int ans1 = x * ans ; int ans2 = x * ( ans + 1 ) ; System . out . println ( ( ( mul - ans1 ) <= ( ans2 - mul ) ) ? ans1 : ans2 ) ; }"
static void smallestPermute ( int n ) { char res [ ] = new char [ n + 1 ] ; if ( n % 2 == 0 ) { for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) res [ i ] = ( char ) ( 48 + i + 2 ) ; else res [ i ] = ( char ) ( 48 + i ) ; } } else { for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( i % 2 == 0 ) res [ i ] = ( char ) ( 48 + i + 2 ) ; else res [ i ] = ( char ) ( 48 + i ) ; } res [ n - 1 ] = ( char ) ( 48 + n - 2 ) ; res [ n - 2 ] = ( char ) ( 48 + n ) ; res [ n - 3 ] = ( char ) ( 48 + n - 1 ) ; } res [ n ] = '\0' ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( res [ i ] ) ; } }
"static double squareRoot ( double n ) { return Math . pow ( 2 , 0.5 * ( Math . log ( n ) / Math . log ( 2 ) ) ) ; }"
"static boolean permutation ( int [ ] arr , int n ) { Set < Integer > hash = new HashSet < Integer > ( ) ; int maxEle = 0 ; for ( int i = 0 ; i < n ; i ++ ) { hash . add ( arr [ i ] ) ; maxEle = Math . max ( maxEle , arr [ i ] ) ; } if ( maxEle != n ) return false ; if ( hash . size ( ) == n ) return true ; return false ; }"
"static int findEvenPair ( int A [ ] , int N ) { int evenPair = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] | A [ j ] ) % 2 == 0 ) evenPair ++ ; } } return evenPair ; }"
"static int solve ( double M , double N , double s ) { int ans = ( ( int ) ( Math . ceil ( M / s ) ) * ( int ) ( Math . ceil ( N / s ) ) ) ; return ans ; }"
"static int countOperations ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] % 2 == 1 ) { arr [ i ] ++ ; arr [ i + 1 ] ++ ; count += 2 ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) return - 1 ; } return count ; }"
"static void printDistSum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; boolean [ ] [ ] dp = new boolean [ n + 1 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] [ arr [ i - 1 ] ] = true ; for ( int j = 1 ; j <= sum ; j ++ ) { if ( dp [ i - 1 ] [ j ] == true ) { dp [ i ] [ j ] = true ; dp [ i ] [ j + arr [ i - 1 ] ] = true ; } } } for ( int j = 0 ; j <= sum ; j ++ ) if ( dp [ n ] [ j ] == true ) System . out . print ( j + "" "" ) ; }"
static void Sum_upto_nth_Term ( int n ) { int r = n * ( n + 1 ) * ( 2 * n + 7 ) / 3 ; System . out . println ( r ) ; }
"static void findSubsequence ( int arr [ ] , int n ) { int sign [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) sign [ i ] = 1 ; else sign [ i ] = - 1 ; } int k = 0 ; int result [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int cur = arr [ i ] ; int j = i ; while ( j < n && sign [ i ] == sign [ j ] ) { cur = Math . max ( cur , arr [ j ] ) ; ++ j ; } result [ k ++ ] = cur ; i = j - 1 ; } for ( int i = 0 ; i < k ; i ++ ) System . out . print ( result [ i ] + "" "" ) ; System . out . print ( ""\n"" ) ; }"
"public static int findMajority ( int arr [ ] , int n ) { return arr [ n / 2 ] ; }"
"static boolean areAnagram ( char [ ] str1 , char [ ] str2 ) { int n1 = str1 . length ; int n2 = str2 . length ; if ( n1 != n2 ) return false ; Arrays . sort ( str1 ) ; Arrays . sort ( str2 ) ; for ( int i = 0 ; i < n1 ; i ++ ) if ( str1 [ i ] != str2 [ i ] ) return false ; return true ; }"
"static int lps ( String s ) { int n = s . length ( ) ; int a [ ] = new int [ n ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int back_up = 0 ; for ( int j = i ; j < n ; j ++ ) { if ( j == i ) a [ j ] = 1 ; else if ( s . charAt ( i ) == s . charAt ( j ) ) { int temp = a [ j ] ; a [ j ] = back_up + 2 ; back_up = temp ; } else { back_up = a [ j ] ; a [ j ] = Math . max ( a [ j - 1 ] , a [ j ] ) ; } } } return a [ n - 1 ] ; }"
static int getPairs ( int a [ ] ) { int count = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { for ( int j = 0 ; j < a . length ; j ++ ) { if ( a [ i ] < a [ j ] ) count ++ ; } } return count ; }
"public static boolean isPossibleToMakeDivisible ( int arr [ ] , int n ) { int remainder = 0 ; for ( int i = 0 ; i < n ; i ++ ) remainder = ( remainder + arr [ i ] ) % 3 ; return ( remainder == 0 ) ; }"
"static int maxOperations ( int X , int Y ) { if ( X > Y ) return - 1 ; int diff = Y - X ; if ( diff == 1 ) return - 1 ; if ( diff % 2 == 0 ) return ( diff / 2 ) ; return ( 1 + ( ( diff - 3 ) / 2 ) ) ; }"
static float getArea ( int a ) { float area = ( float ) ( Math . PI * a * a ) / 4 ; return area ; }
"static void nthPalindrome ( int n , int k ) { int temp = ( k & 1 ) != 0 ? ( k / 2 ) : ( k / 2 - 1 ) ; int palindrome = ( int ) Math . pow ( 10 , temp ) ; palindrome += n - 1 ; System . out . print ( palindrome ) ; if ( ( k & 1 ) > 0 ) palindrome /= 10 ; while ( palindrome > 0 ) { System . out . print ( palindrome % 10 ) ; palindrome /= 10 ; } System . out . println ( """" ) ; }"
"static int kthSmallest ( int n , int k ) { return ( 2 * k ) ; }"
"static void find_numbers ( int N ) { if ( N == 1 ) { System . out . print ( - 1 ) ; } else { System . out . print ( N + "" "" + ( N + 1 ) + "" "" + ( N * ( N + 1 ) ) ) ; } }"
"static String sortString ( String str , int n ) { String new_str = """" ; for ( int i = 'a' ; i <= 'z' ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( str . charAt ( j ) == i ) new_str += str . charAt ( j ) ; return new_str ; }"
"static String replaceRemove ( char [ ] s , char X , char Y , char Z ) { int start = 0 , end = s . length - 1 ; while ( start <= end ) { if ( s [ start ] == Z ) { while ( end >= 0 && s [ end ] == Z ) { end -- ; } char temp ; if ( end > start ) { temp = s [ start ] ; s [ start ] = s [ end ] ; s [ end ] = temp ; if ( s [ start ] == X ) s [ start ] = Y ; start ++ ; } } else { if ( s [ start ] == X ) s [ start ] = Y ; start ++ ; } } String new_s = new String ( s ) ; while ( new_s . length ( ) > 0 && new_s . charAt ( new_s . length ( ) - 1 ) == Z ) { new_s = new_s . substring ( 0 , new_s . length ( ) - 1 ) ; } return new_s ; }"
"static boolean isPossible ( int arr [ ] , int p , int n , int m ) { int sum = 0 ; for ( int i = 0 ; i < p ; i ++ ) sum += arr [ i ] ; if ( sum == ( n * m ) ) return true ; return false ; }"
"public static int countDistinct ( int arr [ ] , int n ) { HashSet < Integer > hs = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { hs . add ( arr [ i ] ) ; } return hs . size ( ) ; }"
"public static int solve ( int low , int high , int T ) { while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( ( mid * ( mid + 1 ) ) == T ) return mid ; if ( mid > 0 && ( mid * ( mid + 1 ) ) > T && ( mid * ( mid - 1 ) ) <= T ) return mid - 1 ; if ( ( mid * ( mid + 1 ) ) > T ) high = mid - 1 ; else low = mid + 1 ; } return - 1 ; }"
static int check ( int num ) { int digitSum = 0 ; while ( num > 0 ) { digitSum = digitSum + num % 10 ; num = num / 10 ; } int temp = digitSum ; int reverseDigitSum = 0 ; while ( temp > 0 ) { int rem = temp % 10 ; reverseDigitSum = reverseDigitSum * 10 + rem ; temp = temp / 10 ; } int number = digitSum * reverseDigitSum ; return number ; }
"static boolean areElementsContiguous ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] > 1 ) return false ; return true ; }"
static int sum_of_series ( int n ) { int result = 0 ; if ( n % 2 == 0 ) { result = - ( n * ( n + 1 ) ) / 2 ; } else { result = ( n * ( n + 1 ) ) / 2 ; } return result ; }
"static int MinimumMoves ( int a [ ] , int n , int x ) { int ans = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= a [ i - 1 ] ) { int p = ( a [ i - 1 ] - a [ i ] ) / x + 1 ; ans += p ; a [ i ] += p * x ; } } return ans ; }"
"static float ellipse ( float l , float b ) { if ( l < 0 || b < 0 ) return - 1 ; float x = ( float ) ( 3.14 * l * b ) / 4 ; return x ; }"
"static int [ ] solve ( int n ) { int low = 1 , high = ( int ) 1e4 , x = n , p = 0 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; int sum = ( mid * ( mid + 1 ) ) / 2 ; if ( x - sum >= 1 ) { p = mid ; low = mid + 1 ; } else { high = mid - 1 ; } } int start = 1 , end = ( int ) 1e4 , y = 1 , q = 0 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; int sum = ( mid * ( mid + 1 ) ) / 2 ; if ( y + sum <= n ) { q = mid ; start = mid + 1 ; } else { end = mid - 1 ; } } x = x - ( p * ( p + 1 ) ) / 2 ; y = y + ( q * ( q + 1 ) ) / 2 ; int r = x ; int c = q + 1 - n + y ; int ans [ ] = { r , c }; return ans ; }"
"static boolean isIdentity ( int mat [ ] [ ] , int N ) { for ( int row = 0 ; row < N ; row ++ ) { for ( int col = 0 ; col < N ; col ++ ) { if ( row == col && mat [ row ] [ col ] != 1 ) return false ; else if ( row != col && mat [ row ] [ col ] != 0 ) return false ; } } return true ; }"
"static int nthTerm ( int n ) { return 3 * ( int ) Math . pow ( n , 2 ) - 4 * n + 2 ; }"
"static int uniqueRows ( int [ ] [ ] s , int m , int n ) { int i , j , count = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < i ; j ++ ) { if ( s [ i ] == s [ j ] ) { count ++ ; break ; } } } if ( count >= 1 ) System . out . println ( ""No"" ) ; else System . out . println ( ""Yes"" ) ; return 0 ; }"
"public static int find_value ( int a [ ] , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } return sum % k ; }"
"static int maxProduct ( int arr [ ] , int n ) { int minVal = arr [ 0 ] ; int maxVal = arr [ 0 ] ; int maxProduct = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) { int temp = maxVal ; maxVal = minVal ; minVal = temp ; } maxVal = Math . max ( arr [ i ] , maxVal * arr [ i ] ) ; minVal = Math . min ( arr [ i ] , minVal * arr [ i ] ) ; maxProduct = Math . max ( maxProduct , maxVal ) ; } return maxProduct ; }"
"static void constructTree ( int n , int d , int h ) { if ( d == 1 ) { if ( n == 2 && h == 1 ) { System . out . println ( ""1 2"" ) ; return ; } System . out . println ( ""-1"" ) ; return ; } if ( d > 2 * h ) { System . out . println ( ""-1"" ) ; return ; } for ( int i = 1 ; i <= h ; i ++ ) System . out . println ( i + "" "" + ( i + 1 ) ) ; if ( d > h ) { System . out . println ( ""1"" + "" "" + ( h + 2 ) ) ; for ( int i = h + 2 ; i <= d ; i ++ ) { System . out . println ( i + "" "" + ( i + 1 ) ) ; } } for ( int i = d + 1 ; i < n ; i ++ ) { int k = 1 ; if ( d == h ) k = 2 ; System . out . println ( k + "" "" + ( i + 1 ) ) ; } }"
"static double polygonArea ( double X [ ] , double Y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; j = i ; } return Math . abs ( area / 2.0 ) ; }"
static double areaOctagon ( double side ) { return ( float ) ( 2 * ( 1 + Math . sqrt ( 2 ) ) * side * side ) ; }
"public static void SplitAndAdd ( int [ ] A , int length , int rotation ) { int [ ] tmp = new int [ length * 2 ] ; System . arraycopy ( A , 0 , tmp , 0 , length ) ; System . arraycopy ( A , 0 , tmp , length , length ) ; for ( int i = rotation ; i < rotation + length ; i ++ ) A [ i - rotation ] = tmp [ i ] ; }"
static int solution ( int [ ] A ) { int n = A . length ; boolean [ ] present = new boolean [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] > 0 && A [ i ] <= n ) present [ A [ i ] ] = true ; } for ( int i = 1 ; i <= n ; i ++ ) if ( ! present [ i ] ) return i ; return n + 1 ; }
"static int perfectSquare ( String s ) { int n = s . length ( ) ; int ans = - 1 ; String num = """" ; for ( int i = 1 ; i < ( 1 << n ) ; i ++ ) { String str = """" ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( ( i >> j ) & 1 ) == 1 ) { str += s . charAt ( j ) ; } } if ( str . charAt ( 0 ) != '0' ) { int temp = 0 ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) temp = temp * 10 + ( int ) ( str . charAt ( j ) - '0' ) ; int k = ( int ) Math . sqrt ( temp ) ; if ( k * k == temp ) { if ( ans < ( int ) str . length ( ) ) { ans = ( int ) str . length ( ) ; num = str ; } } } } if ( ans == - 1 ) return ans ; else { System . out . print ( num + "" "" ) ; return n - ans ; } }"
"static Boolean subArrayExists ( int arr [ ] ) { HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ; int sum = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] == 0 || sum == 0 || hM . get ( sum ) != null ) return true ; hM . put ( sum , i ) ; } return false ; }"
"static void getnumbers ( int n ) { Vector < Integer > divisor = new Vector < Integer > ( ) ; for ( int i = 2 ; i * i <= n ; i ++ ) { while ( n % i == 0 ) { divisor . add ( i ) ; n /= i ; } } if ( n != 1 ) { divisor . add ( n ) ; } int a , b , c , size ; a = b = c = 1 ; size = divisor . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( a == 1 ) { a = a * divisor . get ( i ) ; } else if ( b == 1 || b == a ) { b = b * divisor . get ( i ) ; } else { c = c * divisor . get ( i ) ; } } if ( a == 1 || b == 1 || c == 1 || a == b || b == c || a == c ) { System . out . print ( ""-1"" + ""\n"" ) ; } else { System . out . print ( a + "" "" + b + "" "" + c + ""\n"" ) ; } }"
"static boolean Move ( int a , int x , int b ) { if ( ( ( ( b - a ) % x == 0 ) || ( ( b - a - 1 ) % x == 0 ) && a + 1 != b ) && b >= a ) return true ; return false ; }"
"static boolean isRectangle ( int a , int b , int c , int d ) { if ( a == b && a == c && a == d && c == d && b == c && b == d ) return true ; else if ( a == b && c == d ) return true ; else if ( a == d && c == b ) return true ; else if ( a == c && d == b ) return true ; else return false ; }"
"static int setBitNumber ( int n ) { int k = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; return ( int ) ( Math . pow ( 2 , k ) ) ; }"
static void bin ( int n ) { if ( n > 1 ) bin ( n / 2 ) ; System . out . print ( n % 2 ) ; }
"static Boolean pythagorean_quadruple ( int a , int b , int c , int d ) { int sum = a * a + b * b + c * c ; if ( d * d == sum ) return true ; else return false ; }"
"static boolean check ( int arr [ ] , int n ) { int k = Integer . MIN_VALUE ; int r = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { k = Math . max ( k , arr [ i ] ) ; r = Math . min ( r , arr [ i ] ) ; } k += 1 ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = k - arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( Math . abs ( arr [ i ] ) - 1 < n && arr [ Math . abs ( arr [ i ] ) - 1 ] > 0 ) { arr [ Math . abs ( arr [ i ] ) - 1 ] = - arr [ Math . abs ( arr [ i ] ) - 1 ] ; } } int flag = 0 ; for ( int i = 0 ; i <= k - r - 1 ; i ++ ) { if ( arr [ i ] > 0 ) { flag = 1 ; break ; } } return flag == 0 ; }"
"static int solve ( int M , int N , int s ) { if ( N % s == 0 ) { N = N / s ; } else { N = ( N / s ) + 1 ; } if ( M % s == 0 ) { M = M / s ; } else { M = ( M / s ) + 1 ; } return M * N ; }"
static int removeConsecutiveSame ( Vector < String > v ) { Stack < String > st = new Stack < > ( ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( st . empty ( ) ) st . push ( v . get ( i ) ) ; else { String str = st . peek ( ) ; if ( str . equals ( v . get ( i ) ) ) st . pop ( ) ; else st . push ( v . get ( i ) ) ; } } return st . size ( ) ; }
"static int totalOperations ( String str , int len ) { HashMap < Character , Integer > h = new HashMap < Character , Integer > ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( h . containsKey ( str . charAt ( i ) ) ) h . put ( str . charAt ( i ) , h . get ( str . charAt ( i ) ) + 1 ) ; else h . put ( str . charAt ( i ) , 1 ) ; } Set < Map . Entry < Character , Integer >> set = h . entrySet ( ) ; HashSet < Integer > hs = new HashSet < Integer > ( ) ; for ( Map . Entry < Character , Integer > me : set ) hs . add ( me . getValue ( ) ) ; return hs . size ( ) ; }"
static float rectanglearea ( float r ) { if ( r < 0 ) return - 1 ; float a = r * r ; return a ; }
"static int findSum ( int arr [ ] , int n ) { int sum = 0 ; HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! s . contains ( arr [ i ] ) ) { sum += arr [ i ] ; s . add ( arr [ i ] ) ; } } return sum ; }"
"static int findNumberOfEvenCells ( int n , int q [ ] [ ] , int size ) { int row [ ] = new int [ n ] ; int col [ ] = new int [ n ] ; for ( int i = 0 ; i < size ; i ++ ) { int x = q [ i ] [ 0 ] ; int y = q [ i ] [ 1 ] ; row [ x - 1 ] ++ ; col [ y - 1 ] ++ ; } int r1 = 0 , r2 = 0 ; int c1 = 0 , c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( row [ i ] % 2 == 0 ) { r1 ++ ; } if ( row [ i ] % 2 == 1 ) { r2 ++ ; } if ( col [ i ] % 2 == 0 ) { c1 ++ ; } if ( col [ i ] % 2 == 1 ) { c2 ++ ; } } int count = r1 * c1 + r2 * c2 ; return count ; }"
static int divSum ( int num ) { int result = 0 ; for ( int i = 2 ; i <= Math . sqrt ( num ) ; i ++ ) { if ( num % i == 0 ) { if ( i == ( num / i ) ) result += i ; else result += ( i + num / i ) ; } } return ( result + 1 ) ; }
"static int nCrModp ( int n , int r , int p ) { int C [ ] = new int [ r + 1 ] ; Arrays . fill ( C , 0 ) ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . min ( i , r ) ; j > 0 ; j -- ) C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p ; } return C [ r ] ; }"
"static int seiresSum ( int n , int [ ] a ) { int res = 0 , i ; for ( i = 0 ; i < 2 * n ; i ++ ) { if ( i % 2 == 0 ) res += a [ i ] * a [ i ] ; else res -= a [ i ] * a [ i ] ; } return res ; }"
"static int patternCount ( String str ) { char last = str . charAt ( 0 ) ; int i = 1 , counter = 0 ; while ( i < str . length ( ) ) { if ( str . charAt ( i ) == '0' && last == '1' ) { while ( str . charAt ( i ) == '0' ) i ++ ; if ( str . charAt ( i ) == '1' ) counter ++ ; } last = str . charAt ( i ) ; i ++ ; } return counter ; }"
"static void solve ( int A , int B ) { double p = B / 2.0 ; double M = Math . ceil ( 4 * p ) ; int N = 1 ; int O = - 2 * A ; double Q = Math . ceil ( A * A + 4 * p * p ) ; System . out . println ( M + "" "" + N + "" "" + O + "" "" + Q ) ; }"
static int countBits ( int number ) { return ( int ) ( Math . log ( number ) / Math . log ( 2 ) + 1 ) ; }
"static void findNthTerm ( int N ) { int ans ; if ( N % 2 == 0 ) { ans = ( N / 2 ) * 6 + ( N / 2 ) * 2 ; } else { ans = ( N / 2 + 1 ) * 6 + ( N / 2 ) * 2 ; } System . out . print ( ans + ""\n"" ) ; }"
"static void printPattern ( char [ ] s , int n ) { System . out . println ( s ) ; int i = 0 , j = n - 1 ; while ( i < j ) { char c = s [ i ] ; s [ i ] = s [ j ] ; s [ j ] = c ; i ++ ; j -- ; } i = 0 ; j = n - 1 ; while ( j - i > 1 ) { s [ i ] = s [ j ] = '*' ; System . out . println ( s ) ; i ++ ; j -- ; } }"
"public static int findPosition ( int k , int n ) { long f1 = 0 , f2 = 1 , f3 ; int i = 2 ; while ( i != 0 ) { f3 = f1 + f2 ; f1 = f2 ; f2 = f3 ; if ( f2 % k == 0 ) { return n * i ; } i ++ ; } return 0 ; }"
"static void bin ( Integer n ) { if ( n > 1 ) bin ( n >> 1 ) ; System . out . printf ( ""%d"" , n & 1 ) ; }"
"static double sum ( int n ) { double i , s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) s = s + 1 / i ; return s ; }"
"static int factorial ( int n ) { int i = n , fact = 1 ; while ( n / i != n ) { fact = fact * i ; i -- ; } return fact ; }"
"static int smallestSubWithSum ( int arr [ ] , int n , int x ) { int curr_sum = 0 , min_len = n + 1 ; int start = 0 , end = 0 ; while ( end < n ) { while ( curr_sum <= x && end < n ) curr_sum += arr [ end ++ ] ; while ( curr_sum > x && start < n ) { if ( end - start < min_len ) min_len = end - start ; curr_sum -= arr [ start ++ ] ; } } return min_len ; }"
"static int Maxsum ( int c1 , int c2 , int c3 , int c4 ) { int sum = 0 ; int two34 = Math . min ( c2 , Math . min ( c3 , c4 ) ) ; sum = two34 * 234 ; c2 -= two34 ; sum += Math . min ( c2 , c1 ) * 12 ; return sum ; }"
"static int substrDeletion ( String str , int len ) { int count0 = 0 , count1 = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str . charAt ( i ) == '0' ) count0 ++ ; else count1 ++ ; } return Math . min ( count0 , count1 ) ; }"
"public static int solve ( char [ ] c ) { if ( c . length == 1 ) return c [ 0 ] - '0' ; String ret = """" ; for ( int i = 0 ; i < c . length - 1 ; i ++ ) ret += ( ( c [ i ] - '0' ) + ( c [ i + 1 ] - '0' ) ) % 10 ; return solve ( ret . toCharArray ( ) ) ; }"
"public static void check ( int n , int x , int y ) { long fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { fact *= i ; } long divisor = ( long ) Math . pow ( x , y ) ; if ( fact % divisor == 0 ) System . out . println ( ""YES"" ) ; else System . out . println ( ""NO"" ) ; }"
static int number_cake ( int n ) { return ( n * n * n + 5 * n + 6 ) / 6 ; }
"static int findNumber ( int n ) { int num = n - 1 ; num = 2 * ( int ) Math . pow ( 4 , num ) ; num = ( int ) Math . floor ( num / 3.0 ) ; return num ; }"
"public static void findIndices ( int arr [ ] , int n ) { int leftMin = 0 , rightMin = 0 ; int leftMax = 0 , rightMax = 0 ; int min = arr [ 0 ] , max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < min ) { leftMin = rightMin = i ; min = arr [ i ] ; } else if ( arr [ i ] == min ) rightMin = i ; if ( arr [ i ] > max ) { leftMax = rightMax = i ; max = arr [ i ] ; } else if ( arr [ i ] == max ) rightMax = i ; } System . out . println ( ""Minimum left : "" + leftMin ) ; System . out . println ( ""Minimum right : "" + rightMin ) ; System . out . println ( ""Maximum left : "" + leftMax ) ; System . out . println ( ""Maximum right : "" + rightMax ) ; }"
"static void sortMultiples ( int arr [ ] , int n , int x ) { Vector < Integer > v = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % x == 0 ) { v . add ( arr [ i ] ) ; } } Collections . sort ( v ) ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % x == 0 ) { arr [ i ] = v . get ( j ++ ) ; } } }"
"static int getNumber ( int n , int k ) { int pos ; if ( ( n % 2 ) == 0 ) { pos = n / 2 ; } else { pos = ( n / 2 ) + 1 ; } if ( k <= pos ) { return ( k * 2 - 1 ) ; } else return ( ( k - pos ) * 2 ) ; }"
"static int countUnique ( int mat [ ] [ ] , int n , int m ) { int [ ] rowsum = new int [ n ] ; int [ ] colsum = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] != 0 ) { rowsum [ i ] ++ ; colsum [ j ] ++ ; } int uniquecount = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] != 0 && rowsum [ i ] == 1 && colsum [ j ] == 1 ) uniquecount ++ ; return uniquecount ; }"
"static int productDiagonals ( int arr [ ] [ ] , int n ) { int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { product = product * arr [ i ] [ i ] ; product = product * arr [ i ] [ n - i - 1 ] ; } if ( n % 2 == 1 ) { product = product / arr [ n / 2 ] [ n / 2 ] ; } return product ; }"
"static void CalPeri ( ) { int S = 5 , Perimeter ; Perimeter = 10 * S ; System . out . println ( ""The Perimeter of Decagon is : "" + Perimeter ) ; }"
static int maxProd ( int n ) { if ( n == 2 || n == 3 ) return ( n - 1 ) ; int res = 1 ; while ( n > 4 ) { n -= 3 ; res *= 3 ; } return ( n * res ) ; }
"static void findNthTerm ( int n ) { if ( n % 2 == 0 ) { n = n / 2 ; System . out . print ( Math . pow ( 3 , n - 1 ) + ""\n"" ) ; } else { n = ( n / 2 ) + 1 ; System . out . print ( Math . pow ( 2 , n - 1 ) + ""\n"" ) ; } }"
"static int minOperations ( int [ ] arr , int n ) { int maxi , result = 0 ; int [ ] freq = new int [ 1000001 ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; freq [ x ] ++ ; } maxi = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; for ( int i = 1 ; i <= maxi ; i ++ ) { if ( freq [ i ] != 0 ) { for ( int j = i * 2 ; j <= maxi ; j = j + i ) { freq [ j ] = 0 ; } result ++ ; } } return result ; }"
"static void middlesum ( int mat [ ] [ ] , int n ) { int row_sum = 0 , col_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) row_sum += mat [ n / 2 ] [ i ] ; System . out . println ( ""Sum of middle row = "" + row_sum ) ; for ( int i = 0 ; i < n ; i ++ ) col_sum += mat [ i ] [ n / 2 ] ; System . out . println ( ""Sum of middle column = "" + col_sum ) ; }"
"static int assignValue ( int a , int b , int x ) { int arr [ ] = { a , b }; return ( arr [ x ] ) ; }"
static int properDivisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j * j <= i ; ++ j ) { if ( i % j == 0 ) { if ( i / j == j ) sum += j ; else sum += j + i / j ; } } sum = sum - i ; } return sum ; }
"static int sumOfElements ( int arr [ ] , int n ) { boolean prime [ ] = new boolean [ n + 1 ] ; int i , j ; HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; for ( i = 0 ; i < n ; i ++ ) { if ( m . get ( arr [ i ] ) == null ) m . put ( arr [ i ] , 1 ) ; else m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; } int sum = 0 ; Iterator hmIterator = m . entrySet ( ) . iterator ( ) ; while ( hmIterator . hasNext ( ) ) { Map . Entry mapElement = ( Map . Entry ) hmIterator . next ( ) ; if ( ( ( int ) mapElement . getValue ( ) ) >= ( ( int ) mapElement . getKey ( ) ) ) { sum += ( ( int ) mapElement . getKey ( ) ) ; } } return sum ; }"
"static int countElements ( int p [ ] , int n ) { int ans = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( p [ i - 1 ] > p [ i ] && p [ i ] > p [ i + 1 ] ) ans ++ ; else if ( p [ i - 1 ] < p [ i ] && p [ i ] < p [ i + 1 ] ) ans ++ ; } return ans ; }"
"static void sortWithSetbits ( int arr [ ] , int n , int k ) { Vector < Integer > v1 = new Vector < > ( ) , v2 = new Vector < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( Integer . bitCount ( arr [ i ] ) == k ) { v1 . add ( i ) ; v2 . add ( arr [ i ] ) ; } } Collections . sort ( v2 ) ; for ( int i = 0 ; i < v1 . size ( ) ; i ++ ) { arr [ v1 . get ( i ) ] = v2 . get ( i ) ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + "" "" ) ; } }"
"static int findMax ( int arr [ ] , int n ) { boolean [ ] divisible = new boolean [ n ] ; int res = 0 ; for ( int i = n - 1 ; i > 0 ; i -- ) { if ( divisible [ i ] ) continue ; int cnt = 0 ; for ( int j = 0 ; j < i ; j ++ ) { if ( ( arr [ j ] % arr [ i ] ) == 0 ) { divisible [ j ] = true ; cnt ++ ; } } res = Math . max ( res , cnt ) ; } return res ; }"
"int countSubStr ( char str [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( str [ j ] == '1' ) res ++ ; } } } return res ; }"
"static int CountCharacters ( String str , int k ) { int cnt = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( ( ( int ) str . charAt ( i ) ) < k ) cnt ++ ; } return cnt ; }"
"static void printArray ( int [ ] A , int n , int K ) { int minEle = Integer . MAX_VALUE , maxEle = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { minEle = Math . min ( minEle , A [ i ] ) ; maxEle = Math . max ( maxEle , A [ i ] ) ; } if ( K != 0 ) { if ( K % 2 == 1 ) { for ( int i = 0 ; i < n ; i ++ ) A [ i ] = maxEle - A [ i ] ; } else { for ( int i = 0 ; i < n ; i ++ ) A [ i ] = A [ i ] - minEle ; } } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( A [ i ] + "" "" ) ; }"
static int FirstRepeated ( String str ) { int checker = 0 ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { int val = ( str . charAt ( i ) - 'a' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return i ; checker |= ( 1 << val ) ; } return - 1 ; }
"static int countNegative ( int M [ ] [ ] , int n , int m ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( M [ i ] [ j ] < 0 ) count += 1 ; else break ; } } return count ; }"
"static long getClosest ( int a , int b , int x ) { long num = ( long ) Math . pow ( a , b ) ; int floor = ( int ) ( num / x ) ; long numOnLeft = x * floor ; long numOnRight = x * ( floor + 1 ) ; if ( ( num - numOnLeft ) < ( numOnRight - num ) ) { return numOnLeft ; } else { return numOnRight ; } }"
"public static int middleOfThree ( int a , int b , int c ) { if ( a > b ) { if ( b > c ) return b ; else if ( a > c ) return c ; else return a ; } else { if ( a > c ) return a ; else if ( b > c ) return c ; else return b ; } }"
"static boolean checkSentence ( char [ ] str ) { int len = str . length ; if ( str [ 0 ] < 'A' || str [ 0 ] > 'Z' ) return false ; if ( str [ len - 1 ] != '.' ) return false ; int prev_state = 0 , curr_state = 0 ; int index = 1 ; while ( index <= str . length ) { if ( str [ index ] >= 'A' && str [ index ] <= 'Z' ) curr_state = 0 ; else if ( str [ index ] == ' ' ) curr_state = 1 ; else if ( str [ index ] >= 'a' && str [ index ] <= 'z' ) curr_state = 2 ; else if ( str [ index ] == '.' ) curr_state = 3 ; if ( prev_state == curr_state && curr_state != 2 ) return false ; if ( prev_state == 2 && curr_state == 0 ) return false ; if ( curr_state == 3 && prev_state != 1 ) return ( index + 1 == str . length ) ; index ++ ; prev_state = curr_state ; } return false ; }"
"static void printFibonacciNumbers ( int n ) { int f1 = 0 , f2 = 1 , i ; if ( n < 1 ) return ; for ( i = 1 ; i <= n ; i ++ ) { System . out . print ( f2 + "" "" ) ; int next = f1 + f2 ; f1 = f2 ; f2 = next ; } }"
"static int countIndices ( int arr [ ] , int n ) { int cnt = 0 ; int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( max < arr [ i ] ) { max = arr [ i ] ; cnt ++ ; } } return cnt ; }"
static int nextPowerOf2 ( int n ) { int count = 0 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }
static float squareSide ( float a ) { if ( a < 0 ) return - 1 ; float x = ( 0.423f * a ) ; return x ; }
"static int maxNumOfChocolates ( int arr [ ] , int n , int k ) { HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int [ ] sum = new int [ n ] ; int curr_rem ; int maxSum = 0 ; sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) sum [ i ] = sum [ i - 1 ] + arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { curr_rem = sum [ i ] % k ; if ( curr_rem == 0 ) { if ( maxSum < sum [ i ] ) maxSum = sum [ i ] ; } else if ( ! um . containsKey ( curr_rem ) ) um . put ( curr_rem , i ) ; else if ( maxSum < ( sum [ i ] - sum [ um . get ( curr_rem ) ] ) ) maxSum = sum [ i ] - sum [ um . get ( curr_rem ) ] ; } return ( maxSum / k ) ; }"
"static int getOddOccurrence ( int arr [ ] , int n ) { HashMap < Integer , Integer > hmap = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( hmap . containsKey ( arr [ i ] ) ) { int val = hmap . get ( arr [ i ] ) ; hmap . put ( arr [ i ] , val + 1 ) ; } else hmap . put ( arr [ i ] , 1 ) ; } for ( Integer a : hmap . keySet ( ) ) { if ( hmap . get ( a ) % 2 != 0 ) return a ; } return - 1 ; }"
"static void printTwoElements ( int arr [ ] , int size ) { int i ; System . out . print ( ""The repeating element is "" ) ; for ( i = 0 ; i < size ; i ++ ) { int abs_val = Math . abs ( arr [ i ] ) ; if ( arr [ abs_val - 1 ] > 0 ) arr [ abs_val - 1 ] = - arr [ abs_val - 1 ] ; else System . out . println ( abs_val ) ; } System . out . print ( ""And the missing element is "" ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] > 0 ) System . out . println ( i + 1 ) ; } }"
static boolean isDivisibleBy25 ( String str ) { int n = str . length ( ) ; if ( n == 1 ) return false ; return ( ( str . charAt ( n - 1 ) - '0' == 0 && str . charAt ( n - 2 ) - '0' == 0 ) || ( ( str . charAt ( n - 2 ) - '0' ) * 10 + ( str . charAt ( n - 1 ) - '0' ) ) % 25 == 0 ) ; }
"static boolean isInorder ( int [ ] arr , int n ) { if ( n == 0 || n == 1 ) { return true ; } for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i - 1 ] > arr [ i ] ) { return false ; } } return true ; }"
"static int MaximumHeight ( int [ ] a , int n ) { int result = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int y = ( i * ( i + 1 ) ) / 2 ; if ( y < n ) result = i ; else break ; } return result ; }"
"static int maxRectangles ( int L , int B , int l , int b ) { int horizontal = 0 , vertical = 0 ; if ( l <= L && b <= B ) { int columns = B / b ; int rows = L / l ; horizontal = rows * columns ; } if ( l <= B && b <= L ) { int columns = L / b ; int rows = B / l ; vertical = rows * columns ; } return Math . max ( horizontal , vertical ) ; }"
"static void printFactorialNums ( int n ) { int fact = 1 ; int x = 2 ; while ( fact <= n ) { System . out . print ( fact + "" "" ) ; fact = fact * x ; x ++ ; } }"
static long sum ( long n ) { long root = ( long ) Math . sqrt ( n ) ; long ans = 0 ; for ( int i = 1 ; i <= root ; i ++ ) ans += n / i ; ans = 2 * ans - ( root * root ) ; return ans ; }
"static int findMaxSegment ( String s , int k ) { int seg_len = s . length ( ) - k ; int res = 0 ; for ( int i = 0 ; i < seg_len ; i ++ ) res = res * 10 + ( s . charAt ( i ) - '0' ) ; int seg_len_pow = ( int ) Math . pow ( 10 , seg_len - 1 ) ; int curr_val = res ; for ( int i = 1 ; i <= ( s . length ( ) - seg_len ) ; i ++ ) { curr_val = curr_val - ( s . charAt ( i - 1 ) - '0' ) * seg_len_pow ; curr_val = curr_val * 10 + ( s . charAt ( i + seg_len - 1 ) - '0' ) ; res = Math . max ( res , curr_val ) ; } return res ; }"
static boolean isDivisible ( long n ) { while ( n / 100 != 0 ) { long d = n % 10 ; n /= 10 ; n += d * 7 ; } return ( n % 23 == 0 ) ; }
"static void findPair ( int [ ] arr , int n ) { boolean found = false ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] == arr [ k ] ) { System . out . println ( arr [ i ] + "" "" + arr [ j ] ) ; found = true ; } } } } if ( found == false ) System . out . println ( ""Not exist"" ) ; }"
"static int nthTerm ( int n ) { return 3 * ( int ) Math . pow ( n , 2 ) + 2 * n - 5 ; }"
"static int findMinEqualSums ( int [ ] a , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += a [ i ] ; } int sum1 = 0 , sum2 = 0 ; int min = Integer . MAX_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { sum1 += a [ i ] ; sum2 = sum - sum1 ; if ( Math . abs ( sum1 - sum2 ) < min ) { min = Math . abs ( sum1 - sum2 ) ; } if ( min == 0 ) { break ; } } return min ; }"
"static int maximumSegments ( int n , int a , int b , int c ) { int dp [ ] = new int [ n + 10 ] ; Arrays . fill ( dp , - 1 ) ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( dp [ i ] != - 1 ) { if ( i + a <= n ) dp [ i + a ] = Math . max ( dp [ i ] + 1 , dp [ i + a ] ) ; if ( i + b <= n ) dp [ i + b ] = Math . max ( dp [ i ] + 1 , dp [ i + b ] ) ; if ( i + c <= n ) dp [ i + c ] = Math . max ( dp [ i ] + 1 , dp [ i + c ] ) ; } } return dp [ n ] ; }"
"private static int findX ( int n , int k ) { int r = n , v , u ; int m = ( int ) Math . sqrt ( k ) + 1 ; for ( int i = 2 ; i <= m && k > 1 ; i ++ ) { if ( i == m ) { i = k ; } for ( u = v = 0 ; k % i == 0 ; v ++ ) { k /= i ; } if ( v > 0 ) { int t = n ; while ( t > 0 ) { t /= i ; u += t ; } r = Math . min ( r , u / v ) ; } } return r ; }"
"static int longestAlternatingSubarray ( int a [ ] , int n ) { int longest = 1 ; int cnt = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] * a [ i - 1 ] < 0 ) { cnt ++ ; longest = Math . max ( longest , cnt ) ; } else cnt = 1 ; } return longest ; }"
"static int remainder ( String str ) { int len = str . length ( ) ; int num , rem = 0 ; for ( int i = 0 ; i < len ; i ++ ) { num = rem * 10 + ( str . charAt ( i ) - '0' ) ; rem = num % 11 ; } return rem ; }"
"void productArray ( int arr [ ] , int n ) { if ( n == 1 ) { System . out . print ( ""0"" ) ; return ; } int i , temp = 1 ; int prod [ ] = new int [ n ] ; for ( int j = 0 ; j < n ; j ++ ) prod [ j ] = 1 ; for ( i = 0 ; i < n ; i ++ ) { prod [ i ] = temp ; temp *= arr [ i ] ; } temp = 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { prod [ i ] *= temp ; temp *= arr [ i ] ; } for ( i = 0 ; i < n ; i ++ ) System . out . print ( prod [ i ] + "" "" ) ; return ; }"
"static int FirstDigit ( int arr [ ] , int n ) { double S = 0 ; for ( int i = 0 ; i < n ; i ++ ) S = S + Math . log10 ( arr [ i ] * 1.0 ) ; double fract_S = S - Math . floor ( S ) ; int ans = ( int ) Math . pow ( 10 , fract_S ) ; return ans ; }"
"static double compute ( int a , int b ) { double AM , GM , HM ; AM = ( a + b ) / 2 ; GM = Math . sqrt ( a * b ) ; HM = ( GM * GM ) / AM ; return HM ; }"
"static int reduceString ( String s , int l ) { int count = 1 , steps = 0 ; for ( int i = 1 ; i < l ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( i - 1 ) ) count += 1 ; else { steps += ( count / 2 ) ; count = 1 ; } } steps += count / 2 ; return steps ; }"
"static void count ( String str1 , String str2 ) { int c = 0 , j = 0 ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { if ( str2 . indexOf ( str1 . charAt ( i ) ) >= 0 ) { c += 1 ; } } System . out . println ( ""No. of matching characters are: "" + c ) ; }"
static int findIndex ( int n ) { float fibo = 2.078087F * ( float ) Math . log ( n ) + 1.672276F ; return Math . round ( fibo ) ; }
"static void ReplaceElements ( int arr [ ] , int n ) { if ( n <= 1 ) { return ; } int prev = arr [ 0 ] ; arr [ 0 ] = arr [ 0 ] + arr [ 1 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int curr = arr [ i ] ; arr [ i ] = prev + arr [ i + 1 ] ; prev = curr ; } arr [ n - 1 ] = prev + arr [ n - 1 ] ; }"
"static boolean isRatioPossible ( int lowCost , int upCost , int lowQuant , int upQuant , int r ) { for ( int i = lowQuant ; i <= upQuant ; i ++ ) { int ans = i * r ; if ( lowCost <= ans && ans <= upCost ) return true ; } return false ; }"
"static int findSum ( int N , int K ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) ans += ( i % K ) ; return ans ; }"
"static int findNumberOfTimes ( String str1 , String str2 ) { int freq [ ] = new int [ 26 ] ; int l1 = str1 . length ( ) ; for ( int i = 0 ; i < l1 ; i ++ ) { freq [ str1 . charAt ( i ) - 'a' ] += 1 ; } int l2 = str2 . length ( ) ; int count = Integer . MAX_VALUE ; for ( int i = 0 ; i < l2 ; i ++ ) { count = Math . min ( count , freq [ str2 . charAt ( i ) - 'a' ] ) ; } return count ; }"
static int countSubstringWithEqualEnds ( String s ) { int result = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) if ( s . charAt ( i ) == s . charAt ( j ) ) result ++ ; return result ; }
"static void divide ( int n , int m ) { System . out . println ( ""Remainder = "" + ( ( n ) & ( m - 1 ) ) ) ; System . out . println ( ""Quotient = "" + ( n >> ( int ) ( Math . log ( m ) / Math . log ( 2 ) ) ) ) ; }"
"static String findTwoscomplement ( StringBuffer str ) { int n = str . length ( ) ; int i ; for ( i = n - 1 ; i >= 0 ; i -- ) if ( str . charAt ( i ) == '1' ) break ; if ( i == - 1 ) return ""1"" + str ; for ( int k = i - 1 ; k >= 0 ; k -- ) { if ( str . charAt ( k ) == '1' ) str . replace ( k , k + 1 , ""0"" ) ; else str . replace ( k , k + 1 , ""1"" ) ; } return str . toString ( ) ; }"
"static float harmonicMean ( int arr [ ] , int freq [ ] , int n ) { float sum = 0 , frequency_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( float ) freq [ i ] / arr [ i ] ; frequency_sum = frequency_sum + freq [ i ] ; } return ( frequency_sum / sum ) ; }"
"int getInvCount ( int arr [ ] , int n ) { int invcount = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int small = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) small ++ ; int great = 0 ; for ( int j = i - 1 ; j >= 0 ; j -- ) if ( arr [ i ] < arr [ j ] ) great ++ ; invcount += great * small ; } return invcount ; }"
static int phi ( int n ) { float result = n ; for ( int p = 2 ; p * p <= n ; ++ p ) { if ( n % p == 0 ) { while ( n % p == 0 ) n /= p ; result *= ( 1.0 - ( 1.0 / ( float ) p ) ) ; } } if ( n > 1 ) result *= ( 1.0 - ( 1.0 / ( float ) n ) ) ; return ( int ) result ; }
static int divSum ( int n ) { int result = 0 ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i == ( n / i ) ) result += i ; else result += ( i + n / i ) ; } } return ( result + n + 1 ) ; }
"static int find_sum ( int n , int k ) { int total_sum = ( n * ( n + 1 ) ) / 2 ; int power = k ; while ( power <= n ) { total_sum -= power ; power *= k ; } return total_sum ; }"
static int grayCode ( int n ) { return n ^ ( n >> 1 ) ; }
static int nswp ( int n ) { if ( n == 0 || n == 1 ) return 1 ; return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) ; }
static float squareRoot ( float n ) { float x = n ; float y = 1 ; double e = 0.000001 ; while ( x - y > e ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; }
"static String minInt ( String str ) { String s = """" ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) >= '5' ) { s += ( char ) ( ( '9' - str . charAt ( i ) ) + '0' ) ; } else { s += str . charAt ( i ) ; } } if ( str . charAt ( 0 ) == '0' ) s += '9' ; return s ; }"
"static int ksmallest ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; if ( k < arr [ 0 ] ) return k ; if ( k == arr [ 0 ] ) return arr [ 0 ] + 1 ; if ( k > arr [ n - 1 ] ) return k + n ; if ( arr [ 0 ] == 1 ) k -- ; else k -= ( arr [ 0 ] - 1 ) ; for ( int i = 1 ; i < n ; i ++ ) { int c = arr [ i ] - arr [ i - 1 ] - 1 ; if ( k <= c ) return arr [ i - 1 ] + k ; else k -= c ; } return arr [ n - 1 ] + k ; }"
static boolean isFactorial ( int n ) { for ( int i = 1 ; ; i ++ ) { if ( n % i == 0 ) { n /= i ; } else { break ; } } if ( n == 1 ) { return true ; } else { return false ; } }
static int aliquotSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i < n ; i ++ ) if ( n % i == 0 ) sum += i ; return sum ; }
"static int minimumRemoval ( int n , int a [ ] ) { Map < Integer , Integer > c = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( c . containsKey ( a [ i ] ) ) { c . put ( a [ i ] , c . get ( a [ i ] ) + 1 ) ; } else { c . put ( a [ i ] , 1 ) ; } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { boolean ok = false ; for ( int j = 0 ; j < 31 ; j ++ ) { int x = ( 1 << j ) - a [ i ] ; if ( ( c . get ( x ) != null && ( c . get ( x ) > 1 ) ) || c . get ( x ) != null && ( c . get ( x ) == 1 && x != a [ i ] ) ) { ok = true ; break ; } } if ( ! ok ) ans ++ ; } return ans ; }"
static String to_upper ( char [ ] in ) { for ( int i = 0 ; i < in . length ; i ++ ) { if ( 'a' <= in [ i ] & in [ i ] <= 'z' ) { in [ i ] = ( char ) ( in [ i ] - 'a' + 'A' ) ; } } return String . valueOf ( in ) ; }
static int findMinSum ( int num ) { int sum = 0 ; for ( int i = 2 ; i * i <= num ; i ++ ) { while ( num % i == 0 ) { sum += i ; num /= i ; } } sum += num ; return sum ; }
"static int deleteElement ( int A [ ] , int L , int R , int N ) { int i , j = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( i <= L || i >= R ) { A [ j ] = A [ i ] ; j ++ ; } } return j ; }"
"static void printCubes ( int a , int b ) { for ( int i = a ; i <= b ; i ++ ) { for ( int j = 1 ; j * j * j <= i ; j ++ ) { if ( j * j * j == i ) { System . out . print ( j * j * j + "" "" ) ; break ; } } } }"
"static int minCost ( int [ ] [ ] graph , int n ) { int cost1 = 0 , cost2 = 0 ; boolean [ ] start = new boolean [ n + 1 ] ; boolean [ ] end = new boolean [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { int a = graph [ i ] [ 0 ] ; int b = graph [ i ] [ 1 ] ; int c = graph [ i ] [ 2 ] ; if ( start [ a ] || end [ b ] ) { cost2 += c ; start [ b ] = true ; end [ a ] = true ; } else { cost1 += c ; start [ a ] = true ; end [ b ] = true ; } } return Math . min ( cost1 , cost2 ) ; }"
"void reverse ( String str ) { if ( ( str == null ) || ( str . length ( ) <= 1 ) ) System . out . println ( str ) ; else { System . out . print ( str . charAt ( str . length ( ) - 1 ) ) ; reverse ( str . substring ( 0 , str . length ( ) - 1 ) ) ; } }"
"static boolean isPowerOfK ( int n , int k ) { boolean oneSeen = false ; while ( n > 0 ) { int digit = n % k ; if ( digit > 1 ) return false ; if ( digit == 1 ) { if ( oneSeen ) return false ; oneSeen = true ; } n /= k ; } return true ; }"
"static int solve ( int dp [ ] [ ] , int a [ ] , int low , int high , int turn ) { if ( low == high ) { return a [ low ] * turn ; } if ( dp [ low ] [ high ] != 0 ) { return dp [ low ] [ high ] ; } dp [ low ] [ high ] = Math . max ( a [ low ] * turn + solve ( dp , a , low + 1 , high , turn + 1 ) , a [ high ] * turn + solve ( dp , a , low , high - 1 , turn + 1 ) ) ; return dp [ low ] [ high ] ; }"
"public static void maxOverlap ( int [ ] start , int [ ] end , int n ) { int maxa = Arrays . stream ( start ) . max ( ) . getAsInt ( ) ; int maxb = Arrays . stream ( end ) . max ( ) . getAsInt ( ) ; int maxc = Math . max ( maxa , maxb ) ; int [ ] x = new int [ maxc + 2 ] ; Arrays . fill ( x , 0 ) ; int cur = 0 , idx = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ++ x [ start [ i ] ] ; -- x [ end [ i ] + 1 ] ; } int maxy = Integer . MIN_VALUE ; for ( int i = 0 ; i <= maxc ; i ++ ) { cur += x [ i ] ; if ( maxy < cur ) { maxy = cur ; idx = i ; } } System . out . println ( ""Maximum value is:"" + maxy + "" at position: "" + idx + """" ) ; }"
"static int minTime ( int arr [ ] , int n ) { if ( n <= 0 ) return 0 ; int incl = arr [ 0 ] ; int excl = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int incl_new = arr [ i ] + Math . min ( excl , incl ) ; int excl_new = incl ; incl = incl_new ; excl = excl_new ; } return Math . min ( incl , excl ) ; }"
"int findFirstMissing ( int array [ ] , int start , int end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; int mid = ( start + end ) / 2 ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; }"
"public static int findLCM ( int a , int b ) { int lar = Math . max ( a , b ) ; int small = Math . min ( a , b ) ; for ( int i = lar ; ; i += lar ) { if ( i % small == 0 ) return i ; } }"
"static int countgroup ( int a [ ] , int n ) { int xs = 0 ; for ( int i = 0 ; i < n ; i ++ ) xs = xs ^ a [ i ] ; if ( xs == 0 ) return ( 1 << ( n - 1 ) ) - 1 ; return 0 ; }"
"static int findMaxDiff ( int arr [ ] , int n ) { if ( n < 2 ) { System . out . print ( ""Invalid "" ) ; return 0 ; } int res = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( res < ( arr [ i ] - arr [ j ] - i + j ) ) res = ( arr [ i ] - arr [ j ] - i + j ) ; return res ; }"
"static void knowPair ( int a , int b , int n , int s , int m ) { int i = 0 , rem = 0 ; int count_b = 0 , flag = 0 ; while ( i <= a ) { rem = s - ( n * i ) ; count_b = rem / m ; if ( rem % m == 0 && count_b <= b ) { flag = 1 ; } i ++ ; } if ( flag == 1 ) { System . out . print ( ""YES"" + ""\n"" ) ; } else { System . out . print ( ""NO"" + ""\n"" ) ; } }"
"static void parabola ( float a , float b , float c ) { System . out . println ( ""Vertex: ("" + ( - b / ( 2 * a ) ) + "", "" + ( ( ( 4 * a * c ) - ( b * b ) ) / ( 4 * a ) ) + "")"" ) ; System . out . println ( ""Focus: ("" + ( - b / ( 2 * a ) ) + "", "" + ( ( ( 4 * a * c ) - ( b * b ) + 1 ) / ( 4 * a ) ) + "")"" ) ; System . out . println ( ""Directrix:"" + "" y="" + ( int ) ( c - ( ( b * b ) + 1 ) * 4 * a ) ) ; }"
"static int eggDrop ( int n , int k ) { if ( k == 1 || k == 0 ) return k ; if ( n == 1 ) return k ; int min = Integer . MAX_VALUE ; int x , res ; for ( x = 1 ; x <= k ; x ++ ) { res = Math . max ( eggDrop ( n - 1 , x - 1 ) , eggDrop ( n , k - x ) ) ; if ( res < min ) min = res ; } return min + 1 ; }"
"static StringBuilder findMaximumNum ( StringBuilder str , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { if ( k < 1 ) break ; if ( str . charAt ( i ) != '9' ) { str . setCharAt ( i , '9' ) ; k -- ; } } return str ; }"
"static int minTime ( int [ ] arr , int n , int m ) { int t = 0 ; while ( true ) { int items = 0 ; for ( int i = 0 ; i < n ; i ++ ) items += ( t / arr [ i ] ) ; if ( items >= m ) return t ; t ++ ; } }"
"static boolean HalfDiagonalSums ( int mat [ ] [ ] , int n ) { int diag1_left = 0 , diag1_right = 0 ; int diag2_left = 0 , diag2_right = 0 ; for ( int i = 0 , j = n - 1 ; i < n ; i ++ , j -- ) { if ( i < n / 2 ) { diag1_left += mat [ i ] [ i ] ; diag2_left += mat [ j ] [ i ] ; } else if ( i > n / 2 ) { diag1_right += mat [ i ] [ i ] ; diag2_right += mat [ j ] [ i ] ; } } return ( diag1_left == diag2_right && diag2_right == diag2_left && diag1_right == diag2_left && diag2_right == mat [ n / 2 ] [ n / 2 ] ) ; }"
"static int maxSumPairWithDifferenceLessThanK ( int arr [ ] , int N , int K ) { Arrays . sort ( arr ) ; int dp [ ] = new int [ N ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] = dp [ i - 1 ] ; if ( arr [ i ] - arr [ i - 1 ] < K ) { if ( i >= 2 ) dp [ i ] = Math . max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) ; else dp [ i ] = Math . max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) ; } } return dp [ N - 1 ] ; }"
"static int sum ( int N ) { int S1 , S2 , S3 ; S1 = ( ( N / 3 ) ) * ( 2 * 3 + ( N / 3 - 1 ) * 3 ) / 2 ; S2 = ( ( N / 4 ) ) * ( 2 * 4 + ( N / 4 - 1 ) * 4 ) / 2 ; S3 = ( ( N / 12 ) ) * ( 2 * 12 + ( N / 12 - 1 ) * 12 ) / 2 ; return S1 + S2 - S3 ; }"
"static void printNumbers ( int N ) { int flag = 1 ; int x = N ; if ( N > 0 ) { while ( x > 0 && flag == 1 ) { int digit = x % 10 ; if ( digit != 1 && digit != 3 ) { flag = 0 ; } x = x / 10 ; } if ( flag == 1 ) { System . out . print ( N + "" "" ) ; } printNumbers ( N - 1 ) ; } }"
"static int countOccurrences ( String s , int K ) { int n = s . length ( ) ; int C = 0 , c1 = 0 , c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == 'a' ) c1 ++ ; if ( s . charAt ( i ) == 'b' ) { c2 ++ ; C += c1 ; } } return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2 ; }"
static int triplets ( int N ) { return ( ( N + 1 ) * ( N + 2 ) ) / 2 ; }
"static int countSubarrays ( int a [ ] , int n , int x ) { int count = 0 ; int number = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) { count += 1 ; } else { number += ( count ) * ( count + 1 ) / 2 ; count = 0 ; } } if ( count != 0 ) number += ( count ) * ( count + 1 ) / 2 ; return number ; }"
"static void sort012 ( int a [ ] , int arr_size ) { int lo = 0 ; int hi = arr_size - 1 ; int mid = 0 , temp = 0 ; while ( mid <= hi ) { switch ( a [ mid ] ) { case 0 : { temp = a [ lo ] ; a [ lo ] = a [ mid ] ; a [ mid ] = temp ; lo ++ ; mid ++ ; break ; } case 1 : mid ++ ; break ; case 2 : { temp = a [ mid ] ; a [ mid ] = a [ hi ] ; a [ hi ] = temp ; hi -- ; break ; } } } }"
int catalan ( int n ) { int res = 0 ; if ( n <= 1 ) { return 1 ; } for ( int i = 0 ; i < n ; i ++ ) { res += catalan ( i ) * catalan ( n - i - 1 ) ; } return res ; }
"static void longest ( int a [ ] , int n , int k ) { int [ ] freq = new int [ 7 ] ; int start = 0 , end = 0 , now = 0 , l = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ a [ i ] ] ++ ; if ( freq [ a [ i ] ] == 1 ) now ++ ; while ( now > k ) { freq [ a [ l ] ] -- ; if ( freq [ a [ l ] ] == 0 ) now -- ; l ++ ; } if ( i - l + 1 >= end - start + 1 ) { end = i ; start = l ; } } for ( int i = start ; i <= end ; i ++ ) System . out . print ( a [ i ] + "" "" ) ; }"
"static void K_multiple ( int a [ ] , int n , int k ) { Arrays . sort ( a ) ; HashSet < Integer > s = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] % k == 0 && ! s . contains ( a [ i ] / k ) ) || a [ i ] % k != 0 ) s . add ( a [ i ] ) ; } for ( Integer i : s ) System . out . print ( i + "" "" ) ; }"
static int countConsecutive ( int n ) { String s = Integer . toString ( n ) ; int count = 0 ; for ( int i = 0 ; i < s . length ( ) - 1 ; i ++ ) if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) count ++ ; return count ; }
"public static void printInitials ( String str ) { int len = str . length ( ) ; str = str . trim ( ) ; String t = """" ; for ( int i = 0 ; i < len ; i ++ ) { char ch = str . charAt ( i ) ; if ( ch != ' ' ) { t = t + ch ; } else { System . out . print ( Character . toUpperCase ( t . charAt ( 0 ) ) + "". "" ) ; t = """" ; } } String temp = """" ; for ( int j = 0 ; j < t . length ( ) ; j ++ ) { if ( j == 0 ) temp = temp + Character . toUpperCase ( t . charAt ( 0 ) ) ; else temp = temp + Character . toLowerCase ( t . charAt ( j ) ) ; } System . out . println ( temp ) ; }"
"static int xorPairCount ( int arr [ ] , int n , int x ) { int result = 0 ; Map < Integer , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int curr_xor = x ^ arr [ i ] ; if ( m . containsKey ( curr_xor ) ) result += m . get ( curr_xor ) ; if ( m . containsKey ( arr [ i ] ) ) { m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; } else { m . put ( arr [ i ] , 1 ) ; } } return result ; }"
"static void findMaxFrequency ( String s ) { int arr [ ] = new int [ 26 ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) arr [ s . charAt ( i ) - 'a' ] ++ ; HashMap < Integer , Integer > hash = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < 26 ; i ++ ) if ( arr [ i ] != 0 ) { if ( hash . containsKey ( arr [ i ] ) ) { hash . put ( arr [ i ] , hash . get ( arr [ i ] ) + 1 ) ; } else { hash . put ( arr [ i ] , 1 ) ; } } int max_count = 0 , res = - 1 ; for ( Map . Entry < Integer , Integer > i : hash . entrySet ( ) ) { if ( max_count < i . getValue ( ) ) { res = i . getKey ( ) ; max_count = i . getValue ( ) ; } } System . out . println ( ""Frequency "" + res + "" is repeated "" + max_count + "" times"" ) ; }"
"static int minToggle ( int arr [ ] , int n ) { int zero [ ] = new int [ n + 1 ] ; zero [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( arr [ i - 1 ] == 0 ) zero [ i ] = zero [ i - 1 ] + 1 ; else zero [ i ] = zero [ i - 1 ] ; } int ans = n ; for ( int i = 1 ; i <= n ; ++ i ) ans = Math . min ( ans , i - zero [ i ] + zero [ n ] - zero [ i ] ) ; return ans ; }"
"static int reachTarget ( int target ) { target = Math . abs ( target ) ; int sum = 0 , step = 0 ; while ( sum < target || ( sum - target ) % 2 != 0 ) { step ++ ; sum += step ; } return step ; }"
"static int maxDiff ( int [ ] arr , int n ) { int result = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) result += Math . abs ( arr [ i ] ) ; else i ++ ; } if ( arr [ n - 2 ] != arr [ n - 1 ] ) result += Math . abs ( arr [ n - 1 ] ) ; return result ; }"
"static void splitString ( String str ) { StringBuffer alpha = new StringBuffer ( ) , num = new StringBuffer ( ) , special = new StringBuffer ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( Character . isDigit ( str . charAt ( i ) ) ) num . append ( str . charAt ( i ) ) ; else if ( Character . isAlphabetic ( str . charAt ( i ) ) ) alpha . append ( str . charAt ( i ) ) ; else special . append ( str . charAt ( i ) ) ; } System . out . println ( alpha ) ; System . out . println ( num ) ; System . out . println ( special ) ; }"
static int nextPerfectSquare ( int N ) { int nextN = ( int ) Math . floor ( Math . sqrt ( N ) ) + 1 ; return nextN * nextN ; }
"static void powerfulIntegers ( int x , int y , int bound ) { Set < Integer > s = new HashSet < > ( ) ; ArrayList < Integer > powersOfY = new ArrayList < > ( ) ; int i ; powersOfY . add ( 1 ) ; for ( i = y ; i < bound ; i = i * y ) powersOfY . add ( i ) ; i = 0 ; while ( true ) { int xPowI = ( int ) Math . pow ( ( double ) x , ( double ) i ) ; if ( xPowI >= bound ) break ; for ( int j = 0 ; j < powersOfY . size ( ) ; ++ j ) { int num = xPowI + powersOfY . get ( j ) ; if ( num <= bound ) s . add ( num ) ; else break ; } i ++ ; } Iterator itr = s . iterator ( ) ; while ( itr . hasNext ( ) ) { System . out . print ( itr . next ( ) + "" "" ) ; } }"
"static int nthTerm ( int n ) { return 7 * ( int ) Math . pow ( n , 2 ) - 7 * n + 7 ; }"
"static void subsetSums ( int [ ] arr , int l , int r , int sum ) { if ( l > r ) { System . out . print ( sum + "" "" ) ; return ; } subsetSums ( arr , l + 1 , r , sum + arr [ l ] ) ; subsetSums ( arr , l + 1 , r , sum ) ; }"
"static void randomize ( int arr [ ] , int n ) { Random r = new Random ( ) ; for ( int i = n - 1 ; i > 0 ; i -- ) { int j = r . nextInt ( i + 1 ) ; int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } System . out . println ( Arrays . toString ( arr ) ) ; }"
"static int maxProdSum ( int arr [ ] , int n ) { int leftArraySum = 0 , maxProduct = 0 ; for ( int i = 0 ; i < n ; i ++ ) { leftArraySum += arr [ i ] ; int rightArraySum = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) { rightArraySum += arr [ j ] ; } int k = leftArraySum * rightArraySum ; if ( k > maxProduct ) { maxProduct = k ; } } return maxProduct ; }"
"public static int sum ( int a [ ] , int n ) { Map < Integer , Integer > cnt = new HashMap < Integer , Integer > ( ) ; int ans = 0 , pre_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += ( i * a [ i ] ) - pre_sum ; pre_sum += a [ i ] ; if ( cnt . containsKey ( a [ i ] - 1 ) ) ans -= cnt . get ( a [ i ] - 1 ) ; if ( cnt . containsKey ( a [ i ] + 1 ) ) ans += cnt . get ( a [ i ] + 1 ) ; if ( cnt . containsKey ( a [ i ] ) ) { cnt . put ( a [ i ] , cnt . get ( a [ i ] ) + 1 ) ; } else { cnt . put ( a [ i ] , 1 ) ; } } return ans ; }"
"static int getMinSquares ( int n ) { if ( n <= 3 ) return n ; int res = n ; for ( int x = 1 ; x <= n ; x ++ ) { int temp = x * x ; if ( temp > n ) break ; else res = Math . min ( res , 1 + getMinSquares ( n - temp ) ) ; } return res ; }"
"static int frequencyOfSmallest ( int n , int arr [ ] ) { int mn = arr [ 0 ] , freq = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < mn ) { mn = arr [ i ] ; freq = 1 ; } else if ( arr [ i ] == mn ) freq ++ ; } return freq ; }"
"static void printRoots ( long a , long b , long c ) { System . out . println ( 1 + "", "" + c / ( a * 1.0 ) ) ; }"
"public static int breakEvenPoint ( int exp1 , int S , int M ) { double earn = S - M ; double exp = exp1 ; double res = Math . ceil ( exp / earn ) ; int res1 = ( int ) res ; return res1 ; }"
static void printExpansion ( String str ) { for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) { String subStr = str . substring ( i ) ; System . out . print ( subStr ) ; } }
"static void find ( int n , int m ) { if ( n <= 2 * m ) System . out . println ( ""Minimum "" + 0 ) ; else System . out . println ( ""Minimum "" + ( n - 2 * m ) ) ; int i ; for ( i = 1 ; i <= n ; i ++ ) { if ( i * ( i - 1 ) / 2 >= m ) break ; } System . out . println ( ""Maximum "" + ( n - i ) ) ; }"
"static int palindrome ( int arr [ ] , int begin , int end ) { if ( begin >= end ) { return 1 ; } if ( arr [ begin ] == arr [ end ] ) { return palindrome ( arr , begin + 1 , end - 1 ) ; } else { return 0 ; } }"
"static void printGroups ( int n ) { int x = 1 ; int y = n * n ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n / 2 ; j ++ ) { System . out . print ( ""{ "" + x + "", "" + y + ""} "" ) ; x ++ ; y -- ; } System . out . println ( ) ; } }"
"static int minimumX ( int n , int k ) { int ans = Integer . MAX_VALUE ; for ( int rem = k - 1 ; rem > 0 ; rem -- ) { if ( n % rem == 0 ) ans = Math . min ( ans , rem + ( n / rem ) * k ) ; } return ans ; }"
"static int pairs_count ( int arr [ ] , int n , int sum ) { int ans = 0 ; Arrays . sort ( arr ) ; int i = 0 , j = n - 1 ; while ( i < j ) { if ( arr [ i ] + arr [ j ] < sum ) i ++ ; else if ( arr [ i ] + arr [ j ] > sum ) j -- ; else { int x = arr [ i ] , xx = i ; while ( ( i < j ) && ( arr [ i ] == x ) ) i ++ ; int y = arr [ j ] , yy = j ; while ( ( j >= i ) && ( arr [ j ] == y ) ) j -- ; if ( x == y ) { int temp = i - xx + yy - j - 1 ; ans += ( temp * ( temp + 1 ) ) / 2 ; } else ans += ( i - xx ) * ( yy - j ) ; } } return ans ; }"
"static boolean containsElement ( int [ ] arr , int n ) { int xorArr = 0 ; for ( int i = 0 ; i < n ; ++ i ) xorArr ^= arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) { int x = xorArr ^ arr [ i ] ; if ( arr [ i ] == x ) return true ; } return false ; }"
"static int max_length_substring ( String st , int n , int k ) { int max_len = 0 ; int len = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( st . charAt ( i ) == '0' ) len ++ ; else len = 0 ; max_len = Math . max ( max_len , len ) ; } if ( max_len == n ) return n * k ; int pref = 0 , suff = 0 ; for ( int i = 0 ; st . charAt ( i ) == '0' ; ++ i , ++ pref ) ; for ( int i = n - 1 ; st . charAt ( i ) == '0' ; -- i , ++ suff ) ; if ( k > 1 ) max_len = Math . max ( max_len , pref + suff ) ; return max_len ; }"
"static void printFirstRepeating ( int arr [ ] ) { int min = - 1 ; HashSet < Integer > set = new HashSet < > ( ) ; for ( int i = arr . length - 1 ; i >= 0 ; i -- ) { if ( set . contains ( arr [ i ] ) ) min = i ; else set . add ( arr [ i ] ) ; } if ( min != - 1 ) System . out . println ( ""The first repeating element is "" + arr [ min ] ) ; else System . out . println ( ""There are no repeating elements"" ) ; }"
"static boolean checkDuplicatesWithinK ( int arr [ ] , int k ) { HashSet < Integer > set = new HashSet < > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( set . contains ( arr [ i ] ) ) return true ; set . add ( arr [ i ] ) ; if ( i >= k ) set . remove ( arr [ i - k ] ) ; } return false ; }"
"static int lengthOfSmallestSubsequence ( int K , int [ ] v ) { Queue < Integer > pq = new PriorityQueue < Integer > ( Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < v . length ; i ++ ) { pq . add ( v [ i ] ) ; } int sum = 0 , count = 0 ; while ( ! pq . isEmpty ( ) && sum < K ) { sum += pq . peek ( ) ; pq . remove ( ) ; count ++ ; } if ( sum < K ) { return - 1 ; } return count ; }"
static boolean check ( String str ) { int n = str . length ( ) ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str . charAt ( i ) - '0' ) ; return ( digitSum % 3 == 0 ) ; }
"static void printArray ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int l = 0 , r = n - 1 , flag = 0 , i ; int k = 2 ; while ( l <= r ) { if ( flag == 0 ) { for ( i = l ; i < l + k && i <= r ; i ++ ) System . out . print ( arr [ i ] + "" "" ) ; flag = 1 ; l = i ; } else { for ( i = r ; i > r - k && i >= l ; i -- ) System . out . print ( arr [ i ] + "" "" ) ; flag = 0 ; r = i ; } k ++ ; } }"
"static int pairsInSortedRotated ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; int l = ( i + 1 ) % n ; int r = i ; int cnt = 0 ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) { cnt ++ ; if ( l == ( r - 1 + n ) % n ) { return cnt ; } l = ( l + 1 ) % n ; r = ( r - 1 + n ) % n ; } else if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return cnt ; }"
"static void mySort ( Integer [ ] arr ) { int n = arr . length ; Arrays . sort ( arr , 0 , n / 2 ) ; Arrays . sort ( arr , n / 2 , n , Collections . reverseOrder ( ) ) ; }"
"public static int countSubarrays ( int a [ ] , int n , int m ) { int count = 0 ; int prefix [ ] = new int [ n ] ; int odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { prefix [ odd ] ++ ; if ( ( a [ i ] & 1 ) == 1 ) odd ++ ; if ( odd >= m ) count += prefix [ odd - m ] ; } return count ; }"
"static String makePalindrome ( char [ ] str ) { int i = 0 , j = str . length - 1 ; while ( i <= j ) { if ( str [ i ] == '*' && str [ j ] == '*' ) { str [ i ] = 'a' ; str [ j ] = 'a' ; } else if ( str [ j ] == '*' ) str [ j ] = str [ i ] ; else if ( str [ i ] == '*' ) str [ i ] = str [ j ] ; else if ( str [ i ] != str [ j ] ) return ""-1"" ; i ++ ; j -- ; } return String . valueOf ( str ) ; }"
"static int PowerOFPINnfactorial ( int n , int p ) { int ans = 0 ; int temp = p ; while ( temp <= n ) { ans += n / temp ; temp = temp * p ; } return ans ; }"
"static long firstkdigits ( int n , int k ) { long product = 1 ; for ( int i = 0 ; i < n ; i ++ ) product *= n ; while ( ( int ) ( product / Math . pow ( 10 , k ) ) != 0 ) product = product / 10 ; return product ; }"
"static int steps ( int N , int M ) { if ( N == 1 ) return 0 ; else if ( N == 2 ) return M ; return 2 * M + ( N - 3 ) ; }"
"static int countX ( int a , int b ) { if ( b > a ) return 0 ; else if ( a == b ) return - 1 ; else { int x = a - b , ans = 0 ; for ( int i = 1 ; i * i <= x ; i ++ ) { if ( x % i == 0 ) { int d1 = i , d2 = b - 1 ; if ( i * i != x ) d2 = x / i ; if ( d1 > b ) ans ++ ; if ( d2 > b ) ans ++ ; } } return ans ; } }"
public static String noAdjacentDup ( String s1 ) { int n = s1 . length ( ) ; char [ ] s = s1 . toCharArray ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { s [ i ] = 'a' ; while ( s [ i ] == s [ i - 1 ] || ( i + 1 < n && s [ i ] == s [ i + 1 ] ) ) s [ i ] ++ ; i ++ ; } } return ( new String ( s ) ) ; }
"static void diagonalsquare ( int mat [ ] [ ] , int row , int column ) { System . out . print ( ""Diagonal one : "" ) ; for ( int i = 0 ; i < row ; i ++ ) { for ( int j = 0 ; j < column ; j ++ ) if ( i == j ) System . out . print ( mat [ i ] [ j ] * mat [ i ] [ j ] + "" "" ) ; } System . out . println ( ) ; System . out . print ( ""Diagonal two : "" ) ; for ( int i = 0 ; i < row ; i ++ ) { for ( int j = 0 ; j < column ; j ++ ) if ( i + j == column - 1 ) System . out . print ( mat [ i ] [ j ] * mat [ i ] [ j ] + "" "" ) ; } }"
"static void printPattern ( int n ) { int arr [ ] [ ] = new int [ n ] [ n ] ; int k , i , j , p = 1 , f ; for ( k = 0 ; k < n ; k ++ ) { j = k ; i = 0 ; while ( j >= 0 ) { arr [ i ] [ j ] = p ; p ++ ; i = i + 1 ; j = j - 1 ; } } for ( k = 1 ; k < n ; k ++ ) { i = k ; j = n - 1 ; f = k ; while ( j >= f ) { arr [ i ] [ j ] = p ; p ++ ; i = i + 1 ; j = j - 1 ; } } for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { System . out . print ( arr [ i ] [ j ] + "" "" ) ; } System . out . println ( ) ; } }"
"static int countWays ( int n , int m ) { int count [ ] = new int [ n + 1 ] ; count [ 0 ] = 0 ; int i ; for ( i = 1 ; i <= n ; i ++ ) { if ( i > m ) count [ i ] = count [ i - 1 ] + count [ i - m ] ; else if ( i < m ) count [ i ] = 1 ; else count [ i ] = 2 ; } return count [ n ] ; }"
"static int maxSum ( int p0 , int p1 , int a [ ] , int pos , int n ) { if ( pos == n ) { if ( p0 == p1 ) return p0 ; else return 0 ; } int ans = maxSum ( p0 , p1 , a , pos + 1 , n ) ; ans = Math . max ( ans , maxSum ( p0 + a [ pos ] , p1 , a , pos + 1 , n ) ) ; ans = Math . max ( ans , maxSum ( p0 , p1 + a [ pos ] , a , pos + 1 , n ) ) ; return ans ; }"
"static void odd_even ( int arr [ ] , int n ) { Vector < Integer > odd_indexes = new Vector < Integer > ( ) ; Vector < Integer > even_indexes = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) odd_indexes . add ( arr [ i ] ) ; else even_indexes . add ( arr [ i ] ) ; } Collections . sort ( odd_indexes ) ; Collections . sort ( even_indexes ) ; for ( int i = 0 ; i < odd_indexes . size ( ) ; i ++ ) System . out . print ( odd_indexes . get ( i ) + "" "" ) ; for ( int i = 0 ; i < even_indexes . size ( ) ; i ++ ) System . out . print ( even_indexes . get ( i ) + "" "" ) ; }"
"static void printRotatedString ( String str ) { int len = str . length ( ) ; StringBuffer sb ; for ( int i = 0 ; i < len ; i ++ ) { sb = new StringBuffer ( ) ; int j = i ; int k = 0 ; for ( int k2 = j ; k2 < str . length ( ) ; k2 ++ ) { sb . insert ( k , str . charAt ( j ) ) ; k ++ ; j ++ ; } j = 0 ; while ( j < i ) { sb . insert ( k , str . charAt ( j ) ) ; j ++ ; k ++ ; } System . out . println ( sb ) ; } }"
public static boolean isEven ( int n ) { if ( ( n & 1 ) == 0 ) return true ; else return false ; }
"static void printPath ( String str ) { int i = 0 ; int curX = 0 , curY = 0 ; while ( i < str . length ( ) ) { int nextX = ( str . charAt ( i ) - 'A' ) / 5 ; int nextY = ( str . charAt ( i ) - 'B' + 1 ) % 5 ; while ( curX > nextX ) { System . out . println ( ""Move Up"" ) ; curX -- ; } while ( curY > nextY ) { System . out . println ( ""Move Left"" ) ; curY -- ; } while ( curX < nextX ) { System . out . println ( ""Move Down"" ) ; curX ++ ; } while ( curY < nextY ) { System . out . println ( ""Move Right"" ) ; curY ++ ; } System . out . println ( ""Press OK"" ) ; i ++ ; } }"
"static boolean isSubset ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 ; int j = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < m ; j ++ ) if ( arr2 [ i ] == arr1 [ j ] ) break ; if ( j == m ) return false ; } return true ; }"
"static int countNum ( int N , int arr [ ] ) { int sum = 0 , count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } for ( int i = 0 ; i < N ; i ++ ) { if ( ( sum - arr [ i ] ) % arr [ i ] == 0 ) { count ++ ; } } return count ; }"
"static String permutation ( int arr [ ] , int N ) { int [ ] hash = new int [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { hash [ arr [ i ] ] ++ ; } for ( int i = 1 ; i <= N ; i ++ ) { if ( hash [ i ] != 1 ) return ""No"" ; } return ""Yes"" ; }"
"static void printSubStr ( String str , int low , int high ) { System . out . println ( str . substring ( low , high + 1 ) ) ; }"
"static int cntPairs ( int a [ ] , int n ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) odd ++ ; else if ( ( a [ i ] / 2 ) % 2 == 1 ) even ++ ; } int ans = odd * even + ( odd * ( odd - 1 ) ) / 2 ; return ans ; }"
public static void findFibSubset ( Integer [ ] x ) { Integer max = Collections . max ( Arrays . asList ( x ) ) ; List < Integer > fib = new ArrayList < Integer > ( ) ; List < Integer > result = new ArrayList < Integer > ( ) ; Integer a = 0 ; Integer b = 1 ; while ( b < max ) { Integer c = a + b ; a = b ; b = c ; fib . add ( c ) ; } for ( Integer i = 0 ; i < x . length ; i ++ ) { if ( fib . contains ( x [ i ] ) ) { result . add ( x [ i ] ) ; } } System . out . println ( result ) ; }
"static void getElements ( int a , int arr [ ] , int n ) { int elements [ ] = new int [ n + 1 ] ; elements [ 0 ] = a ; for ( int i = 0 ; i < n ; i ++ ) { elements [ i + 1 ] = arr [ i ] ^ elements [ i ] ; } for ( int i = 0 ; i < n + 1 ; i ++ ) System . out . print ( elements [ i ] + "" "" ) ; }"
"static int answer_query ( int a [ ] , int n , int l , int r ) { int count = 0 ; for ( int i = l ; i < r ; i ++ ) if ( a [ i ] == a [ i + 1 ] ) count += 1 ; return count ; }"
"static int summingSeries ( long n ) { return ( int ) Math . pow ( n , 2 ) ; }"
"static void printLines ( int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { System . out . println ( k * ( 6 * i + 1 ) + "" "" + k * ( 6 * i + 2 ) + "" "" + k * ( 6 * i + 3 ) + "" "" + k * ( 6 * i + 5 ) ) ; } }"
"public static boolean is_possible ( String s ) { int l = s . length ( ) ; int one = 0 , zero = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s . charAt ( i ) == '0' ) zero ++ ; else one ++ ; } if ( l % 2 == 0 ) return ( one == zero ) ; else return ( Math . abs ( one - zero ) == 1 ) ; }"
"public static int eulerian ( int n , int m ) { int [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { if ( i > j ) { if ( j == 0 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ; } } } return dp [ n ] [ m ] ; }"
"static float trianglearea ( float l , float b ) { if ( l < 0 || b < 0 ) return - 1 ; float area = ( l * b ) / 2 ; return area ; }"
"static void printEqualModNumbers ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int d = arr [ n - 1 ] - arr [ 0 ] ; Vector < Integer > v = new Vector < > ( ) ; for ( int i = 1 ; i * i <= d ; i ++ ) { if ( d % i == 0 ) { v . add ( i ) ; if ( i != d / i ) v . add ( d / i ) ; } } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { int temp = arr [ 0 ] % v . get ( i ) ; int j ; for ( j = 1 ; j < n ; j ++ ) if ( arr [ j ] % v . get ( i ) != temp ) break ; if ( j == n ) System . out . print ( v . get ( i ) + "" "" ) ; } }"
"static int search ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) { return i ; } } return - 1 ; }"
static int highestPowerof2 ( int n ) { int res = 0 ; for ( int i = n ; i >= 1 ; i -- ) { if ( ( i & ( i - 1 ) ) == 0 ) { res = i ; break ; } } return res ; }
"static int ways ( String s , int n ) { int dp [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { String temp = """" ; for ( int j = i ; j < n ; j ++ ) { temp += s . charAt ( j ) ; String test = """" ; for ( int k = i - 1 ; k >= 0 ; k -- ) { test += s . charAt ( k ) ; if ( test . compareTo ( temp ) < 0 ) { dp [ i ] [ j ] += dp [ k ] [ i - 1 ] ; } } } } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += dp [ i ] [ n - 1 ] ; } return ans ; }"
static boolean isPowerOfTwo ( int x ) { return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; }
"static int largestGCDSubsequence ( int arr [ ] , int n ) { int ans = 0 ; int maxele = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; ; for ( int i = 2 ; i <= maxele ; ++ i ) { int count = 0 ; for ( int j = 0 ; j < n ; ++ j ) { if ( arr [ j ] % i == 0 ) ++ count ; } ans = Math . max ( ans , count ) ; } return ans ; }"
static int possibleways ( int n ) { if ( n % 2 == 1 ) return 0 ; else if ( n % 4 == 0 ) return n / 4 - 1 ; else return n / 4 ; }
"static double getValue ( double n ) { double result = ( Math . floor ( Math . log ( n + 1 ) / Math . log ( 2 ) ) ) ; return Math . pow ( 2 , result ) ; }"
"public static int Valid ( int a , int b , int c ) { if ( a + b + c == 180 && a != 0 && b != 0 && c != 0 ) return 1 ; else return 0 ; }"
"static boolean isValidSeq ( int [ ] a , int n ) { int nodes = n + 2 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] < 1 || a [ i ] > nodes ) return false ; } return true ; }"
"static void Loss ( int SP , int P ) { float loss = 0 ; loss = ( float ) ( 2 * P * P * SP ) / ( 100 * 100 - P * P ) ; System . out . println ( ""Loss = "" + loss ) ; }"
"static void printUnique ( int l , int r ) { for ( int i = l ; i <= r ; i ++ ) { int num = i ; boolean visited [ ] = new boolean [ 10 ] ; while ( num != 0 ) { if ( visited [ num % 10 ] ) break ; visited [ num % 10 ] = true ; num = num / 10 ; } if ( num == 0 ) System . out . print ( i + "" "" ) ; } }"
"static void updateArray ( int arr [ ] , int n ) { for ( int i = n - 1 ; i > 0 ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ 0 ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + "" "" ) ; }"
"static int findMinDifference ( int arr [ ] , int n ) { int min , secondMin , max , secondMax ; min = secondMax = ( arr [ 0 ] < arr [ 1 ] ) ? arr [ 0 ] : arr [ 1 ] ; max = secondMin = ( arr [ 0 ] < arr [ 1 ] ) ? arr [ 1 ] : arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { secondMax = max ; max = arr [ i ] ; } else if ( arr [ i ] > secondMax ) { secondMax = arr [ i ] ; } else if ( arr [ i ] < min ) { secondMin = min ; min = arr [ i ] ; } else if ( arr [ i ] < secondMin ) { secondMin = arr [ i ] ; } } int diff = Math . min ( max - secondMin , secondMax - min ) ; return diff ; }"
"static boolean EqualNumber ( int A , int B ) { if ( ( A ^ B ) != 0 ) return true ; else return false ; }"
"static long product ( int [ ] [ ] mat , int n ) { long d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { d1 += mat [ i ] [ i ] ; d2 += mat [ i ] [ n - i - 1 ] ; } return 1L * d1 * d2 ; }"
"static int min_sum ( int n , int k , int a [ ] ) { Arrays . sort ( a ) ; if ( a [ 0 ] < 0 ) return - 1 ; if ( k == 0 ) { if ( a [ 0 ] == a [ n - 1 ] ) return ( n * a [ 0 ] ) ; else return - 1 ; } else { int f = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int p = a [ i ] - a [ 0 ] ; if ( p % k == 0 ) continue ; else { f = 1 ; break ; } } if ( f > 0 ) return - 1 ; else { if ( k == 1 ) return n ; else return ( n * ( a [ 0 ] % k ) ) ; } } }"
"static int minOperations ( int n , String a , String b , String c ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { char x = a . charAt ( i ) ; char y = b . charAt ( i ) ; char z = c . charAt ( i ) ; if ( x == y && y == z ) ; else if ( x == y || y == z || x == z ) { ans ++ ; } else { ans += 2 ; } } return ans ; }"
"static void fibonacci ( double n ) { double fib ; for ( double i = 0 ; i < n ; i ++ ) { fib = ( Math . pow ( ( 1 + Math . sqrt ( 5 ) ) , i ) - Math . pow ( ( 1 - Math . sqrt ( 5 ) ) , i ) ) / ( Math . pow ( 2 , i ) * Math . sqrt ( 5 ) ) ; System . out . print ( ( int ) fib + "" "" ) ; } }"
"static boolean findTriplet ( int a1 [ ] , int a2 [ ] , int a3 [ ] , int n1 , int n2 , int n3 , int sum ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n1 ; i ++ ) { s . add ( a1 [ i ] ) ; } ArrayList < Integer > al = new ArrayList < > ( s ) ; for ( int i = 0 ; i < n2 ; i ++ ) { for ( int j = 0 ; j < n3 ; j ++ ) { if ( al . contains ( sum - a2 [ i ] - a3 [ j ] ) & al . indexOf ( sum - a2 [ i ] - a3 [ j ] ) != al . get ( al . size ( ) - 1 ) ) { return true ; } } } return false ; }"
"static int maxLen ( int arr [ ] ) { HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ; int sum = 0 ; int max_len = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] == 0 && max_len == 0 ) max_len = 1 ; if ( sum == 0 ) max_len = i + 1 ; Integer prev_i = hM . get ( sum ) ; if ( prev_i != null ) max_len = Math . max ( max_len , i - prev_i ) ; else hM . put ( sum , i ) ; } return max_len ; }"
"static void printRepeatingEven ( int arr [ ] , int n ) { long _xor = 0L ; long pos ; for ( int i = 0 ; i < n ; ++ i ) { pos = 1 << arr [ i ] ; _xor ^= pos ; } for ( int i = 0 ; i < n ; ++ i ) { pos = 1 << arr [ i ] ; if ( ! ( ( pos & _xor ) != 0 ) ) { System . out . print ( arr [ i ] + "" "" ) ; _xor ^= pos ; } } }"
"static int zigzag ( int n , int k ) { int dp [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= Math . min ( i , k ) ; j ++ ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] ; } return dp [ n ] [ k ] ; }"
"static int Resources ( int process , int need ) { int minResources = 0 ; minResources = process * ( need - 1 ) + 1 ; return minResources ; }"
"static int minimum_cost ( int a [ ] , int n ) { int mn = Integer . MAX_VALUE ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mn = Math . min ( a [ i ] , mn ) ; sum += a [ i ] ; } return mn * ( sum - mn ) ; }"
"static int maxLength ( int [ ] a , int n ) { int maximum = 1 ; int left [ ] = new int [ n ] ; int right [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { left [ i ] = 1 ; right [ i ] = 1 ; } for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( a [ i ] > a [ i + 1 ] ) { right [ i ] = right [ i + 1 ] + 1 ; } maximum = Math . max ( maximum , right [ i ] ) ; } for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] < a [ i - 1 ] ) { left [ i ] = left [ i - 1 ] + 1 ; } } if ( n > 2 ) { for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i - 1 ] > a [ i + 1 ] ) { maximum = Math . max ( maximum , left [ i - 1 ] + right [ i + 1 ] ) ; } } } return maximum ; }"
"public static boolean isPower ( int x , int y ) { if ( x == 1 ) return ( y == 1 ) ; int pow = 1 ; while ( pow < y ) pow = pow * x ; return ( pow == y ) ; }"
"public static int CntDivbyX ( int arr [ ] , int n , int x ) { int number = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { number = ( number * 2 + arr [ i ] ) % x ; if ( number == 0 ) count += 1 ; } return count ; }"
"static int pre_compute ( int a [ ] , int n , int index , int k ) { int dp [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > a [ 0 ] ) dp [ 0 ] [ i ] = a [ i ] + a [ 0 ] ; else dp [ 0 ] [ i ] = a [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] > a [ i ] && j > i ) { if ( dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } return dp [ index ] [ k ] ; }"
"static void leftRotate ( int arr [ ] , int n , int k ) { for ( int i = k ; i < k + n ; i ++ ) System . out . print ( arr [ i % n ] + "" "" ) ; }"
static int abFree ( char [ ] s ) { int b_count = 0 ; int res = 0 ; for ( int i = 0 ; i < s . length ; i ++ ) { if ( s [ s . length - i - 1 ] == 'a' ) { res = ( res + b_count ) ; b_count = ( b_count * 2 ) ; } else { b_count += 1 ; } } return res ; }
static int edgeCover ( int n ) { int result = 0 ; result = ( int ) Math . ceil ( ( double ) n / 2.0 ) ; return result ; }
"static int maxOnesIndex ( boolean arr [ ] , int n ) { int i = 0 ; int leftCnt = 0 ; int rightCnt = 0 ; int maxIndex = - 1 ; int lastInd = - 1 ; int maxCnt = 0 ; while ( i < n ) { if ( arr [ i ] ) { rightCnt ++ ; } else { if ( lastInd != - 1 ) { if ( rightCnt + leftCnt + 1 > maxCnt ) { maxCnt = leftCnt + rightCnt + 1 ; maxIndex = lastInd ; } } lastInd = i ; leftCnt = rightCnt ; rightCnt = 0 ; } i ++ ; } if ( lastInd != - 1 ) { if ( leftCnt + rightCnt + 1 > maxCnt ) { maxCnt = leftCnt + rightCnt + 1 ; maxIndex = lastInd ; } } return maxIndex ; }"
"static int countOddSquares ( int n , int m ) { return ( int ) Math . pow ( m , 0.5 ) - ( int ) Math . pow ( n - 1 , 0.5 ) ; }"
static long centered_heptagonal_num ( long n ) { return ( 7 * n * n - 7 * n + 2 ) / 2 ; }
"static void NFG ( int a [ ] , int n , int freq [ ] ) { Stack < Integer > s = new Stack < Integer > ( ) ; s . push ( 0 ) ; int res [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) res [ i ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( freq [ a [ s . peek ( ) ] ] > freq [ a [ i ] ] ) s . push ( i ) ; else { while ( freq [ a [ s . peek ( ) ] ] < freq [ a [ i ] ] && s . size ( ) > 0 ) { res [ s . peek ( ) ] = a [ i ] ; s . pop ( ) ; } s . push ( i ) ; } } while ( s . size ( ) > 0 ) { res [ s . peek ( ) ] = - 1 ; s . pop ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( res [ i ] + "" "" ) ; } }"
"static int summation ( int n ) { int sum ; sum = ( int ) ( Math . pow ( 10 , n + 1 ) - 10 - ( 9 * n ) ) / 81 ; return sum ; }"
"static void EvenOddLength ( int arr [ ] , int n ) { int even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { String x = Integer . toString ( arr [ i ] ) ; if ( x . length ( ) % 2 == 0 ) even ++ ; } System . out . println ( ""Number of even length elements = "" + even ) ; System . out . println ( ""Number of odd length elements = "" + ( n - even ) ) ; }"
static int getHermiteNumber ( int n ) { if ( n == 0 ) return 1 ; else if ( n == 1 ) return 1 ; else return - 2 * ( n - 1 ) * getHermiteNumber ( n - 2 ) ; }
"public static int findFrequency ( int arr [ ] , int n , int left , int right , int element ) { int count = 0 ; for ( int i = left - 1 ; i < right ; ++ i ) if ( arr [ i ] == element ) ++ count ; return count ; }"
"static int extraElement ( int A [ ] , int B [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans ^= A [ i ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) ans ^= B [ i ] ; return ans ; }"
"static int calculate ( String N ) { int len = N . length ( ) ; int l = ( len ) / 2 ; int count = 0 ; for ( int i = 1 ; i <= l ; i ++ ) { String s = N . substring ( 0 , i ) ; int l1 = s . length ( ) ; String t = N . substring ( i , l1 + i ) ; if ( s . charAt ( 0 ) == '0' || t . charAt ( 0 ) == '0' ) continue ; if ( s . compareTo ( t ) == 0 ) count ++ ; } return count ; }"
"static void AlternateRearrange ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; Vector v1 = new Vector ( ) ; Vector v2 = new Vector ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 0 ) v1 . add ( arr [ i ] ) ; else v2 . add ( arr [ i ] ) ; int index = 0 , i = 0 , j = 0 ; boolean flag = false ; if ( arr [ 0 ] % 2 == 0 ) flag = true ; while ( index < n ) { if ( flag == true ) { arr [ index ] = ( int ) v1 . get ( i ) ; i += 1 ; index += 1 ; flag = ! flag ; } else { arr [ index ] = ( int ) v2 . get ( j ) ; j += 1 ; index += 1 ; flag = ! flag ; } } for ( i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + "" "" ) ; }"
"public static void precisionCompute ( int x , int y , int n ) { if ( y == 0 ) { System . out . print ( ""Infinite"" ) ; return ; } if ( x == 0 ) { System . out . print ( ""0"" ) ; return ; } if ( n <= 0 ) { System . out . print ( x / y ) ; return ; } if ( ( ( x > 0 ) && ( y < 0 ) ) || ( ( x < 0 ) && ( y > 0 ) ) ) { System . out . print ( ""-"" ) ; x = x > 0 ? x : - x ; y = y > 0 ? y : - y ; } int d = x / y ; for ( int i = 0 ; i <= n ; i ++ ) { System . out . print ( d ) ; x = x - ( y * d ) ; if ( x == 0 ) break ; x = x * 10 ; d = x / y ; if ( i == 0 ) System . out . print ( ""."" ) ; } }"
"static int numberOfCuts ( int M , int N ) { int result = 0 ; result = ( M - 1 ) * ( N - 1 ) ; return result ; }"
"static void printSubsequences ( String s ) { char [ ] str = s . toCharArray ( ) ; int n = str . length ; int opsize = ( int ) ( Math . pow ( 2 , n - 1 ) ) ; for ( int counter = 0 ; counter < opsize ; counter ++ ) { for ( int j = 0 ; j < n ; j ++ ) { System . out . print ( str [ j ] ) ; if ( ( counter & ( 1 << j ) ) > 0 ) System . out . print ( "" "" ) ; } System . out . println ( ) ; } }"
"static int getMissingNo ( int a [ ] , int n ) { int x1 = a [ 0 ] ; int x2 = 1 ; for ( int i = 1 ; i < n ; i ++ ) x1 = x1 ^ a [ i ] ; for ( int i = 2 ; i <= n + 1 ; i ++ ) x2 = x2 ^ i ; return ( x1 ^ x2 ) ; }"
"static void printQueries ( int n , int a [ ] , int q , int qry [ ] ) { HashSet < Integer > occ = new HashSet < > ( ) ; int [ ] suffixCount = new int [ n + 1 ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { occ . add ( a [ i ] ) ; suffixCount [ i + 1 ] = occ . size ( ) ; } for ( int i = 0 ; i < q ; i ++ ) System . out . println ( suffixCount [ qry [ i ] ] ) ; }"
"static int superSeq ( String X , String Y , int m , int n ) { if ( m == 0 ) return n ; if ( n == 0 ) return m ; if ( X . charAt ( m - 1 ) == Y . charAt ( n - 1 ) ) return 1 + superSeq ( X , Y , m - 1 , n - 1 ) ; return 1 + Math . min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) ) ; }"
"static int search ( int arr [ ] , int n , int x , int k ) { int i = 0 ; while ( i < n ) { if ( arr [ i ] == x ) return i ; i = i + Math . max ( 1 , Math . abs ( arr [ i ] - x ) / k ) ; } System . out . println ( ""number is "" + ""not present!"" ) ; return - 1 ; }"
private static int solve ( char [ ] mood ) { int n = mood . length ; int score = 0 ; int code = 0 ; int jam = 0 ; Stack < Character > stk = new Stack < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( stk . size ( ) == 0 ) { stk . push ( mood [ i ] ) ; } else { if ( stk . peek ( ) == mood [ i ] ) { stk . pop ( ) ; score += 10 ; } else { int pool = stk . size ( ) ; int left = n - i ; if ( pool + 1 <= left - 1 ) { stk . push ( mood [ i ] ) ; } else { stk . pop ( ) ; score += 5 ; } } } } return score ; }
"static int squares ( int l , int b , int a ) { return ( int ) ( Math . ceil ( l / ( double ) a ) * Math . ceil ( b / ( double ) a ) ) ; }"
public static int nobleInteger ( int arr [ ] ) { int size = arr . length ; for ( int i = 0 ; i < size ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < size ; j ++ ) if ( arr [ i ] < arr [ j ] ) count ++ ; if ( count == arr [ i ] ) return arr [ i ] ; } return - 1 ; }
"static double average ( int arr [ ] , int n , int k ) { double total = 0 ; if ( 2 * k >= n ) return 0 ; Arrays . sort ( arr ) ; int start = k , end = n - k - 1 ; for ( int i = start ; i <= end ; i ++ ) total += arr [ i ] ; return ( total / ( n - 2 * k ) ) ; }"
"static int maxOnesIndex ( boolean arr [ ] , int n ) { int start = 0 ; int end = 0 ; int maxIndex = - 1 ; int lastInd = - 1 ; int maxCnt = 0 ; while ( end < n ) { while ( end < n && arr [ end ] ) { end ++ ; } if ( maxCnt < end - start && lastInd != - 1 ) { maxCnt = end - start ; maxIndex = lastInd ; } start = lastInd + 1 ; lastInd = end ; end ++ ; } if ( maxCnt < end - start && lastInd != - 1 ) { maxCnt = end - start ; maxIndex = lastInd ; } return maxIndex ; }"
"public static String check_last ( int arr [ ] , int n , int p ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + arr [ i ] ; if ( p == 1 ) { if ( sum % 2 == 0 ) return ""ODD"" ; else return ""EVEN"" ; } return ""EVEN"" ; }"
"static long yMod ( long y , long x ) { if ( ( Math . log ( y ) / Math . log ( 2 ) ) < x ) return y ; if ( x > 63 ) return y ; return ( y % ( 1 << ( int ) x ) ) ; }"
"static int find_n ( int [ ] a ) { int j = 0 , k = 0 , s = 0 ; int x = Arrays . stream ( a ) . max ( ) . getAsInt ( ) ; int y = Arrays . stream ( a ) . min ( ) . getAsInt ( ) ; for ( int i : a ) { if ( a [ i ] == x ) { s = i ; break ; } } for ( int i : a ) { if ( i != x && i <= y && i != 0 ) { a [ j ] += 1 ; a [ s ] -= 1 ; x -= 1 ; k += 1 ; j += 1 ; } else if ( i != 0 ) { j += 1 ; } } for ( int i : a ) { if ( a [ i ] != x ) { k = - 1 ; break ; } } return k ; }"
"static int Squares ( int n , int m , int a ) { return ( ( m + a - 1 ) / a ) * ( ( n + a - 1 ) / a ) ; }"
static int check ( int n ) { int sum = 0 ; while ( n != 0 ) { sum += n % 10 ; n = n / 10 ; } if ( sum % 7 == 0 ) return 1 ; else return 0 ; }
"static float squarearea ( float r ) { if ( r < 0 ) return - 1 ; float a = 4 * ( float ) ( Math . pow ( r , 2 ) / 5 ) ; return a ; }"
"static int nthTerm ( int n ) { return 5 * ( int ) Math . pow ( n , 2 ) - 5 * n ; }"
static char getChar ( String str ) { int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { sum += ( str . charAt ( i ) - 'a' + 1 ) ; } if ( sum % 26 == 0 ) return 'z' ; else { sum = sum % 26 ; return ( char ) ( 'a' + sum - 1 ) ; } }
"public static int count ( String s , char c ) { int res = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == c ) res ++ ; } return res ; }"
"static int lis ( int [ ] arr , int n ) { int [ ] mpis = new int [ n ] ; int max = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) mpis [ i ] = arr [ i ] ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && mpis [ i ] < ( mpis [ j ] * arr [ i ] ) ) mpis [ i ] = mpis [ j ] * arr [ i ] ; for ( int k = 0 ; k < mpis . length ; k ++ ) { if ( mpis [ k ] > max ) { max = mpis [ k ] ; } } return max ; }"
"static boolean isPossible ( int n , int k , int arr [ ] ) { int sum = arr [ 0 ] ; int maxVal = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { sum += arr [ i ] ; maxVal = Math . max ( maxVal , arr [ i ] ) ; } if ( ( float ) maxVal > ( float ) ( sum + k ) / n ) return false ; return true ; }"
public static int oddSum ( int n ) { return ( n * n ) ; }
"static String isDivisible ( int n ) { int temp = n ; while ( n > 0 ) { int k = n % 10 ; if ( temp % k == 0 ) { return ""YES"" ; } n /= 10 ; } return ""NO"" ; }"
"static boolean isConvertible ( String str1 , String str2 , int k ) { if ( ( str1 . length ( ) + str2 . length ( ) ) < k ) return true ; int commonLength = 0 ; for ( int i = 0 ; i < Math . min ( str1 . length ( ) , str2 . length ( ) ) ; i ++ ) { if ( str1 == str2 ) commonLength ++ ; else break ; } if ( ( k - str1 . length ( ) - str2 . length ( ) + 2 * commonLength ) % 2 == 0 ) return true ; return false ; }"
static int power ( int n ) { if ( n == 1 ) return 2 ; return 2 * power ( n - 1 ) ; }
"int countSubStr ( char str [ ] , int n ) { int m = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) m ++ ; } return m * ( m - 1 ) / 2 ; }"
"static int countEvenOdd ( int n ) { int even_count = 0 ; int odd_count = 0 ; while ( n > 0 ) { int rem = n % 10 ; if ( rem % 2 == 0 ) even_count ++ ; else odd_count ++ ; n = n / 10 ; } System . out . println ( ""Even count : "" + even_count ) ; System . out . println ( ""Odd count : "" + odd_count ) ; if ( even_count % 2 == 0 && odd_count % 2 != 0 ) return 1 ; else return 0 ; }"
"static int maxSumPairWithDifferenceLessThanK ( int arr [ ] , int N , int k ) { int maxSum = 0 ; Arrays . sort ( arr ) ; for ( int i = N - 1 ; i > 0 ; -- i ) { if ( arr [ i ] - arr [ i - 1 ] < k ) { maxSum += arr [ i ] ; maxSum += arr [ i - 1 ] ; -- i ; } } return maxSum ; }"
public static int repUnitValue ( int n ) { if ( n % 2 == 0 || n % 5 == 0 ) return 0 ; int rem = 1 ; int power = 1 ; int k = 1 ; while ( rem % n != 0 ) { k ++ ; power = power * 10 % n ; rem = ( rem + power ) % n ; } return k ; }
"static int binarySearch ( int arr [ ] , int low , int high , int key ) { if ( high < low ) return - 1 ; int mid = ( low + high ) / 2 ; if ( key == arr [ mid ] ) return mid ; if ( key > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high , key ) ; return binarySearch ( arr , low , ( mid - 1 ) , key ) ; }"
"static String isDivisible ( long n ) { long temp = n ; int sum = 0 ; while ( n != 0 ) { int k = ( int ) n % 10 ; sum += k ; n /= 10 ; } if ( temp % sum == 0 ) return ""YES"" ; return ""NO"" ; }"
"static boolean check ( int n , int k , int [ ] a , int [ ] b ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; boolean fl = false ; int ind = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] != b [ i ] ) { if ( fl == true ) { return false ; } fl = true ; ind = i ; } } if ( ind == - 1 | Math . abs ( a [ ind ] - b [ ind ] ) <= k ) { return true ; } return false ; }"
"static void maxSum ( int [ ] a , int n ) { int maxAnd = Arrays . stream ( a ) . max ( ) . getAsInt ( ) ; int maxOR = 0 ; for ( int i = 0 ; i < n ; i ++ ) { maxOR |= a [ i ] ; } System . out . println ( ( maxAnd + maxOR ) ) ; }"
static int sumofseries ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) / 4 ) ; }
"static void printPattern ( int n , int m , boolean flag ) { System . out . print ( m + "" "" ) ; if ( flag == false && n == m ) return ; if ( flag ) { if ( m - 5 > 0 ) printPattern ( n , m - 5 , true ) ; else printPattern ( n , m - 5 , false ) ; } else printPattern ( n , m + 5 , false ) ; }"
"static int zzis ( int arr [ ] , int n ) { int Z [ ] [ ] = new int [ n ] [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) Z [ i ] [ 0 ] = Z [ i ] [ 1 ] = 1 ; int res = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] < arr [ i ] && Z [ i ] [ 0 ] < Z [ j ] [ 1 ] + 1 ) Z [ i ] [ 0 ] = Z [ j ] [ 1 ] + 1 ; if ( arr [ j ] > arr [ i ] && Z [ i ] [ 1 ] < Z [ j ] [ 0 ] + 1 ) Z [ i ] [ 1 ] = Z [ j ] [ 0 ] + 1 ; } if ( res < Math . max ( Z [ i ] [ 0 ] , Z [ i ] [ 1 ] ) ) res = Math . max ( Z [ i ] [ 0 ] , Z [ i ] [ 1 ] ) ; } return res ; }"
"static int countSubarrWithEqualZeroAndOne ( int [ ] arr , int n ) { Map < Integer , Integer > myMap = new HashMap < > ( ) ; int sum = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) arr [ i ] = - 1 ; sum += arr [ i ] ; if ( sum == 0 ) count ++ ; if ( myMap . containsKey ( sum ) ) count += myMap . get ( sum ) ; if ( ! myMap . containsKey ( sum ) ) myMap . put ( sum , 1 ) ; else myMap . put ( sum , myMap . get ( sum ) + 1 ) ; } return count ; }"
"static void findPair ( int arr [ ] , int n ) { if ( n < 2 ) { System . out . print ( ""-1"" ) ; return ; } int i , first , second ; first = second = - 1 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) { second = arr [ i ] ; } } System . out . println ( ""n = "" + first + "" and r = "" + second ) ; }"
static int binomialCoeffSum ( int n ) { return ( 1 << n ) ; }
"static int sizeSubSet ( int a [ ] , int k , int n ) { Arrays . sort ( a ) ; HashMap < Integer , Integer > s = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % k != 0 || s . get ( a [ i ] / k ) == null ) s . put ( a [ i ] , s . get ( a [ i ] ) == null ? 1 : s . get ( a [ i ] ) + 1 ) ; } return s . size ( ) ; }"
"static int cost ( int [ ] a , int n ) { int min = a [ 0 ] ; for ( int i = 1 ; i < a . length ; i ++ ) { if ( a [ i ] < min ) min = a [ i ] ; } return ( n - 1 ) * min ; }"
"static int numofsubset ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int count = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ; } return count ; }"
"static int getNumber ( int n , int k ) { int [ ] arr = new int [ n ] ; int i = 0 ; int odd = 1 ; while ( odd <= n ) { arr [ i ++ ] = odd ; odd += 2 ; } int even = 2 ; while ( even <= n ) { arr [ i ++ ] = even ; even += 2 ; } return arr [ k - 1 ] ; }"
"static int maxPrimefactorNum ( int N ) { if ( N < 2 ) return 0 ; boolean [ ] arr = new boolean [ N + 1 ] ; int prod = 1 , res = 0 ; for ( int p = 2 ; p * p <= N ; p ++ ) { if ( arr [ p ] == false ) { for ( int i = p * 2 ; i <= N ; i += p ) arr [ i ] = true ; prod *= p ; if ( prod > N ) return res ; res ++ ; } } return res ; }"
"static int findOptimalSolution ( int [ ] a , int N ) { Arrays . sort ( a ) ; int points = 0 ; for ( int i = 0 ; i < N ; i ++ ) { points += a [ i ] * i ; } return points ; }"
"static int nth_term ( int a , int b , int n ) { int z = 0 ; if ( n % 6 == 1 ) z = a ; else if ( n % 6 == 2 ) z = b ; else if ( n % 6 == 3 ) z = b - a ; else if ( n % 6 == 4 ) z = - a ; else if ( n % 6 == 5 ) z = - b ; if ( n % 6 == 0 ) z = - ( b - a ) ; return z ; }"
"static int MaxNumbers ( int a [ ] , int n ) { int [ ] fre = { 0 , 0 , 0 }; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] %= 3 ; fre [ a [ i ] ] ++ ; } int ans = fre [ 0 ] ; int k = Math . min ( fre [ 1 ] , fre [ 2 ] ) ; ans += k ; fre [ 1 ] -= k ; fre [ 2 ] -= k ; ans += fre [ 1 ] / 3 + fre [ 2 ] / 3 ; return ans ; }"
"public static void PrintNumber ( int N , int Original , int K , boolean flag ) { System . out . print ( N + "" "" ) ; if ( N <= 0 ) flag = ! flag ; if ( N == Original && ! flag ) return ; if ( flag == true ) { PrintNumber ( N - K , Original , K , flag ) ; return ; } if ( ! flag ) { PrintNumber ( N + K , Original , K , flag ) ; return ; } }"
"static void findSubSeq ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int count [ ] = new int [ n ] ; int prev [ ] = new int [ n ] ; int i , j ; for ( i = 0 ; i < n ; i ++ ) count [ i ] = 1 ; for ( j = 0 ; j < n ; j ++ ) prev [ j ] = - 1 ; int max = 0 ; int maxprev = - 1 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] % arr [ j ] == 0 && count [ j ] + 1 > count [ i ] ) { count [ i ] = count [ j ] + 1 ; prev [ i ] = j ; } } if ( max < count [ i ] ) { max = count [ i ] ; maxprev = i ; } } i = maxprev ; while ( i >= 0 ) { if ( arr [ i ] != - 1 ) System . out . print ( arr [ i ] + "" "" ) ; i = prev [ i ] ; } }"
"static boolean check ( int s ) { int [ ] freq = new int [ 10 ] ; int r , i ; for ( i = 0 ; i < 10 ; i ++ ) { freq [ i ] = 0 ; } while ( s != 0 ) { r = s % 10 ; s = ( int ) ( s / 10 ) ; freq [ r ] += 1 ; } int xor__ = 0 ; for ( i = 0 ; i < 10 ; i ++ ) { xor__ = xor__ ^ freq [ i ] ; if ( xor__ == 0 ) return true ; else return false ; } return true ; }"
"static int seriesSum ( int calculated , int current , int N ) { int i , cur = 1 ; if ( current == N + 1 ) return 0 ; for ( i = calculated ; i < calculated + current ; i ++ ) cur *= i ; return cur + seriesSum ( i , current + 1 , N ) ; }"
"static int solve ( int ang , int n ) { if ( ( ang * n ) > ( 180 * ( n - 2 ) ) ) { return 0 ; } else if ( ( ang * n ) % 180 != 0 ) { return 0 ; } int ans = 1 ; int freq = ( ang * n ) / 180 ; ans = ans * ( n - 1 - freq ) ; ans = ans * n ; return ans ; }"
"public void decToBinary ( int n ) { for ( int i = 31 ; i >= 0 ; i -- ) { int k = n >> i ; if ( ( k & 1 ) > 0 ) System . out . print ( ""1"" ) ; else System . out . print ( ""0"" ) ; } }"
static int maxvolume ( int s ) { int length = s / 3 ; s -= length ; int breadth = s / 2 ; int height = s - breadth ; return length * breadth * height ; }
"static int countSubstrs ( String s1 , String s2 ) { int ans = 0 ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { String s3 = """" ; char [ ] s4 = s1 . toCharArray ( ) ; for ( int j = i ; j < s1 . length ( ) ; j ++ ) { s3 += s4 [ j ] ; if ( s2 . indexOf ( s3 ) != - 1 ) ans ++ ; } } return ans ; }"
"static int returnWinner ( String s , int l ) { int freq [ ] = new int [ 26 ] ; for ( int i = 0 ; i < l ; i ++ ) { freq [ s . charAt ( i ) - 'a' ] ++ ; } int cnt = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] % 2 != 0 ) cnt ++ ; } if ( ( cnt == 0 ) || ( cnt & 1 ) == 1 ) return 1 ; else return 2 ; }"
"static int winner ( int a [ ] , int n , int k ) { if ( k >= n - 1 ) return n ; int best = 0 , times = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > best ) { best = a [ i ] ; if ( i == 1 ) times = 1 ; } else times += 1 ; if ( times >= k ) return best ; } return best ; }"
"public static long solve ( int [ ] arr ) { int n = arr . length ; long sum = 0 ; int max = Integer . MIN_VALUE ; for ( int a : arr ) { if ( a > max ) max = a ; sum += a ; } long elem = Long . max ( ( sum + n - 2 ) / ( n - 1 ) , max ) ; return elem * ( n - 1 ) - sum ; }"
"static int search ( int arr [ ] , int n , int x ) { int i = 0 ; while ( i <= n - 1 ) { if ( arr [ i ] == x ) return i ; i += Math . abs ( arr [ i ] - x ) ; } return - 1 ; }"
"static int minXOR ( int arr [ ] , int n ) { Arrays . parallelSort ( arr ) ; int minXor = Integer . MAX_VALUE ; int val = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { val = arr [ i ] ^ arr [ i + 1 ] ; minXor = Math . min ( minXor , val ) ; } return minXor ; }"
"static int evenDecimalValue ( String str , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int decimalValue = 0 ; int powerOf2 = 1 ; for ( int k = i ; k <= j ; k ++ ) { decimalValue += ( ( str . charAt ( k ) - '0' ) * powerOf2 ) ; powerOf2 *= 2 ; } if ( decimalValue % 2 == 0 ) result ++ ; } } return result ; }"
"static int CountWays ( int n , boolean flag ) { if ( n == 0 ) return 1 ; int sum = 0 ; if ( flag == false && n > 1 ) sum = sum + CountWays ( n - 1 , false ) + CountWays ( n - 2 , true ) ; else sum = sum + CountWays ( n - 1 , false ) ; return sum ; }"
"static int sumPairs ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( arr [ i ] * ( 2 * n ) ) ; } return sum ; }"
static int countStaircases ( int N ) { int [ ] [ ] memo = new int [ N + 5 ] [ N + 5 ] ; for ( int i = 0 ; i <= N ; i ++ ) { for ( int j = 0 ; j <= N ; j ++ ) { memo [ i ] [ j ] = 0 ; } } memo [ 3 ] [ 2 ] = memo [ 4 ] [ 2 ] = 1 ; for ( int i = 5 ; i <= N ; i ++ ) { for ( int j = 2 ; j <= i ; j ++ ) { if ( j == 2 ) { memo [ i ] [ j ] = memo [ i - j ] [ j ] + 1 ; } else { memo [ i ] [ j ] = memo [ i - j ] [ j ] + memo [ i - j ] [ j - 1 ] ; } } } int answer = 0 ; for ( int i = 1 ; i <= N ; i ++ ) answer = answer + memo [ N ] [ i ] ; return answer ; }
"static String find_number ( int N , int K ) { String r ; if ( N % 100 == 0 ) { N += 1 ; r = String . valueOf ( N ) ; } else { r = String . valueOf ( N ) ; } for ( int i = 1 ; i <= K ; i ++ ) r += ""00"" ; return r ; }"
static long calculateSum ( int n ) { long sum = 0 ; sum = 1 << n ; return ( sum - 1 ) ; }
"public static int search ( int arr [ ] , int x ) { int n = arr . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) return i ; } return - 1 ; }"
"static void converthenumber ( int n ) { String s = Integer . toString ( n ) ; String res = """" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '1' || s . charAt ( i ) == '3' || s . charAt ( i ) == '5' || s . charAt ( i ) == '7' || s . charAt ( i ) == '9' ) res += s . charAt ( i ) ; if ( res . length ( ) == 2 ) break ; } if ( res . length ( ) == 2 ) System . out . println ( res ) ; else System . out . println ( - 1 ) ; }"
"static long moduloMultiplication ( long a , long b , long mod ) { long res = 0 ; a %= mod ; while ( b > 0 ) { if ( ( b & 1 ) > 0 ) { res = ( res + a ) % mod ; } a = ( 2 * a ) % mod ; b >>= 1 ; } return res ; }"
"static boolean match ( String first , String second ) { if ( first . length ( ) == 0 && second . length ( ) == 0 ) return true ; if ( first . length ( ) > 1 && first . charAt ( 0 ) == '*' && second . length ( ) == 0 ) return false ; if ( ( first . length ( ) > 1 && first . charAt ( 0 ) == '?' ) || ( first . length ( ) != 0 && second . length ( ) != 0 && first . charAt ( 0 ) == second . charAt ( 0 ) ) ) return match ( first . substring ( 1 ) , second . substring ( 1 ) ) ; if ( first . length ( ) > 0 && first . charAt ( 0 ) == '*' ) return match ( first . substring ( 1 ) , second ) || match ( first , second . substring ( 1 ) ) ; return false ; }"
"static int surfaceArea ( int b , int s ) { return 2 * b * s + ( int ) Math . pow ( b , 2 ) ; }"
"public static int [ ] countSum ( int arr [ ] , int n ) { int result = 0 ; int [ ] countODD = new int [ n + 1 ] ; int [ ] countEVEN = new int [ n + 1 ] ; countODD [ 0 ] = 0 ; countEVEN [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] % 2 == 0 ) { countEVEN [ i ] = countEVEN [ i - 1 ] + countEVEN [ i - 1 ] + 1 ; countODD [ i ] = countODD [ i - 1 ] + countODD [ i - 1 ] ; } else { countEVEN [ i ] = countEVEN [ i - 1 ] + countODD [ i - 1 ] ; countODD [ i ] = countODD [ i - 1 ] + countEVEN [ i - 1 ] + 1 ; } } int [ ] ans = new int [ 2 ] ; ans [ 0 ] = countEVEN [ n ] ; ans [ 1 ] = countODD [ n ] ; return ans ; }"
"static int findCost ( String str , int arr [ ] , int n ) { long costofC = 0 , costofO = 0 , costofD = 0 , costofE = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == 'c' ) costofC += arr [ i ] ; else if ( str . charAt ( i ) == 'o' ) costofO = Math . min ( costofC , costofO + arr [ i ] ) ; else if ( str . charAt ( i ) == 'd' ) costofD = Math . min ( costofO , costofD + arr [ i ] ) ; else if ( str . charAt ( i ) == 'e' ) costofE = Math . min ( costofD , costofE + arr [ i ] ) ; } return ( int ) costofE ; }"
"static void printPowerSet ( char [ ] set , int set_size ) { long pow_set_size = ( long ) Math . pow ( 2 , set_size ) ; int counter , j ; for ( counter = 0 ; counter < pow_set_size ; counter ++ ) { for ( j = 0 ; j < set_size ; j ++ ) { if ( ( counter & ( 1 << j ) ) > 0 ) System . out . print ( set [ j ] ) ; } System . out . println ( ) ; } }"
static int series ( int n ) { return ( 8 * n * n ) + 1 ; }
"static int Rank ( int Edges , int Vertices ) { int result = 0 ; result = Edges - Vertices + 1 ; return result ; }"
static int count ( int n ) { if ( n < 3 ) return n ; if ( n >= 3 && n < 10 ) return n - 1 ; int po = 1 ; while ( n / po > 9 ) po = po * 10 ; int msd = n / po ; if ( msd != 3 ) return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) ; else return count ( msd * po - 1 ) ; }
"static int lagDuration ( int h1 , int m1 , int h2 , int m2 , int k ) { int lag , t1 , t2 ; t1 = ( h1 + k ) * 60 + m1 ; t2 = h2 * 60 + m2 ; lag = t1 - t2 ; return lag ; }"
static int countToMake0lternate ( String s ) { int result = 0 ; for ( int i = 0 ; i < ( s . length ( ) - 1 ) ; i ++ ) if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) result ++ ; return result ; }
static long ispowerof2 ( long num ) { if ( ( num & ( num - 1 ) ) == 0 ) return 1 ; return 0 ; }
"static int pairORSum ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] | arr [ j ] ; return ans ; }"
static boolean isPalindrome ( int n ) { int divisor = 1 ; while ( n / divisor >= 10 ) divisor *= 10 ; while ( n != 0 ) { int leading = n / divisor ; int trailing = n % 10 ; if ( leading != trailing ) return false ; n = ( n % divisor ) / 10 ; divisor = divisor / 100 ; } return true ; }
public static int getFirstSetBitPos ( int n ) { return ( int ) ( ( Math . log10 ( n & - n ) ) / Math . log10 ( 2 ) ) + 1 ; }
"static int returnMaxSum ( int A [ ] , int B [ ] , int n ) { Set < Integer > mp = new HashSet < Integer > ( ) ; int result = 0 ; int curr_sum = 0 , curr_begin = 0 ; for ( int i = 0 ; i < n ; ++ i ) { while ( mp . contains ( A [ i ] ) ) { mp . remove ( A [ curr_begin ] ) ; curr_sum -= B [ curr_begin ] ; curr_begin ++ ; } mp . add ( A [ i ] ) ; curr_sum += B [ i ] ; result = Integer . max ( result , curr_sum ) ; } return result ; }"
"static int getMinimumSum ( int arr [ ] , int n ) { int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { ans = Math . min ( ans , arr [ i ] + arr [ j ] + arr [ k ] ) ; } } } return ans ; }"
"static int maxSubarrayLength ( int [ ] A , int N ) { int maxLen = 0 ; int curr_sum = 0 ; HashMap < Integer , Integer > hash = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) curr_sum -= 1 ; else curr_sum += 1 ; if ( curr_sum == 0 ) maxLen = Math . max ( maxLen , i + 1 ) ; if ( hash . containsKey ( curr_sum ) ) maxLen = Math . max ( maxLen , i - hash . get ( curr_sum ) ) ; else { hash . put ( curr_sum , i ) ; } } return maxLen ; }"
"static long countPairs ( int [ ] arr , int n ) { int count_2 = 0 , count_others = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 2 ) { count_2 ++ ; } else if ( arr [ i ] > 2 ) { count_others ++ ; } } long ans = 1L * count_2 * count_others + ( 1L * count_others * ( count_others - 1 ) ) / 2 ; return ans ; }"
"static int Minimum_Operations ( int [ ] a , int n ) { int [ ] np = new int [ n + 1 ] ; np [ n ] = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { np [ i ] = np [ i + 1 ] ; if ( a [ i ] <= 0 ) np [ i ] ++ ; } int pos = 0 ; int ans = n ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] >= 0 ) pos ++ ; ans = Math . min ( ans , pos + np [ i + 1 ] ) ; } return ans ; }"
"static int solve ( char X [ ] , char Y [ ] , int l , int r , int k , int dp [ ] [ ] [ ] ) { if ( k == 0 ) { return 0 ; } if ( l < 0 | r < 0 ) { return ( int ) 1e9 ; } if ( dp [ l ] [ r ] [ k ] != - 1 ) { return dp [ l ] [ r ] [ k ] ; } int cost = ( X [ l ] - 'a' ) ^ ( Y [ r ] - 'a' ) ; return dp [ l ] [ r ] [ k ] = Math . min ( Math . min ( cost + solve ( X , Y , l - 1 , r - 1 , k - 1 , dp ) , solve ( X , Y , l - 1 , r , k , dp ) ) , solve ( X , Y , l , r - 1 , k , dp ) ) ; }"
"static boolean asPowerSum ( int w , int m ) { while ( m > 0 ) { if ( ( m - 1 ) % w == 0 ) m = ( m - 1 ) / w ; else if ( ( m + 1 ) % w == 0 ) m = ( m + 1 ) / w ; else if ( m % w == 0 ) m = m / w ; else break ; } return ( m == 0 ) ; }"
"static int countNumber ( int N , int S ) { int countElements = 0 ; int currSum = 0 ; while ( currSum <= S ) { currSum += N ; N -- ; countElements ++ ; } return countElements ; }"
"static void mergeTwoHalf ( int [ ] A , int n ) { Arrays . sort ( A ) ; }"
static double vol_of_octahedron ( double side ) { return ( ( side * side * side ) * ( Math . sqrt ( 2 ) / 3 ) ) ; }
"static void findNumbers ( int n ) { String ans = """" ; for ( int i = 0 ; i < n - 1 ; i ++ ) ans += '7' ; String even = ans + '6' ; String odd = ans + '7' ; System . out . println ( ""Even : "" + even ) ; System . out . println ( ""Odd : "" + odd ) ; }"
public static boolean isAnBn ( String s ) { int l = s . length ( ) ; if ( l % 2 == 1 ) { return false ; } int i = 0 ; int j = l - 1 ; while ( i < j ) { if ( s . charAt ( i ) != 'a' || s . charAt ( j ) != 'b' ) { return false ; } i ++ ; j -- ; } return true ; }
"static void triangular_series ( int n ) { int i , j = 1 , k = 1 ; for ( i = 1 ; i <= n ; i ++ ) { System . out . printf ( ""%d "" , k ) ; j = j + 1 ; k = k + j ; } }"
"static int sumOfSeries ( int n ) { return ( int ) ( 0.6172 * ( Math . pow ( 10 , n ) - 1 ) - 0.55 * n ) ; }"
"static int numOfIncSubseqOfSizeK ( int arr [ ] , int n , int k ) { int dp [ ] [ ] = new int [ k ] [ n ] , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { dp [ 0 ] [ i ] = 1 ; } for ( int l = 1 ; l < k ; l ++ ) { for ( int i = l ; i < n ; i ++ ) { dp [ l ] [ i ] = 0 ; for ( int j = l - 1 ; j < i ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { dp [ l ] [ i ] += dp [ l - 1 ] [ j ] ; } } } } for ( int i = k - 1 ; i < n ; i ++ ) { sum += dp [ k - 1 ] [ i ] ; } return sum ; }"
"static int findMaxAverage ( int [ ] arr , int n , int k ) { if ( k > n ) return - 1 ; int [ ] csum = new int [ n ] ; csum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ; int max_sum = csum [ k - 1 ] , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { int curr_sum = csum [ i ] - csum [ i - k ] ; if ( curr_sum > max_sum ) { max_sum = curr_sum ; max_end = i ; } } return max_end - k + 1 ; }"
static void findNthTerm ( int n ) { if ( n % 2 == 0 ) { n = n / 2 ; n = 2 * ( n - 1 ) ; System . out . println ( n / 2 ) ; } else { n = ( n / 2 ) + 1 ; n = 2 * ( n - 1 ) ; System . out . println ( n ) ; } }
"static int maximumPoints ( int arr [ ] , int n , int k , int i ) { int start ; if ( k > i ) start = 0 ; else start = i - k ; int res = 0 ; for ( int j = start ; j <= start + k && j < n ; j ++ ) res += arr [ j ] ; int curr_sum = res ; for ( int j = start + k + 1 ; j < n && j <= i + k ; j ++ ) { curr_sum += arr [ j ] - arr [ j - k - 1 ] ; res = Math . max ( res , curr_sum ) ; } return res ; }"
"static void checksum ( int n ) { if ( n % 3 == 0 ) System . out . println ( n / 3 - 1 + "" "" + n / 3 + "" "" + ( n / 3 + 1 ) ) ; else System . out . println ( ""-1"" ) ; }"
"static void normalSieve ( int n ) { boolean prime [ ] = new boolean [ n / 2 ] ; Arrays . fill ( prime , false ) ; for ( int i = 3 ; i * i < n ; i += 2 ) { if ( prime [ i / 2 ] == false ) for ( int j = i * i ; j < n ; j += i * 2 ) prime [ j / 2 ] = true ; } System . out . print ( ""2 "" ) ; for ( int i = 3 ; i < n ; i += 2 ) if ( prime [ i / 2 ] == false ) System . out . print ( i + "" "" ) ; }"
static boolean isDivisible ( int n ) { int d ; while ( ( n / 100 ) > 0 ) { d = n % 10 ; n /= 10 ; n = Math . abs ( n - ( d * 14 ) ) ; } return ( n % 47 == 0 ) ; }
static String maxInt ( char str [ ] ) { for ( int i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] < '5' ) { str [ i ] = ( char ) ( ( '9' - str [ i ] ) + '0' ) ; } } if ( str [ 0 ] == '0' ) str [ 0 ] = '9' ; String str2 = new String ( str ) ; return str2 ; }
"static void half ( int arr [ ] , int n ) { int i ; int flag = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) System . out . print ( arr [ i ] / 2 + "" "" ) ; else { if ( flag == 0 ) { System . out . print ( arr [ i ] / 2 - 1 + "" "" ) ; flag = 1 ; } else { int q = arr [ i ] / 2 ; System . out . print ( q + "" "" ) ; flag = 0 ; } } } }"
static int countSetBits ( int n ) { n ++ ; int powerOf2 = 2 ; int cnt = n / 2 ; while ( powerOf2 <= n ) { int totalPairs = n / powerOf2 ; cnt += ( totalPairs / 2 ) * powerOf2 ; cnt += ( totalPairs % 2 == 1 ) ? ( n % powerOf2 ) : 0 ; powerOf2 <<= 1 ; } return cnt ; }
"static void findEncryptedArray ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( sum - arr [ i ] + "" "" ) ; }"
"static int countSolutions ( int a ) { int count = Integer . bitCount ( a ) ; count = ( int ) Math . pow ( 2 , count ) ; return count ; }"
"static int getMinimumSum ( int arr [ ] , int n ) { int fMin = Integer . MAX_VALUE , sMin = Integer . MAX_VALUE , tMin = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < fMin ) { tMin = sMin ; sMin = fMin ; fMin = arr [ i ] ; } else if ( arr [ i ] < sMin ) { tMin = sMin ; sMin = arr [ i ] ; } else if ( arr [ i ] < tMin ) { tMin = arr [ i ] ; } } return ( fMin + sMin + tMin ) ; }"
"static void timeToMeet ( double s , double v ) { double V = 3 * v / 2 ; double time = s / V ; System . out . println ( ( float ) time ) ; }"
"static void findFactors ( int a , int b ) { int c ; c = a + b - 1 ; System . out . print ( c ) ; }"
static int countWays ( int n ) { int DP [ ] = new int [ n + 1 ] ; DP [ 0 ] = DP [ 1 ] = DP [ 2 ] = 1 ; DP [ 3 ] = 2 ; for ( int i = 4 ; i <= n ; i ++ ) DP [ i ] = DP [ i - 1 ] + DP [ i - 3 ] + DP [ i - 4 ] ; return DP [ n ] ; }
"static int maxDistance ( int [ ] arr , int n ) { HashMap < Integer , Integer > map = new HashMap < > ( ) ; int max_dist = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! map . containsKey ( arr [ i ] ) ) map . put ( arr [ i ] , i ) ; else max_dist = Math . max ( max_dist , i - map . get ( arr [ i ] ) ) ; } return max_dist ; }"
"static int findNumber ( int n , int m ) { int num = ( m - 1 ) * 9 + n ; return num ; }"
"static int findX ( int A , int B ) { int j = 0 , x = 0 ; while ( A != 0 || B != 0 ) { if ( ( A % 2 == 1 ) && ( B % 2 == 1 ) ) { x += ( 1 << j ) ; } A >>= 1 ; B >>= 1 ; j += 1 ; } return x ; }"
"static void noOfMoves ( int arr [ ] , int n ) { int cnt = 0 ; int maxCnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) { cnt ++ ; } else { if ( cnt != 0 ) { maxCnt = Math . max ( maxCnt , cnt ) ; cnt = 0 ; } } } System . out . print ( maxCnt + ""\n"" ) ; }"
"static int count ( int n ) { return ( int ) ( 15 * Math . pow ( 16 , n - 1 ) ) ; }"
"static int closestNumber ( int n , int m ) { int q = n / m ; int n1 = m * q ; int n2 = ( n * m ) > 0 ? ( m * ( q + 1 ) ) : ( m * ( q - 1 ) ) ; if ( Math . abs ( n - n1 ) < Math . abs ( n - n2 ) ) return n1 ; return n2 ; }"
static int sequence ( int n ) { if ( n == 1 || n == 2 ) return 1 ; else return sequence ( sequence ( n - 1 ) ) + sequence ( n - sequence ( n - 1 ) ) ; }
"static boolean pairInSortedRotated ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; int l = ( i + 1 ) % n ; int r = i ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) return true ; if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return false ; }"
void cocktailSort ( int a [ ] ) { boolean swapped = true ; int start = 0 ; int end = a . length ; while ( swapped == true ) { swapped = false ; for ( int i = start ; i < end - 1 ; ++ i ) { if ( a [ i ] > a [ i + 1 ] ) { int temp = a [ i ] ; a [ i ] = a [ i + 1 ] ; a [ i + 1 ] = temp ; swapped = true ; } } if ( swapped == false ) break ; swapped = false ; end = end - 1 ; for ( int i = end - 1 ; i >= start ; i -- ) { if ( a [ i ] > a [ i + 1 ] ) { int temp = a [ i ] ; a [ i ] = a [ i + 1 ] ; a [ i + 1 ] = temp ; swapped = true ; } } start = start + 1 ; } }
"static boolean printPairs ( int arr [ ] , int n , int k ) { boolean isPairFound = true ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i != j && arr [ i ] % arr [ j ] == k ) { System . out . print ( ""("" + arr [ i ] + "", "" + arr [ j ] + "")"" + "" "" ) ; isPairFound = true ; } } } return isPairFound ; }"
"static int findMaximumDiff ( int [ ] a , int n ) { int ind1 = 0 ; for ( int i = n - 1 ; i > 0 ; i -- ) { if ( a [ 0 ] != a [ i ] ) { ind1 = i ; break ; } } int ind2 = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( a [ n - 1 ] != a [ i ] ) { ind2 = ( n - 1 - i ) ; break ; } } return Math . max ( ind1 , ind2 ) ; }"
"static double extrapolate ( double [ ] [ ] d , double x ) { double y = d [ 0 ] [ 1 ] + ( x - d [ 0 ] [ 0 ] ) / ( d [ 1 ] [ 0 ] - d [ 0 ] [ 0 ] ) * ( d [ 1 ] [ 1 ] - d [ 0 ] [ 1 ] ) ; return y ; }"
static int findSDSFunc ( int n ) { int DP [ ] = new int [ n + 1 ] ; DP [ 0 ] = 0 ; DP [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) DP [ i ] = DP [ i / 2 ] ; else DP [ i ] = DP [ ( i - 1 ) / 2 ] + DP [ ( i + 1 ) / 2 ] ; } return DP [ n ] ; }
"static boolean ifPossible ( int arr [ ] , int n ) { int copy [ ] = Arrays . copyOf ( arr , arr . length ) ; Arrays . sort ( copy ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! ( arr [ i ] == copy [ i ] ) && ! ( arr [ n - 1 - i ] == copy [ i ] ) ) return false ; } return true ; }"
public static int findMaximumPieces ( int n ) { int x = n / 2 ; return ( ( x + 1 ) * ( n - x + 1 ) ) ; }
public static int countIdenticalRows ( int mat [ ] [ ] ) { int count = 0 ; for ( int i = 0 ; i < mat . length ; i ++ ) { HashSet < Integer > hs = new HashSet < > ( ) ; for ( int j = 0 ; j < mat [ i ] . length ; j ++ ) { hs . add ( mat [ i ] [ j ] ) ; } if ( hs . size ( ) == 1 ) count ++ ; } return count ; }
"static boolean isExists ( int a [ ] , int n ) { Map < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq . put ( a [ i ] , freq . get ( a [ i ] ) == null ? 0 : freq . get ( a [ i ] ) + 1 ) ; sum += a [ i ] ; } if ( sum % 2 == 0 ) { if ( freq . get ( sum / 2 ) != null ) return true ; } return false ; }"
"static int maxSubArraySumRepeated ( int a [ ] , int n , int k ) { int max_so_far = 0 ; int INT_MIN , max_ending_here = 0 ; for ( int i = 0 ; i < n * k ; i ++ ) { max_ending_here = max_ending_here + a [ i % n ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }"
"static void relativeComplement ( int arr1 [ ] , int arr2 [ ] , int n , int m ) { int i = 0 , j = 0 ; while ( i < n && j < m ) { if ( arr1 [ i ] < arr2 [ j ] ) { System . out . print ( arr1 [ i ] + "" "" ) ; i ++ ; } else if ( arr1 [ i ] > arr2 [ j ] ) { j ++ ; } else if ( arr1 [ i ] == arr2 [ j ] ) { i ++ ; j ++ ; } } while ( i < n ) System . out . print ( arr1 [ i ] + "" "" ) ; }"
"static Vector < String > splitStrings ( String str , char dl ) { String word = """" ; int num = 0 ; str = str + dl ; int l = str . length ( ) ; Vector < String > substr_list = new Vector < String > ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( str . charAt ( i ) != dl ) { word = word + str . charAt ( i ) ; } else { if ( ( int ) word . length ( ) != 0 ) { substr_list . add ( word ) ; } word = """" ; } } return substr_list ; }"
"static int minimizeDiff ( int [ ] arr , int n , int k ) { int max = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int min = Arrays . stream ( arr ) . min ( ) . getAsInt ( ) ; if ( ( max - min ) <= k ) { return ( max - min ) ; } int avg = ( max + min ) / 2 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > avg ) { arr [ i ] -= k ; } else { arr [ i ] += k ; } } max = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; min = Arrays . stream ( arr ) . min ( ) . getAsInt ( ) ; return ( max - min ) ; }"
public static int findRemainder ( int n ) { int x = n & 3 ; return x ; }
"static int breakSum ( int n ) { if ( n == 0 || n == 1 ) return n ; return Math . max ( ( breakSum ( n / 2 ) + breakSum ( n / 3 ) + breakSum ( n / 4 ) ) , n ) ; }"
"static int maximize ( int A1 [ ] , int A2 [ ] , int n , int x , int y ) { int [ ] c = new int [ n ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { c [ i ] = A2 [ i ] - A1 [ i ] ; sum += A1 [ i ] ; } int temp ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( c [ i ] < c [ i + 1 ] ) { temp = c [ i ] ; c [ i ] = c [ i + 1 ] ; c [ i + 1 ] = temp ; } } int maxi = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum += c [ i ] ; if ( i + 1 >= ( n - x ) ) maxi = Math . max ( sum , maxi ) ; } return maxi ; }"
"static void findMinimumOperation ( int n , int d , int arrays [ ] [ ] ) { int cnt = 0 ; int first = Integer . MIN_VALUE , end = Integer . MAX_VALUE ; while ( n > 0 ) { int arr [ ] = { arrays [ cnt ] [ 0 ] , arrays [ cnt ] [ 1 ] }; Arrays . sort ( arr ) ; first = Math . max ( first , arr [ 0 ] ) ; end = Math . min ( end , arr [ 1 ] ) ; cnt ++ ; n -- ; } if ( first > end ) System . out . print ( ""-1"" ) ; else { if ( d >= first && d <= end ) { System . out . print ( ""0"" ) ; } else System . out . print ( Math . min ( Math . abs ( first - d ) , Math . abs ( d - end ) ) ) ; } }"
"static void printExpansion ( String str ) { String suff = """" ; for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) { suff = suff + str . charAt ( i ) ; System . out . print ( suff ) ; } }"
"static int countStr ( int n , int bCount , int cCount ) { if ( bCount < 0 || cCount < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( bCount == 0 && cCount == 0 ) return 1 ; int res = countStr ( n - 1 , bCount , cCount ) ; res += countStr ( n - 1 , bCount - 1 , cCount ) ; res += countStr ( n - 1 , bCount , cCount - 1 ) ; return res ; }"
"static boolean checkForSorting ( int arr [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { if ( arr [ i ] - arr [ i + 1 ] == 1 ) { int temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; } else return false ; } } return true ; }"
"static int countEvenSum ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { int sum = 0 ; for ( int j = i ; j <= n - 1 ; j ++ ) { sum = sum + arr [ j ] ; if ( sum % 2 == 0 ) result ++ ; } } return ( result ) ; }"
"static int countPiles ( int n , int [ ] a ) { HashMap < Integer , Integer > occ = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) occ . put ( a [ i ] , occ . get ( a [ i ] ) == null ? 1 : occ . get ( a [ i ] ) + 1 ) ; int pile = 0 ; while ( ! occ . isEmpty ( ) ) { pile ++ ; int size = 0 ; HashSet < Integer > toRemove = new HashSet < > ( ) ; for ( HashMap . Entry < Integer , Integer > tm : occ . entrySet ( ) ) { int mx = tm . getKey ( ) ; int ct = tm . getValue ( ) ; int use = Math . min ( ct , mx - size + 1 ) ; occ . put ( mx , occ . get ( mx ) - use ) ; size += use ; if ( occ . get ( mx ) == 0 ) toRemove . add ( mx ) ; } for ( int tm : toRemove ) occ . remove ( tm ) ; } return pile ; }"
"static int difference ( int n ) { int S , res ; S = ( n * ( n + 1 ) ) / 2 ; res = S * ( S - 1 ) ; return res ; }"
"static void findSymPairs ( int arr [ ] [ ] ) { HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { int first = arr [ i ] [ 0 ] ; int sec = arr [ i ] [ 1 ] ; Integer val = hM . get ( sec ) ; if ( val != null && val == first ) System . out . println ( ""("" + sec + "", "" + first + "")"" ) ; else hM . put ( first , sec ) ; } }"
"static int complement ( int num ) { int i , len = 0 , temp , comp ; temp = num ; while ( true ) { len ++ ; num = num / 10 ; if ( Math . abs ( num ) == 0 ) break ; } num = temp ; comp = ( int ) Math . pow ( 10 , len ) - num ; return comp ; }"
"static int replace ( String A , String B ) { int n = A . length ( ) , m = B . length ( ) ; int count = 0 , i , j ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < m ; j ++ ) { if ( i + j >= n ) break ; else if ( A . charAt ( i + j ) != B . charAt ( j ) ) break ; } if ( j == m ) { count ++ ; i += m - 1 ; } } return count ; }"
"public static int countTriplets ( int [ ] arr , int n , int a , int b ) { int ans = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] + arr [ k ] >= a && arr [ i ] + arr [ j ] + arr [ k ] <= b ) { ans ++ ; } } } } return ans ; }"
"static boolean checkplusperfect ( int x ) { int temp = x ; int n = 0 ; while ( x != 0 ) { x /= 10 ; n ++ ; } x = temp ; int sum = 0 ; while ( x != 0 ) { sum += Math . pow ( x % 10 , n ) ; x /= 10 ; } return ( sum == temp ) ; }"
"static int rightmostNonZero ( int a [ ] , int n ) { int c5 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( a [ i ] > 0 && a [ i ] % 5 == 0 ) { a [ i ] /= 5 ; c5 ++ ; } } for ( int i = 0 ; i < n ; i ++ ) { while ( c5 != 0 && a [ i ] > 0 && ( a [ i ] & 1 ) == 0 ) { a [ i ] >>= 1 ; c5 -- ; } } int ans = 1 ; for ( int i = 0 ; i < n ; i ++ ) { ans = ( ans * a [ i ] % 10 ) % 10 ; } if ( c5 != 0 ) ans = ( ans * 5 ) % 10 ; if ( ans != 0 ) return ans ; return - 1 ; }"
static int divisible ( String num ) { int n = num . length ( ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( int ) ( num . charAt ( i ) ) ; if ( sum % 3 == 0 ) return 0 ; if ( n == 1 ) return - 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( sum % 3 == ( num . charAt ( i ) - '0' ) % 3 ) return 1 ; if ( n == 2 ) return - 1 ; return 2 ; }
static int firstDigit ( int x ) { while ( x >= 10 ) x = x / 10 ; return x ; }
public static int playGame ( int arr [ ] ) { HashSet < Integer > set = new HashSet < > ( ) ; for ( int i : arr ) set . add ( i ) ; return ( set . size ( ) % 2 == 0 ) ? 1 : 2 ; }
"public static void FindAllElements ( int n , int k ) { int sum = k ; int [ ] A = new int [ k ] ; Arrays . fill ( A , 0 , k , 1 ) ; for ( int i = k - 1 ; i >= 0 ; -- i ) { while ( sum + A [ i ] <= n ) { sum += A [ i ] ; A [ i ] *= 2 ; } } if ( sum != n ) { System . out . print ( ""Impossible"" ) ; } else { for ( int i = 0 ; i < k ; ++ i ) System . out . print ( A [ i ] + "" "" ) ; } }"
"static int sum ( int k , int n ) { int sum = ( int ) ( Math . pow ( k , n + 1 ) - Math . pow ( k - 1 , n + 1 ) ) ; return sum ; }"
"static void LeibnizHarmonicTriangle ( int n ) { int C [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) System . out . print ( ""1/"" + i * C [ i - 1 ] [ j - 1 ] + "" "" ) ; System . out . println ( ) ; } }"
"static void findTriplets ( int arr [ ] , int n ) { boolean found = false ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int l = i + 1 ; int r = n - 1 ; int x = arr [ i ] ; while ( l < r ) { if ( x + arr [ l ] + arr [ r ] == 0 ) { System . out . print ( x + "" "" ) ; System . out . print ( arr [ l ] + "" "" ) ; System . out . println ( arr [ r ] + "" "" ) ; l ++ ; r -- ; found = true ; } else if ( x + arr [ l ] + arr [ r ] < 0 ) l ++ ; else r -- ; } } if ( found == false ) System . out . println ( "" No Triplet Found"" ) ; }"
"public static int longestSubarray ( int [ ] input ) { int prev = - 1 ; int current , next ; int prevCount = 0 , currentCount = 1 ; int longest = 1 ; current = input [ 0 ] ; for ( int i = 1 ; i < input . length ; i ++ ) { next = input [ i ] ; if ( next == current ) { currentCount ++ ; } else if ( next == prev ) { prevCount += currentCount ; prev = current ; current = next ; currentCount = 1 ; } else { longest = Math . max ( longest , currentCount + prevCount ) ; prev = current ; prevCount = currentCount ; current = next ; currentCount = 1 ; } } return Math . max ( longest , currentCount + prevCount ) ; }"
"static int findK ( int n , int k ) { ArrayList < Integer > a = new ArrayList < Integer > ( n ) ; for ( int i = 1 ; i < n ; i ++ ) if ( i % 2 == 1 ) a . add ( i ) ; for ( int i = 1 ; i < n ; i ++ ) if ( i % 2 == 0 ) a . add ( i ) ; return ( a . get ( k - 1 ) ) ; }"
static int ways ( int n ) { return n / 2 ; }
"static void reverseFibonacci ( int n ) { int a [ ] = new int [ n ] ; a [ 0 ] = 0 ; a [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) { a [ i ] = a [ i - 2 ] + a [ i - 1 ] ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { System . out . print ( a [ i ] + "" "" ) ; } }"
"public static void Calculate_area ( ) { double b = 3 , h = 4 , s1 = 3 , s2 = 6 ; double s3 = 6 , Ht = 8 , SA ; SA = b * h + ( s1 + s2 + s3 ) * Ht ; System . out . printf ( ""The area of triangular prism is : %f"" , SA ) ; }"
"static String largestPalinSub ( String s ) { String res = """" ; char mx = s . charAt ( 0 ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) mx = ( char ) Math . max ( ( int ) mx , ( int ) s . charAt ( i ) ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( s . charAt ( i ) == mx ) res += s . charAt ( i ) ; return res ; }"
"static int findLen ( int [ ] arr , int n , int m ) { Vector < Integer > filter = new Vector < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & m ) == m ) filter . add ( arr [ i ] ) ; if ( filter . size ( ) == 0 ) return 0 ; int c_and = filter . get ( 0 ) ; for ( int i = 1 ; i < filter . size ( ) ; i ++ ) c_and &= filter . get ( i ) ; if ( c_and == m ) return filter . size ( ) ; return 0 ; }"
"public static long gcd ( long a , long b ) { if ( a < b ) { long tmp = a ; a = b ; b = tmp ; } while ( b != 0 ) { long r = a % b ; a = b ; b = r ; } return a ; }"
"static int sqrtSearch ( int low , int high , int N ) { if ( low <= high ) { int mid = ( int ) ( low + high ) / 2 ; if ( ( mid * mid <= N ) && ( ( mid + 1 ) * ( mid + 1 ) > N ) ) { return mid ; } else if ( mid * mid < N ) { return sqrtSearch ( mid + 1 , high , N ) ; } else { return sqrtSearch ( low , mid - 1 , N ) ; } } return low ; }"
"static boolean isSubSeqDivisible ( String str ) { int i , j , k , l = str . length ( ) ; int arr [ ] = new int [ l ] ; for ( i = 0 ; i < l ; i ++ ) { for ( j = i ; j < l ; j ++ ) { for ( k = j ; k < l ; k ++ ) { if ( arr [ i ] % 8 == 0 ) return true ; else if ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 && i != j ) return true ; else if ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 && i != j && j != k && i != k ) return true ; } } } return false ; }"
"static int findElement ( int arr [ ] , int size ) { int right_sum = 0 , left_sum = 0 ; for ( int i = 1 ; i < size ; i ++ ) right_sum += arr [ i ] ; for ( int i = 0 , j = 1 ; j < size ; i ++ , j ++ ) { right_sum -= arr [ j ] ; left_sum += arr [ i ] ; if ( left_sum == right_sum ) return arr [ i + 1 ] ; } return - 1 ; }"
static long count_of_ways ( long n ) { long count = 0 ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) for ( int k = 0 ; k <= n ; k ++ ) if ( i + j + k == n ) count ++ ; return count ; }
"static double largestSumOfAverages ( int [ ] A , int K ) { int n = A . length ; double [ ] pre_sum = new double [ n + 1 ] ; pre_sum [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] ; double [ ] dp = new double [ n ] ; double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i ) ; for ( int k = 0 ; k < K - 1 ; k ++ ) for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) dp [ i ] = Math . max ( dp [ i ] , ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] ) ; return dp [ 0 ] ; }"
"static void countFreq ( int [ ] a , int n ) { HashMap < Integer , Integer > hm = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) hm . put ( a [ i ] , hm . get ( a [ i ] ) == null ? 1 : hm . get ( a [ i ] ) + 1 ) ; SortedMap < Integer , Integer > st = new TreeMap < > ( ) ; for ( HashMap . Entry < Integer , Integer > x : hm . entrySet ( ) ) { st . put ( x . getKey ( ) , x . getValue ( ) ) ; } int cumul = 0 ; for ( SortedMap . Entry < Integer , Integer > x : st . entrySet ( ) ) { cumul += x . getValue ( ) ; System . out . println ( x . getKey ( ) + "" "" + cumul ) ; } }"
"static int countPairs ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] == arr [ j ] ) ans ++ ; return ans ; }"
"static String findNumber ( int s , int d ) { String num = """" ; int val = s / d ; int rem = s % d ; int i ; for ( i = 1 ; i <= d - rem ; i ++ ) { num = num + String . valueOf ( val ) ; } if ( rem > 0 ) { val ++ ; for ( i = d - rem + 1 ; i <= d ; i ++ ) { num = num + String . valueOf ( val ) ; } } return num ; }"
"static int getSingle ( int arr [ ] , int n ) { int ones = 0 , twos = 0 ; int common_bit_mask ; for ( int i = 0 ; i < n ; i ++ ) { twos = twos | ( ones & arr [ i ] ) ; ones = ones ^ arr [ i ] ; common_bit_mask = ~ ( ones & twos ) ; ones &= common_bit_mask ; twos &= common_bit_mask ; } return ones ; }"
static int per ( int n ) { if ( n == 0 ) return 3 ; if ( n == 1 ) return 0 ; if ( n == 2 ) return 2 ; return per ( n - 2 ) + per ( n - 3 ) ; }
"static void computeTotient ( int n ) { long phi [ ] = new long [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) phi [ i ] = i ; for ( int p = 2 ; p <= n ; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1 ; for ( int i = 2 * p ; i <= n ; i += p ) { phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ; } } } for ( int i = 1 ; i <= n ; i ++ ) System . out . println ( ""Totient of "" + i + "" is "" + phi [ i ] ) ; }"
"void computeLPSArray ( String pat , int M , int lps [ ] ) { int len = 0 ; int i = 1 ; lps [ 0 ] = 0 ; while ( i < M ) { if ( pat . charAt ( i ) == pat . charAt ( len ) ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) { len = lps [ len - 1 ] ; } else { lps [ i ] = len ; i ++ ; } } } }"
"static void display ( int n ) { int i , j , k ; for ( i = 1 ; i <= n ; i ++ ) { for ( j = 1 , k = i ; j <= i ; j ++ , k -- ) { if ( k % 2 == 0 ) { System . out . print ( j ) ; } else { System . out . print ( ""*"" ) ; } } System . out . print ( ""\n"" ) ; } }"
"static void rearrange ( int [ ] arr , int n ) { int temp [ ] = new int [ n ] ; int small = 0 , large = n - 1 ; boolean flag = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( flag ) temp [ i ] = arr [ large -- ] ; else temp [ i ] = arr [ small ++ ] ; flag = ! flag ; } arr = temp . clone ( ) ; }"
"static int TotalWays ( int n , int s , int k ) { int [ ] dp = new int [ n ] ; dp [ s - 1 ] = 1 ; for ( int i = s ; i < n ; i ++ ) { int idx = Math . max ( s - 1 , i - k ) ; for ( int j = idx ; j < i ; j ++ ) { dp [ i ] += dp [ j ] ; } } return dp [ n - 1 ] ; }"
static int term ( int n ) { int x = ( ( ( 1 ) + ( int ) Math . sqrt ( 1 + ( 8 * n ) ) ) / 2 ) ; return x ; }
"static int maxSumSubarrayRemovingOneEle ( int arr [ ] , int n ) { int fw [ ] = new int [ n ] ; int bw [ ] = new int [ n ] ; int cur_max = arr [ 0 ] , max_so_far = arr [ 0 ] ; fw [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { cur_max = Math . max ( arr [ i ] , cur_max + arr [ i ] ) ; max_so_far = Math . max ( max_so_far , cur_max ) ; fw [ i ] = cur_max ; } cur_max = max_so_far = bw [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { cur_max = Math . max ( arr [ i ] , cur_max + arr [ i ] ) ; max_so_far = Math . max ( max_so_far , cur_max ) ; bw [ i ] = cur_max ; } int fans = max_so_far ; for ( int i = 1 ; i < n - 1 ; i ++ ) fans = Math . max ( fans , fw [ i - 1 ] + bw [ i + 1 ] ) ; return fans ; }"
"static boolean validateStackSequence ( int pushed [ ] , int popped [ ] , int len ) { int j = 0 ; Stack < Integer > st = new Stack < > ( ) ; for ( int i = 0 ; i < len ; i ++ ) { st . push ( pushed [ i ] ) ; while ( ! st . empty ( ) && j < len && st . peek ( ) == popped [ j ] ) { st . pop ( ) ; j ++ ; } } return j == len ; }"
"static double circlearea ( double a ) { if ( a < 0 ) return - 1 ; double A = ( 3.14 * 3 * Math . pow ( a , 2 ) ) / 4 ; return A ; }"
static long countWays ( int n ) { long dp [ ] [ ] = new long [ 2 ] [ n + 1 ] ; dp [ 0 ] [ 1 ] = 1 ; dp [ 1 ] [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] ; dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ; } return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] ; }
"static void pairwiseDifference ( int arr [ ] , int n ) { int diff ; for ( int i = 0 ; i < n - 1 ; i ++ ) { diff = Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; System . out . print ( diff + "" "" ) ; } }"
"static int MaximumNumbers ( String s ) { int n = s . length ( ) ; int [ ] remIndex = { - 1 , - 1 , - 1 }; remIndex [ 0 ] = 0 ; int [ ] res = new int [ n + 1 ] ; int r = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { r = ( r + s . charAt ( i - 1 ) - '0' ) % 3 ; res [ i ] = res [ i - 1 ] ; if ( remIndex [ r ] != - 1 ) res [ i ] = Math . max ( res [ i ] , res [ remIndex [ r ] ] + 1 ) ; remIndex [ r ] = i + 1 ; } return res [ n ] ; }"
"static int minPower ( int n , int x ) { if ( x == 1 ) return n ; int ans = 0 ; while ( n > 0 ) { ans += ( n % x ) ; n /= x ; } return ans ; }"
"static int valueofX ( int ar [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ar [ i ] ; } if ( sum % n == 0 ) { return sum / n ; } else { int A = sum / n , B = sum / n + 1 ; int ValueA = 0 , ValueB = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ValueA += ( ar [ i ] - A ) * ( ar [ i ] - A ) ; ValueB += ( ar [ i ] - B ) * ( ar [ i ] - B ) ; } if ( ValueA < ValueB ) { return A ; } else { return B ; } } }"
"static String getWinner ( String str , int len ) { int total = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str . charAt ( i ) == 'S' ) { total ++ ; } } if ( ( total % 2 ) == 1 ) return ""First"" ; return ""Second"" ; }"
public static int [ ] fix ( int [ ] A ) { Set < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < A . length ; i ++ ) { s . add ( A [ i ] ) ; } for ( int i = 0 ; i < A . length ; i ++ ) { if ( s . contains ( i ) ) A [ i ] = i ; else A [ i ] = - 1 ; } return A ; }
"static int minOperations ( String str , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( str . charAt ( i ) != str . charAt ( i + 1 ) ) count ++ ; } return ( count + 1 ) / 2 ; }"
"static int minproduct ( int a [ ] , int b [ ] , int n , int k ) { int diff = 0 , res = 0 ; int temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int pro = a [ i ] * b [ i ] ; res = res + pro ; if ( pro < 0 && b [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro < 0 && a [ i ] < 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] > 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; int d = Math . abs ( pro - temp ) ; if ( d > diff ) diff = d ; } return res - diff ; }"
"static int countPoints ( int n , int m , int a [ ] , int [ ] b , int x , int y ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; int j = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < m ) { if ( a [ i ] + y < b [ j ] ) break ; if ( b [ j ] >= a [ i ] - x && b [ j ] <= a [ i ] + y ) { count ++ ; j ++ ; break ; } else j ++ ; } } return count ; }"
"static int getPosition ( int a [ ] , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = ( a [ i ] / m + ( a [ i ] % m ) ) ; } int ans = - 1 , max = - 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( max < a [ i ] ) { max = a [ i ] ; ans = i ; } } return ans + 1 ; }"
static int phi ( int n ) { int result = n ; for ( int p = 2 ; p * p <= n ; ++ p ) { if ( n % p == 0 ) { while ( n % p == 0 ) n /= p ; result -= result / p ; } } if ( n > 1 ) result -= result / n ; return result ; }
"static int countways ( int a [ ] , int n ) { int cnt [ ] = new int [ n ] ; int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s += a [ i ] ; } if ( s % 3 != 0 ) return 0 ; s /= 3 ; int ss = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { ss += a [ i ] ; if ( ss == s ) cnt [ i ] = 1 ; } for ( int i = n - 2 ; i >= 0 ; i -- ) cnt [ i ] += cnt [ i + 1 ] ; int ans = 0 ; ss = 0 ; for ( int i = 0 ; i + 2 < n ; i ++ ) { ss += a [ i ] ; if ( ss == s ) ans += cnt [ i + 2 ] ; } return ans ; }"
"static void result ( long n , long k , long t ) { if ( t <= k ) System . out . println ( t ) ; else if ( t <= n ) System . out . println ( k ) ; else { long temp = t - n ; temp = k - temp ; System . out . println ( temp ) ; } }"
"static void calculate ( int a [ ] , int b [ ] , int n , int m ) { int mul = 1 ; for ( int i = 0 ; i < m ; i ++ ) if ( b [ i ] != 0 ) mul = mul * b [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = ( int ) Math . floor ( a [ i ] / mul ) ; System . out . print ( x + "" "" ) ; } }"
"static void subsetDifference ( int n ) { int s = n * ( n + 1 ) / 2 ; if ( n % 4 == 0 ) { System . out . println ( ""First subset sum = "" + s / 2 ) ; System . out . println ( ""Second subset sum = "" + s / 2 ) ; System . out . println ( ""Difference = "" + 0 ) ; } else { if ( n % 4 == 1 || n % 4 == 2 ) { System . out . println ( ""First subset sum = "" + s / 2 ) ; System . out . println ( ""Second subset sum = "" + ( ( s / 2 ) + 1 ) ) ; System . out . println ( ""Difference = "" + 1 ) ; } else { System . out . println ( ""First subset sum = "" + s / 2 ) ; System . out . println ( ""Second subset sum = "" + s / 2 ) ; System . out . println ( ""Difference = "" + 0 ) ; } } }"
"static int countOddPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( A [ i ] % 2 != 1 ) ) { count ++ ; } } int evenPairCount = count * ( count - 1 ) / 2 ; int totPairs = N * ( N - 1 ) / 2 ; return totPairs - evenPairCount ; }"
"static int countHexadecimal ( int L , int R ) { int count = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( i >= 10 && i <= 15 ) count ++ ; else if ( i > 15 ) { int k = i ; while ( k != 0 ) { if ( k % 16 >= 10 ) count ++ ; k = k / 16 ; } } } return count ; }"
"static int countSolutions ( int n , int val ) { int total = 0 ; if ( n == 1 && val >= 0 ) return 1 ; for ( int i = 0 ; i <= val ; i ++ ) { total += countSolutions ( n - 1 , val - i ) ; } return total ; }"
"static int LongestFibSubseq ( int A [ ] , int n ) { TreeSet < Integer > S = new TreeSet < > ( ) ; for ( int t : A ) { S . add ( t ) ; } int maxLen = 0 , x , y ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { x = A [ j ] ; y = A [ i ] + A [ j ] ; int length = 3 ; while ( S . contains ( y ) && ( y != S . last ( ) ) ) { int z = x + y ; x = y ; y = z ; maxLen = Math . max ( maxLen , ++ length ) ; } } } return maxLen >= 3 ? maxLen : 0 ; }"
"static int countWays ( int index , int cnt , int dp [ ] [ ] , int n , int m , int k ) { if ( index == n ) { if ( cnt == k ) return 1 ; else return 0 ; } if ( dp [ index ] [ cnt ] != - 1 ) return dp [ index ] [ cnt ] ; int ans = 0 ; ans += countWays ( index + 1 , cnt , dp , n , m , k ) ; ans += ( m - 1 ) * countWays ( index + 1 , cnt + 1 , dp , n , m , k ) ; return dp [ index ] [ cnt ] = ans ; }"
static String evenlength ( String n ) { String res = n ; for ( int j = n . length ( ) - 1 ; j >= 0 ; -- j ) res += n . charAt ( j ) ; return res ; }
"static int maxSubStrings ( String s , int k ) { int maxSubStr = 0 , n = s . length ( ) ; for ( int c = 0 ; c < 26 ; c ++ ) { char ch = ( char ) ( ( int ) 'a' + c ) ; int curr = 0 ; for ( int i = 0 ; i <= n - k ; i ++ ) { if ( s . charAt ( i ) != ch ) continue ; int cnt = 0 ; while ( i < n && s . charAt ( i ) == ch && cnt != k ) { i ++ ; cnt ++ ; } i -- ; if ( cnt == k ) curr ++ ; } maxSubStr = Math . max ( maxSubStr , curr ) ; } return maxSubStr ; }"
"static int findDiff ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int count = 0 , max_count = 0 , min_count = n ; for ( int i = 0 ; i < ( n - 1 ) ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { count += 1 ; continue ; } else { max_count = Math . max ( max_count , count ) ; min_count = Math . min ( min_count , count ) ; count = 0 ; } } return ( max_count - min_count ) ; }"
"static boolean SumDivisible ( int n , int k ) { int sum = 0 , position = 1 ; while ( n > 0 ) { if ( position % 2 == 1 ) sum += n % 10 ; n = n / 10 ; position ++ ; } if ( sum % k == 0 ) return true ; return false ; }"
"static char encodedChar ( char [ ] str , int k ) { int i , j ; int n = str . length ; int len ; int num ; int freq ; i = 0 ; while ( i < n ) { j = i ; len = 0 ; freq = 0 ; while ( j < n && Character . isAlphabetic ( str [ j ] ) ) { j ++ ; len ++ ; } while ( j < n && Character . isDigit ( str [ j ] ) ) { freq = freq * 10 + ( str [ j ] - '0' ) ; j ++ ; } num = freq * len ; if ( k > num ) { k -= num ; i = j ; } else { k -- ; k %= len ; return str [ i + k ] ; } } return str [ k - 1 ] ; }"
"static int search ( int arr [ ] , int n , int x ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) return i ; } return - 1 ; }"
"static int minCost ( int [ ] cost , int n ) { int totalCost = 0 ; int boardingBus = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( cost [ boardingBus ] > cost [ i ] ) { totalCost += ( ( i - boardingBus ) * cost [ boardingBus ] ) ; boardingBus = i ; } } totalCost += ( ( n - boardingBus ) * cost [ boardingBus ] ) ; return totalCost ; }"
"static void pattern ( int rows_no ) { int i , j , k ; for ( i = 1 ; i <= rows_no ; i ++ ) { for ( k = 1 ; k < i ; k ++ ) System . out . print ( "" "" ) ; for ( j = i ; j <= rows_no ; j ++ ) System . out . print ( j + "" "" ) ; System . out . println ( ) ; } for ( i = rows_no - 1 ; i >= 1 ; i -- ) { for ( k = 1 ; k < i ; k ++ ) System . out . print ( "" "" ) ; for ( j = i ; j <= rows_no ; j ++ ) System . out . print ( j + "" "" ) ; System . out . println ( ) ; } }"
"static void findSubSeq ( int arr [ ] , int n , int sum ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( sum < arr [ i ] ) arr [ i ] = - 1 ; else sum -= arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != - 1 ) System . out . print ( arr [ i ] + "" "" ) ; } }"
"static void findArea ( float a , float b ) { float Area ; Area = ( float ) 3.142 * a * b ; System . out . println ( ""Area: "" + Area ) ; }"
"static void findNumbers ( int N ) { int i = 1 ; while ( i <= N ) { System . out . print ( ( i * i * i ) + "" "" ) ; i ++ ; } }"
"static void findTheNumber ( int n ) { if ( n == 1 ) { System . out . print ( ""Impossible"" + ""\n"" ) ; return ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { System . out . print ( ""5"" ) ; } System . out . print ( ""4"" ) ; }"
public static long productPrimeFactors ( int n ) { long product = 1 ; if ( n % 2 == 0 ) { product *= 2 ; while ( n % 2 == 0 ) n = n / 2 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { product = product * i ; while ( n % i == 0 ) n = n / i ; } } if ( n > 2 ) product = product * n ; return product ; }
"static int maxLen ( int arr [ ] , int n ) { int max_len = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sum = 0 ; for ( int j = i ; j < n ; j ++ ) { curr_sum += arr [ j ] ; if ( curr_sum == 0 ) max_len = Math . max ( max_len , j - i + 1 ) ; } } return max_len ; }"
"public static int sumoflength ( int [ ] arr , int n ) { Set < Integer > s = new HashSet < > ( ) ; int j = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < n && ! s . contains ( arr [ j ] ) ) { s . add ( arr [ i ] ) ; j ++ ; } ans += ( ( j - i ) * ( j - i + 1 ) ) / 2 ; s . remove ( arr [ i ] ) ; } return ans ; }"
"public static int min_noOf_operation ( int arr [ ] , int n , int k ) { int noOfSubtraction ; int res = 0 ; for ( int i = 1 ; i < n ; i ++ ) { noOfSubtraction = 0 ; if ( arr [ i ] > arr [ i - 1 ] ) { noOfSubtraction = ( arr [ i ] - arr [ i - 1 ] ) / k ; if ( ( arr [ i ] - arr [ i - 1 ] ) % k != 0 ) noOfSubtraction ++ ; arr [ i ] = arr [ i ] - k * noOfSubtraction ; } res = res + noOfSubtraction ; } return res ; }"
"static int countP ( int n , int k ) { int [ ] [ ] dp = new int [ n + 1 ] [ k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int i = 0 ; i <= k ; i ++ ) dp [ 0 ] [ k ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= k ; j ++ ) if ( j == 1 || i == j ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ; return dp [ n ] [ k ] ; }"
"static void centeredHexagonalSeries ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( 3 * i * ( i - 1 ) + 1 + "" "" ) ; }"
"static long getNthTerm ( long N ) { return 4 * ( long ) Math . pow ( N , 2 ) - 3 * N + 2 ; }"
"static int averageOdd ( int n ) { if ( n % 2 == 0 ) { System . out . println ( ""Invalid Input"" ) ; return - 1 ; } int sum = 0 , count = 0 ; while ( n >= 1 ) { count ++ ; sum += n ; n = n - 2 ; } return sum / count ; }"
public static int sumOfSubstrings ( String num ) { int n = num . length ( ) ; int sumofdigit [ ] = new int [ n ] ; sumofdigit [ 0 ] = num . charAt ( 0 ) - '0' ; int res = sumofdigit [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { int numi = num . charAt ( i ) - '0' ; sumofdigit [ i ] = ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] ; res += sumofdigit [ i ] ; } return res ; }
"static void findNumbers ( int arr [ ] , int n ) { int num [ ] = new int [ n ] ; int b_minus_a = arr [ n - 1 ] - arr [ 1 ] ; num [ 1 ] = ( arr [ 0 ] + b_minus_a ) / 2 ; num [ 0 ] = arr [ 0 ] - num [ 1 ] ; for ( int i = 1 ; i <= ( n - 2 ) ; i ++ ) num [ i + 1 ] = arr [ i ] - num [ 0 ] ; System . out . print ( ""Numbers are: "" ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( num [ i ] + "" "" ) ; }"
"public static void checkType ( int arr [ ] , int n ) { if ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] <= arr [ n - 1 ] ) System . out . println ( ""Increasing"" ) ; else if ( arr [ 0 ] >= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) System . out . println ( ""Decreasing"" ) ; else if ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) System . out . println ( ""Increasing then decreasing"" ) ; else System . out . println ( ""Decreasing then increasing"" ) ; }"
"static int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; HashSet < Integer > us = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < m ; i ++ ) us . add ( arr1 [ i ] ) ; for ( int j = 0 ; j < n ; j ++ ) if ( us . contains ( x - arr2 [ j ] ) ) count ++ ; return count ; }"
"static long count ( int arr [ ] , int n , int x ) { if ( x == 1 ) { long ans = ( long ) Math . pow ( 2 , n ) - 1 ; return ans ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % x == 0 ) count ++ ; } long ans = ( long ) Math . pow ( 2 , count ) - 1 ; return ans ; }"
static boolean isEqualBlock ( int n ) { int first_bit = n % 2 ; int first_count = 1 ; n = n / 2 ; while ( n % 2 == first_bit && n > 0 ) { n = n / 2 ; first_count ++ ; } if ( n == 0 ) return false ; while ( n > 0 ) { first_bit = n % 2 ; int curr_count = 1 ; n = n / 2 ; while ( n % 2 == first_bit ) { n = n / 2 ; curr_count ++ ; } if ( curr_count != first_count ) return false ; } return true ; }
"static void find_Solution ( double x , int n ) { double sum = x , e = 2 , o = 1 , p = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { p += 2 ; sum += ( double ) ( o / e ) * ( double ) ( Math . pow ( x , p ) / p ) ; o = o * ( o + 2 ) ; e = e * ( e + 2 ) ; } System . out . println ( sum ) ; }"
"static int countEvenSum ( int arr [ ] , int n ) { int temp [ ] = { 1 , 0 }; int result = 0 , sum = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { sum = ( ( sum + arr [ i ] ) % 2 + 2 ) % 2 ; temp [ sum ] ++ ; } result = result + ( temp [ 0 ] * ( temp [ 0 ] - 1 ) / 2 ) ; result = result + ( temp [ 1 ] * ( temp [ 1 ] - 1 ) / 2 ) ; return ( result ) ; }"
"static void groupElements ( int arr [ ] , int n ) { boolean visited [ ] = new boolean [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { visited [ i ] = false ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ! visited [ i ] ) { System . out . print ( arr [ i ] + "" "" ) ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { System . out . print ( arr [ i ] + "" "" ) ; visited [ j ] = true ; } } } } }"
static boolean adjacentSet ( int n ) { int x = ( n & ( n >> 1 ) ) ; if ( x == 1 ) return true ; else return false ; }
"static int min_elimination ( int n , int arr [ ] ) { int countOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 1 ) countOdd ++ ; return Math . min ( countOdd , n - countOdd ) ; }"
static int countPairs ( String str ) { int result = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( str . charAt ( i ) - str . charAt ( j ) ) == Math . abs ( i - j ) ) result ++ ; return result ; }
"static int smallestSubWithSum ( int arr [ ] , int n , int x ) { int curr_sum = 0 , min_len = n + 1 ; int start = 0 , end = 0 ; while ( end < n ) { while ( curr_sum <= x && end < n ) { if ( curr_sum <= 0 && x > 0 ) { start = end ; curr_sum = 0 ; } curr_sum += arr [ end ++ ] ; } while ( curr_sum > x && start < n ) { if ( end - start < min_len ) min_len = end - start ; curr_sum -= arr [ start ++ ] ; } } return min_len ; }"
"static int maxEvenLenSum ( int arr [ ] , int n ) { if ( n < 2 ) return 0 ; int [ ] dp = new int [ n ] ; dp [ n - 1 ] = 0 ; dp [ n - 2 ] = arr [ n - 2 ] + arr [ n - 1 ] ; for ( int i = n - 3 ; i >= 0 ; i -- ) { dp [ i ] = arr [ i ] + arr [ i + 1 ] ; if ( dp [ i + 2 ] > 0 ) dp [ i ] += dp [ i + 2 ] ; } int maxSum = Arrays . stream ( dp ) . max ( ) . getAsInt ( ) ; return maxSum ; }"
"static int find_k ( int a , int b ) { if ( ( a + b ) % 2 == 0 ) return ( ( a + b ) / 2 ) ; return - 1 ; }"
"public static int findMaxRec ( int A [ ] , int n ) { if ( n == 1 ) return A [ 0 ] ; return Math . max ( A [ n - 1 ] , findMaxRec ( A , n - 1 ) ) ; }"
"static int maxEvenSubarray ( int array [ ] , int N ) { int ans = 0 ; int count = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] % 2 == 0 ) { count ++ ; ans = Math . max ( ans , count ) ; } else { count = 0 ; } } ans = Math . max ( ans , count ) ; return ans ; }"
"static boolean isPossible ( int Sx , int Sy , int Dx , int Dy , int x , int y ) { if ( Math . abs ( Sx - Dx ) % x == 0 && Math . abs ( Sy - Dy ) % y == 0 && ( Math . abs ( Sx - Dx ) / x ) % 2 == ( Math . abs ( Sy - Dy ) / y ) % 2 ) return true ; return false ; }"
"public static void digit_product_Sum ( int N ) { int a [ ] = new int [ N + 1 ] ; int product = 1 ; a [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { product = a [ i - 1 ] / 10 ; if ( product == 0 ) product = 1 ; else product = a [ i - 1 ] % 10 ; int val = a [ i - 1 ] / 10 ; if ( val == 0 ) val = a [ i - 1 ] ; a [ i ] = a [ i - 1 ] + ( val * product ) ; } for ( int i = 0 ; i < N ; i ++ ) System . out . print ( a [ i ] + "" "" ) ; }"
static int nthEven ( int n ) { return ( 2 * n ) ; }
"static int solve ( int x , int y ) { int cnt = 0 ; if ( x == 1 && y == 1 ) return 0 ; while ( true ) { if ( x == 0 || y == 0 ) return Integer . MAX_VALUE ; if ( x == 1 || y == 1 ) return ( cnt + Math . max ( x , y ) - 1 ) ; if ( x > y ) x -= y ; else y -= x ; cnt ++ ; } }"
"static int countX ( int n ) { String binary = Integer . toBinaryString ( n ) ; int count = 0 ; for ( int i = 0 ; i < binary . length ( ) ; i ++ ) { if ( binary . charAt ( i ) == '1' ) count ++ ; } int answer = ( int ) Math . pow ( 2 , count ) ; return answer ; }"
"int minDist ( int arr [ ] , int n , int x , int y ) { int i , j ; int min_dist = Integer . MAX_VALUE ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( ( x == arr [ i ] && y == arr [ j ] || y == arr [ i ] && x == arr [ j ] ) && min_dist > Math . abs ( i - j ) ) min_dist = Math . abs ( i - j ) ; } } return min_dist ; }"
static double heptdiagonal ( double a ) { if ( a < 0 ) return - 1 ; double d = 1.802 * a ; return d ; }
"static int maxDiff ( int arr [ ] , int n ) { int diff = arr [ 1 ] - arr [ 0 ] ; int curr_sum = diff ; int max_sum = curr_sum ; for ( int i = 1 ; i < n - 1 ; i ++ ) { diff = arr [ i + 1 ] - arr [ i ] ; if ( curr_sum > 0 ) curr_sum += diff ; else curr_sum = diff ; if ( curr_sum > max_sum ) max_sum = curr_sum ; } return max_sum ; }"
"static void concatenate ( char a [ ] , char b [ ] , char c [ ] , int n1 , int n2 ) { int i ; for ( i = 0 ; i < n1 ; i ++ ) { c [ i ] = a [ i ] ; } for ( int j = 0 ; j < n2 ; j ++ ) { c [ i ++ ] = b [ j ] ; } }"
"public static int countSubArrays ( int arr [ ] , int x ) { int count = 0 ; int start = - 1 , end = - 1 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] < x ) { if ( start == - 1 ) { start = i ; end = i ; } else { end = i ; } } else { if ( start != - 1 && end != - 1 ) { int length = end - start + 1 ; count = count + ( ( length * ( length + 1 ) ) / 2 ) ; } start = - 1 ; end = - 1 ; } } if ( start != - 1 && end != - 1 ) { int length = end - start + 1 ; count = count + ( ( length * ( length + 1 ) ) / 2 ) ; } return count ; }"
"static void pairs ( int arr [ ] , int n , int k ) { int smallest = Integer . MAX_VALUE ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) { if ( Math . abs ( arr [ i ] + arr [ j ] - k ) < smallest ) { smallest = Math . abs ( arr [ i ] + arr [ j ] - k ) ; count = 1 ; } else if ( Math . abs ( arr [ i ] + arr [ j ] - k ) == smallest ) count ++ ; } System . out . println ( ""Minimal Value = "" + smallest ) ; System . out . println ( ""Total Pairs = "" + count ) ; }"
"static int solve ( int [ ] A , int n ) { int i , cnt = 0 , j ; int [ ] parent = new int [ n + 1 ] ; int [ ] vis = new int [ n + 1 ] ; for ( i = 0 ; i < n + 1 ; i ++ ) { parent [ i ] = - 1 ; vis [ i ] = 0 ; } for ( i = 0 ; i < n ; i ++ ) { j = i ; if ( parent [ j ] == - 1 ) { while ( parent [ j ] == - 1 ) { parent [ j ] = i ; j = ( j + A [ j ] + 1 ) % n ; } if ( parent [ j ] == i ) { while ( vis [ j ] == 0 ) { vis [ j ] = 1 ; cnt ++ ; j = ( j + A [ j ] + 1 ) % n ; } } } } return cnt ; }"
static long evenFib ( int n ) { if ( n < 1 ) return n ; if ( n == 1 ) return 2 ; return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) ; }
"public static int solve ( int n , int s , boolean [ ] check ) { if ( n > 10 ) { return 0 ; } if ( s > n * ( n + 1 ) * ( 28 - n ) / 3 ) { return 0 ; } int a = s / n ; if ( a > 9 ) { a = 9 ; } if ( n == 1 ) { if ( s > 9 || check [ s ] ) { return 0 ; } else { return 1 ; } } int count = 0 ; for ( int i = a ; i >= 0 ; i -- ) { if ( check [ i ] ) { continue ; } check [ i ] = true ; count += solve ( n - 1 , s - i * n , check ) ; check [ i ] = false ; } return count ; }"
"static int smallestIndex ( int [ ] a , int n ) { int right1 = 0 , right0 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) right1 = i ; else right0 = i ; } return Math . min ( right1 , right0 ) ; }"
"static int findMinRooms ( String slots [ ] , int n , int m ) { int counts [ ] = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) counts [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( slots [ i ] . charAt ( j ) == '1' ) counts [ j ] ++ ; int max = - 1 ; for ( int i = 0 ; i < m ; i ++ ) if ( max < counts [ i ] ) max = counts [ i ] ; return max ; }"
static int summation ( int n ) { int abs_sum = n * ( n + 1 ) / 2 ; int sign = n + 1 % 2 == 0 ? 1 : - 1 ; int result_sum = sign * abs_sum ; return result_sum ; }
"static int maxProduct ( int [ ] arr , int n ) { if ( n < 3 ) return - 1 ; int max_product = Integer . MIN_VALUE ; for ( int i = 0 ; i < n - 2 ; i ++ ) for ( int j = i + 1 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) max_product = Math . max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) ; return max_product ; }"
static int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) sum += ( n / i ) * i ; return sum ; }
"static double sumProductDifference ( int a , int b , int c , int d , int e ) { double rootSum = ( double ) ( - 1 * b ) / a ; double rootProduct = ( double ) e / a ; return Math . abs ( rootSum - rootProduct ) ; }"
"static int MinOfCubed ( int k ) { if ( k < 8 ) return k ; int res = k ; for ( int i = 1 ; i <= k ; i ++ ) { if ( ( i * i * i ) > k ) return res ; res = Math . min ( res , MinOfCubed ( k - ( i * i * i ) ) + 1 ) ; } return res ; }"
"static int maxAbsDiff ( int arr [ ] , int n ) { int minEle = arr [ 0 ] ; int maxEle = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { minEle = Math . min ( minEle , arr [ i ] ) ; maxEle = Math . max ( maxEle , arr [ i ] ) ; } return ( maxEle - minEle ) ; }"
"static int isPossible ( int n , int index , int modulo , int M , int arr [ ] , int dp [ ] [ ] ) { modulo = ( ( modulo % M ) + M ) % M ; if ( index == n ) { if ( modulo == 0 ) { return 1 ; } return 0 ; } if ( dp [ index ] [ modulo ] != - 1 ) { return dp [ index ] [ modulo ] ; } int placeAdd = isPossible ( n , index + 1 , modulo + arr [ index ] , M , arr , dp ) ; int placeMinus = isPossible ( n , index + 1 , modulo - arr [ index ] , M , arr , dp ) ; int res = placeAdd ; dp [ index ] [ modulo ] = res ; return res ; }"
"private static char findExtraCharacter ( String s1 , String s2 ) { String smallStr ; String largeStr ; if ( s1 . length ( ) > s2 . length ( ) ) { smallStr = s2 ; largeStr = s1 ; } else { smallStr = s1 ; largeStr = s2 ; } int smallStrCodeTotal = 0 ; int largeStrCodeTotal = 0 ; int i = 0 ; for ( ; i < smallStr . length ( ) ; i ++ ) { smallStrCodeTotal += smallStr . charAt ( i ) ; largeStrCodeTotal += largeStr . charAt ( i ) ; } largeStrCodeTotal += largeStr . charAt ( i ) ; int intChar = largeStrCodeTotal - smallStrCodeTotal ; return ( char ) intChar ; }"
static int findSum ( int n ) { int [ ] [ ] arr = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) arr [ i ] [ j ] = Math . abs ( i - j ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += arr [ i ] [ j ] ; return sum ; }
"static void findCount ( int n ) { long a = 1 , b = 0 , c = 0 ; int x = n / 60 ; a = ( long ) Math . pow ( 32 , x ) ; x = 60 * x ; for ( int i = x + 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) { b += a ; a = 0 ; } if ( i % 5 == 0 ) { c += b ; b = 0 ; } if ( i % 12 == 0 ) { a += ( 2 * c ) ; c = 0 ; } } System . out . println ( ""a = "" + a + "", b = "" + b + "", c = "" + c ) ; }"
"static int getMaxValue ( int arr [ ] , int arr_size ) { int i , first , second ; if ( arr_size < 2 ) { return 0 ; } first = second = Integer . MIN_VALUE ; for ( i = 0 ; i < arr_size ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second && arr [ i ] != first ) { second = arr [ i ] ; } } if ( second == Integer . MIN_VALUE ) { return 0 ; } else { return second ; } }"
static int squareDigitSum ( String number ) { int summ = 0 ; int num = Integer . parseInt ( number ) ; int squareNum = num * num ; while ( squareNum > 0 ) { summ = summ + ( squareNum % 10 ) ; squareNum = squareNum / 10 ; } return summ ; }
static long oddNumSum ( int n ) { return ( n * ( 2 * n + 1 ) * ( 24 * n * n * n - 12 * n * n - 14 * n + 7 ) ) / 15 ; }
"public static int segments ( int n , int [ ] p , int m ) { HashMap < Integer , Integer > c = new HashMap < > ( ) ; c . put ( 0 , 1 ) ; boolean has = false ; int sum = 0 ; int ans = 0 ; for ( int r = 0 ; r < n ; r ++ ) { if ( p [ r ] < m ) sum -- ; else if ( p [ r ] > m ) sum ++ ; if ( p [ r ] == m ) has = true ; if ( has ) ans += ( c . get ( sum ) == null ? 0 : c . get ( sum ) ) + ( c . get ( sum - 1 ) == null ? 0 : c . get ( sum - 1 ) ) ; else c . put ( sum , c . get ( sum ) == null ? 1 : c . get ( sum ) + 1 ) ; } return ans ; }"
"static void printMatrix ( int n , int m ) { if ( n < 5 || m < 5 ) { System . out . print ( - 1 ) ; return ; } char [ ] s = ""aeiou"" . toCharArray ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { System . out . print ( s [ j % 5 ] + "" "" ) ; } System . out . println ( ) ; char c = s [ 0 ] ; for ( int k = 0 ; k < 4 ; k ++ ) { s [ k ] = s [ k + 1 ] ; } s [ 4 ] = c ; } }"
"private static int minBroadcastRange ( int [ ] houses , int [ ] towers ) { int n = houses . length ; int m = towers . length ; int leftTower = Integer . MIN_VALUE ; int rightTower = towers [ 0 ] ; int j = 0 , k = 0 ; int min_range = 0 ; while ( j < n ) { if ( houses [ j ] < rightTower ) { int left = houses [ j ] - leftTower ; int right = rightTower - houses [ j ] ; int local_max = left < right ? left : right ; if ( local_max > min_range ) min_range = local_max ; j ++ ; } else { leftTower = towers [ k ] ; if ( k < m - 1 ) { k ++ ; rightTower = towers [ k ] ; } else rightTower = Integer . MAX_VALUE ; } } return min_range ; }"
"static void findPhoneNumber ( int n ) { int temp = n ; int sum = 0 ; while ( temp != 0 ) { sum += temp % 10 ; temp = temp / 10 ; } if ( sum < 10 ) System . out . print ( n + ""0"" + sum ) ; else System . out . print ( n + """" + sum ) ; }"
"public static void printChar ( String str , int n ) { int [ ] freq = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ str . charAt ( i ) - 'a' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str . charAt ( i ) - 'a' ] % 2 == 1 ) { System . out . print ( str . charAt ( i ) ) ; } } }"
"static int solve ( int [ ] arr , int n ) { int k = arr . length ; int mp [ ] = new int [ n + 2 ] ; for ( int i = 0 ; i <= n ; i ++ ) { mp [ i ] = 0 ; } for ( int i = 0 ; i < k ; i ++ ) { mp [ arr [ i ] ] = 1 ; } int leftSegment = arr [ 0 ] - 1 ; for ( int i = 1 ; i < k ; i ++ ) { leftSegment = Math . max ( leftSegment , arr [ i ] - arr [ i - 1 ] - 1 ) ; } int rightSegment = n - arr [ k - 1 ] ; int maxSegment = Math . max ( leftSegment , rightSegment ) ; int tim ; if ( ( maxSegment & 1 ) == 1 ) tim = ( maxSegment / 2 ) + 1 ; else tim = maxSegment / 2 ; return tim ; }"
"static int cntSquares ( int n ) { int squares = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { squares += Math . pow ( i , 2 ) ; } return squares ; }"
"static int findLastIndex ( String str , Character x ) { for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) if ( str . charAt ( i ) == x ) return i ; return - 1 ; }"
"static int LongestSubarray ( int [ ] arr , int n , int k ) { int [ ] arr2 = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) arr2 [ i ] = arr [ i ] % k ; int current_length , max_length = 0 ; int j ; for ( int i = 0 ; i < n ; ) { current_length = 1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr2 [ j ] == arr2 [ i ] ) current_length ++ ; else break ; } max_length = Math . max ( max_length , current_length ) ; i = j ; } return max_length ; }"
"static Character findKthChar ( String s , int k ) { int len = s . length ( ) ; int i = 0 ; int total_len = 0 ; while ( i < len ) { if ( Character . isLetter ( s . charAt ( i ) ) ) { total_len ++ ; if ( total_len == k ) return s . charAt ( i ) ; i ++ ; } else { int n = 0 ; while ( i < len && ! Character . isLetter ( s . charAt ( i ) ) ) { n = n * 10 + ( s . charAt ( i ) - '0' ) ; i ++ ; } int next_total_len = total_len * n ; if ( k <= next_total_len ) { int pos = k % total_len ; if ( pos == 0 ) { pos = total_len ; } return findKthChar ( s , pos ) ; } else { total_len = next_total_len ; } } } return ' ' ; }"
"static boolean search ( int mat [ ] [ ] , int m , int n , int x ) { int i = m - 1 , j = 0 ; while ( i >= 0 && j < n ) { if ( mat [ i ] [ j ] == x ) return true ; if ( mat [ i ] [ j ] > x ) i -- ; else j ++ ; } return false ; }"
"static void findMissing ( int a [ ] , int b [ ] , int n , int m ) { HashSet < Integer > s = new HashSet < > ( ) ; for ( int i = 0 ; i < m ; i ++ ) s . add ( b [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( ! s . contains ( a [ i ] ) ) System . out . print ( a [ i ] + "" "" ) ; }"
"static void solve ( int n ) { int n_2 = n / 2 ; String den ; den = ""1"" ; while ( n_2 -- > 0 ) den += '0' ; System . out . println ( 1 + ""/"" + den ) ; }"
"static void checkEqualMatrix ( int arr [ ] [ ] , int n , int m , int k ) { int c = 0 , cnt1 = 0 , cnt2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( c % 2 == 0 ) { if ( arr [ i ] [ j ] == k ) { cnt1 ++ ; } } else { if ( arr [ i ] [ j ] == k ) { cnt2 ++ ; } } c = c + 1 ; } } if ( cnt1 >= 1 && cnt2 >= 1 ) { System . out . println ( ""Yes"" ) ; } else { System . out . println ( ""No"" ) ; } }"
"static void printSum ( int m [ ] , int s [ ] , int n ) { int total = 0 ; for ( int i = 0 ; i < n ; i ++ ) { total += s [ i ] ; total += ( m [ i ] * 60 ) ; } System . out . print ( total / 3600 + "" : "" ) ; total %= 3600 ; System . out . print ( total / 60 + "": "" ) ; total %= 60 ; System . out . println ( total ) ; }"
"static int maxModValue ( int arr [ ] , int n ) { int ans = 0 ; Arrays . sort ( arr ) ; for ( int j = n - 2 ; j >= 0 ; -- j ) { if ( ans >= arr [ j ] ) break ; if ( arr [ j ] == arr [ j + 1 ] ) continue ; for ( int i = 2 * arr [ j ] ; i <= arr [ n - 1 ] + arr [ j ] ; i += arr [ j ] ) { int ind = Arrays . binarySearch ( arr , i ) ; if ( ind < 0 ) ind = Math . abs ( ind + 1 ) ; else { while ( arr [ ind ] == i ) { ind -- ; if ( ind == 0 ) { ind = - 1 ; break ; } } ind ++ ; } ans = Math . max ( ans , arr [ ind - 1 ] % arr [ j ] ) ; } } return ans ; }"
"static void printSeries ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { int num = i * ( i + 1 ) * ( i + 2 ) / 6 ; System . out . print ( num + "" "" ) ; } }"
static boolean getParity ( int n ) { boolean parity = false ; while ( n != 0 ) { parity = ! parity ; n = n & ( n - 1 ) ; } return parity ; }
"static void FindPoints ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y4 ) { int x5 = Math . max ( x1 , x3 ) ; int y5 = Math . max ( y1 , y3 ) ; int x6 = Math . min ( x2 , x4 ) ; int y6 = Math . min ( y2 , y4 ) ; if ( x5 > x6 || y5 > y6 ) { System . out . println ( ""No intersection"" ) ; return ; } System . out . print ( ""("" + x5 + "", "" + y5 + "") "" ) ; System . out . print ( ""("" + x6 + "", "" + y6 + "") "" ) ; int x7 = x5 ; int y7 = y6 ; System . out . print ( ""("" + x7 + "", "" + y7 + "") "" ) ; int x8 = x6 ; int y8 = y5 ; System . out . print ( ""("" + x8 + "", "" + y8 + "") "" ) ; }"
"static int getPassingCars ( int [ ] A , int n ) { int result = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( A [ i ] == 0 ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( A [ j ] == 1 ) result ++ ; } } return result ; }"
"static int findMinCost ( int arr [ ] , int n , int choc_cost ) { int choc_buy = arr [ 0 ] ; int curr_choc = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int choc = arr [ i ] - arr [ i + 1 ] ; curr_choc += choc ; if ( curr_choc < 0 ) { choc_buy += Math . abs ( curr_choc ) ; curr_choc = 0 ; } } return choc_buy * choc_cost ; }"
"static void record_sum ( int record [ ] , int l , int r , int n , int adder ) { for ( int i = l ; i <= r ; i ++ ) { record [ i ] += adder ; } }"
"static int MatrixChainOrder ( int p [ ] , int n ) { int m [ ] [ ] = new int [ n ] [ n ] ; int i , j , k , L , q ; for ( i = 1 ; i < n ; i ++ ) m [ i ] [ i ] = 0 ; for ( L = 2 ; L < n ; L ++ ) { for ( i = 1 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( j == n ) continue ; m [ i ] [ j ] = Integer . MAX_VALUE ; for ( k = i ; k <= j - 1 ; k ++ ) { q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q ; } } } return m [ 1 ] [ n - 1 ] ; }"
"static int findAndSum ( int [ ] arr , int n ) { int sum = 0 ; int mul = 1 ; for ( int i = 0 ; i < 30 ; i ++ ) { boolean count_on = false ; int l = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) if ( count_on ) l ++ ; else { count_on = true ; l ++ ; } else if ( count_on ) { sum += ( ( mul * l * ( l + 1 ) ) / 2 ) ; count_on = false ; l = 0 ; } } if ( count_on ) { sum += ( ( mul * l * ( l + 1 ) ) / 2 ) ; count_on = false ; l = 0 ; } mul *= 2 ; } return sum ; }"
"static long nthTermOfTheSeries ( int n ) { long nthTerm ; if ( n % 2 == 0 ) nthTerm = ( long ) Math . pow ( n - 1 , 2 ) + n ; else nthTerm = ( long ) Math . pow ( n + 1 , 2 ) + n ; return nthTerm ; }"
"static void pythagoreanTriplets ( int limit ) { int a , b , c = 0 ; int m = 2 ; while ( c < limit ) { for ( int n = 1 ; n < m ; ++ n ) { a = m * m - n * n ; b = 2 * m * n ; c = m * m + n * n ; if ( c > limit ) break ; System . out . println ( a + "" "" + b + "" "" + c ) ; } m ++ ; } }"
"static int MinimumCost ( int a [ ] , int n , int x ) { for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = Math . min ( a [ i ] , 2 * a [ i - 1 ] ) ; } int ind = 0 ; int sum = 0 ; while ( x > 0 ) { if ( x != 0 ) sum += a [ ind ] ; ind ++ ; x = x >> 1 ; } return sum ; }"
static int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j * j <= i ; ++ j ) { if ( i % j == 0 ) { if ( i / j == j ) sum += j ; else sum += j + i / j ; } } } return sum ; }
"static String strBitwiseAND ( String [ ] arr , int n ) { String res = """" ; int smallest_size = Integer . MAX_VALUE ; int largest_size = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { StringBuilder temp = new StringBuilder ( ) ; temp . append ( arr [ i ] ) ; arr [ i ] = temp . reverse ( ) . toString ( ) ; smallest_size = Math . min ( smallest_size , arr [ i ] . length ( ) ) ; largest_size = Math . max ( largest_size , arr [ i ] . length ( ) ) ; } for ( int i = 0 ; i < smallest_size ; i ++ ) { boolean all_ones = true ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] . charAt ( i ) == '0' ) { all_ones = false ; break ; } } res += ( all_ones ? '1' : '0' ) ; } for ( int i = 0 ; i < largest_size - smallest_size ; i ++ ) res += '0' ; StringBuilder temp = new StringBuilder ( ) ; temp . append ( res ) ; res = temp . reverse ( ) . toString ( ) ; return res ; }"
"static int count9s ( char number [ ] ) { int n = number . length ; int d [ ] = new int [ 9 ] ; d [ 0 ] = 1 ; int result = 0 ; int mod_sum = 0 , continuous_zero = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( number [ i ] - '0' ) == 0 ) { continuous_zero ++ ; } else { continuous_zero = 0 ; } mod_sum += ( number [ i ] - '0' ) ; mod_sum %= 9 ; result += d [ mod_sum ] ; d [ mod_sum ] ++ ; result -= continuous_zero ; } return result ; }"
int pentagonalNum ( int n ) { return ( 3 * n * n - n ) / 2 ; }
static boolean isDivisible ( long n ) { while ( n / 100 > 0 ) { int last_digit = ( int ) n % 10 ; n /= 10 ; n += last_digit * 3 ; } return ( n % 29 == 0 ) ; }
"static void search ( int arr [ ] , int low , int high ) { if ( low > high ) return ; if ( low == high ) { System . out . printf ( ""The required element is %d "" , arr [ low ] ) ; return ; } int mid = ( low + high ) / 2 ; if ( mid % 2 == 0 ) { if ( arr [ mid ] == arr [ mid + 1 ] ) search ( arr , mid + 2 , high ) ; else search ( arr , low , mid ) ; } else { if ( arr [ mid ] == arr [ mid - 1 ] ) search ( arr , mid + 1 , high ) ; else search ( arr , low , mid - 1 ) ; } }"
"static int findSum ( int arr [ ] , int N ) { Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) mp . put ( arr [ i ] , mp . get ( arr [ i ] ) == null ? 1 : mp . get ( arr [ i ] ) + 1 ) ; int minFreq = Integer . MAX_VALUE ; minFreq = Collections . min ( mp . entrySet ( ) , Comparator . comparingInt ( Map . Entry :: getKey ) ) . getValue ( ) ; int sum = 0 ; for ( Map . Entry < Integer , Integer > entry : mp . entrySet ( ) ) { if ( entry . getValue ( ) == minFreq ) { sum += entry . getKey ( ) * entry . getValue ( ) ; } } return sum ; }"
"static long getNthTerm ( long N ) { return ( ( int ) Math . pow ( N , 2 ) + N + 1 ) ; }"
"static int compute ( int [ ] graph , int N ) { int count = 0 ; for ( int i = 1 ; i < 7 ; i ++ ) { if ( graph [ i ] == 0 ) count ++ ; } return count ; }"
"static void printHutStar ( int n ) { int i , j ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) System . out . print ( "" "" ) ; for ( j = 0 ; j < ( 2 * i + 1 ) ; j ++ ) System . out . print ( ""*"" ) ; System . out . println ( ) ; } for ( i = 0 ; i < 3 ; i ++ ) { for ( j = 0 ; j < 3 ; j ++ ) System . out . print ( ""*"" ) ; for ( j = 0 ; j < ( 2 * n - 7 ) ; j ++ ) System . out . print ( "" "" ) ; for ( j = 0 ; j < 3 ; j ++ ) System . out . print ( ""*"" ) ; System . out . println ( ) ; } }"
"static float findArea ( float a , float b , float c ) { if ( a < 0 || b < 0 || c < 0 || ( a + b <= c ) || a + c <= b || b + c <= a ) { System . out . println ( ""Not a valid triangle"" ) ; System . exit ( 0 ) ; } float s = ( a + b + c ) / 2 ; return ( float ) Math . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ; }"
"static boolean isSellingPossible ( int n , int a [ ] ) { int i , c25 = 0 , c50 = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 25 ) c25 ++ ; else if ( a [ i ] == 50 ) { c50 ++ ; if ( c25 == 0 ) break ; c25 -- ; } else { if ( c50 > 0 && c25 > 0 ) { c50 -- ; c25 -- ; } else if ( c25 >= 3 ) c25 -= 3 ; else break ; } } if ( i == n ) return true ; else return false ; }"
static int sumOfTheSeries ( int n ) { int sum_n = ( n * ( n + 1 ) / 2 ) ; int sum_sq_n = ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; return ( sum_n + sum_sq_n ) ; }
"public static int lenoflongestnonpalindrome ( String s ) { int max1 = 1 , len = 0 ; char [ ] new_str = s . toCharArray ( ) ; for ( int i = 0 ; i < new_str . length - 1 ; i ++ ) { if ( new_str [ i ] == new_str [ i + 1 ] ) len = 0 ; else if ( i > 0 && ( new_str [ i + 1 ] == new_str [ i - 1 ] ) ) len = 1 ; else len ++ ; max1 = Math . max ( max1 , len + 1 ) ; } if ( max1 == 1 ) return 0 ; else return max1 ; }"
"static int getRemainder ( int num , int divisor ) { return ( num - divisor * ( num / divisor ) ) ; }"
"public static void findFirstAndLast ( int arr [ ] , int x ) { int n = arr . length ; int first = - 1 , last = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( x != arr [ i ] ) continue ; if ( first == - 1 ) first = i ; last = i ; } if ( first != - 1 ) { System . out . println ( ""First Occurrence = "" + first ) ; System . out . println ( ""Last Occurrence = "" + last ) ; } else System . out . println ( ""Not Found"" ) ; }"
"static String repeat ( String s , int n ) { String s1 = s ; for ( int i = 1 ; i < n ; i ++ ) s += s1 ; return s ; }"
"static String areAllBitsSet ( int n ) { if ( n == 0 ) return ""No"" ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) return ""No"" ; n = n >> 1 ; } return ""Yes"" ; }"
"static boolean isSymmetric ( int mat [ ] [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) return false ; return true ; }"
"static int minNumber ( int a [ ] , int n , int x ) { Arrays . sort ( a ) ; int k ; for ( k = 0 ; a [ ( n ) / 2 ] != x ; k ++ ) { a [ n ++ ] = x ; Arrays . sort ( a ) ; } return k ; }"
"public static int counLastDigitK ( int low , int high , int k ) { int count = 0 ; for ( int i = low ; i <= high ; i ++ ) if ( i % 10 == k ) count ++ ; return count ; }"
"static int cntSubsets ( int [ ] arr , int n ) { int max = ( int ) Math . pow ( 2 , n ) ; int result = 0 ; for ( int i = 0 ; i < max ; i ++ ) { int counter = i ; if ( ( counter & ( counter >> 1 ) ) > 0 ) continue ; result ++ ; } return result ; }"
"static int frequency ( int a [ ] , int n , int x ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == x ) count ++ ; return count ; }"
"static void profitLoss ( int N , int M ) { if ( N == M ) System . out . print ( ""No Profit nor Loss"" ) ; else { float result = 0 ; result = ( float ) ( Math . abs ( N - M ) ) / M ; if ( N - M < 0 ) System . out . print ( ""Loss = -"" + result * 100 + ""%"" ) ; else System . out . print ( ""Profit = "" + result * 100 + ""%"" ) ; } }"
static boolean pronic_check ( int n ) { int x = ( int ) ( Math . sqrt ( n ) ) ; if ( x * ( x + 1 ) == n ) return true ; else return false ; }
public static boolean isPalindrome ( float num ) { String s = String . valueOf ( num ) ; int low = 0 ; int high = s . length ( ) - 1 ; while ( low < high ) { if ( s . charAt ( low ) != s . charAt ( high ) ) return false ; low ++ ; high -- ; } return true ; }
"static int countPairs ( int A , int B ) { int cnt = 0 ; for ( int i = 0 ; i <= A ; ++ i ) { for ( int j = i ; j <= A ; ++ j ) { int AND = i & j ; int OR = i | j ; if ( OR == A && AND == B ) { cnt ++ ; } } } return cnt ; }"
"static void LeadingZeros ( int x , int y ) { if ( ( x ^ y ) <= ( x & y ) ) System . out . print ( ""\nEqual"" ) ; else if ( ( x & ( ~ y ) ) > y ) System . out . print ( y ) ; else System . out . print ( x ) ; }"
"static int countSegments ( int a [ ] , int n , int x ) { boolean flag = false ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) { flag = true ; } else { if ( flag ) count += 1 ; flag = false ; } } if ( flag ) count += 1 ; return count ; }"
"static int perimeter ( int diameter , int height ) { return 2 * ( diameter + height ) ; }"
"static float rainDayProbability ( int a [ ] , int n ) { float count = 0 , m ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) count ++ ; } m = count / n ; return m ; }"
"public static void countCurrency ( int amount ) { int [ ] notes = new int [ ] { 2000 , 500 , 200 , 100 , 50 , 20 , 10 , 5 , 1 }; int [ ] noteCounter = new int [ 9 ] ; for ( int i = 0 ; i < 9 ; i ++ ) { if ( amount >= notes [ i ] ) { noteCounter [ i ] = amount / notes [ i ] ; amount = amount - noteCounter [ i ] * notes [ i ] ; } } System . out . println ( ""Currency Count ->"" ) ; for ( int i = 0 ; i < 9 ; i ++ ) { if ( noteCounter [ i ] != 0 ) { System . out . println ( notes [ i ] + "" : "" + noteCounter [ i ] ) ; } } }"
"static int insertSorted ( int arr [ ] , int n , int key , int capacity ) { if ( n >= capacity ) return n ; int i ; for ( i = n - 1 ; ( i >= 0 && arr [ i ] > key ) ; i -- ) arr [ i + 1 ] = arr [ i ] ; arr [ i + 1 ] = key ; return ( n + 1 ) ; }"
static long count_of_ways ( long n ) { long count = 0 ; count = ( n + 1 ) * ( n + 2 ) / 2 ; return count ; }
"static int minIncrementForUnique ( int [ ] A ) { HashMap < Integer , Integer > mpp = new HashMap < Integer , Integer > ( ) ; for ( int i : A ) { if ( mpp . containsKey ( i ) ) mpp . put ( i , mpp . get ( i ) + 1 ) ; else mpp . put ( i , 1 ) ; } Vector < Integer > taken = new Vector < Integer > ( ) ; int ans = 0 ; for ( int x = 0 ; x < 100000 ; x ++ ) { if ( mpp . containsKey ( x ) && mpp . get ( x ) >= 2 ) taken . add ( x * ( mpp . get ( x ) - 1 ) ) ; else if ( taken . size ( ) > 0 && ( ( mpp . containsKey ( x ) && mpp . get ( x ) == 0 ) || ! mpp . containsKey ( x ) ) ) { ans += x - taken . get ( taken . size ( ) - 1 ) ; taken . remove ( taken . size ( ) - 1 ) ; } } return ans ; }"
static long findSumSubsets ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ) ; }
"static void printSpiral ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int x ; x = Math . min ( Math . min ( i , j ) , Math . min ( n - 1 - i , n - 1 - j ) ) ; if ( i <= j ) System . out . print ( ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ) + ""\t"" ) ; else System . out . print ( ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) + ""\t"" ) ; } System . out . println ( ) ; } }"
"static int evaluateBoolExpr ( StringBuffer s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i += 2 ) { if ( i + 1 < n && i + 2 < n ) { if ( s . charAt ( i + 1 ) == 'A' ) { if ( s . charAt ( i + 2 ) == '0' || s . charAt ( i ) == 0 ) s . setCharAt ( i + 2 , '0' ) ; else s . setCharAt ( i + 2 , '1' ) ; } else if ( ( i + 1 ) < n && s . charAt ( i + 1 ) == 'B' ) { if ( s . charAt ( i + 2 ) == '1' || s . charAt ( i ) == '1' ) s . setCharAt ( i + 2 , '1' ) ; else s . setCharAt ( i + 2 , '0' ) ; } else { if ( s . charAt ( i + 2 ) == s . charAt ( i ) ) s . setCharAt ( i + 2 , '0' ) ; else s . setCharAt ( i + 2 , '1' ) ; } } } return s . charAt ( n - 1 ) - '0' ; }"
static int addOne ( int x ) { int m = 1 ; while ( ( int ) ( x & m ) >= 1 ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }
"static int minimumProduct ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; int product = 1 ; for ( int i = 0 ; i < n ; i += 2 ) { product *= ( arr [ i ] + arr [ i + 1 ] ) ; } return product ; }"
"public static int calculateEnergy ( int mat [ ] [ ] , int n ) { int i_des , j_des , q ; int tot_energy = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { q = mat [ i ] [ j ] / n ; i_des = q ; j_des = mat [ i ] [ j ] - ( n * q ) ; tot_energy += Math . abs ( i_des - i ) + Math . abs ( j_des - j ) ; } } return tot_energy ; }"
"static long getSum ( int n , int d ) { long sum = 0 ; while ( d <= n ) { sum += d ; d += 10 ; } return sum ; }"
"void printRepeating ( int arr [ ] , int size ) { int i ; System . out . println ( ""The repeating elements are : "" ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ Math . abs ( arr [ i ] ) ] > 0 ) arr [ Math . abs ( arr [ i ] ) ] = - arr [ Math . abs ( arr [ i ] ) ] ; else System . out . print ( Math . abs ( arr [ i ] ) + "" "" ) ; } }"
"static void solveWordWrap ( int arr [ ] , int n , int k ) { int i , j ; int currlen ; int cost ; int dp [ ] = new int [ n ] ; int ans [ ] = new int [ n ] ; dp [ n - 1 ] = 0 ; ans [ n - 1 ] = n - 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) { currlen = - 1 ; dp [ i ] = Integer . MAX_VALUE ; for ( j = i ; j < n ; j ++ ) { currlen += ( arr [ j ] + 1 ) ; if ( currlen > k ) break ; if ( j == n - 1 ) cost = 0 ; else cost = ( k - currlen ) * ( k - currlen ) + dp [ j + 1 ] ; if ( cost < dp [ i ] ) { dp [ i ] = cost ; ans [ i ] = j ; } } } i = 0 ; while ( i < n ) { System . out . print ( ( i + 1 ) + "" "" + ( ans [ i ] + 1 ) + "" "" ) ; i = ans [ i ] + 1 ; } }"
"static void shufleArray ( int a [ ] , int f , int l ) { if ( l > f ) return ; if ( l - f == 1 ) return ; int mid = ( f + l ) / 2 ; int temp = mid + 1 ; int mmid = ( f + mid ) / 2 ; for ( int i = mmid + 1 ; i <= mid ; i ++ ) { int temp1 = a [ i ] ; a [ i ] = a [ temp ] ; a [ temp ++ ] = temp1 ; } shufleArray ( a , f , mid ) ; shufleArray ( a , mid + 1 , l ) ; }"
"static int getTotalXorOfSubarrayXors ( int arr [ ] , int N ) { if ( N % 2 == 0 ) return 0 ; int res = 0 ; for ( int i = 0 ; i < N ; i += 2 ) res ^= arr [ i ] ; return res ; }"
"static void spiralFill ( int m , int n , int a [ ] [ ] ) { int val = 1 ; int k = 0 , l = 0 ; while ( k < m && l < n ) { for ( int i = l ; i < n ; ++ i ) { a [ k ] [ i ] = val ++ ; } k ++ ; for ( int i = k ; i < m ; ++ i ) { a [ i ] [ n - 1 ] = val ++ ; } n -- ; if ( k < m ) { for ( int i = n - 1 ; i >= l ; -- i ) { a [ m - 1 ] [ i ] = val ++ ; } m -- ; } if ( l < n ) { for ( int i = m - 1 ; i >= k ; -- i ) { a [ i ] [ l ] = val ++ ; } l ++ ; } } }"
"public static boolean isFascinating ( int num ) { int [ ] freq = new int [ 10 ] ; String val = """" + num + num * 2 + num * 3 ; for ( int i = 0 ; i < val . length ( ) ; i ++ ) { int digit = val . charAt ( i ) - '0' ; if ( freq [ digit ] > 0 ) return false ; else freq [ digit ] ++ ; } for ( int i = 1 ; i < freq . length ; i ++ ) { if ( freq [ i ] == 0 ) return false ; } return true ; }"
"static int divCount ( int n ) { boolean hash [ ] = new boolean [ n + 1 ] ; Arrays . fill ( hash , true ) ; for ( int p = 2 ; p * p < n ; p ++ ) if ( hash [ p ] == true ) for ( int i = p * 2 ; i < n ; i += p ) hash [ i ] = false ; int total = 1 ; for ( int p = 2 ; p <= n ; p ++ ) { if ( hash [ p ] ) { int count = 0 ; if ( n % p == 0 ) { while ( n % p == 0 ) { n = n / p ; count ++ ; } total = total * ( count + 1 ) ; } } } return total ; }"
static void printNumber ( int n ) { int count [ ] = new int [ 10 ] ; while ( n > 0 ) { count [ n % 10 ] ++ ; n /= 10 ; } for ( int i = 1 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < count [ i ] * i ; j ++ ) System . out . print ( i ) ; } }
"static int countOdd ( int L , int R ) { int N = ( R - L ) / 2 ; if ( R % 2 != 0 || L % 2 != 0 ) N ++ ; return N ; }"
"static void pattern ( int min_stars , int p_height ) { int p_space ; p_space = p_height - 1 ; int i , j , k , n , x ; x = 1 ; for ( i = 0 ; i < p_height ; i ++ ) { for ( j = p_space ; j > i ; j -- ) { System . out . print ( "" "" ) ; } for ( k = 0 ; k < min_stars ; k ++ ) System . out . print ( ""*"" ) ; for ( n = ( p_height + p_height - 2 ) ; n >= x ; n -- ) System . out . print ( "" "" ) ; for ( k = 0 ; k < min_stars ; k ++ ) System . out . print ( ""*"" ) ; min_stars = min_stars + 2 ; x = x + 2 ; System . out . println ( ) ; } }"
"static boolean isSubArray ( int A [ ] , int B [ ] , int n , int m ) { int i = 0 , j = 0 ; while ( i < n && j < m ) { if ( A [ i ] == B [ j ] ) { i ++ ; j ++ ; if ( j == m ) return true ; } else { i = i - j + 1 ; j = 0 ; } } return false ; }"
"private static void search ( int [ ] [ ] mat , int n , int x ) { int i = 0 , j = n - 1 ; while ( i < n && j >= 0 ) { if ( mat [ i ] [ j ] == x ) { System . out . print ( ""n Found at "" + i + "" "" + j ) ; return ; } if ( mat [ i ] [ j ] > x ) j -- ; else i ++ ; } System . out . print ( ""n Element not found"" ) ; return ; }"
"static int maxProduct ( int arr [ ] , int n ) { if ( n < 3 ) { return - 1 ; } Arrays . sort ( arr ) ; return Math . max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) ; }"
"static int nthTerm ( int n ) { return 2 * ( int ) Math . pow ( n , 2 ) - n - 1 ; }"
"int getNthUglyNo ( int n ) { int ugly [ ] = new int [ n ] ; int i2 = 0 , i3 = 0 , i5 = 0 ; int next_multiple_of_2 = 2 ; int next_multiple_of_3 = 3 ; int next_multiple_of_5 = 5 ; int next_ugly_no = 1 ; ugly [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { next_ugly_no = Math . min ( next_multiple_of_2 , Math . min ( next_multiple_of_3 , next_multiple_of_5 ) ) ; ugly [ i ] = next_ugly_no ; if ( next_ugly_no == next_multiple_of_2 ) { i2 = i2 + 1 ; next_multiple_of_2 = ugly [ i2 ] * 2 ; } if ( next_ugly_no == next_multiple_of_3 ) { i3 = i3 + 1 ; next_multiple_of_3 = ugly [ i3 ] * 3 ; } if ( next_ugly_no == next_multiple_of_5 ) { i5 = i5 + 1 ; next_multiple_of_5 = ugly [ i5 ] * 5 ; } } return next_ugly_no ; }"
"public static void kLargest ( Integer [ ] arr , int k ) { Arrays . sort ( arr , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < k ; i ++ ) System . out . print ( arr [ i ] + "" "" ) ; }"
"static void compute ( long S , long X ) { long A = ( S - X ) / 2 ; int a = 0 , b = 0 ; final int LONG_FIELD_SIZE = 8 ; for ( int i = 0 ; i < 8 * LONG_FIELD_SIZE ; i ++ ) { long Xi = ( X & ( 1 << i ) ) ; long Ai = ( A & ( 1 << i ) ) ; if ( Xi == 0 && Ai == 0 ) { } else if ( Xi == 0 && Ai > 0 ) { a = ( ( 1 << i ) | a ) ; b = ( ( 1 << i ) | b ) ; } else if ( Xi > 0 && Ai == 0 ) { a = ( ( 1 << i ) | a ) ; } else { System . out . println ( ""Not Possible"" ) ; return ; } } System . out . println ( ""a = "" + a + ""\nb = "" + b ) ; }"
"static int findevenPair ( int [ ] A , int N ) { int i , j ; int evenPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] & A [ j ] ) % 2 == 0 ) evenPair ++ ; } } return evenPair ; }"
static int firstFactorialDivisibleNumber ( int x ) { int i = 1 ; int fact = 1 ; for ( i = 1 ; i < x ; i ++ ) { fact = fact * i ; if ( fact % x == 0 ) break ; } return i ; }
"static void findMajority ( int arr [ ] , int n ) { int len = 32 ; int number = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) != 0 ) count ++ ; } if ( count > ( n / 2 ) ) number += ( 1 << i ) ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == number ) count ++ ; if ( count > ( n / 2 ) ) System . out . println ( number ) ; else System . out . println ( ""Majority Element Not Present"" ) ; }"
static int findStarNum ( int n ) { return ( 6 * n * ( n - 1 ) + 1 ) ; }
"static int findLongestRepeatingSubSeq ( String str ) { int n = str . length ( ) ; int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } return dp [ n ] [ n ] ; }"
"static String find_Square_369 ( String num ) { char a , b , c , d ; if ( num . charAt ( 0 ) == '3' ) { a = '1' ; b = '0' ; c = '8' ; d = '9' ; } else if ( num . charAt ( 0 ) == '6' ) { a = '4' ; b = '3' ; c = '5' ; d = '6' ; } else { a = '9' ; b = '8' ; c = '0' ; d = '1' ; } String result = """" ; int size = num . length ( ) ; for ( int i = 1 ; i < size ; i ++ ) result += a ; result += b ; for ( int i = 1 ; i < size ; i ++ ) result += c ; result += d ; return result ; }"
static boolean isNumber ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( Character . isDigit ( s . charAt ( i ) ) == false ) return false ; return true ; }
"static float kPresentProbability ( int a [ ] , int n , int k ) { float count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == k ) count ++ ; return count / n ; }"
"static String lexNext ( String str , int n ) { char [ ] s = str . toCharArray ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] != 'z' ) { s [ i ] ++ ; return String . valueOf ( s ) ; } s [ i ] = 'a' ; } return null ; }"
static int oddTriangularNumber ( int N ) { return ( N * ( ( 2 * N ) - 1 ) ) ; }
"static int minimumChar ( String S1 , String S2 ) { int n = S1 . length ( ) ; int m = S2 . length ( ) ; int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < m - n + 1 ; i ++ ) { int minRemovedChar = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( S1 . charAt ( j ) != S2 . charAt ( i + j ) ) { minRemovedChar ++ ; } } ans = Math . min ( minRemovedChar , ans ) ; } return ans ; }"
"static float calc_Expectation ( float a [ ] , float n ) { float prb = ( 1 / n ) ; float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] * prb ; return sum ; }"
"static long subarrayXor ( int arr [ ] , int n , int m ) { long ans = 0 ; int [ ] xorArr = new int [ n ] ; HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; xorArr [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) xorArr [ i ] = xorArr [ i - 1 ] ^ arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { int tmp = m ^ xorArr [ i ] ; ans = ans + ( mp . containsKey ( tmp ) == false ? 0 : ( ( long ) mp . get ( tmp ) ) ) ; if ( xorArr [ i ] == m ) ans ++ ; if ( mp . containsKey ( xorArr [ i ] ) ) mp . put ( xorArr [ i ] , mp . get ( xorArr [ i ] ) + 1 ) ; else mp . put ( xorArr [ i ] , 1 ) ; } return ans ; }"
"static String isEvenOrOdd ( int L , int R ) { int oddCount = ( R - L ) / 2 ; if ( R % 2 == 1 || L % 2 == 1 ) oddCount ++ ; if ( oddCount % 2 == 0 ) return ""Even"" ; else return ""Odd"" ; }"
private static int maxConsecutiveOnes ( int x ) { int count = 0 ; while ( x != 0 ) { x = ( x & ( x << 1 ) ) ; count ++ ; } return count ; }
"static int get ( int x , int y , int z ) { if ( x > z ) return - 1 ; int val = z - x ; int div = ( z - x ) / y ; int ans = div * y + x ; return ans ; }"
"static int count ( int x , int y ) { int ans = 0 ; Map < Integer , Integer > m = new HashMap < > ( ) ; while ( x % y != 0 ) { x = x % y ; ans ++ ; if ( m . containsKey ( x ) ) return - 1 ; m . put ( x , 1 ) ; x = x * 10 ; } return ans ; }"
static boolean checkJumbled ( int num ) { if ( num / 10 == 0 ) return true ; while ( num != 0 ) { if ( num / 10 == 0 ) return true ; int digit1 = num % 10 ; int digit2 = ( num / 10 ) % 10 ; if ( Math . abs ( digit2 - digit1 ) > 1 ) return false ; num = num / 10 ; } return true ; }
"static int nthTerm ( int n ) { return ( int ) Math . pow ( n , 2 ) + 2 * n + 2 ; }"
"static void findLarger ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = n - 1 ; i >= n / 2 ; i -- ) System . out . print ( arr [ i ] + "" "" ) ; }"
"public static int middleOfThree ( int a , int b , int c ) { if ( ( a < b && b < c ) || ( c < b && b < a ) ) return b ; else if ( ( b < a && a < c ) || ( c < a && a < b ) ) return a ; else return c ; }"
static long partitions ( int n ) { long p [ ] = new long [ n + 1 ] ; p [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int k = 1 ; while ( ( k * ( 3 * k - 1 ) ) / 2 <= i ) { p [ i ] += ( k % 2 != 0 ? 1 : - 1 ) * p [ i - ( k * ( 3 * k - 1 ) ) / 2 ] ; if ( k > 0 ) { k *= - 1 ; } else { k = 1 - k ; } } } return p [ n ] ; }
"static int numberOfDays ( int a , int b , int n ) { int Days = b * ( n + a ) / ( a + b ) ; return Days ; }"
"static int countFibs ( int low , int high ) { int f1 = 0 , f2 = 1 , f3 = 1 ; int result = 0 ; while ( f1 <= high ) { if ( f1 >= low ) result ++ ; f1 = f2 ; f2 = f3 ; f3 = f1 + f2 ; } return result ; }"
"static void ReplaceElements ( int arr [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , 1 ) ; } else { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } } for ( int i = 0 ; i < n ; ++ i ) { arr [ i ] = n - mp . get ( arr [ i ] ) ; } }"
"static int countNum ( int [ ] arr , int n ) { int count = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i + 1 ] - 1 ) count += arr [ i + 1 ] - arr [ i ] - 1 ; return count ; }"
"static float sumOfAP ( float a , float d , float n ) { float sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d ) ; return sum ; }"
static int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= n ; j ++ ) sum = sum + i * j ; return sum ; }
"static int findSum ( int n ) { int ans = 0 , temp = 0 , num ; for ( int i = 1 ; i <= n && temp < n ; i ++ ) { temp = i - 1 ; num = 1 ; while ( temp < n ) { if ( temp + i <= n ) ans += ( i * num ) ; else ans += ( ( n - temp ) * num ) ; temp += i ; num ++ ; } } return ans ; }"
"public static int findMinRec ( int A [ ] , int n ) { if ( n == 1 ) return A [ 0 ] ; return Math . min ( A [ n - 1 ] , findMinRec ( A , n - 1 ) ) ; }"
static int findTrailingZeros ( int n ) { int count = 0 ; for ( int i = 5 ; n / i >= 1 ; i *= 5 ) count += n / i ; return count ; }
"static int minimumDeletions ( int a [ ] , int n ) { if ( n <= 2 ) return 0 ; int count = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( ( a [ i ] < a [ i + 1 ] && a [ i + 1 ] < a [ i + 2 ] ) || ( a [ i ] > a [ i + 1 ] && a [ i + 1 ] > a [ i + 2 ] ) ) count ++ ; } return count ; }"
"public static void amendSentence ( String sstr ) { char [ ] str = sstr . toCharArray ( ) ; for ( int i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) { str [ i ] = ( char ) ( str [ i ] + 32 ) ; if ( i != 0 ) System . out . print ( "" "" ) ; System . out . print ( str [ i ] ) ; } else System . out . print ( str [ i ] ) ; } }"
"static void findTriplets ( int [ ] arr , int n ) { boolean found = true ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] + arr [ k ] == 0 ) { System . out . print ( arr [ i ] ) ; System . out . print ( "" "" ) ; System . out . print ( arr [ j ] ) ; System . out . print ( "" "" ) ; System . out . print ( arr [ k ] ) ; System . out . print ( ""\n"" ) ; found = true ; } } } } if ( found == false ) System . out . println ( "" not exist "" ) ; }"
"static void ReplaceElements ( int [ ] arr , int n ) { if ( n <= 1 ) return ; int prev = arr [ 0 ] ; arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int curr = arr [ i ] ; arr [ i ] = prev ^ arr [ i + 1 ] ; prev = curr ; } arr [ n - 1 ] = prev ^ arr [ n - 1 ] ; }"
"static int alternate ( int a , int b , int x ) { return x = a ^ b ^ x ; }"
"static void printPrevSmaller ( int [ ] arr , int n ) { System . out . print ( ""_, "" ) ; for ( int i = 1 ; i < n ; i ++ ) { int j ; for ( j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ j ] < arr [ i ] ) { System . out . print ( arr [ j ] + "", "" ) ; break ; } } if ( j == - 1 ) System . out . print ( ""_, "" ) ; } }"
"static void printAsMaximalPrimeSum ( int n ) { if ( n % 2 == 1 ) { System . out . print ( ""3 "" ) ; n -= 3 ; } while ( n > 0 ) { System . out . print ( ""2 "" ) ; n -= 2 ; } }"
"static void convert12 ( String str ) { int h1 = ( int ) str . charAt ( 0 ) - '0' ; int h2 = ( int ) str . charAt ( 1 ) - '0' ; int hh = h1 * 10 + h2 ; String Meridien ; if ( hh < 12 ) { Meridien = ""AM"" ; } else Meridien = ""PM"" ; hh %= 12 ; if ( hh == 0 ) { System . out . print ( ""12"" ) ; for ( int i = 2 ; i < 8 ; ++ i ) { System . out . print ( str . charAt ( i ) ) ; } } else { System . out . print ( hh ) ; for ( int i = 2 ; i < 8 ; ++ i ) { System . out . print ( str . charAt ( i ) ) ; } } System . out . println ( "" "" + Meridien ) ; }"
static int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ; return sum ; }
"static float findWater ( int i , int j , float X ) { if ( j > i ) { System . out . println ( ""Incorrect Input"" ) ; System . exit ( 0 ) ; } int ll = Math . round ( ( i * ( i + 1 ) ) ) ; float [ ] glass = new float [ ll + 2 ] ; int index = 0 ; glass [ index ] = X ; for ( int row = 1 ; row <= i ; ++ row ) { for ( int col = 1 ; col <= row ; ++ col , ++ index ) { X = glass [ index ] ; glass [ index ] = ( X >= 1.0f ) ? 1.0f : X ; X = ( X >= 1.0f ) ? ( X - 1 ) : 0.0f ; glass [ index + row ] += X / 2 ; glass [ index + row + 1 ] += X / 2 ; } } return glass [ ( int ) ( i * ( i - 1 ) / 2 + j - 1 ) ] ; }"
"static void reduceArray ( int arr [ ] , int n , int K ) { Vector < Integer > vec = new Vector < Integer > ( ) ; int size = 0 ; int curr_ele = arr [ 0 ] , curr_freq = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( curr_ele == arr [ i ] && curr_freq <= K ) { vec . add ( arr [ i ] ) ; size ++ ; } else if ( curr_ele != arr [ i ] ) { curr_ele = arr [ i ] ; vec . add ( arr [ i ] ) ; size ++ ; curr_freq = 1 ; } curr_freq ++ ; } System . out . print ( ""{"" ) ; for ( int i = 0 ; i < size ; i ++ ) { System . out . print ( vec . get ( i ) + "", "" ) ; } System . out . print ( ""}"" ) ; }"
"static void printNos ( int n ) { if ( n > 0 ) { printNos ( n - 1 ) ; System . out . print ( n + "" "" ) ; } return ; }"
static boolean check ( String s ) { for ( int i = 0 ; i < s . length ( ) - 1 ; i ++ ) if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) return true ; return false ; }
"static void complement ( String number1 ) { char [ ] number = number1 . toCharArray ( ) ; for ( int i = 0 ; i < number . length ; i ++ ) if ( number [ i ] != '.' ) number [ i ] = ( char ) ( ( int ) ( '9' ) - ( int ) ( number [ i ] ) + ( int ) ( '0' ) ) ; System . out . println ( ""9's complement is : "" + String . valueOf ( number ) ) ; }"
public static double sumOfTheSeries ( int n ) { return ( double ) n / ( n + 1 ) ; }
"static int minJumps ( int arr [ ] , int l , int h ) { if ( h == l ) return 0 ; if ( arr [ l ] == 0 ) return Integer . MAX_VALUE ; int min = Integer . MAX_VALUE ; for ( int i = l + 1 ; i <= h && i <= l + arr [ l ] ; i ++ ) { int jumps = minJumps ( arr , i , h ) ; if ( jumps != Integer . MAX_VALUE && jumps + 1 < min ) min = jumps + 1 ; } return min ; }"
"static int findMinDel ( int [ ] arr , int n ) { int min_num = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) min_num = Math . min ( arr [ i ] , min_num ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == min_num ) cnt ++ ; return n - cnt ; }"
"static int LISusingLCS ( Vector < Integer > seq ) { int n = seq . size ( ) ; int L [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; Vector < Integer > sortedseq = new Vector < Integer > ( seq ) ; Collections . sort ( sortedseq ) ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 || j == 0 ) L [ i ] [ j ] = 0 ; else if ( seq . get ( i - 1 ) == sortedseq . get ( j - 1 ) ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = Math . max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ n ] [ n ] ; }"
"static int KthMinValAfterMconcatenate ( int [ ] A , int N , int M , int K ) { ArrayList V = new ArrayList ( ) ; for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { V . add ( A [ j ] ) ; } } Collections . sort ( V ) ; return ( ( int ) V . get ( K - 1 ) ) ; }"
static int findThirdDigit ( int n ) { if ( n < 3 ) return 0 ; return ( n & 1 ) > 0 ? 1 : 6 ; }
"static int countDivisibles ( int A , int B , int M ) { int counter = 0 ; for ( int i = A ; i <= B ; i ++ ) if ( i % M == 0 ) counter ++ ; return counter ; }"
"static boolean isPossible ( int a [ ] , int n ) { int cur = a [ 0 ] ; cur -- ; for ( int i = 1 ; i < n ; i ++ ) { int nxt = a [ i ] ; if ( nxt > cur ) nxt -- ; else if ( nxt < cur ) return false ; cur = nxt ; } return true ; }"
"static int maxval ( int a [ ] , int n ) { if ( n < 2 ) { return - 99999 ; } int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int x = ( a [ i ] + i ) * ( a [ j ] + j ) ; if ( max < x ) { max = x ; } } } return max ; }"
public static double hexagonArea ( double s ) { return ( ( 3 * Math . sqrt ( 3 ) * ( s * s ) ) / 2 ) ; }
"static int count_pairs ( int a [ ] , int b [ ] , int n , int m ) { int odd1 = 0 , even1 = 0 ; int odd2 = 0 , even2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) odd1 ++ ; else even1 ++ ; } for ( int i = 0 ; i < m ; i ++ ) { if ( b [ i ] % 2 == 1 ) odd2 ++ ; else even2 ++ ; } int pairs = Math . min ( odd1 , odd2 ) + Math . min ( even1 , even2 ) ; return pairs ; }"
"static void towerOfHanoi ( int n , char from_rod , char to_rod , char aux_rod1 , char aux_rod2 ) { if ( n == 0 ) return ; if ( n == 1 ) { System . out . println ( ""Move disk "" + n + "" from rod "" + from_rod + "" to rod "" + to_rod ) ; return ; } towerOfHanoi ( n - 2 , from_rod , aux_rod1 , aux_rod2 , to_rod ) ; System . out . println ( ""Move disk "" + ( n - 1 ) + "" from rod "" + from_rod + "" to rod "" + aux_rod2 ) ; System . out . println ( ""Move disk "" + n + "" from rod "" + from_rod + "" to rod "" + to_rod ) ; System . out . println ( ""Move disk "" + ( n - 1 ) + "" from rod "" + aux_rod2 + "" to rod "" + to_rod ) ; towerOfHanoi ( n - 2 , aux_rod1 , to_rod , from_rod , aux_rod2 ) ; }"
"public static long SubArraySum ( int arr [ ] , int n ) { long result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += ( arr [ i ] * ( i + 1 ) * ( n - i ) ) ; return result ; }"
"static String revAlternateK ( String s , int k , int len ) { for ( int i = 0 ; i < s . length ( ) ; ) { if ( i + k > len ) break ; s = s . substring ( 0 , i ) + new String ( new StringBuilder ( s . substring ( i , i + k ) ) . reverse ( ) ) + s . substring ( i + k ) ; i += 2 * k ; } return s ; }"
"static int countOps ( int A [ ] [ ] , int B [ ] [ ] , int m , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) A [ i ] [ j ] -= B [ i ] [ j ] ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 1 ; j < m ; j ++ ) if ( A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j ] + A [ 0 ] [ 0 ] != 0 ) return - 1 ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += Math . abs ( A [ i ] [ 0 ] ) ; for ( int j = 0 ; j < m ; j ++ ) result += Math . abs ( A [ 0 ] [ j ] - A [ 0 ] [ 0 ] ) ; return ( result ) ; }"
"static double findHypotenuse ( double side1 , double side2 ) { double h = Math . sqrt ( ( side1 * side1 ) + ( side2 * side2 ) ) ; return h ; }"
"public static void leyland ( int n ) { List < Integer > ans = new ArrayList < Integer > ( ) ; for ( int x = 2 ; x <= n ; x ++ ) { for ( int y = 2 ; y <= x ; y ++ ) { int temp = ( int ) Math . pow ( x , y ) + ( int ) Math . pow ( y , x ) ; ans . add ( temp ) ; } } Collections . sort ( ans ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( ans . get ( i ) + "" "" ) ; }"
"static int Subtract ( int a , int b ) { int c ; c = a + ( ~ b + 1 ) ; return c ; }"
"static int numberSequence ( int n ) { int num = ( int ) ( Math . pow ( 4 , n ) - Math . pow ( 2 , n ) ) - 1 ; return num ; }"
"static void bitonicGenerator ( int arr [ ] , int n ) { Vector < Integer > evenArr = new Vector < Integer > ( ) ; Vector < Integer > oddArr = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 != 1 ) { evenArr . add ( arr [ i ] ) ; } else { oddArr . add ( arr [ i ] ) ; } } Collections . sort ( evenArr ) ; Collections . sort ( oddArr , Collections . reverseOrder ( ) ) ; int i = 0 ; for ( int j = 0 ; j < evenArr . size ( ) ; j ++ ) { arr [ i ++ ] = evenArr . get ( j ) ; } for ( int j = 0 ; j < oddArr . size ( ) ; j ++ ) { arr [ i ++ ] = oddArr . get ( j ) ; } }"
"static void halfsquare ( int n , int x , int y ) { int half = n / 2 ; if ( ( half == x || half == x - 1 ) && ( half == y || half == y - 1 ) ) System . out . println ( ""NO"" ) ; else System . out . println ( ""YES"" ) ; }"
"static void indexedSequentialSearch ( int arr [ ] , int n , int k ) { int elements [ ] = new int [ 20 ] ; int indices [ ] = new int [ 20 ] ; int temp , i ; int j = 0 , ind = 0 , start = 0 , end = 0 ; for ( i = 0 ; i < n ; i += 3 ) { elements [ ind ] = arr [ i ] ; indices [ ind ] = i ; ind ++ ; } if ( k < elements [ 0 ] ) { System . out . println ( ""Not found"" ) ; return ; } else { for ( i = 1 ; i <= ind ; i ++ ) if ( k < elements [ i ] ) { start = indices [ i - 1 ] ; end = indices [ i ] ; break ; } } for ( i = start ; i <= end ; i ++ ) { if ( k == arr [ i ] ) { j = 1 ; break ; } } if ( j == 1 ) System . out . println ( ""Found at index "" + i ) ; else System . out . println ( ""Not found"" ) ; }"
"static float discountPercentage ( float S , float M ) { float discount = M - S ; float disPercent = ( discount / M ) * 100 ; return disPercent ; }"
"static int breakSum ( int n ) { int dp [ ] = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = Math . max ( dp [ i / 2 ] + dp [ i / 3 ] + dp [ i / 4 ] , i ) ; return dp [ n ] ; }"
"static int findLength ( String str , int n ) { int ans = 0 ; for ( int i = 0 ; i <= n - 2 ; i ++ ) { int l = i , r = i + 1 ; int lsum = 0 , rsum = 0 ; while ( r < n && l >= 0 ) { lsum += str . charAt ( l ) - '0' ; rsum += str . charAt ( r ) - '0' ; if ( lsum == rsum ) { ans = Math . max ( ans , r - l + 1 ) ; } l -- ; r ++ ; } } return ans ; }"
"static int countSubseq ( int arr [ ] , int n ) { int count = 0 ; HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( mp . containsKey ( arr [ i ] ) ) mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; else mp . put ( arr [ i ] , 1 ) ; for ( Map . Entry < Integer , Integer > entry : mp . entrySet ( ) ) { if ( entry . getKey ( ) == 0 ) count += Math . pow ( 2 , entry . getValue ( ) ) - 1 ; else count += Math . pow ( 2 , entry . getValue ( ) - 1 ) ; } return count ; }"
"static int linearSearch ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == i ) return i ; } return - 1 ; }"
static int multiplyBySeven ( int n ) { return ( ( n << 3 ) - n ) ; }
"static int countSquares ( int row , int column ) { int topLeft = Math . min ( row , column ) - 1 ; int bottomRight = 8 - Math . max ( row , column ) ; int topRight = Math . min ( row , 9 - column ) - 1 ; int bottomLeft = 8 - Math . max ( row , 9 - column ) ; return ( topLeft + topRight + bottomRight + bottomLeft ) ; }"
"public static void printPairs ( int arr [ ] , int n ) { Vector < Integer > v = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( arr [ i ] ) == Math . abs ( arr [ j ] ) ) v . add ( Math . abs ( arr [ i ] ) ) ; if ( v . size ( ) == 0 ) return ; Collections . sort ( v ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) System . out . print ( - v . get ( i ) + "" "" + v . get ( i ) ) ; }"
public static int countSetBits ( int n ) { if ( n == 0 ) return 0 ; else return ( n & 1 ) + countSetBits ( n >> 1 ) ; }
"static int minCost ( int arr [ ] , int n ) { int count_even = 0 ; int count_odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) count_even ++ ; else count_odd ++ ; } return Math . min ( count_even , count_odd ) ; }"
"static void pendulumArrangement ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int odd , temp , in , pos ; pos = n - 1 ; if ( n % 2 == 0 ) odd = n - 1 ; else odd = n - 2 ; while ( odd > 0 ) { temp = arr [ odd ] ; in = odd ; while ( in != pos ) { arr [ in ] = arr [ in + 1 ] ; in ++ ; } arr [ in ] = temp ; odd = odd - 2 ; pos = pos - 1 ; } int start = 0 , end = ( n - 1 ) / 2 ; for ( ; start < end ; start ++ , end -- ) { temp = arr [ start ] ; arr [ start ] = arr [ end ] ; arr [ end ] = temp ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + "" "" ) ; }"
"static void gouldSequence ( int n ) { for ( int row_num = 1 ; row_num <= n ; row_num ++ ) { int count = 1 ; int c = 1 ; for ( int i = 1 ; i <= row_num ; i ++ ) { c = c * ( row_num - i ) / i ; if ( c % 2 == 1 ) count ++ ; } System . out . print ( count + "" "" ) ; } }"
static int countDivisbleby4 ( String s ) { int n = s . length ( ) ; int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) if ( s . charAt ( i ) == '4' || s . charAt ( i ) == '8' || s . charAt ( i ) == '0' ) count ++ ; for ( int i = 0 ; i < n - 1 ; ++ i ) { int h = ( s . charAt ( i ) - '0' ) * 10 + ( s . charAt ( i + 1 ) - '0' ) ; if ( h % 4 == 0 ) count = count + i + 1 ; } return count ; }
"static void generate ( int ones , int zeroes , String str , int len ) { if ( len == str . length ( ) ) { System . out . print ( str + "" "" ) ; return ; } generate ( ones + 1 , zeroes , str + ""1"" , len ) ; if ( ones > zeroes ) { generate ( ones , zeroes + 1 , str + ""0"" , len ) ; } }"
"static void perfectSquares ( int l , int r ) { for ( int i = l ; i <= r ; i ++ ) { if ( Math . sqrt ( i ) == ( int ) Math . sqrt ( i ) ) System . out . print ( i + "" "" ) ; } }"
"static int MinOperation ( int a [ ] , int n , int k ) { int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( a [ i ] != 1 && a [ i ] > k ) { result = result + Math . min ( a [ i ] % k , k - a [ i ] % k ) ; } else { result = result + k - a [ i ] ; } } return result ; }"
"static boolean arePermutations ( int a [ ] , int b [ ] , int n , int m ) { int sum1 = 0 , sum2 = 0 , mul1 = 1 , mul2 = 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 += a [ i ] ; mul1 *= a [ i ] ; } for ( int i = 0 ; i < m ; i ++ ) { sum2 += b [ i ] ; mul2 *= b [ i ] ; } return ( ( sum1 == sum2 ) && ( mul1 == mul2 ) ) ; }"
"public static void shuffle ( int card [ ] , int n ) { Random rand = new Random ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int r = i + rand . nextInt ( 52 - i ) ; int temp = card [ r ] ; card [ r ] = card [ i ] ; card [ i ] = temp ; } }"
"static void find3Numbers ( int arr [ ] , int n ) { int small = + 2147483647 , large = + 2147483647 ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] <= small ) small = arr [ i ] ; else if ( arr [ i ] <= large ) large = arr [ i ] ; else break ; } if ( i == n ) { System . out . print ( ""No such triplet found"" ) ; return ; } for ( int j = 0 ; j <= i ; j ++ ) { if ( arr [ j ] < large ) { small = arr [ j ] ; break ; } } System . out . print ( small + "" "" + large + "" "" + arr [ i ] ) ; return ; }"
"static int calculate ( int n , int power ) { int sum = 0 ; int bp = ( int ) Math . pow ( n , power ) ; while ( bp != 0 ) { int d = bp % 10 ; sum += d ; bp /= 10 ; } return sum ; }"
"static int numOfways ( int n , int k ) { int p = 1 ; if ( k % 2 != 0 ) p = - 1 ; return ( int ) ( Math . pow ( n - 1 , k ) + p * ( n - 1 ) ) / n ; }"
static Vector < Integer > createSemiPrimeSieve ( int n ) { int v [ ] = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { v [ i ] = i ; } int countDivision [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { countDivision [ i ] = 2 ; } for ( int i = 2 ; i <= n ; i ++ ) { if ( v [ i ] == i && countDivision [ i ] == 2 ) { for ( int j = 2 * i ; j <= n ; j += i ) { if ( countDivision [ j ] > 0 ) { v [ j ] = v [ j ] / i ; countDivision [ j ] -- ; } } } } Vector < Integer > res = new Vector < > ( ) ; for ( int i = 2 ; i <= n ; i ++ ) { if ( v [ i ] == 1 && countDivision [ i ] == 0 ) { res . add ( i ) ; } } return res ; }
"static void newvol ( double x ) { System . out . print ( ""percentage increase "" + ""in the volume of the cylinder is "" + x + ""%"" ) ; }"
"static int findLength ( String str ) { int n = str . length ( ) ; int maxlen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j += 2 ) { int length = j - i + 1 ; int leftsum = 0 , rightsum = 0 ; for ( int k = 0 ; k < length / 2 ; k ++ ) { leftsum += ( str . charAt ( i + k ) - '0' ) ; rightsum += ( str . charAt ( i + k + length / 2 ) - '0' ) ; } if ( leftsum == rightsum && maxlen < length ) maxlen = length ; } } return maxlen ; }"
"static void removeElements ( int arr [ ] , int n , int l , int r ) { HashMap < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { int val = 0 ; if ( mp . get ( arr [ i ] ) == null ) { val = 1 ; } else { val = mp . get ( arr [ i ] ) + 1 ; } mp . put ( arr [ i ] , val ) ; } for ( int i = 0 ; i < n ; ++ i ) { if ( mp . get ( arr [ i ] ) < l || mp . get ( arr [ i ] ) > r ) { System . out . print ( arr [ i ] + "" "" ) ; } } }"
"static int findMaxProduct ( int arr [ ] , int n ) { int i ; int ans = Integer . MIN_VALUE ; int maxval = 1 ; int minval = 1 ; int prevMax ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) { maxval = maxval * arr [ i ] ; minval = Math . min ( 1 , minval * arr [ i ] ) ; } else if ( arr [ i ] == 0 ) { minval = 1 ; maxval = 0 ; } else if ( arr [ i ] < 0 ) { prevMax = maxval ; maxval = minval * arr [ i ] ; minval = prevMax * arr [ i ] ; } ans = Math . max ( ans , maxval ) ; if ( maxval <= 0 ) { maxval = 1 ; } } return ans ; }"
"static float circumferenceparallelogram ( float a , float b ) { return ( ( 2 * a ) + ( 2 * b ) ) ; }"
"static void CountWords ( String str , int k ) { int sum = 0 ; int NumberOfWords = 0 ; int counter = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; ++ i ) { if ( str . charAt ( i ) == ' ' ) { if ( sum < k ) { counter ++ ; } sum = 0 ; NumberOfWords ++ ; } else { sum += str . charAt ( i ) ; } } NumberOfWords ++ ; if ( sum < k ) { counter ++ ; } System . out . println ( ""Number of words having sum "" + ""of ASCII values less than k = "" + counter ) ; System . out . println ( ""Number of words having sum of "" + ""ASCII values greater than or equal to k = "" + ( NumberOfWords - counter ) ) ; }"
static int numberOfDistinct ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { ans ++ ; if ( ( n / i ) != i ) ans ++ ; } } return ans ; }
"static int count ( String s , int k ) { int n = s . length ( ) ; int d = 0 , i ; int count = 0 ; for ( i = 0 ; i < n ; i ++ ) d += s . charAt ( i ) ; if ( d % k == 0 ) count += 1 ; for ( i = k ; i < n ; i ++ ) { int prev = s . charAt ( i - k ) ; d -= prev ; d += s . charAt ( i ) ; if ( d % k == 0 ) count += 1 ; } return count ; }"
"static void ReplaceElements ( int arr [ ] , int n ) { int max_ele = arr [ 0 ] ; arr [ 0 ] = - 1 ; for ( int i = 1 ; i < n ; ++ i ) { if ( max_ele > arr [ i ] ) arr [ i ] = max_ele ; else if ( max_ele <= arr [ i ] ) { int temp = arr [ i ] ; arr [ i ] = max_ele ; max_ele = temp ; } } }"
"static boolean makeAndCheckString ( Vector < String > words , String str ) { int n = words . size ( ) ; boolean first = false , second = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( words . get ( i ) == str ) return true ; if ( str . charAt ( 0 ) == words . get ( i ) . charAt ( 1 ) ) first = true ; if ( str . charAt ( 1 ) == words . get ( i ) . charAt ( 0 ) ) second = true ; if ( first && second ) return true ; } return false ; }"
"static void printPattern ( int N ) { for ( int i = 1 ; i <= N ; i ++ ) { System . out . print ( "" "" + ( ( i % 2 == 0 ) ? ( i - 1 ) : ( i + 1 ) ) ) ; } }"
"static boolean isDivisible ( String str , int k ) { int n = str . length ( ) ; int c = 0 ; for ( int i = 0 ; i < k ; i ++ ) if ( str . charAt ( n - i - 1 ) == '0' ) c ++ ; return ( c == k ) ; }"
"static int maximumSumSubarray ( int arr [ ] , int n ) { int min_prefix_sum = 0 ; int res = Integer . MIN_VALUE ; int prefix_sum [ ] = new int [ n ] ; prefix_sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { res = Math . max ( res , prefix_sum [ i ] - min_prefix_sum ) ; min_prefix_sum = Math . min ( min_prefix_sum , prefix_sum [ i ] ) ; } return res ; }"
"static void printPartition ( int n , int m ) { int k = n / m ; int ct = n % m ; int i ; for ( i = 1 ; i <= ct ; i ++ ) System . out . print ( k + 1 + "" "" ) ; for ( ; i <= m ; i ++ ) System . out . print ( k + "" "" ) ; }"
"static Vector < Integer > processQueries ( int Q [ ] , int m , int n ) { int [ ] a = new int [ m + 1 ] ; int [ ] pos = new int [ m + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) { a [ i - 1 ] = i ; pos [ i ] = i - 1 ; } Vector < Integer > ans = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int q = Q [ i ] ; int p = pos [ q ] ; ans . add ( p ) ; for ( int j = p ; j > 0 ; j -- ) { a [ j ] = a [ j ] + a [ j - 1 ] ; a [ j - 1 ] = a [ j ] - a [ j - 1 ] ; a [ j ] = a [ j ] - a [ j - 1 ] ; pos [ a [ j ] ] = j ; } pos [ a [ 0 ] ] = 0 ; } return ans ; }"
"static int findInteger ( int arr [ ] , int n ) { int neg = 0 , pos = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] < 0 ) neg ++ ; else pos ++ ; } return ( sum / Math . abs ( neg - pos ) ) ; }"
"static int countSink ( int n , int m , int edgeFrom [ ] , int edgeTo [ ] ) { int [ ] mark = new int [ n + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) mark [ edgeFrom [ i ] ] = 1 ; int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( mark [ i ] == 0 ) count ++ ; return count ; }"
"static boolean areSumSame ( int a [ ] [ ] , int n , int m ) { int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 = 0 ; sum2 = 0 ; for ( int j = 0 ; j < m ; j ++ ) { sum1 += a [ i ] [ j ] ; sum2 += a [ j ] [ i ] ; } if ( sum1 == sum2 ) return true ; } return false ; }"
"static int findMinDifference ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int diff1 = arr [ n - 1 ] - arr [ 1 ] ; int diff2 = arr [ n - 2 ] - arr [ 0 ] ; return Math . min ( diff1 , diff2 ) ; }"
"static int minSum ( int [ ] A , int n ) { int min_val = Arrays . stream ( A ) . min ( ) . getAsInt ( ) ; return ( min_val * ( n - 1 ) ) ; }"
"static void printPFsInPairs ( int n ) { for ( int i = 1 ; i * i <= n ; i ++ ) if ( n % i == 0 ) System . out . println ( i + ""*"" + n / i ) ; }"
"static void printDistinct ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) i ++ ; System . out . print ( arr [ i ] + "" "" ) ; } }"
public static char [ ] sortArrays ( char [ ] arr ) { int length = arr . length ; for ( int j = 0 ; j < arr . length - 1 ; j ++ ) { int d1 = arr [ j ] ; int d2 = arr [ j + 1 ] ; if ( d1 > d2 ) { char temp = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; j = - 1 ; } } return arr ; }
static float Cel_To_Fah ( float n ) { return ( ( n * 9.0f / 5.0f ) + 32.0f ) ; }
"static void thirdLargest ( int arr [ ] , int arr_size ) { if ( arr_size < 3 ) { System . out . printf ( "" Invalid Input "" ) ; return ; } int first = arr [ 0 ] , second = Integer . MIN_VALUE , third = Integer . MIN_VALUE ; for ( int i = 1 ; i < arr_size ; i ++ ) { if ( arr [ i ] > first ) { third = second ; second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) { third = second ; second = arr [ i ] ; } else if ( arr [ i ] > third ) { third = arr [ i ] ; } } System . out . printf ( ""The third Largest element is %d\n"" , third ) ; }"
public static int countunsetbits ( int n ) { int count = 0 ; for ( int x = 1 ; x <= n ; x = x << 1 ) if ( ( x & n ) == 0 ) count ++ ; return count ; }
"static int findCnt ( int [ ] arr , int n , int k ) { int ret = 0 ; int i = 0 ; while ( i < n ) { int j = i + 1 ; while ( j < n && arr [ j ] >= arr [ j - 1 ] ) j ++ ; int x = Math . max ( 0 , j - i - k + 1 ) ; ret += ( x * ( x + 1 ) ) / 2 ; i = j ; } return ret ; }"
"static void pythagoreanTriplet ( int n ) { for ( int i = 1 ; i <= n / 3 ; i ++ ) { for ( int j = i + 1 ; j <= n / 2 ; j ++ ) { int k = n - i - j ; if ( i * i + j * j == k * k ) { System . out . print ( i + "", "" + j + "", "" + k ) ; return ; } } } System . out . print ( ""No Triplet"" ) ; }"
"static int countWays ( int [ ] arr , int n ) { int max_val = 0 ; for ( int i = 0 ; i < n ; i ++ ) max_val = Math . max ( max_val , arr [ i ] ) ; int [ ] freq = new int [ max_val + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; int ans = 0 ; ans += freq [ 0 ] * ( freq [ 0 ] - 1 ) * ( freq [ 0 ] - 2 ) / 6 ; for ( int i = 1 ; i <= max_val ; i ++ ) ans += freq [ 0 ] * freq [ i ] * ( freq [ i ] - 1 ) / 2 ; for ( int i = 1 ; 2 * i <= max_val ; i ++ ) ans += freq [ i ] * ( freq [ i ] - 1 ) / 2 * freq [ 2 * i ] ; for ( int i = 1 ; i <= max_val ; i ++ ) { for ( int j = i + 1 ; i + j <= max_val ; j ++ ) ans += freq [ i ] * freq [ j ] * freq [ i + j ] ; } return ans ; }"
"static int countWays ( int N ) { int E = ( N * ( N - 1 ) ) / 2 ; if ( N == 1 ) return 0 ; return ( int ) Math . pow ( 2 , E - 1 ) ; }"
"static void findNthNum ( int N ) { int bit_L = 1 , last_num = 0 ; while ( bit_L * ( bit_L + 1 ) / 2 < N ) { last_num = last_num + bit_L ; bit_L ++ ; } int bit_R = N - last_num - 1 ; System . out . print ( ( 1 << bit_L ) + ( 1 << bit_R ) + ""\n"" ) ; }"
"public static int countarray ( int n , int k , int x ) { int [ ] dp = new int [ 109 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) dp [ i ] = ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] ; return ( x == 1 ? ( k - 1 ) * dp [ n - 2 ] : dp [ n - 1 ] ) ; }"
static int nthTerm ( int N ) { int nth = 0 ; if ( N % 2 == 1 ) nth = ( N * N ) + 1 ; else nth = ( N * N ) - 1 ; return nth ; }
static boolean isDivisible ( long n ) { while ( n / 100 != 0 ) { int d = ( int ) ( n % 10 ) ; n /= 10 ; n -= d * 4 ; } return ( n % 41 == 0 ) ; }
"public static int eulerian ( int n , int m ) { if ( m >= n || n == 0 ) return 0 ; if ( m == 0 ) return 1 ; return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) ; }"
"public static int maxSum ( int stack1 [ ] , int stack2 [ ] , int stack3 [ ] , int n1 , int n2 , int n3 ) { int sum1 = 0 , sum2 = 0 , sum3 = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) sum1 += stack1 [ i ] ; for ( int i = 0 ; i < n2 ; i ++ ) sum2 += stack2 [ i ] ; for ( int i = 0 ; i < n3 ; i ++ ) sum3 += stack3 [ i ] ; int top1 = 0 , top2 = 0 , top3 = 0 ; int ans = 0 ; while ( true ) { if ( top1 == n1 || top2 == n2 || top3 == n3 ) return 0 ; if ( sum1 == sum2 && sum2 == sum3 ) return sum1 ; if ( sum1 >= sum2 && sum1 >= sum3 ) sum1 -= stack1 [ top1 ++ ] ; else if ( sum2 >= sum3 && sum2 >= sum3 ) sum2 -= stack2 [ top2 ++ ] ; else if ( sum3 >= sum2 && sum3 >= sum1 ) sum3 -= stack3 [ top3 ++ ] ; } }"
"static void last_digit ( int X , int Y ) { System . out . print ( X % Y ) ; }"
"static void alter ( long x , long y ) { while ( true ) { if ( x == 0 || y == 0 ) break ; if ( x >= 2 * y ) x = x % ( 2 * y ) ; else if ( y >= 2 * x ) y = y % ( 2 * x ) ; else break ; } System . out . println ( ""X = "" + x + "", "" + ""Y = "" + y ) ; }"
static void maxRegions ( int n ) { int num ; num = n * ( n + 1 ) / 2 + 1 ; System . out . println ( num ) ; ; }
"static void printDiagonalSums ( int [ ] [ ] mat , int n ) { int principal = 0 , secondary = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) principal += mat [ i ] [ j ] ; if ( ( i + j ) == ( n - 1 ) ) secondary += mat [ i ] [ j ] ; } } System . out . println ( ""Principal Diagonal:"" + principal ) ; System . out . println ( ""Secondary Diagonal:"" + secondary ) ; }"
"static Boolean isOverflow ( long a , long b ) { if ( a == 0 || b == 0 ) return false ; long result = a * b ; if ( a == result / b ) return false ; else return true ; }"
static int minParentheses ( String p ) { int bal = 0 ; int ans = 0 ; for ( int i = 0 ; i < p . length ( ) ; ++ i ) { bal += p . charAt ( i ) == '(' ? 1 : - 1 ; if ( bal == - 1 ) { ans += 1 ; bal += 1 ; } } return bal + ans ; }
"static int oddEquivalent ( String s , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '1' ) count ++ ; } return count ; }"
"static void printNonConsecutive ( int n ) { int p = ( 1 << n ) ; for ( int i = 1 ; i < p ; i ++ ) if ( ( i & ( i << 1 ) ) == 0 ) System . out . print ( i + "" "" ) ; }"
"static int rev ( int n , int temp ) { if ( n == 0 ) return temp ; temp = ( temp * 10 ) + ( n % 10 ) ; return rev ( n / 10 , temp ) ; }"
"static int closetAND ( int arr [ ] , int n , int k ) { int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int X = arr [ i ] ; for ( int j = i ; j < n ; j ++ ) { X &= arr [ j ] ; ans = Math . min ( ans , Math . abs ( k - X ) ) ; } } return ans ; }"
"static int russianPeasant ( int a , int b ) { int res = 0 ; while ( b > 0 ) { if ( ( b & 1 ) != 0 ) res = res + a ; a = a << 1 ; b = b >> 1 ; } return res ; }"
"public static double answer ( double X , double K ) { double i = 10 ; double MIN = Math . pow ( i , K - 1 ) ; if ( MIN % X == 0 ) return ( MIN ) ; else return ( ( MIN + X ) - ( ( MIN + X ) % X ) ) ; }"
"static int maxSum ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( arr [ i ] * i ) ; return sum ; }"
"public static void longestSubsequence ( int [ ] a , int n ) { HashMap < Integer , Integer > mp = new HashMap < > ( ) ; int [ ] dp = new int [ n ] ; int maximum = Integer . MIN_VALUE ; int index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . get ( a [ i ] - 1 ) != null ) { int lastIndex = mp . get ( a [ i ] - 1 ) - 1 ; dp [ i ] = 1 + dp [ lastIndex ] ; } else dp [ i ] = 1 ; mp . put ( a [ i ] , i + 1 ) ; if ( maximum < dp [ i ] ) { maximum = dp [ i ] ; index = i ; } } for ( int curr = a [ index ] - maximum + 1 ; curr <= a [ index ] ; curr ++ ) System . out . print ( curr + "" "" ) ; }"
static int countWays ( int n ) { int count = 0 ; for ( int i = 1 ; i * i < n ; i ++ ) if ( n % i == 0 ) count ++ ; return count ; }
"static void generateNumbers ( int factor [ ] , int n , int k ) { int next [ ] = new int [ k ] ; int output = 0 ; for ( int i = 0 ; i < n ; ) { int toincrement = 0 ; for ( int j = 0 ; j < k ; j ++ ) if ( next [ j ] < next [ toincrement ] ) toincrement = j ; if ( output != next [ toincrement ] ) { output = next [ toincrement ] ; System . out . print ( next [ toincrement ] + "" "" ) ; i ++ ; } next [ toincrement ] += factor [ toincrement ] ; } }"
"static int countSteps ( int x , int y ) { if ( x % y == 0 ) return x / y ; return x / y + countSteps ( y , x % y ) ; }"
"static int superSeq ( String X , String Y , int m , int n ) { int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j ; else if ( j == 0 ) dp [ i ] [ j ] = i ; else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } return dp [ m ] [ n ] ; }"
"static boolean sackRace ( int p1 , int s1 , int p2 , int s2 ) { return ( ( s1 > s2 && ( p2 - p1 ) % ( s1 - s2 ) == 0 ) || ( s2 > s1 && ( p1 - p2 ) % ( s2 - s1 ) == 0 ) ) ; }"
"static int find ( int a [ ] , int b [ ] , int k , int n1 , int n2 ) { LinkedHashSet < Integer > s = new LinkedHashSet < > ( ) ; for ( int i = 0 ; i < n2 ; i ++ ) s . add ( b [ i ] ) ; int missing = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( ! s . contains ( a [ i ] ) ) missing ++ ; if ( missing == k ) return a [ i ] ; } return - 1 ; }"
"static void arrayEvenAndOdd ( int arr [ ] , int n ) { int i = - 1 , j = 0 ; while ( j != n ) { if ( arr [ j ] % 2 == 0 ) { i ++ ; int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } j ++ ; } for ( int k = 0 ; k < n ; k ++ ) System . out . print ( arr [ k ] + "" "" ) ; }"
"static int findMinX ( int num [ ] , int rem [ ] , int k ) { int x = 1 ; while ( true ) { int j ; for ( j = 0 ; j < k ; j ++ ) if ( x % num [ j ] != rem [ j ] ) break ; if ( j == k ) return x ; x ++ ; } }"
"static String longestRepeatedSubstring ( String str ) { int n = str . length ( ) ; int LCSRe [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; String res = """" ; int res_length = 0 ; int i , index = 0 ; for ( i = 1 ; i <= n ; i ++ ) { for ( int j = i + 1 ; j <= n ; j ++ ) { if ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && LCSRe [ i - 1 ] [ j - 1 ] < ( j - i ) ) { LCSRe [ i ] [ j ] = LCSRe [ i - 1 ] [ j - 1 ] + 1 ; if ( LCSRe [ i ] [ j ] > res_length ) { res_length = LCSRe [ i ] [ j ] ; index = Math . max ( i , index ) ; } } else { LCSRe [ i ] [ j ] = 0 ; } } } if ( res_length > 0 ) { for ( i = index - res_length + 1 ; i <= index ; i ++ ) { res += str . charAt ( i - 1 ) ; } } return res ; }"
"static void printArray ( int X , int d , int first_ele ) { while ( X > 0 ) { int count_ele = 0 , pow_of_two = 2 ; while ( X - pow_of_two + 1 >= 0 ) { count_ele ++ ; pow_of_two *= 2 ; } X = X - ( pow_of_two / 2 ) + 1 ; for ( int j = 0 ; j < count_ele ; j ++ ) System . out . print ( first_ele + "" "" ) ; first_ele += d ; } }"
static int findSum ( int n ) { return n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) / 24 ; }
"static void print_sequence ( int n , int k ) { int b = n / ( k * ( k + 1 ) / 2 ) ; if ( b == 0 ) { System . out . println ( ""-1"" ) ; } else { int r = 1 ; for ( int x = 1 ; x * x <= n ; x ++ ) { if ( n % x != 0 ) continue ; if ( x <= b && x > r ) r = x ; if ( n / x <= b && n / x > r ) r = n / x ; } for ( int i = 1 ; i < k ; i ++ ) System . out . print ( r * i + "" "" ) ; int res = n - ( r * ( k * ( k - 1 ) / 2 ) ) ; System . out . println ( res ) ; } }"
"static int calculate_change ( int length , int breadth ) { int change = 0 ; change = length + breadth + ( ( length * breadth ) / 100 ) ; return change ; }"
"static int Count ( String s , int pos ) { int c = s . charAt ( pos - 1 ) ; int counter = 0 ; for ( int i = 0 ; i < pos - 1 ; i ++ ) { if ( s . charAt ( i ) == c ) counter = counter + 1 ; } return counter ; }"
"static void Permutation ( int n , int k ) { int [ ] p = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) p [ i ] = i ; for ( int i = 1 ; i < n - k ; i ++ ) p [ i + 1 ] = i ; p [ 1 ] = n - k ; for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( p [ i ] + "" "" ) ; }"
"static int horner ( int poly [ ] , int n , int x ) { int result = poly [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) result = result * x + poly [ i ] ; return result ; }"
"static int binarySearch ( int arr [ ] , int left , int right ) { if ( left <= right ) { int mid = ( left + right ) / 2 ; if ( arr [ mid - 1 ] < arr [ mid ] && arr [ mid ] > arr [ mid + 1 ] ) return mid ; if ( arr [ mid ] < arr [ mid + 1 ] ) return binarySearch ( arr , mid + 1 , right ) ; else return binarySearch ( arr , left , mid - 1 ) ; } return - 1 ; }"
"static boolean isFrequencyEqual ( String str , int len ) { if ( len % 2 == 1 ) { return false ; } int i , freq [ ] = new int [ 26 ] ; for ( i = 0 ; i < len ; i ++ ) { freq [ str . charAt ( i ) - 'a' ] ++ ; } for ( i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] == len / 2 ) { return true ; } } return false ; }"
"static int findInteger ( int arr [ ] , int n ) { HashMap < Integer , Integer > hash = new HashMap < > ( ) ; int maximum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) hash . put ( Math . abs ( arr [ i ] ) , ( hash . get ( Math . abs ( arr [ i ] ) ) == null ? 0 : hash . get ( Math . abs ( arr [ i ] ) ) ) - 1 ) ; else hash . put ( Math . abs ( arr [ i ] ) , ( hash . get ( Math . abs ( arr [ i ] ) ) == null ? 0 : hash . get ( Math . abs ( arr [ i ] ) ) ) + 1 ) ; } for ( int i = 0 ; i < n ; i ++ ) if ( hash . get ( arr [ i ] ) > 0 ) return arr [ i ] ; return - 1 ; }"
"static int minSum ( int arr [ ] , int n ) { Vector < Integer > evenArr = new Vector < > ( ) ; Vector < Integer > oddArr = new Vector < > ( ) ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n / 2 ) { oddArr . add ( arr [ i ] ) ; } else { evenArr . add ( arr [ i ] ) ; } } Comparator comparator = Collections . reverseOrder ( ) ; Collections . sort ( evenArr , comparator ) ; int i = 0 , sum = 0 ; for ( int j = 0 ; j < evenArr . size ( ) ; j ++ ) { arr [ i ++ ] = evenArr . get ( j ) ; arr [ i ++ ] = oddArr . get ( j ) ; sum += evenArr . get ( j ) * oddArr . get ( j ) ; } return sum ; }"
"static void firstFit ( int blockSize [ ] , int m , int processSize [ ] , int n ) { int allocation [ ] = new int [ n ] ; for ( int i = 0 ; i < allocation . length ; i ++ ) allocation [ i ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( blockSize [ j ] >= processSize [ i ] ) { allocation [ i ] = j ; blockSize [ j ] -= processSize [ i ] ; break ; } } } System . out . println ( ""\nProcess No.\tProcess Size\tBlock no."" ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( "" "" + ( i + 1 ) + ""\t\t"" + processSize [ i ] + ""\t\t"" ) ; if ( allocation [ i ] != - 1 ) System . out . print ( allocation [ i ] + 1 ) ; else System . out . print ( ""Not Allocated"" ) ; System . out . println ( ) ; } }"
"static void replaceOriginal ( String s , int n ) { char r [ ] = new char [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { r [ i ] = s . charAt ( n - 1 - i ) ; if ( s . charAt ( i ) != 'a' && s . charAt ( i ) != 'e' && s . charAt ( i ) != 'i' && s . charAt ( i ) != 'o' && s . charAt ( i ) != 'u' ) { System . out . print ( r [ i ] ) ; } } System . out . println ( """" ) ; }"
static int findLargestDivisor ( int n ) { for ( int i = 2 ; i < Math . sqrt ( n ) + 1 ; i ++ ) { while ( n % ( i * i ) == 0 ) { n = n / i ; } } return n ; }
"static boolean isHeap ( int arr [ ] , int i , int n ) { if ( i > ( n - 2 ) / 2 ) { return true ; } if ( arr [ i ] >= arr [ 2 * i + 1 ] && arr [ i ] >= arr [ 2 * i + 2 ] && isHeap ( arr , 2 * i + 1 , n ) && isHeap ( arr , 2 * i + 2 , n ) ) { return true ; } return false ; }"
"static void generate_derangement ( int N ) { int S [ ] = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) S [ i ] = i ; int D [ ] = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i += 2 ) { if ( i == N ) { D [ N ] = S [ N - 1 ] ; D [ N - 1 ] = S [ N ] ; } else { D [ i ] = i + 1 ; D [ i + 1 ] = i ; } } for ( int i = 1 ; i <= N ; i ++ ) System . out . print ( D [ i ] + "" "" ) ; System . out . println ( ) ; }"
"static int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 ; Arrays . sort ( arr ) ; int l = 0 ; int r = 0 ; while ( r < n ) { if ( arr [ r ] - arr [ l ] == k ) { count ++ ; l ++ ; r ++ ; } else if ( arr [ r ] - arr [ l ] > k ) l ++ ; else r ++ ; } return count ; }"
"static int findMinNumber ( int n ) { int count = 0 , ans = 1 ; while ( n % 2 == 0 ) { count ++ ; n /= 2 ; } if ( count % 2 == 1 ) ans *= 2 ; for ( int i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { count = 0 ; while ( n % i == 0 ) { count ++ ; n /= i ; } if ( count % 2 == 1 ) ans *= i ; } if ( n > 2 ) ans *= n ; return ans ; }"
"public static int longOddEvenIncSeq ( int arr [ ] , int n ) { int [ ] lioes = new int [ n ] ; int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) lioes [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j ] ) % 2 != 0 && lioes [ i ] < lioes [ j ] + 1 ) lioes [ i ] = lioes [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( maxLen < lioes [ i ] ) maxLen = lioes [ i ] ; return maxLen ; }"
"static int countFreq ( String pat , String txt ) { int M = pat . length ( ) ; int N = txt . length ( ) ; int res = 0 ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) { if ( txt . charAt ( i + j ) != pat . charAt ( j ) ) { break ; } } if ( j == M ) { res ++ ; j = 0 ; } } return res ; }"
"static int countNumbers ( int n ) { int k = 0 ; int count = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) count += ( int ) ( Math . pow ( 2 , k ) ) ; k += 1 ; n >>= 1 ; } return count ; }"
static int firstDigit ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { fact = fact * i ; while ( fact % 10 == 0 ) fact = fact / 10 ; } while ( fact >= 10 ) fact = fact / 10 ; return fact ; }
"static int count_numbers ( int k , int n , boolean flag ) { if ( n == 1 ) { if ( flag ) { return ( k - 1 ) ; } else { return 1 ; } } if ( flag ) return ( k - 1 ) * ( count_numbers ( k , n - 1 , false ) + count_numbers ( k , n - 1 , true ) ) ; else return count_numbers ( k , n - 1 , true ) ; }"
"static int numberOfMinutes ( int S , int S1 ) { int Min = 0 ; Min = ( int ) ( ( ( S - S1 ) / Math . floor ( S ) ) * 60 ) ; return Min ; }"
"static String constructPalin ( char [ ] str , int len ) { int i = 0 , j = len - 1 ; for ( ; i < j ; i ++ , j -- ) { if ( str [ i ] == str [ j ] && str [ i ] != '*' ) continue ; else if ( str [ i ] == str [ j ] && str [ i ] == '*' ) { str [ i ] = 'a' ; str [ j ] = 'a' ; continue ; } else if ( str [ i ] == '*' ) { str [ i ] = str [ j ] ; continue ; } else if ( str [ j ] == '*' ) { str [ j ] = str [ i ] ; continue ; } System . out . println ( ""Not Possible"" ) ; return """" ; } return String . valueOf ( str ) ; }"
"static int countDivisibles ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] % arr [ j ] == 0 || arr [ j ] % arr [ i ] == 0 ) res ++ ; return res ; }"
"static int minimumChanges ( int arr [ ] , int n , int d ) { int maxFreq = - 1 ; HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { int a0 = arr [ i ] - ( i ) * d ; if ( freq . containsKey ( a0 ) ) { freq . put ( a0 , freq . get ( a0 ) + 1 ) ; } else freq . put ( a0 , 1 ) ; if ( freq . get ( a0 ) > maxFreq ) maxFreq = freq . get ( a0 ) ; } return ( n - maxFreq ) ; }"
"static int printPattern ( int i , int j , int n ) { if ( j >= n ) { return 0 ; } if ( i >= n ) { return 1 ; } if ( j == i || j == n - 1 - i ) { if ( i == n - 1 - j ) { System . out . print ( ""/"" ) ; } else { System . out . print ( ""\\"");}}else{System.out.print("" * "" ) ; } if ( printPattern ( i , j + 1 , n ) == 1 ) { return 1 ; } System . out . println ( ) ; return printPattern ( i + 1 , 0 , n ) ; }"
static int Circular ( int n ) { int Result = 1 ; while ( n > 0 ) { Result = Result * n ; n -- ; } return Result ; }
"static int findMinDiff ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; int diff = Integer . MAX_VALUE ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [ i + 1 ] - arr [ i ] ; return diff ; }"
"static int ceilSearch ( int arr [ ] , int low , int high , int x ) { int i ; if ( x <= arr [ low ] ) return low ; for ( i = low ; i < high ; i ++ ) { if ( arr [ i ] == x ) return i ; if ( arr [ i ] < x && arr [ i + 1 ] >= x ) return i + 1 ; } return - 1 ; }"
"static void printModulus ( int X , int Y ) { int n = Math . max ( X , Y ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( X % i == Y % i ) System . out . print ( i + "" "" ) ; } }"
"static void steps ( String str , int n ) { boolean flag = false ; int x = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( x == 0 ) flag = true ; if ( x == n - 1 ) flag = false ; for ( int j = 0 ; j < x ; j ++ ) System . out . print ( ""*"" ) ; System . out . print ( str . charAt ( i ) + ""\n"" ) ; if ( flag == true ) x ++ ; else x -- ; } }"
"static int countSeq ( int n , int diff ) { if ( Math . abs ( diff ) > n ) return 0 ; if ( n == 1 && diff == 0 ) return 2 ; if ( n == 1 && Math . abs ( diff ) == 1 ) return 1 ; int res = countSeq ( n - 1 , diff + 1 ) + 2 * countSeq ( n - 1 , diff ) + countSeq ( n - 1 , diff - 1 ) ; return res ; }"
"static void findTime ( String T , int K ) { int minutes = ( ( T . charAt ( 0 ) - '0' ) * 10 + T . charAt ( 1 ) - '0' ) * 60 + ( ( T . charAt ( 3 ) - '0' ) * 10 + T . charAt ( 4 ) - '0' ) ; minutes += K ; int hour = ( minutes / 60 ) % 24 ; int min = minutes % 60 ; if ( hour < 10 ) { System . out . print ( ""0"" + hour + "":"" ) ; } else { System . out . print ( hour + "":"" ) ; } if ( min < 10 ) { System . out . println ( ""0"" + min ) ; } else { System . out . println ( min ) ; } }"
static int countLattice ( int r ) { if ( r <= 0 ) return 0 ; int result = 4 ; for ( int x = 1 ; x < r ; x ++ ) { int ySquare = r * r - x * x ; int y = ( int ) Math . sqrt ( ySquare ) ; if ( y * y == ySquare ) result += 4 ; } return result ; }
"static int cntSubSeq ( int arr [ ] , int n ) { int pos_count = 0 ; int neg_count = 0 ; int result ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) pos_count ++ ; if ( arr [ i ] < 0 ) neg_count ++ ; } result = ( int ) Math . pow ( 2 , pos_count ) ; if ( neg_count > 0 ) result *= Math . pow ( 2 , neg_count - 1 ) ; result -= 1 ; return result ; }"
"static int findAnswer ( String str1 , String str2 , int n ) { int l = 0 , r = 0 ; int ans = 2 ; for ( int i = 0 ; i < n ; ++ i ) { if ( str1 . charAt ( i ) != str2 . charAt ( i ) ) { l = i ; break ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( str1 . charAt ( i ) != str2 . charAt ( i ) ) { r = i ; break ; } } if ( r < l ) return 26 * ( n + 1 ) ; else if ( l == r ) return ans ; else { for ( int i = l + 1 ; i <= r ; i ++ ) { if ( str1 . charAt ( i ) != str2 . charAt ( i - 1 ) ) { ans -- ; break ; } } for ( int i = l + 1 ; i <= r ; i ++ ) { if ( str1 . charAt ( i - 1 ) != str2 . charAt ( i ) ) { ans -- ; break ; } } return ans ; } }"
"static int findSum ( int arr [ ] , int N ) { Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } int maxFreq = 0 ; for ( Map . Entry < Integer , Integer > entry : mp . entrySet ( ) ) { if ( entry . getValue ( ) > maxFreq ) { maxFreq = entry . getValue ( ) ; } } int sum = 0 ; for ( Map . Entry < Integer , Integer > entry : mp . entrySet ( ) ) { if ( entry . getValue ( ) == maxFreq ) { sum += entry . getKey ( ) * entry . getValue ( ) ; } } return sum ; }"
"static Boolean areConsecutives ( int arr [ ] , int n ) { int first_term = Integer . MAX_VALUE ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] < first_term ) first_term = arr [ j ] ; } int ap_sum = ( n * ( 2 * first_term + ( n - 1 ) * 1 ) ) / 2 ; int arr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) arr_sum += arr [ i ] ; return ap_sum == arr_sum ; }"
"static void SieveOfEratosthenes ( int n , boolean isPrime [ ] ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) isPrime [ i ] = false ; } } }"
"static int smallestMultiple ( int n ) { if ( n == 1 ) return 5 ; return ( int ) ( Math . pow ( 10 , n - 1 ) ) ; }"
"static int minSum ( int arr [ ] , int n , int x ) { int sum = 0 ; int largestDivisible = - 1 , minimum = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] % x == 0 && largestDivisible < arr [ i ] ) largestDivisible = arr [ i ] ; if ( arr [ i ] < minimum ) minimum = arr [ i ] ; } if ( largestDivisible == - 1 ) return sum ; int sumAfterOperation = sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible / x ) ; return Math . min ( sum , sumAfterOperation ) ; }"
static int evenbinomialCoeffSum ( int n ) { return ( 1 << ( n - 1 ) ) ; }
"static int countSubarray ( int arr [ ] , int n , int k ) { int s = 0 ; int i = 0 ; while ( i < n ) { if ( arr [ i ] > k ) { i ++ ; continue ; } int count = 0 ; while ( i < n && arr [ i ] <= k ) { i ++ ; count ++ ; } s += ( ( count * ( count + 1 ) ) / 2 ) ; } return ( n * ( n + 1 ) / 2 - s ) ; }"
"static int sortedCount ( int mat [ ] [ ] , int r , int c ) { int result = 0 ; for ( int i = 0 ; i < r ; i ++ ) { int j ; for ( j = 0 ; j < c - 1 ; j ++ ) if ( mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] ) break ; if ( j == c - 1 ) result ++ ; } for ( int i = 0 ; i < r ; i ++ ) { int j ; for ( j = c - 1 ; j > 0 ; j -- ) if ( mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] ) break ; if ( c > 1 && j == 0 ) result ++ ; } return result ; }"
"public static int countPairs ( int arr [ ] , int n ) { HashMap < Integer , Integer > hm = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( hm . containsKey ( arr [ i ] ) ) hm . put ( arr [ i ] , hm . get ( arr [ i ] ) + 1 ) ; else hm . put ( arr [ i ] , 1 ) ; } int ans = 0 ; for ( Map . Entry < Integer , Integer > it : hm . entrySet ( ) ) { int count = it . getValue ( ) ; ans += ( count * ( count - 1 ) ) / 2 ; } return ans ; }"
"static void solve ( int n , int t , char s [ ] ) { for ( int i = 0 ; i < t ; i ++ ) for ( int j = 0 ; j < n - 1 ; j ++ ) if ( s [ j ] == 'B' && s [ j + 1 ] == 'G' ) { char temp = s [ j ] ; s [ j ] = s [ j + 1 ] ; s [ j + 1 ] = temp ; j ++ ; } System . out . print ( s ) ; }"
"static double MinimumMail ( int n , int k , int x ) { double m = ( n - 1 ) + Math . ceil ( ( n - 1 ) * 1.0 / x ) * ( n - 1 ) + Math . ceil ( n * 1.0 / x ) * ( k - n ) ; return m ; }"
"static int totalSumDivisibleByNum ( int n , int number ) { int firstnum = ( int ) Math . pow ( 10 , n - 1 ) ; int lastnum = ( int ) Math . pow ( 10 , n ) ; int sum = 0 ; for ( int i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) sum += i ; return sum ; }"
"static void angleequichord ( int z ) { System . out . println ( ""The angle subtended at the center is "" + z + "" degrees"" ) ; }"
"static int minRadius ( int k , int [ ] x , int [ ] y , int n ) { int [ ] dis = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; Arrays . sort ( dis ) ; return dis [ k - 1 ] ; }"
"static int snoob ( int x ) { int rightOne , nextHigherOneBit , rightOnesPattern , next = 0 ; if ( x > 0 ) { rightOne = x & - x ; nextHigherOneBit = x + rightOne ; rightOnesPattern = x ^ nextHigherOneBit ; rightOnesPattern = ( rightOnesPattern ) / rightOne ; rightOnesPattern >>= 2 ; next = nextHigherOneBit | rightOnesPattern ; } return next ; }"
"static void incrementVector ( Vector < Integer > a ) { int n = a . size ( ) ; a . set ( n - 1 , a . get ( n - 1 ) + 1 ) ; int carry = a . get ( n - 1 ) / 10 ; a . set ( n - 1 , a . get ( n - 1 ) % 10 ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( carry == 1 ) { a . set ( i , a . get ( i ) + 1 ) ; carry = a . get ( i ) / 10 ; a . set ( i , a . get ( i ) % 10 ) ; } } if ( carry == 1 ) a . add ( 0 , 1 ) ; }"
static int inversegrayCode ( int n ) { int inv = 0 ; for ( ; n != 0 ; n = n >> 1 ) inv ^= n ; return inv ; }
"static int [ ] numberOfLines ( String S , int [ ] widths ) { if ( S . isEmpty ( ) ) return new int [ ] { 0 , 0 }; int lines = 1 , width = 0 ; for ( char character : S . toCharArray ( ) ) { int w = widths [ character - 'a' ] ; width += w ; if ( width >= 10 ) { lines ++ ; width = w ; } } return new int [ ] { lines , width }; }"
"static int xorLessK ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int tempXor = 0 ; for ( int j = i ; j < n ; j ++ ) { tempXor ^= arr [ j ] ; if ( tempXor < k ) count ++ ; } } return count ; }"
"static int strScore ( String str [ ] , String s , int n ) { int score = 0 , index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == s ) { for ( int j = 0 ; j < s . length ( ) ; j ++ ) score += s . charAt ( j ) - 'a' + 1 ; index = i + 1 ; break ; } } score = score * index ; return score ; }"
"static int minOperations ( int ar [ ] , int k ) { Arrays . sort ( ar ) ; int opsNeeded = 0 ; for ( int i = 0 ; i < k ; i ++ ) { opsNeeded += ar [ k - 1 ] - ar [ i ] ; } int ans = opsNeeded ; for ( int i = k ; i < ar . length ; i ++ ) { opsNeeded = opsNeeded - ( ar [ i - 1 ] - ar [ i - k ] ) ; opsNeeded += ( k - 1 ) * ( ar [ i ] - ar [ i - 1 ] ) ; ans = Math . min ( ans , opsNeeded ) ; } return ans ; }"
"static void printSquares ( int n ) { int square = 0 , prev_x = 0 ; for ( int x = 0 ; x < n ; x ++ ) { square = ( square + x + prev_x ) ; System . out . print ( square + "" "" ) ; prev_x = x ; } }"
static boolean divisibleBy36 ( String num ) { int l = num . length ( ) ; if ( l == 0 ) return false ; if ( l == 1 && num . charAt ( 0 ) != '0' ) return false ; int two_digit_num = ( num . charAt ( l - 2 ) - '0' ) * 10 + ( num . charAt ( l - 1 ) - '0' ) ; if ( two_digit_num % 4 != 0 ) return false ; int sum = 0 ; for ( int i = 0 ; i < l ; i ++ ) sum += ( num . charAt ( i ) - '0' ) ; if ( sum % 9 != 0 ) return false ; return true ; }
"static void originalArray ( int greater [ ] , int n ) { Vector < Integer > temp = new Vector < Integer > ( ) ; for ( int i = 0 ; i <= n ; i ++ ) temp . add ( i ) ; int arr [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int k = n - greater [ i ] - i ; arr [ i ] = temp . get ( k ) ; temp . remove ( k ) ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + "" "" ) ; }"
"static boolean check ( String str ) { int n = str . length ( ) ; int oddDigSum = 0 , evenDigSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) oddDigSum += ( str . charAt ( i ) - '0' ) ; else evenDigSum += ( str . charAt ( i ) - '0' ) ; } return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) ; }"
"static int countNumbers ( int x , int n ) { if ( x > n ) return 0 ; return 1 + countNumbers ( x * 10 , n ) + countNumbers ( x * 10 + 1 , n ) ; }"
"static void vietaFormula ( int roots [ ] , int n ) { int coeff [ ] = new int [ ++ n + 1 ] ; Arrays . fill ( coeff , 0 ) ; coeff [ n ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = n - i - 1 ; j < n ; j ++ ) { coeff [ j ] = coeff [ j ] + ( - 1 ) * roots [ i - 1 ] * coeff [ j + 1 ] ; } } System . out . print ( ""Polynomial Coefficients: "" ) ; for ( int i = n ; i > 0 ; i -- ) { System . out . print ( coeff [ i ] + "" "" ) ; } }"
"static int isChangeable ( int notes [ ] , int n ) { int fiveCount = 0 ; int tenCount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( notes [ i ] == 5 ) fiveCount ++ ; else if ( notes [ i ] == 10 ) { if ( fiveCount > 0 ) { fiveCount -- ; tenCount ++ ; } else return 0 ; } else { if ( fiveCount > 0 && tenCount > 0 ) { fiveCount -- ; tenCount -- ; } else if ( fiveCount >= 3 ) { fiveCount -= 3 ; } else return 0 ; } } return 1 ; }"
"public static void rearrange ( int arr [ ] , int n ) { int max_idx = n - 1 , min_idx = 0 ; int max_elem = arr [ n - 1 ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem ; max_idx -- ; } else { arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem ; min_idx ++ ; } } for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] / max_elem ; }"
static int findSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += i * ( n - i ) ; return 2 * sum ; }
"static int findTransitionPoint ( int arr [ ] , int n ) { int lb = 0 , ub = n - 1 ; while ( lb <= ub ) { int mid = ( lb + ub ) / 2 ; if ( arr [ mid ] == 0 ) lb = mid + 1 ; else if ( arr [ mid ] == 1 ) { if ( arr [ mid - 1 ] == 0 ) return mid ; ub = mid - 1 ; } } return - 1 ; }"
"static double findMod ( double a , double b ) { if ( a < 0 ) a = - a ; if ( b < 0 ) b = - b ; double mod = a ; while ( mod >= b ) mod = mod - b ; if ( a < 0 ) return - mod ; return mod ; }"
"static float getPercentile ( int rank , int students ) { float result = ( float ) ( students - rank ) / students * 100 ; return result ; }"
"static void alternateSubarray ( boolean arr [ ] , int n ) { int count = 1 ; boolean prev = arr [ 0 ] ; for ( int i = 1 ; i < n ; ++ i ) { if ( ( arr [ i ] ^ prev ) == false ) { while ( count > 0 ) { System . out . print ( count -- + "" "" ) ; } } ++ count ; prev = arr [ i ] ; } while ( count != 0 ) { System . out . print ( count -- + "" "" ) ; } }"
"static void MinSteps ( int SourceX , int SourceY , int DestX , int DestY ) { System . out . println ( Math . max ( Math . abs ( SourceX - DestX ) , Math . abs ( SourceY - DestY ) ) ) ; while ( ( SourceX != DestX ) || ( SourceY != DestY ) ) { if ( SourceX < DestX ) { System . out . print ( 'U' ) ; SourceX ++ ; } if ( SourceX > DestX ) { System . out . println ( 'D' ) ; SourceX -- ; } if ( SourceY > DestY ) { System . out . print ( 'L' ) ; SourceY -- ; } if ( SourceY < DestY ) { System . out . print ( 'R' ) ; SourceY ++ ; } System . out . println ( ) ; } }"
static int fun ( int n ) { return n & ( n - 1 ) ; }
"static int minJumps ( int a , int b , int d ) { int temp = a ; a = Math . min ( a , b ) ; b = Math . max ( temp , b ) ; if ( d >= b ) return ( d + b - 1 ) / b ; if ( d == 0 ) return 0 ; if ( d == a ) return 1 ; return 2 ; }"
static int centered_square_num ( int n ) { return n * n + ( ( n - 1 ) * ( n - 1 ) ) ; }
"static int lis ( int arr [ ] , int n ) { int lis [ ] = new int [ n ] ; int i , j , max = 0 ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ; return max ; }"
"static int firstNonRepeating ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ i ] == arr [ j ] ) break ; if ( j == n ) return arr [ i ] ; } return - 1 ; }"
"static void removeDuplicates ( char [ ] S ) { int n = S . length ; if ( n < 2 ) { return ; } int j = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( S [ j ] != S [ i ] ) { j ++ ; S [ j ] = S [ i ] ; } } System . out . println ( Arrays . copyOfRange ( S , 0 , j + 1 ) ) ; }"
"static int findNumber ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int max = arr [ n - 1 ] ; int table [ ] = new int [ ( 2 * max ) + 1 ] ; table [ 0 ] = 0 ; for ( int i = 1 ; i < ( 2 * max ) + 1 ; i ++ ) table [ i ] = Integer . MAX_VALUE ; int ans = - 1 ; for ( int i = 1 ; i < ( 2 * max ) + 1 ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] <= i ) { int res = table [ i - arr [ j ] ] ; if ( res != Integer . MAX_VALUE && res + 1 < table [ i ] ) table [ i ] = res + 1 ; } } if ( i > arr [ n - 1 ] && table [ i ] == Integer . MAX_VALUE ) { ans = i ; break ; } } return ans ; }"
"static void findValues ( int a , int b ) { if ( ( a - b ) % 2 == 1 ) { System . out . println ( ""-1"" ) ; return ; } System . out . println ( ( ( a - b ) / 2 ) + "" "" + ( ( a + b ) / 2 ) ) ; }"
"static int countEleLessThanOrEqual ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { for ( int i = 0 ; i < m ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr2 [ j ] <= arr1 [ i ] ) count ++ ; System . out . print ( count + "" "" ) ; } return m ; }"
"static void SternSequenceFunc ( Vector < Integer > BrocotSequence , int n ) { for ( int i = 1 ; BrocotSequence . size ( ) < n ; i ++ ) { int considered_element = BrocotSequence . get ( i ) ; int precedent = BrocotSequence . get ( i - 1 ) ; BrocotSequence . add ( considered_element + precedent ) ; BrocotSequence . add ( considered_element ) ; } for ( int i = 0 ; i < 15 ; ++ i ) System . out . print ( BrocotSequence . get ( i ) + "" "" ) ; }"
"static void printPossible ( int a , int b , int c ) { if ( ( a + b + c ) % 2 != 0 || a + b < c ) System . out . println ( ""NO"" ) ; else System . out . println ( ""YES"" ) ; }"
"static int findMinInsertions ( char str [ ] , int l , int h ) { if ( l > h ) return Integer . MAX_VALUE ; if ( l == h ) return 0 ; if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1 ; return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str , l + 1 , h - 1 ) : ( Integer . min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) ; }"
"static int MinOfCubedDP ( int k ) { int [ ] DP = new int [ k + 1 ] ; int j = 1 , t = 1 ; DP [ 0 ] = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { DP [ i ] = Integer . MAX_VALUE ; while ( j <= i ) { if ( j == i ) DP [ i ] = 1 ; else if ( DP [ i ] > DP [ i - j ] ) DP [ i ] = DP [ i - j ] + 1 ; t ++ ; j = t * t * t ; } t = j = 1 ; } return DP [ k ] ; }"
static boolean isPowerOfFour ( int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) && ( n & 0xAAAAAAAA ) == 0 ; }
"static int countDistinct ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) { i ++ ; } res ++ ; } return res ; }"
"static void pre_process ( String substrings [ ] , String s ) { int n = s . length ( ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { String dup = """" ; for ( int j = i ; j < n ; j ++ ) { dup += s . charAt ( j ) ; substrings [ count ++ ] = dup ; } } int size = substrings . length ; for ( int i = 0 ; i < size - 1 ; i ++ ) { for ( int j = i + 1 ; j < substrings . length ; j ++ ) { if ( substrings [ i ] . compareTo ( substrings [ j ] ) > 0 ) { String temp = substrings [ i ] ; substrings [ i ] = substrings [ j ] ; substrings [ j ] = temp ; } } } }"
"static int countMaxContiguous ( int arr [ ] , int n ) { int current_max = 0 , max_so_far = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 != 0 ) current_max = 0 ; else { current_max ++ ; max_so_far = Math . max ( current_max , max_so_far ) ; } } return max_so_far ; }"
"static int bitAtGivenPosSetOrUnset ( int n , int k ) { int new_num = n >> ( k - 1 ) ; return ( new_num & 1 ) ; }"
"public static int nthTerm ( int N ) { int nth = 0 , i ; for ( i = N ; i > 0 ; i -- ) { nth += Math . pow ( i , i ) ; } return nth ; }"
static float angleOncirCumference ( float z ) { return ( z / 2 ) ; }
"static void countSubsequence ( String s , int n ) { int cntG = 0 , cntF = 0 , result = 0 , C = 0 ; for ( int i = 0 ; i < n ; i ++ ) { switch ( s . charAt ( i ) ) { case 'G' : cntG ++ ; result += C ; break ; case 'F' : cntF ++ ; C += cntG ; break ; default : continue ; } } System . out . println ( result ) ; }"
"static void minReplacement ( String str ) { if ( str . length ( ) > 26 ) { System . out . println ( ""IMPOSSIBLE"" ) ; } else { int hash [ ] = new int [ 26 ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { hash [ str . charAt ( i ) - 'a' ] ++ ; } int count = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( hash [ str . charAt ( i ) - 'a' ] > 1 ) { for ( int j = 0 ; j < 26 ; j ++ ) { if ( hash [ j ] == 0 ) { hash [ str . charAt ( i ) - 'a' ] -- ; str = str . substring ( 0 , i ) + ( char ) ( j + 'a' ) + str . substring ( i + 1 ) ; hash [ j ] ++ ; break ; } } } } System . out . println ( str ) ; } }"
static int numberOfWays ( int x ) { if ( x == 0 || x == 1 ) return 1 ; else return numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ; }
static long nthTerm ( long n ) { long nth ; if ( n % 2 == 0 ) nth = 2 * ( ( n * n ) - n ) ; else nth = ( 2 * n * n ) - n ; return nth ; }
"static int missingNumber ( int a [ ] , int n ) { Map < Integer , Integer > mp = new LinkedHashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > 0 ) { mp . put ( a [ i ] , mp . get ( a [ i ] ) == null ? 1 : mp . get ( a [ i ] ) + 1 ) ; } } int index = 1 ; while ( true ) { if ( ! mp . containsKey ( index ) ) { return index ; } index ++ ; } }"
"static int countSubarrays ( int a [ ] , int n ) { int count = 0 ; int [ ] pre = new int [ n + 1 ] ; Arrays . fill ( pre , 0 ) ; for ( int i = 1 ; i < n + 1 ; i ++ ) { pre [ i ] = pre [ i - 1 ] + a [ i - 1 ] ; } for ( int i = 1 ; i < n + 1 ; i ++ ) { for ( int j = i ; j < n + 1 ; j ++ ) { int sum1 = pre [ j ] - pre [ i - 1 ] , count1 = j - i + 1 ; int sum2 = pre [ n ] - sum1 , count2 = ( ( n - count1 ) == 0 ) ? 1 : ( n - count1 ) ; int includ = sum1 / count1 ; int exclud = sum2 / count2 ; if ( includ > exclud ) count ++ ; } } return count ; }"
"static void WindowtoViewport ( int x_w , int y_w , int x_wmax , int y_wmax , int x_wmin , int y_wmin , int x_vmax , int y_vmax , int x_vmin , int y_vmin ) { int x_v , y_v ; float sx , sy ; sx = ( float ) ( x_vmax - x_vmin ) / ( x_wmax - x_wmin ) ; sy = ( float ) ( y_vmax - y_vmin ) / ( y_wmax - y_wmin ) ; x_v = ( int ) ( x_vmin + ( float ) ( ( x_w - x_wmin ) * sx ) ) ; y_v = ( int ) ( y_vmin + ( float ) ( ( y_w - y_wmin ) * sy ) ) ; System . out . printf ( ""The point on viewport: (%d, %d )\n "" , x_v , y_v ) ; }"
"boolean find3Numbers ( int A [ ] , int arr_size , int sum ) { int l , r ; for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { for ( int j = i + 1 ; j < arr_size - 1 ; j ++ ) { for ( int k = j + 1 ; k < arr_size ; k ++ ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { System . out . print ( ""Triplet is "" + A [ i ] + "", "" + A [ j ] + "", "" + A [ k ] ) ; return true ; } } } } return false ; }"
"static int maxPartitions ( int arr [ ] , int n ) { int ans = 0 , max_so_far = 0 ; for ( int i = 0 ; i < n ; ++ i ) { max_so_far = Math . max ( max_so_far , arr [ i ] ) ; if ( max_so_far == i ) ans ++ ; } return ans ; }"
"static int minJumps ( int arr [ ] , int n ) { int [ ] jumps = new int [ n ] ; int min ; jumps [ n - 1 ] = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] == 0 ) jumps [ i ] = Integer . MAX_VALUE ; else if ( arr [ i ] >= n - i - 1 ) jumps [ i ] = 1 ; else { min = Integer . MAX_VALUE ; for ( int j = i + 1 ; j < n && j <= arr [ i ] + i ; j ++ ) { if ( min > jumps [ j ] ) min = jumps [ j ] ; } if ( min != Integer . MAX_VALUE ) jumps [ i ] = min + 1 ; else jumps [ i ] = min ; } } return jumps [ 0 ] ; }"
"static int countSol ( int coeff [ ] , int n , int rhs ) { int dp [ ] = new int [ rhs + 1 ] ; Arrays . fill ( dp , 0 ) ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = coeff [ i ] ; j <= rhs ; j ++ ) dp [ j ] += dp [ j - coeff [ i ] ] ; return dp [ rhs ] ; }"
"static int distribution ( int arr [ ] , int n ) { Set < Integer > resources = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) resources . add ( arr [ i ] ) ; return Math . min ( resources . size ( ) , n / 2 ) ; }"
"static void checksum ( int n ) { if ( n == 0 ) { System . out . println ( ""-2 -1 0 1 2"" ) ; return ; } int inc ; if ( n > 0 ) inc = 1 ; else inc = - 1 ; for ( int i = 0 ; i <= n - 4 ; i += inc ) { if ( i + i + 1 + i + 2 + i + 3 + i + 4 == n ) { System . out . print ( ( i ) + "" "" + ( i + 1 ) + "" "" + ( i + 2 ) + "" "" + ( i + 3 ) + "" "" + ( i + 4 ) ) ; return ; } } System . out . println ( ""-1"" ) ; }"
"static int minimumSets ( int arr [ ] , int n , int key ) { int i , j ; Arrays . sort ( arr ) ; for ( i = 0 , j = n - 1 ; i <= j ; ++ i ) if ( arr [ i ] + arr [ j ] <= key ) j -- ; return i ; }"
"static int findMinDiff ( int [ ] arr , int n ) { int diff = Integer . MAX_VALUE ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( ( arr [ i ] - arr [ j ] ) ) < diff ) diff = Math . abs ( ( arr [ i ] - arr [ j ] ) ) ; return diff ; }"
"static void printSubArrays ( int [ ] arr , int start , int end ) { if ( end == arr . length ) return ; else if ( start > end ) printSubArrays ( arr , 0 , end + 1 ) ; else { System . out . print ( ""["" ) ; for ( int i = start ; i < end ; i ++ ) { System . out . print ( arr [ i ] + "", "" ) ; } System . out . println ( arr [ end ] + ""]"" ) ; printSubArrays ( arr , start + 1 , end ) ; } return ; }"
"static int findCountOfPairs ( int a , int b , int n ) { int ans = 0 ; for ( int i = 1 ; i <= a ; i ++ ) { ans += b / n ; ans += ( i % n + b % n ) >= n ? 1 : 0 ; } return ans ; }"
"static int maxnumber ( int n , int k ) { for ( int j = 0 ; j < k ; j ++ ) { int ans = 0 ; int i = 1 ; while ( n / i > 0 ) { int temp = ( n / ( i * 10 ) ) * i + ( n % i ) ; i *= 10 ; ans = Math . max ( ans , temp ) ; } n = ans ; } return n ; }"
"static boolean hasCrest ( int arr [ ] , int n , int L , int R ) { int [ ] present = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { present [ i ] = 0 ; } for ( int i = 1 ; i <= n - 2 ; i ++ ) { if ( ( arr [ i ] <= arr [ i + 1 ] ) && ( arr [ i ] <= arr [ i - 1 ] ) ) { present [ i ] = 1 ; } } for ( int i = 1 ; i < n ; i ++ ) { present [ i ] += present [ i - 1 ] ; } if ( present [ L ] == present [ R - 1 ] ) return true ; return false ; }"
"static void findMajority ( int arr [ ] , int n ) { int maxCount = 0 ; int index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count > maxCount ) { maxCount = count ; index = i ; } } if ( maxCount > n / 2 ) System . out . println ( arr [ index ] ) ; else System . out . println ( ""No Majority Element"" ) ; }"
"static void printTrib ( int n ) { if ( n < 1 ) return ; int first = 0 , second = 0 ; int third = 1 ; System . out . print ( first + "" "" ) ; if ( n > 1 ) System . out . print ( second + "" "" ) ; if ( n > 2 ) System . out . print ( second + "" "" ) ; for ( int i = 3 ; i < n ; i ++ ) { int curr = first + second + third ; first = second ; second = third ; third = curr ; System . out . print ( curr + "" "" ) ; } }"
"static void maxCircularSum ( int [ ] arr , int n , int k ) { if ( n < k ) { System . out . println ( ""Invalid"" ) ; return ; } int sum = 0 , start = 0 , end = k - 1 ; for ( int i = 0 ; i < k ; i ++ ) sum += arr [ i ] ; int ans = sum ; for ( int i = k ; i < n + k ; i ++ ) { sum += arr [ i % n ] - arr [ ( i - k ) % n ] ; if ( sum > ans ) { ans = sum ; start = ( i - k + 1 ) % n ; end = i % n ; } } System . out . println ( ""max circular sum = "" + ans ) ; System . out . println ( ""start index = "" + start + ""\nend index = "" + end ) ; }"
static int evenNumSubstring ( String str ) { int len = str . length ( ) ; int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int temp = str . charAt ( i ) - '0' ; if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; }
"static int minimumSubarrays ( int ar [ ] , int n ) { Vector se = new Vector ( ) ; int cnt = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( se . contains ( ar [ i ] ) == false ) { se . add ( ar [ i ] ) ; } else { cnt ++ ; se . clear ( ) ; se . add ( ar [ i ] ) ; } } return cnt ; }"
"static int countPairs ( int arr [ ] , int n ) { HashMap < Integer , Integer > map = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) map . put ( arr [ i ] - i , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) map . put ( arr [ i ] - i , map . get ( arr [ i ] - i ) + 1 ) ; int res = 0 ; for ( int x : map . values ( ) ) { int cnt = x ; res += ( ( cnt * ( cnt - 1 ) ) / 2 ) ; } return res ; }"
"static int lastPosition ( int n , int m , int k ) { if ( m <= n - k + 1 ) return m + k - 1 ; m = m - ( n - k + 1 ) ; return ( m % n == 0 ) ? n : ( m % n ) ; }"
"static int count ( int S [ ] , int m , int n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; }"
"static String decodeMedianString ( String s ) { int l = s . length ( ) ; String s1 = """" ; boolean isEven = ( l % 2 == 0 ) ? true : false ; for ( int i = 0 ; i < l ; i += 2 ) { if ( isEven ) { s1 = s . charAt ( i ) + s1 ; s1 += s . charAt ( i + 1 ) ; } else { if ( l - i > 1 ) { s1 += s . charAt ( i ) ; s1 = s . charAt ( i + 1 ) + s1 ; } else { s1 += s . charAt ( i ) ; } } } return s1 ; }"
"static void checkSolution ( int a , int b , int c ) { if ( ( ( b * b ) - ( 4 * a * c ) ) > 0 ) System . out . println ( ""2 solutions"" ) ; else if ( ( ( b * b ) - ( 4 * a * c ) ) == 0 ) System . out . println ( ""1 solution"" ) ; else System . out . println ( ""No solutions"" ) ; }"
"static boolean find3Numbers ( int A [ ] , int arr_size , int sum ) { for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; int curr_sum = sum - A [ i ] ; for ( int j = i + 1 ; j < arr_size ; j ++ ) { if ( s . contains ( curr_sum - A [ j ] ) && curr_sum - A [ j ] != ( int ) s . toArray ( ) [ s . size ( ) - 1 ] ) { System . out . printf ( ""Triplet is %d, %d, %d"" , A [ i ] , A [ j ] , curr_sum - A [ j ] ) ; return true ; } s . add ( A [ j ] ) ; } } return false ; }"
"static int max_profit ( int a [ ] , int b [ ] , int n , int fee ) { int i , j , profit ; int l , r , diff_day = 1 , sum = 0 ; b [ 0 ] = 0 ; b [ 1 ] = diff_day ; for ( i = 1 ; i < n ; i ++ ) { l = 0 ; r = diff_day ; sum = 0 ; for ( j = n - 1 ; j >= i ; j -- ) { profit = ( a [ r ] - a [ l ] ) - fee ; if ( profit > 0 ) { sum = sum + profit ; } l ++ ; r ++ ; } if ( b [ 0 ] < sum ) { b [ 0 ] = sum ; b [ 1 ] = diff_day ; } diff_day ++ ; } return 0 ; }"
"static int findMaxSum ( int [ ] arr , int n ) { int res = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int prefix_sum = arr [ i ] ; for ( int j = 0 ; j < i ; j ++ ) prefix_sum += arr [ j ] ; int suffix_sum = arr [ i ] ; for ( int j = n - 1 ; j > i ; j -- ) suffix_sum += arr [ j ] ; if ( prefix_sum == suffix_sum ) res = Math . max ( res , prefix_sum ) ; } return res ; }"
"static boolean isReversible ( String str ) { int i = 0 , j = str . length ( ) - 1 ; while ( i < j ) { if ( str . charAt ( i ) != str . charAt ( j ) ) return false ; i ++ ; j -- ; } return true ; }"
static char maxRepeating ( String str ) { int len = str . length ( ) ; int count = 0 ; char res = str . charAt ( 0 ) ; for ( int i = 0 ; i < len ; i ++ ) { int cur_count = 1 ; for ( int j = i + 1 ; j < len ; j ++ ) { if ( str . charAt ( i ) != str . charAt ( j ) ) break ; cur_count ++ ; } if ( cur_count > count ) { count = cur_count ; res = str . charAt ( i ) ; } } return res ; }
"static int longestSubarray ( int a [ ] , int n , int x ) { int count = 0 ; int length = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) { count += 1 ; } else { length = Math . max ( length , count ) ; count = 0 ; } } if ( count > 0 ) length = Math . max ( length , count ) ; return length ; }"
public static boolean checkPangram ( String str ) { boolean [ ] mark = new boolean [ 26 ] ; int index = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( 'A' <= str . charAt ( i ) && str . charAt ( i ) <= 'Z' ) index = str . charAt ( i ) - 'A' ; else if ( 'a' <= str . charAt ( i ) && str . charAt ( i ) <= 'z' ) index = str . charAt ( i ) - 'a' ; mark [ index ] = true ; } for ( int i = 0 ; i <= 25 ; i ++ ) if ( mark [ i ] == false ) return ( false ) ; return ( true ) ; }
static void interchangeFirstLast ( int m [ ] [ ] ) { int rows = m . length ; for ( int i = 0 ; i < m [ 0 ] . length ; i ++ ) { int t = m [ 0 ] [ i ] ; m [ 0 ] [ i ] = m [ rows - 1 ] [ i ] ; m [ rows - 1 ] [ i ] = t ; } }
"public static void getPairsCount ( int [ ] arr , int sum ) { int count = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) for ( int j = i + 1 ; j < arr . length ; j ++ ) if ( ( arr [ i ] + arr [ j ] ) == sum ) count ++ ; System . out . printf ( ""Count of pairs is %d"" , count ) ; }"
"static boolean FindPoint ( int x1 , int y1 , int x2 , int y2 , int x , int y ) { if ( x > x1 && x < x2 && y > y1 && y < y2 ) return true ; return false ; }"
static int cassini ( int n ) { return ( n & 1 ) != 0 ? - 1 : 1 ; }
"static int solve ( int A [ ] , int B [ ] , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) if ( Integer . bitCount ( A [ i ] | A [ j ] ) == B [ j ] ) { cnt ++ ; } return cnt ; }"
static int makeOdd ( int n ) { if ( n % 2 != 0 ) return 1 ; int i ; for ( i = 2 ; i <= n ; i ++ ) if ( ( n % i == 0 ) && ( ( n / i ) % 2 == 1 ) ) break ; return i ; }
"static int checkBitonic ( int arr [ ] , int n ) { int i , j ; for ( i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] ) continue ; if ( arr [ i ] <= arr [ i - 1 ] ) break ; } if ( i == n - 1 ) return 1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] < arr [ j - 1 ] ) continue ; if ( arr [ j ] >= arr [ j - 1 ] ) break ; } i = j ; if ( i != n ) return 0 ; return 1 ; }"
"static int minMoves ( int n , int a [ ] , int k ) { int ct1 [ ] = new int [ k ] ; int ct0 [ ] = new int [ k ] ; int moves = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == 1 ) ct1 [ i % k ] ++ ; else ct0 [ i % k ] ++ ; for ( int i = 0 ; i < k ; i ++ ) moves += Math . min ( ct1 [ i ] , ct0 [ i ] ) ; return moves ; }"
"static int minOperations ( String s , String t , int n ) { int ct0 = 0 , ct1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == t . charAt ( i ) ) continue ; if ( s . charAt ( i ) == '0' ) ct0 ++ ; else ct1 ++ ; } return Math . max ( ct0 , ct1 ) ; }"
"static int findSum ( int N , int k ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += ( int ) Math . pow ( i , k ) ; } return sum ; }"
"static long calculate ( long a [ ] , int n ) { Arrays . sort ( a ) ; int i , j ; Vector < Long > s = new Vector < > ( ) ; for ( i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) s . add ( ( a [ i ] + a [ j ] ) ) ; long mini = Collections . min ( s ) ; long maxi = Collections . max ( s ) ; return Math . abs ( maxi - mini ) ; }"
"static int largestSquareFactor ( int num ) { int answer = 1 ; for ( int i = 2 ; i < Math . sqrt ( num ) ; ++ i ) { int cnt = 0 ; int j = i ; while ( num % j == 0 ) { cnt ++ ; j *= i ; } if ( ( cnt & 1 ) != 0 ) { cnt -- ; answer *= Math . pow ( i , cnt ) ; } else { answer *= Math . pow ( i , cnt ) ; } } return answer ; }"
"static int usingBinarySearch ( int start , int end , int N , int S ) { if ( start >= end ) return start ; int mid = start + ( end - start ) / 2 ; int totalSum = ( N * ( N + 1 ) ) / 2 ; int midSum = ( mid * ( mid + 1 ) ) / 2 ; if ( ( totalSum - midSum ) <= S ) { return usingBinarySearch ( start , mid , N , S ) ; } return usingBinarySearch ( mid + 1 , end , N , S ) ; }"
"static int getMinDiff ( int arr [ ] , int n , int k ) { if ( n == 1 ) return 0 ; Arrays . sort ( arr ) ; int ans = arr [ n - 1 ] - arr [ 0 ] ; int small = arr [ 0 ] + k ; int big = arr [ n - 1 ] - k ; int temp = 0 ; if ( small > big ) { temp = small ; small = big ; big = temp ; } for ( int i = 1 ; i < n - 1 ; i ++ ) { int subtract = arr [ i ] - k ; int add = arr [ i ] + k ; if ( subtract >= small || add <= big ) continue ; if ( big - subtract <= add - small ) small = subtract ; else big = add ; } return Math . min ( ans , big - small ) ; }"
"static int maximumXOR ( int n , int l , int r ) { int x = 0 ; for ( int i = ( int ) ( Math . log ( r ) / Math . log ( 2 ) ) ; i >= 0 ; -- i ) { if ( ( n & ( 1 << i ) ) > 0 ) { if ( ( x > r ) || ( x + ( 1 << i ) - 1 < l ) ) x ^= ( 1 << i ) ; } else { if ( ( x ^ ( 1 << i ) ) <= r ) x ^= ( 1 << i ) ; } } return n ^ x ; }"
"static int findMinSum ( int arr [ ] , int n ) { int occ = n - 1 , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] * ( int ) Math . pow ( 2 , occ ) ; occ -- ; } return sum ; }"
"static int countPairs ( int a [ ] , int n ) { int mn = Integer . MAX_VALUE ; int mx = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { mn = Math . min ( mn , a [ i ] ) ; mx = Math . max ( mx , a [ i ] ) ; } int c1 = 0 ; int c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == mn ) c1 ++ ; if ( a [ i ] == mx ) c2 ++ ; } if ( mn == mx ) return n * ( n - 1 ) / 2 ; else return c1 * c2 ; }"
"static void split ( int x , int n ) { if ( x < n ) System . out . print ( ""-1 "" ) ; else if ( x % n == 0 ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( ( x / n ) + "" "" ) ; } else { int zp = n - ( x % n ) ; int pp = x / n ; for ( int i = 0 ; i < n ; i ++ ) { if ( i >= zp ) System . out . print ( ( pp + 1 ) + "" "" ) ; else System . out . print ( pp + "" "" ) ; } } }"
"static void printSquares ( int n ) { int square = 0 , odd = 1 ; for ( int x = 0 ; x < n ; x ++ ) { System . out . print ( square + "" "" ) ; square = square + odd ; odd = odd + 2 ; } }"
"static int maxTripletSum ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ; }"
"static void printCombination ( int n ) { System . out . print ( 1 + "" "" ) ; if ( ( n - 2 ) % 3 == 0 ) System . out . print ( 2 + "" "" + ( n - 3 ) ) ; else System . out . print ( 1 + "" "" + ( n - 2 ) ) ; }"
"static int SquareCube ( long N ) { int cnt = 0 , i = 1 ; while ( ( int ) ( Math . pow ( i , 6 ) ) <= N ) { ++ cnt ; ++ i ; } return cnt ; }"
"public static long findWays ( int m , int n , int x ) { long [ ] [ ] table = new long [ n + 1 ] [ x + 1 ] ; for ( int j = 1 ; j <= m && j <= x ; j ++ ) table [ 1 ] [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= x ; j ++ ) { for ( int k = 1 ; k < j && k <= m ; k ++ ) table [ i ] [ j ] += table [ i - 1 ] [ j - k ] ; } } return table [ n ] [ x ] ; }"
"static int kthLargestSum ( int arr [ ] , int n , int k ) { int sum [ ] = new int [ n + 1 ] ; sum [ 0 ] = 0 ; sum [ 1 ] = arr [ 0 ] ; for ( int i = 2 ; i <= n ; i ++ ) sum [ i ] = sum [ i - 1 ] + arr [ i - 1 ] ; PriorityQueue < Integer > Q = new PriorityQueue < Integer > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { int x = sum [ j ] - sum [ i - 1 ] ; if ( Q . size ( ) < k ) Q . add ( x ) ; else { if ( Q . peek ( ) < x ) { Q . poll ( ) ; Q . add ( x ) ; } } } } return Q . poll ( ) ; }"
"static void checkArray ( int a [ ] , int b [ ] , int n ) { int operations = 0 ; int i = 0 ; while ( i < n ) { if ( a [ i ] - b [ i ] == 0 ) { i ++ ; continue ; } int diff = a [ i ] - b [ i ] ; i ++ ; while ( i < n && a [ i ] - b [ i ] == diff ) { i ++ ; } operations ++ ; } System . out . println ( operations ) ; }"
"static int printSmallest ( int a [ ] ) { int sum , sum1 ; Arrays . sort ( a ) ; int i , j , k , num ; for ( i = 0 ; i < 3 ; i ++ ) { if ( a [ i ] % 3 == 0 ) { return a [ i ] ; } } for ( i = 0 ; i < 3 ; i ++ ) { for ( j = 0 ; j < 3 ; j ++ ) { num = ( a [ i ] * 10 ) + a [ j ] ; if ( num % 3 == 0 ) { return num ; } } } return a [ 0 ] * 100 + a [ 0 ] * 10 + a [ 0 ] ; }"
"static void minimizeWithKSwaps ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n - 1 && k > 0 ; ++ i ) { int pos = i ; for ( int j = i + 1 ; j < n ; ++ j ) { if ( j - i > k ) break ; if ( arr [ j ] < arr [ pos ] ) pos = j ; } int temp ; for ( int j = pos ; j > i ; -- j ) { temp = arr [ j ] ; arr [ j ] = arr [ j - 1 ] ; arr [ j - 1 ] = temp ; } k -= pos - i ; } }"
"static void findMin ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; Arrays . sort ( arr ) ; int min = arr [ 0 ] ; int max = 0 ; for ( int i = n - 1 ; i >= 1 ; i -- ) { int num = arr [ i ] ; int total = num + min ; int j ; for ( j = 2 ; j <= num ; j ++ ) { if ( num % j == 0 ) { int d = j ; int now = ( num / d ) + ( min * d ) ; int reduce = total - now ; if ( reduce > max ) max = reduce ; } } } System . out . println ( sum - max ) ; }"
"static String newString ( String s , int k ) { String X = """" ; while ( s . length ( ) > 0 ) { char temp = s . charAt ( 0 ) ; for ( int i = 1 ; i < k && i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) < temp ) { temp = s . charAt ( i ) ; } } X = X + temp ; for ( int i = 0 ; i < k ; i ++ ) { if ( s . charAt ( i ) == temp ) { s = s . substring ( 0 , i ) + s . substring ( i + 1 ) ; break ; } } } return X ; }"
"static float SellingPrice ( float CP , float PP ) { float P_decimal = 1 + ( PP / 100 ) ; float res = P_decimal * CP ; return res ; }"
"static void solve ( String s ) { String z = s ; int l = s . length ( ) ; int i ; String str ; if ( s . indexOf ( '+' ) != - 1 ) { i = s . indexOf ( '+' ) ; str = s . replace ( '+' , '-' ) ; } else { i = s . indexOf ( '-' ) ; str = s . replace ( '-' , '+' ) ; } System . out . println ( ""Conjugate of "" + z + "" = "" + str ) ; }"
"static void vowelOrConsonant ( char x ) { if ( x == 'a' || x == 'e' || x == 'i' || x == 'o' || x == 'u' ) System . out . println ( ""Vowel"" ) ; else System . out . println ( ""Consonant"" ) ; }"
"static String findSum ( String str1 , String str2 ) { if ( str1 . length ( ) > str2 . length ( ) ) { String t = str1 ; str1 = str2 ; str2 = t ; } String str = """" ; int n1 = str1 . length ( ) , n2 = str2 . length ( ) ; int diff = n2 - n1 ; int carry = 0 ; for ( int i = n1 - 1 ; i >= 0 ; i -- ) { int sum = ( ( int ) ( str1 . charAt ( i ) - '0' ) + ( int ) ( str2 . charAt ( i + diff ) - '0' ) + carry ) ; str += ( char ) ( sum % 10 + '0' ) ; carry = sum / 10 ; } for ( int i = n2 - n1 - 1 ; i >= 0 ; i -- ) { int sum = ( ( int ) ( str2 . charAt ( i ) - '0' ) + carry ) ; str += ( char ) ( sum % 10 + '0' ) ; carry = sum / 10 ; } if ( carry > 0 ) str += ( char ) ( carry + '0' ) ; return new StringBuilder ( str ) . reverse ( ) . toString ( ) ; }"
"static int binarySearchCount ( int arr [ ] , int n , int key ) { int left = 0 , right = n ; int mid = 0 ; while ( left < right ) { mid = ( right + left ) >> 1 ; if ( arr [ mid ] == key ) { while ( mid + 1 < n && arr [ mid + 1 ] == key ) mid ++ ; break ; } else if ( arr [ mid ] > key ) right = mid ; else left = mid + 1 ; } while ( mid > - 1 && arr [ mid ] > key ) mid -- ; return mid + 1 ; }"
static boolean isMinHeap ( int [ ] level ) { int n = level . length - 1 ; for ( int i = ( n / 2 - 1 ) ; i >= 0 ; i -- ) { if ( level [ i ] > level [ 2 * i + 1 ] ) return false ; if ( 2 * i + 2 < n ) { if ( level [ i ] > level [ 2 * i + 2 ] ) return false ; } } return true ; }
"static void printMaxSum ( int arr [ ] , int n ) { int dp [ ] = new int [ n ] ; Arrays . fill ( dp , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = arr [ i ] ; int maxi = 0 ; for ( int j = 1 ; j <= Math . sqrt ( i + 1 ) ; j ++ ) { if ( ( ( i + 1 ) % j == 0 ) && ( i + 1 ) != j ) { if ( dp [ j - 1 ] > maxi ) maxi = dp [ j - 1 ] ; if ( dp [ ( i + 1 ) / j - 1 ] > maxi && j != 1 ) maxi = dp [ ( i + 1 ) / j - 1 ] ; } } dp [ i ] += maxi ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( dp [ i ] + "" "" ) ; }"
"static int findRepeatingElement ( int arr [ ] , int low , int high ) { if ( low > high ) return - 1 ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] != mid + 1 ) { if ( mid > 0 && arr [ mid ] == arr [ mid - 1 ] ) return mid ; return findRepeatingElement ( arr , low , mid - 1 ) ; } return findRepeatingElement ( arr , mid + 1 , high ) ; }"
"static int LCIS ( int arr1 [ ] , int n , int arr2 [ ] , int m ) { int table [ ] = new int [ m ] ; for ( int j = 0 ; j < m ; j ++ ) table [ j ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int current = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( arr1 [ i ] == arr2 [ j ] ) if ( current + 1 > table [ j ] ) table [ j ] = current + 1 ; if ( arr1 [ i ] > arr2 [ j ] ) if ( table [ j ] > current ) current = table [ j ] ; } } int result = 0 ; for ( int i = 0 ; i < m ; i ++ ) if ( table [ i ] > result ) result = table [ i ] ; return result ; }"
"static void sortArray ( int a [ ] , int n ) { Vector < Integer > ans = new Vector < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= 0 ) ans . add ( a [ i ] ) ; } Collections . sort ( ans ) ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= 0 ) { a [ i ] = ans . get ( j ) ; j ++ ; } } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( a [ i ] + "" "" ) ; }"
static boolean isDivisible ( int n ) { int d ; while ( ( n / 100 ) <= 0 ) { d = n % 10 ; n /= 10 ; n = Math . abs ( n - ( d * 7 ) ) ; } return ( n % 71 == 0 ) ; }
"static void pyramid ( int n ) { int i , j , num , gap ; for ( i = n ; i >= 1 ; i -- ) { for ( gap = n - 1 ; gap >= i ; gap -- ) { System . out . print ( "" "" ) ; System . out . print ( "" "" ) ; } num = 'A' ; for ( j = 1 ; j <= i ; j ++ ) { System . out . print ( ( char ) num ++ + "" "" ) ; } for ( j = i - 1 ; j >= 0 ; j -- ) { System . out . print ( ( char ) -- num + "" "" ) ; } System . out . println ( """" ) ; } }"
static boolean checkTriangularSumRepresentation ( int n ) { HashSet < Integer > tri = new HashSet < > ( ) ; int i = 1 ; while ( true ) { int x = i * ( i + 1 ) / 2 ; if ( x >= n ) { break ; } tri . add ( x ) ; i ++ ; } for ( Integer tm : tri ) { if ( tri . contains ( n - tm ) && ( n - tm ) != ( int ) tri . toArray ( ) [ tri . size ( ) - 1 ] ) { return true ; } } return false ; }
static int calculateLeaps ( int n ) { if ( n == 0 || n == 1 ) { return 1 ; } else { int leaps = 0 ; for ( int i = 0 ; i < n ; i ++ ) leaps += calculateLeaps ( i ) ; return leaps ; } }
"static int rotateRec ( int n , int L [ ] , int B [ ] ) { int m = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( Math . max ( L [ i ] , B [ i ] ) <= m ) m = Math . max ( L [ i ] , B [ i ] ) ; else if ( Math . min ( L [ i ] , B [ i ] ) <= m ) m = Math . min ( L [ i ] , B [ i ] ) ; else { return 0 ; } } return 1 ; }"
"static boolean check ( String s , int m ) { int l = s . length ( ) ; int c1 = 0 ; int c2 = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s . charAt ( i ) == '0' ) { c2 = 0 ; c1 ++ ; } else { c1 = 0 ; c2 ++ ; } if ( c1 == m || c2 == m ) return true ; } return false ; }"
"static void printTwoSetBitNums ( int n ) { int x = 1 ; while ( n > 0 ) { int y = 0 ; while ( y < x ) { System . out . print ( ( ( 1 << x ) + ( 1 << y ) ) + "" "" ) ; n -- ; if ( n == 0 ) return ; y ++ ; } x ++ ; } }"
"static int EqualNumbers ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; if ( sum % n != 0 ) return n - 1 ; return n ; }"
"static public int LongestSubarray ( int arr [ ] , int n , int k ) { int count = 1 ; int max_length = 1 ; int prev_mod = arr [ 0 ] % k ; for ( int i = 1 ; i < n ; i ++ ) { int curr_mod = arr [ i ] % k ; if ( curr_mod == prev_mod ) { count ++ ; } else { max_length = Math . max ( max_length , count ) ; count = 1 ; prev_mod = curr_mod ; } } return max_length ; }"
"static int rangeGCD ( int n , int m ) { return ( n == m ) ? n : 1 ; }"
static int nondecdigits ( int n ) { int x = 0 ; for ( x = n ; x >= 1 ; x -- ) { int no = x ; int prev_dig = 11 ; boolean flag = true ; while ( no != 0 ) { if ( prev_dig < no % 10 ) { flag = false ; break ; } prev_dig = no % 10 ; no /= 10 ; } if ( flag == true ) break ; } return x ; }
"static int findAnswer ( int X , int N ) { return ( N - 1 ) * 9 + X ; }"
"static String reversingString ( char [ ] str , int start , int end ) { while ( start < end ) { str [ start ] ^= str [ end ] ; str [ end ] ^= str [ start ] ; str [ start ] ^= str [ end ] ; ++ start ; -- end ; } return String . valueOf ( str ) ; }"
"static int minimumflip ( int mat [ ] [ ] , int n ) { int transpose [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) transpose [ i ] [ j ] = mat [ j ] [ i ] ; int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( transpose [ i ] [ j ] != mat [ i ] [ j ] ) flip ++ ; return flip / 2 ; }"
"static int getMaxNum ( int a , int b , int c ) { if ( b % c == 0 ) return b ; int x = ( ( b / c ) * c ) ; if ( x >= a && x <= b ) return x ; else return - 1 ; }"
public static String recursiveReverse ( char [ ] str ) { Stack < Character > st = new Stack < > ( ) ; for ( int i = 0 ; i < str . length ; i ++ ) st . push ( str [ i ] ) ; for ( int i = 0 ; i < str . length ; i ++ ) { str [ i ] = st . peek ( ) ; st . pop ( ) ; } return String . valueOf ( str ) ; }
static boolean isTidy ( int num ) { int prev = 10 ; while ( num != 0 ) { int rem = num % 10 ; num /= 10 ; if ( rem > prev ) return false ; prev = rem ; } return true ; }
"static int findLastIndex ( String str , Character x ) { int index = - 1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( str . charAt ( i ) == x ) index = i ; return index ; }"
"static double Nth_Term ( int n ) { return ( 2 * Math . pow ( n , 3 ) - 3 * Math . pow ( n , 2 ) + n + 6 ) / 6 ; }"
"static void printNonDivisible ( int [ ] A , int [ ] B , int n , int m ) { for ( int i = 0 ; i < m ; i ++ ) { int j = 0 ; for ( j = 0 ; j < n ; j ++ ) if ( B [ i ] % A [ j ] == 0 ) break ; if ( j == n ) System . out . println ( B [ i ] ) ; } }"
"static long findSmallestNonZeroY ( long A_num ) { String A_binary = Long . toBinaryString ( A_num ) ; long B = 1 ; int len = A_binary . length ( ) ; int no_ones = Long . bitCount ( A_num ) ; if ( len == no_ones ) { return A_num + 1 ; } for ( int i = 0 ; i < len ; i ++ ) { char ch = A_binary . charAt ( len - i - 1 ) ; if ( ch == '0' ) { B = ( long ) Math . pow ( 2.0 , ( double ) i ) ; break ; } } return B ; }"
"static void getPermutation ( int a [ ] , int n ) { int [ ] ans = new int [ n ] ; ans [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) ans [ i ] = a [ i ] - a [ i - 1 ] ; boolean [ ] present = new boolean [ n + 1 ] ; for ( int i = 0 ; i < ans . length ; i ++ ) { if ( present [ ans [ i ] ] ) { System . out . print ( ""-1"" ) ; return ; } else present [ ans [ i ] ] = true ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( ans [ i ] + "" "" ) ; }"
"static boolean isPossibleTriangle ( int [ ] arr , int N ) { if ( N < 3 ) return false ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < N - 2 ; i ++ ) if ( arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] ) return true ; return false ; }"
"static int maxProfit ( int price [ ] , int n ) { int profit [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) profit [ i ] = 0 ; int max_price = price [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( price [ i ] > max_price ) max_price = price [ i ] ; profit [ i ] = Math . max ( profit [ i + 1 ] , max_price - price [ i ] ) ; } int min_price = price [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( price [ i ] < min_price ) min_price = price [ i ] ; profit [ i ] = Math . max ( profit [ i - 1 ] , profit [ i ] + ( price [ i ] - min_price ) ) ; } int result = profit [ n - 1 ] ; return result ; }"
"static int maxValue ( int arr [ ] , int n , int moves ) { for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > 0 ) { int distance = n - 1 - i ; if ( moves < distance ) break ; int can_take = moves / distance ; int take = Math . min ( arr [ i ] , can_take ) ; arr [ n - 1 ] += take ; moves -= take * distance ; } } return arr [ n - 1 ] ; }"
"public static void rearrange ( int arr [ ] , int n ) { int max_ele = arr [ n - 1 ] ; int min_ele = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] = max_ele ; max_ele -= 1 ; } else { arr [ i ] = min_ele ; min_ele += 1 ; } } }"
static int getSum ( int n ) { int sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; }
static long doublefactorial ( long n ) { if ( n == 0 || n == 1 ) return 1 ; return n * doublefactorial ( n - 2 ) ; }
"static void Maximum_xor_Triplet ( int n , int a [ ] ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { s . add ( a [ i ] ^ a [ j ] ) ; } } int ans = 0 ; for ( Integer i : s ) { for ( int j = 0 ; j < n ; j ++ ) { ans = Math . max ( ans , i ^ a [ j ] ) ; } } System . out . println ( ans ) ; }"
static boolean isPower ( int n ) { for ( int x = 2 ; x <= Math . sqrt ( n ) ; x ++ ) { int p = x ; while ( p <= n ) { p = p * x ; if ( p == n ) return true ; } } return false ; }
"static String FirstAndLast ( String str ) { String [ ] arrOfStr = str . split ( "" "" ) ; String res = """" ; for ( String a : arrOfStr ) { res += a . substring ( 1 , a . length ( ) - 1 ) + "" "" ; } return res ; }"
static void moveSpaceInFront ( char str [ ] ) { int i = str . length - 1 ; for ( int j = i ; j >= 0 ; j -- ) if ( str [ j ] != ' ' ) str [ i -- ] = str [ j ] ; while ( i >= 0 ) str [ i -- ] = ' ' ; }
"static boolean isCyclic ( long N ) { long num = N ; int count = 0 ; int digit = ( int ) ( num % 10 ) ; boolean allSame = true ; while ( num > 0 ) { count ++ ; if ( num % 10 != digit ) allSame = false ; num = num / 10 ; } if ( allSame == true ) return false ; if ( count % 2 == 0 ) { long halfPower = ( long ) Math . pow ( 10 , count / 2 ) ; long firstHalf = N % halfPower ; long secondHalf = N / halfPower ; if ( firstHalf == firstHalf && isCyclic ( firstHalf ) ) return false ; } num = N ; while ( true ) { long rem = num % 10 ; long div = num / 10 ; num = ( long ) ( Math . pow ( 10 , count - 1 ) ) * rem + div ; if ( num == N ) break ; if ( num % N != 0 ) return false ; } return true ; }"
"public static int countOddSquares ( int n , int m ) { return ( int ) Math . pow ( ( double ) m , 0.5 ) - ( int ) Math . pow ( ( double ) n - 1 , 0.5 ) ; }"
"static void findRealAndImag ( String s ) { int l = s . length ( ) ; int i ; if ( s . indexOf ( '+' ) != - 1 ) { i = s . indexOf ( '+' ) ; } else { i = s . indexOf ( '-' ) ; } String real = s . substring ( 0 , i ) ; String imaginary = s . substring ( i + 1 , l - 1 ) ; System . out . println ( ""Real part: "" + real ) ; System . out . println ( ""Imaginary part: "" + imaginary ) ; }"
static boolean isPower ( int n ) { for ( int x = 2 ; x <= ( int ) Math . sqrt ( n ) ; x ++ ) { float f = ( float ) Math . log ( n ) / ( float ) Math . log ( x ) ; if ( ( f - ( int ) f ) == 0.0 ) return true ; } return false ; }
"static boolean isPower ( int x , int y ) { int res1 = ( int ) Math . log ( y ) / ( int ) Math . log ( x ) ; double res2 = Math . log ( y ) / Math . log ( x ) ; return ( res1 == res2 ) ; }"
"static int get_last_two_digit ( long N ) { if ( N <= 10 ) { long ans = 0 , fac = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { fac = fac * i ; ans += fac ; } return ( int ) ans % 100 ; } else return 13 ; }"
"static void find ( int n ) { String [ ] arr = new String [ n + 1 ] ; arr [ 0 ] = """" ; int size = 1 , m = 1 ; while ( size <= n ) { for ( int i = 0 ; i < m && ( size + i ) <= n ; i ++ ) arr [ size + i ] = ""3"" + arr [ size - m + i ] ; for ( int i = 0 ; i < m && ( size + m + i ) <= n ; i ++ ) arr [ size + m + i ] = ""4"" + arr [ size - m + i ] ; m = m << 1 ; size = size + m ; } System . out . println ( arr [ n ] ) ; }"
"static int findMin ( int arr [ ] , int low , int high ) { if ( high < low ) return arr [ 0 ] ; if ( high == low ) return arr [ low ] ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ] ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , low , mid - 1 ) ; return findMin ( arr , mid + 1 , high ) ; }"
"static double calculate_angle ( int n , int i , int j , int k ) { int x , y ; if ( i < j ) x = j - i ; else x = j + n - i ; if ( j < k ) y = k - j ; else y = k + n - j ; double ang1 = ( 180 * x ) / n ; double ang2 = ( 180 * y ) / n ; double ans = 180 - ang1 - ang2 ; return ans ; }"
"static int firstElement ( int arr [ ] , int n , int k ) { HashMap < Integer , Integer > count_map = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int a = 0 ; if ( count_map . get ( arr [ i ] ) != null ) { a = count_map . get ( arr [ i ] ) ; } count_map . put ( arr [ i ] , a + 1 ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( count_map . get ( arr [ i ] ) == k ) { return arr [ i ] ; } } return - 1 ; }"
"static int maximumDifferenceSum ( int arr [ ] , int N ) { int dp [ ] [ ] = new int [ N ] [ 2 ] ; for ( int i = 0 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 ; for ( int i = 0 ; i < ( N - 1 ) ; i ++ ) { dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + Math . abs ( 1 - arr [ i ] ) ) ; dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] + Math . abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + Math . abs ( arr [ i + 1 ] - arr [ i ] ) ) ; } return Math . max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) ; }"
"static void countPairs ( int arr [ ] , int N ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } int maxFreq = 0 ; for ( Map . Entry < Integer , Integer > it : mp . entrySet ( ) ) { maxFreq = Math . max ( maxFreq , it . getValue ( ) ) ; } System . out . print ( N - maxFreq + ""\n"" ) ; }"
static boolean isMultipleOf10 ( int n ) { if ( n % 15 == 0 ) return true ; return false ; }
"static void findElements ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; if ( count >= 2 ) System . out . print ( arr [ i ] + "" "" ) ; } }"
"static int findSplTripletsSum ( int a [ ] , int b [ ] , int c [ ] , int p , int q , int r ) { int sum = 0 ; for ( int i = 0 ; i < p ; i ++ ) { for ( int j = 0 ; j < q ; j ++ ) { for ( int k = 0 ; k < r ; k ++ ) { if ( a [ i ] <= b [ j ] && c [ k ] <= b [ j ] ) { sum += ( a [ i ] + b [ j ] ) * ( b [ j ] + c [ k ] ) ; } } } } return sum ; }"
"static int countSteps ( int x , int y ) { if ( x < y ) { return x + y + 2 * ( ( y - x ) / 2 ) ; } else { return x + y + 2 * ( ( ( x - y ) + 1 ) / 2 ) ; } }"
"static int findRepeating ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) res = res ^ ( i + 1 ) ^ arr [ i ] ; res = res ^ arr [ n - 1 ] ; return res ; }"
"static void otherEndPoint ( int x1 , int y1 , int m1 , int m2 ) { float x2 = ( float ) ( 2 * m1 - x1 ) ; float y2 = ( float ) ( 2 * m2 - y1 ) ; System . out . println ( ""x2 = "" + x2 + "", "" + ""y2 = "" + y2 ) ; }"
"static void CountPair ( int L , int R ) { int x = ( R - L + 1 ) ; System . out . println ( x / 2 + ""\n"" ) ; }"
public static long productPrimeFactors ( int n ) { long product = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( n % i == 0 ) { boolean isPrime = true ; for ( int j = 2 ; j <= i / 2 ; j ++ ) { if ( i % j == 0 ) { isPrime = false ; break ; } } if ( isPrime ) { product = product * i ; } } } return product ; }
"public static int findMaxGCD ( int arr [ ] , int n ) { int high = 0 ; for ( int i = 0 ; i < n ; i ++ ) high = Math . max ( high , arr [ i ] ) ; int count [ ] = new int [ high + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) count [ arr [ i ] ] ++ ; int counter = 0 ; for ( int i = high ; i >= 1 ; i -- ) { int j = i ; while ( j <= high ) { if ( count [ j ] > 0 ) counter += count [ j ] ; j += i ; if ( counter == 2 ) return i ; } counter = 0 ; } return 1 ; }"
"static int find_greatest_divisor ( int l , int r ) { if ( l == r ) { return l ; } return 1 ; }"
static boolean isDivisible ( long n ) { while ( n / 100 > 0 ) { long d = n % 10 ; n /= 10 ; n -= d * 5 ; } return ( n % 17 == 0 ) ; }
"static int getTotalNumberOfSequences ( int m , int n ) { int T [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < m + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) { if ( i == 0 || j == 0 ) T [ i ] [ j ] = 0 ; else if ( i < j ) T [ i ] [ j ] = 0 ; else if ( j == 1 ) T [ i ] [ j ] = i ; else T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i / 2 ] [ j - 1 ] ; } } return T [ m ] [ n ] ; }"
"static int maximum_middle_value ( int n , int k , int arr [ ] ) { int ans = - 1 ; int low = ( n + 1 - k ) / 2 ; int high = ( n + 1 - k ) / 2 + k ; for ( int i = low ; i <= high ; i ++ ) { ans = Math . max ( ans , arr [ i - 1 ] ) ; } return ans ; }"
"static int CalculateDifference ( int arr [ ] , int n ) { int max_val = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max_val ) max_val = arr [ i ] ; } boolean [ ] prime = new boolean [ max_val + 1 ] ; for ( int i = 0 ; i <= max_val ; i ++ ) prime [ i ] = true ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int S1 = 0 , S2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { S1 += arr [ i ] ; } else if ( arr [ i ] != 1 ) { S2 += arr [ i ] ; } } return Math . abs ( S2 - S1 ) ; }"
"static boolean checkPattern ( String str , String pattern ) { int len = pattern . length ( ) ; if ( str . length ( ) < len ) { return false ; } for ( int i = 0 ; i < len - 1 ; i ++ ) { char x = pattern . charAt ( i ) ; char y = pattern . charAt ( i + 1 ) ; int last = str . lastIndexOf ( x ) ; int first = str . indexOf ( y ) ; if ( last == - 1 || first == - 1 || last > first ) { return false ; } } return true ; }"
"static void solve ( String s , int k ) { int count = 0 , length = 0 , pos = 0 ; HashMap < Character , Integer > m = new HashMap < Character , Integer > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( m . containsKey ( s . charAt ( i ) ) ) m . put ( s . charAt ( i ) , m . get ( s . charAt ( i ) ) + 1 ) ; else m . put ( s . charAt ( i ) , 1 ) ; length ++ ; if ( length > k ) { m . put ( s . charAt ( pos ) , m . get ( s . charAt ( pos ) ) - 1 ) ; pos ++ ; length -- ; } if ( length == k && m . get ( s . charAt ( i ) ) == length ) count ++ ; } System . out . println ( count ) ; }"
"static int OR ( int a [ ] , int n ) { int ans = a [ 0 ] ; int i ; for ( i = 1 ; i < n ; i ++ ) { ans |= a [ i ] ; } return ans ; }"
"static void printMultiples ( int n ) { int unit_digit = n % 10 ; if ( unit_digit == 0 ) unit_digit = 10 ; for ( int i = unit_digit ; i <= n ; i += unit_digit ) System . out . print ( i + "" "" ) ; }"
"static void block ( long x ) { ArrayList < Integer > v = new ArrayList < Integer > ( ) ; System . out . print ( ""Blocks for "" + x + "" : "" ) ; while ( x > 0 ) { v . add ( ( int ) x % 2 ) ; x = x / 2 ; } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( v . get ( i ) == 1 ) { System . out . print ( i ) ; if ( i != v . size ( ) - 1 ) System . out . print ( "", "" ) ; } } System . out . println ( ) ; }"
"int findgroups ( int arr [ ] , int n ) { int c [ ] = new int [ ] { 0 , 0 , 0 }; int i ; int res = 0 ; for ( i = 0 ; i < n ; i ++ ) c [ arr [ i ] % 3 ] ++ ; res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ; res += c [ 1 ] * c [ 2 ] ; res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 ; res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 ; res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) ; res += c [ 0 ] * c [ 1 ] * c [ 2 ] ; return res ; }"
static int PositionRightmostSetbit ( int n ) { int position = 1 ; int m = 1 ; while ( ( n & m ) == 0 ) { m = m << 1 ; position ++ ; } return position ; }
"static void findElements ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) System . out . print ( arr [ i ] + "" "" ) ; }"
static int countFriendsPairings ( int n ) { int dp [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i <= 2 ) dp [ i ] = i ; else dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ n ] ; }
static int getProduct ( int n ) { int product = 1 ; while ( n != 0 ) { product = product * ( n % 10 ) ; n = n / 10 ; } return product ; }
"public static int count4Divisibiles ( int arr [ ] , int n ) { int freq [ ] = { 0 , 0 , 0 , 0 }; int i = 0 ; int ans ; for ( i = 0 ; i < n ; i ++ ) ++ freq [ arr [ i ] % 4 ] ; ans = freq [ 0 ] * ( freq [ 0 ] - 1 ) / 2 ; ans += freq [ 2 ] * ( freq [ 2 ] - 1 ) / 2 ; ans += freq [ 1 ] * freq [ 3 ] ; return ( ans ) ; }"
"static void maximumArea ( int l , int b , int x , int y ) { int left , right , above , below ; left = x * b ; right = ( l - x - 1 ) * b ; above = l * y ; below = ( b - y - 1 ) * l ; System . out . print ( Math . max ( Math . max ( left , right ) , Math . max ( above , below ) ) ) ; }"
"static double trianglearea ( double a ) { if ( a < 0 ) return - 1 ; double area = ( 3 * Math . sqrt ( 3 ) * Math . pow ( a , 2 ) ) / 4 ; return area ; }"
"static int maxPrefix ( String s , String t ) { int count = 0 ; for ( int i = 0 ; i < t . length ( ) ; i ++ ) { if ( count == t . length ( ) ) break ; if ( t . charAt ( i ) == s . charAt ( count ) ) count ++ ; } return count ; }"
static int centeredHexagonalNumber ( int n ) { return 3 * n * ( n - 1 ) + 1 ; }
"static int minimumNumbers ( int n , int s ) { if ( ( s % n ) > 0 ) return s / n + 1 ; else return s / n ; }"
"static void fillWithFreq ( int arr [ ] , int n ) { int temp [ ] = new int [ n ] ; Arrays . fill ( temp , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) temp [ arr [ i ] ] += 1 ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; }"
"public static int CountPair ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( i * arr [ i ] > j * arr [ j ] ) result ++ ; } return result ; }"
static int CountPairs ( int n ) { int k = n ; int imin = 1 ; int ans = 0 ; while ( imin <= n ) { int imax = n / k ; ans += k * ( imax - imin + 1 ) ; imin = imax + 1 ; k = n / imin ; } return ans ; }
static int countIntegralSolutions ( int n ) { int result = 0 ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n - i ; j ++ ) for ( int k = 0 ; k <= ( n - i - j ) ; k ++ ) if ( i + j + k == n ) result ++ ; return result ; }
"static int XorSum ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int k = 0 ; for ( int j = 1 ; j <= arr [ i ] ; j ++ ) k ^= arr [ i ] ; result += k ; } return result ; }"
"static int findBitonicity ( int [ ] arr , int n ) { int bt = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] ) bt ++ ; else if ( arr [ i ] < arr [ i - 1 ] ) bt -- ; } return bt ; }"
"static long getTrailingZeroes ( long n ) { long count = 0 ; long val , powerTwo = 2 ; do { val = n / powerTwo ; count += val ; powerTwo *= 2 ; } while ( val != 0 ) ; return ( count / 4 ) ; }"
"static int cost ( String str ) { int len = str . length ( ) ; int res = 0 ; for ( int i = 0 , j = len - 1 ; i < j ; i ++ , j -- ) if ( str . charAt ( i ) != str . charAt ( j ) ) res += Math . min ( str . charAt ( i ) , str . charAt ( j ) ) - 'a' + 1 ; return res ; }"
static int centereddecagonalnum ( int n ) { return ( 5 * n * n + 5 * n + 1 ) ; }
"static int minChanges ( char [ ] str , int n ) { int count = 0 , zeros = 0 , ones = 0 ; if ( str [ 0 ] != '1' ) { count ++ ; ones ++ ; } for ( int i = 1 ; i < n ; i ++ ) { if ( str [ i ] == '0' ) zeros ++ ; else ones ++ ; if ( zeros > ones ) { zeros -- ; ones ++ ; count ++ ; } } return count ; }"
"public static void countEle ( Stack < Integer > s , int [ ] a , int N ) { HashMap < Integer , Boolean > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < N ; ++ i ) { int num = a [ i ] ; if ( mp . containsKey ( num ) ) System . out . print ( ""0 "" ) ; else { int cnt = 0 ; while ( s . peek ( ) != num ) { mp . put ( s . peek ( ) , true ) ; s . pop ( ) ; cnt ++ ; } s . pop ( ) ; cnt ++ ; System . out . print ( cnt + "" "" ) ; } } }"
"static void solve ( int d1 , int d2 , int d3 ) { int maxx = Math . max ( d1 , Math . max ( d2 , d3 ) ) ; int sum = ( d1 + d2 + d3 ) ; if ( 2 * maxx > sum || sum % 2 == 1 ) { System . out . print ( ""-1"" ) ; return ; } int x1 = 0 , y1 = 0 ; int x2 = d1 , y2 = 0 ; int x3 = ( d1 + d2 - d3 ) / 2 ; int y3 = ( d2 + d3 - d1 ) / 2 ; System . out . print ( ""("" + x1 + "", "" + y1 + ""), ("" + x2 + "", "" + y2 + "") and ("" + x3 + "", "" + y3 + "")"" ) ; }"
"static int countDecreasing ( int A [ ] , int n ) { int cnt = 0 ; int len = 1 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( A [ i + 1 ] < A [ i ] ) len ++ ; else { cnt += ( ( ( len - 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += ( ( ( len - 1 ) * len ) / 2 ) ; return cnt ; }"
"static int getIndexInSortedArray ( int arr [ ] , int n , int idx ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ idx ] ) result ++ ; if ( arr [ i ] == arr [ idx ] && i < idx ) result ++ ; } return result ; }"
"public static void printArray ( int arr [ ] [ ] , int row , int col ) { HashSet < String > set = new HashSet < String > ( ) ; for ( int i = 0 ; i < row ; i ++ ) { String s = """" ; for ( int j = 0 ; j < col ; j ++ ) s += String . valueOf ( arr [ i ] [ j ] ) ; if ( ! set . contains ( s ) ) { set . add ( s ) ; System . out . println ( s ) ; } } }"
"static int maxAND ( int L , int R ) { int maximum = L & R ; for ( int i = L ; i < R ; i ++ ) for ( int j = i + 1 ; j <= R ; j ++ ) maximum = Math . max ( maximum , ( i & j ) ) ; return maximum ; }"
"int subArraySum ( int arr [ ] , int n , int sum ) { int curr_sum = arr [ 0 ] , start = 0 , i ; for ( i = 1 ; i <= n ; i ++ ) { while ( curr_sum > sum && start < i - 1 ) { curr_sum = curr_sum - arr [ start ] ; start ++ ; } if ( curr_sum == sum ) { int p = i - 1 ; System . out . println ( ""Sum found between indexes "" + start + "" and "" + p ) ; return 1 ; } if ( i < n ) curr_sum = curr_sum + arr [ i ] ; } System . out . println ( ""No subarray found"" ) ; return 0 ; }"
"static double expect ( double m , double n ) { double ans = 0.0 , i ; for ( i = m ; i > 0 ; i -- ) ans += ( Math . pow ( i / m , n ) - Math . pow ( ( i - 1 ) / m , n ) ) * i ; return ans ; }"
"static int findOddPair ( int A [ ] , int N ) { int i , j ; int oddPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] ^ A [ j ] ) % 2 != 0 ) oddPair ++ ; } } return oddPair ; }"
"static void kmax ( int arr [ ] , int k , int n ) { for ( int c = 0 ; c < k ; c ++ ) { int max_so_far = Integer . MIN_VALUE ; int max_here = 0 ; int start = 0 , end = 0 , s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { max_here += arr [ i ] ; if ( max_so_far < max_here ) { max_so_far = max_here ; start = s ; end = i ; } if ( max_here < 0 ) { max_here = 0 ; s = i + 1 ; } } System . out . println ( ""Maximum non-overlapping sub-arraysum"" + ( c + 1 ) + "": "" + max_so_far + "", starting index: "" + start + "", ending index: "" + end + ""."" ) ; for ( int l = start ; l <= end ; l ++ ) arr [ l ] = Integer . MIN_VALUE ; } System . out . println ( ) ; }"
"static void findWinner ( int n ) { if ( ( n - 1 ) % 6 == 0 ) { System . out . println ( ""Second Player wins the game"" ) ; } else { System . out . println ( ""First Player wins the game"" ) ; } }"
"static int countPairs ( int a [ ] , int b [ ] , int n , int m ) { int cnt = 0 ; HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { int sum = a [ i ] + b [ j ] ; if ( s . contains ( sum ) == false ) { cnt ++ ; s . add ( sum ) ; } } } return cnt ; }"
"static double calTime ( double arr [ ] , int n ) { double work = 0 ; for ( int i = 0 ; i < n ; i ++ ) work += 1 / arr [ i ] ; return 1 / work ; }"
"public static long findWays ( int f , int d , int s ) { long mem [ ] [ ] = new long [ d + 1 ] [ s + 1 ] ; mem [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= d ; i ++ ) { for ( int j = i ; j <= s ; j ++ ) { mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ] ; if ( j - f - 1 >= 0 ) mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ] ; } } return mem [ d ] [ s ] ; }"
"static void alternateSubarray ( boolean arr [ ] , int n ) { int len [ ] = new int [ n ] ; len [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; -- i ) { if ( arr [ i ] ^ arr [ i + 1 ] == true ) len [ i ] = len [ i + 1 ] + 1 ; else len [ i ] = 1 ; } for ( int i = 0 ; i < n ; ++ i ) System . out . print ( len [ i ] + "" "" ) ; }"
static int countWays ( String s ) { int count [ ] = new int [ 26 ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) count [ s . charAt ( i ) - 'a' ] ++ ; count [ s . charAt ( 0 ) - 'a' ] = 1 ; int ans = 1 ; for ( int i = 0 ; i < 26 ; ++ i ) if ( count [ i ] != 0 ) ans *= count [ i ] ; return ans ; }
static int removeConsecutiveSame ( Vector < String > v ) { int n = v . size ( ) ; for ( int i = 0 ; i < n - 1 ; ) { if ( v . get ( i ) . equals ( v . get ( i + 1 ) ) ) { v . remove ( i ) ; v . remove ( i ) ; if ( i > 0 ) i -- ; n = n - 2 ; } else i ++ ; } return v . size ( ) ; }
static int findSum ( int n ) { n -- ; int sum = 0 ; sum += ( n * ( n + 1 ) ) / 2 ; sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; return sum ; }
"static void positiveNegativeZero ( int [ ] arr ) { int len = arr . length ; float positiveCount = 0 ; float negativeCount = 0 ; float zeroCount = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( arr [ i ] > 0 ) { positiveCount ++ ; } else if ( arr [ i ] < 0 ) { negativeCount ++ ; } else if ( arr [ i ] == 0 ) { zeroCount ++ ; } } System . out . printf ( ""%1.4f "" , positiveCount / len ) ; System . out . printf ( ""%1.4f "" , negativeCount / len ) ; System . out . printf ( ""%1.4f "" , zeroCount / len ) ; System . out . println ( ) ; }"
"static int maxval ( int [ ] a , int n ) { if ( n < 2 ) { System . out . print ( ""Invalid Input"" ) ; return - 9999 ; } int max1 = 0 , max2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] + i ; if ( x > max1 ) { max2 = max1 ; max1 = x ; } else if ( x > max2 & x != max1 ) { max2 = x ; } } return ( max1 * max2 ) ; }"
"static int countSubarrays ( int [ ] arr , int n ) { int difference = 0 ; int ans = 0 ; int [ ] hash_positive = new int [ n + 1 ] ; int [ ] hash_negative = new int [ n + 1 ] ; hash_positive [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) == 1 ) { difference ++ ; } else { difference -- ; } if ( difference < 0 ) { ans += hash_negative [ - difference ] ; hash_negative [ - difference ] ++ ; } else { ans += hash_positive [ difference ] ; hash_positive [ difference ] ++ ; } } return ans ; }"
"void printClosest ( int ar1 [ ] , int ar2 [ ] , int m , int n , int x ) { int diff = Integer . MAX_VALUE ; int res_l = 0 , res_r = 0 ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) ; } if ( ar1 [ l ] + ar2 [ r ] > x ) r -- ; else l ++ ; } System . out . print ( ""The closest pair is ["" + ar1 [ res_l ] + "", "" + ar2 [ res_r ] + ""]"" ) ; }"
"static void findNums ( int n ) { if ( n <= 11 ) { if ( n == 8 ) System . out . print ( ""4 4"" ) ; if ( n == 10 ) System . out . print ( ""4 6"" ) ; else System . out . print ( ""-1"" ) ; return ; } if ( n % 2 == 0 ) System . out . print ( ""4 "" + ( n - 4 ) ) ; else System . out . print ( ""9 "" + ( n - 9 ) ) ; }"
static int findN ( int k ) { int ans ; if ( k == 0 ) ans = 3 ; if ( k == 1 ) ans = 1 ; else if ( k % 4 == 0 ) ans = k ; else if ( k % 4 == 3 ) ans = k - 1 ; else ans = - 1 ; return ans ; }
"static void midpoint ( int x1 , int x2 , int y1 , int y2 ) { System . out . print ( ( x1 + x2 ) / 2 + "" , "" + ( y1 + y2 ) / 2 ) ; }"
"static String removeOddFrequencyCharacters ( String s ) { HashMap < Character , Integer > m = new HashMap < Character , Integer > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char p = s . charAt ( i ) ; Integer count = m . get ( p ) ; if ( count == null ) { count = 0 ; m . put ( p , 1 ) ; } else m . put ( p , count + 1 ) ; } String new_string = """" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ( m . get ( s . charAt ( i ) ) & 1 ) == 1 ) continue ; new_string += s . charAt ( i ) ; } return new_string ; }"
"static void sortWithRemainderP ( int arr [ ] , int n , int k , int p ) { Vector < Integer > v1 = new Vector < Integer > ( ) ; Vector < Integer > v2 = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == p ) { v1 . add ( i ) ; v2 . add ( arr [ i ] ) ; } } Collections . sort ( v2 ) ; for ( int i = 0 ; i < v1 . size ( ) ; i ++ ) arr [ v1 . get ( i ) ] = v2 . get ( i ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + "" "" ) ; }"
"static int sortedAfterSwap ( int [ ] A , int [ ] B , int n ) { int t = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( B [ i ] != 0 ) { if ( A [ i ] != i + 1 ) t = A [ i ] ; A [ i ] = A [ i + 1 ] ; A [ i + 1 ] = t ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] != i + 1 ) return 0 ; } return 1 ; }"
"static void findAndPrintOriginalArray ( int arr [ ] , int n ) { int arr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) arr_sum += arr [ i ] ; arr_sum = arr_sum / ( n - 1 ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr_sum - arr [ i ] + "" "" ) ; }"
"static void arrangeString ( String str , int x , int y ) { int count_0 = 0 ; int count_1 = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( str . charAt ( i ) == '0' ) count_0 ++ ; else count_1 ++ ; } while ( count_0 > 0 || count_1 > 0 ) { for ( int j = 0 ; j < x && count_0 > 0 ; j ++ ) { if ( count_0 > 0 ) { System . out . print ( ""0"" ) ; count_0 -- ; } } for ( int j = 0 ; j < y && count_1 > 0 ; j ++ ) { if ( count_1 > 0 ) { System . out . print ( ""1"" ) ; count_1 -- ; } } } }"
"static long minOperations ( long n ) { long count = 0 ; long d = 0 ; if ( n == 1 ) return 0 ; while ( n > 9 ) { d = Math . max ( n % 10 , d ) ; n /= 10 ; count += 10 ; } d = Math . max ( d , n - 1 ) ; count += Math . abs ( d ) ; return count - 1 ; }"
"static String maxValue ( char [ ] a , char [ ] b ) { Arrays . sort ( b ) ; int n = a . length ; int m = b . length ; int j = m - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( j < 0 ) break ; if ( b [ j ] > a [ i ] ) { a [ i ] = b [ j ] ; j -- ; } } return String . valueOf ( a ) ; }"
"static void midPoint ( int X1 , int Y1 , int X2 , int Y2 ) { int dx = X2 - X1 ; int dy = Y2 - Y1 ; int d = dy - ( dx / 2 ) ; int x = X1 , y = Y1 ; System . out . print ( x + "","" + y + ""\n"" ) ; while ( x < X2 ) { x ++ ; if ( d < 0 ) d = d + dy ; else { d += ( dy - dx ) ; y ++ ; } System . out . print ( x + "","" + y + ""\n"" ) ; } }"
"static int countDigits ( int a , int b ) { int count = 0 ; int p = Math . abs ( a * b ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = p / 10 ; } return count ; }"
"static int minimumflip ( int mat [ ] [ ] , int n ) { int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) flip ++ ; return flip ; }"
"static int findMinimumK ( int a [ ] , int n , int s ) { int maximum = a [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { maximum = Math . max ( maximum , a [ i ] ) ; } int low = 1 , high = maximum + 1 ; int ans = high ; while ( low <= high ) { int mid = ( low + high ) / 2 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += ( int ) ( a [ i ] / mid ) ; } if ( sum > s ) low = mid + 1 ; else { ans = Math . min ( ans , mid ) ; high = mid - 1 ; } } return ans ; }"
"static String firstLetterWord ( String str ) { String result = """" ; boolean v = true ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ' ' ) { v = true ; } else if ( str . charAt ( i ) != ' ' && v == true ) { result += ( str . charAt ( i ) ) ; v = false ; } } return result ; }"
static int countMultiples ( int n ) { int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( i % 3 == 0 || i % 7 == 0 ) res ++ ; return res ; }
"static boolean isPossible ( Integer a [ ] , int b [ ] , int n , int k ) { Arrays . sort ( a , Collections . reverseOrder ( ) ) ; Arrays . sort ( b ) ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] + b [ i ] < k ) return false ; return true ; }"
"static int OddDivCount ( int a , int b ) { int res = 0 ; for ( int i = a ; i <= b ; ++ i ) { int divCount = 0 ; for ( int j = 1 ; j <= i ; ++ j ) { if ( i % j == 0 ) { ++ divCount ; } } if ( ( divCount % 2 ) != 0 ) { ++ res ; } } return res ; }"
"static int findArea ( int arr [ ] , int n ) { Set < Integer > s = new HashSet < > ( ) ; int first = 0 , second = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! s . contains ( arr [ i ] ) ) { s . add ( arr [ i ] ) ; continue ; } if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } return ( first * second ) ; }"
"static int countPairs ( int [ ] arr1 , int [ ] arr2 , int m , int n , int x ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( ( arr1 [ i ] + arr2 [ j ] ) == x ) count ++ ; return count ; }"
static void lastFiveDigits ( int n ) { n = ( n / 10000 ) * 10000 + ( ( n / 100 ) % 10 ) * 1000 + ( n % 10 ) * 100 + ( ( n / 10 ) % 10 ) * 10 + ( n / 1000 ) % 10 ; int ans = 1 ; for ( int i = 0 ; i < 5 ; i ++ ) { ans *= n ; ans %= 100000 ; } System . out . println ( ans ) ; }
"static int countRotations ( int arr [ ] , int low , int high ) { if ( high < low ) return 0 ; if ( high == low ) return low ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return ( mid + 1 ) ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mid ; if ( arr [ high ] > arr [ mid ] ) return countRotations ( arr , low , mid - 1 ) ; return countRotations ( arr , mid + 1 , high ) ; }"
"static int numberofways ( int n , int m ) { int dp [ ] [ ] = new int [ n + 2 ] [ n + 2 ] ; dp [ 0 ] [ n + 1 ] = 1 ; for ( int k = n ; k >= m ; k -- ) { for ( int i = 0 ; i <= n ; i ++ ) { dp [ i ] [ k ] = dp [ i ] [ k + 1 ] ; if ( i - k >= 0 ) dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) ; } } return dp [ n ] [ m ] ; }"
"static void find_array ( int [ ] a , int n ) { int x = 0 ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] += x ; System . out . print ( a [ i ] + "" "" ) ; x = Math . max ( x , a [ i ] ) ; } }"
"static void findGreater ( int a , int b ) { double x = ( double ) a * ( double ) ( Math . log ( ( double ) ( b ) ) ) ; double y = ( double ) b * ( double ) ( Math . log ( ( double ) ( a ) ) ) ; if ( y > x ) { System . out . println ( ""a^b is greater"" ) ; } else if ( y < x ) { System . out . println ( ""b^a is greater"" ) ; } else { System . out . println ( ""Both are equal"" ) ; } }"
"static int countDigit ( int n ) { int temp = n , count = 0 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d == 2 || d == 3 || d == 5 || d == 7 ) count ++ ; } return count ; }"
"static int CntDivbyX ( int arr [ ] , int n , int x ) { int number = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { number = number * 2 + arr [ i ] ; if ( ( number % x == 0 ) ) count += 1 ; } return count ; }"
static boolean isCorrectOrder ( int n ) { boolean flag = true ; int prev = - 1 ; int type = - 1 ; while ( n != 0 ) { if ( type == - 1 ) { if ( prev == - 1 ) { prev = n % 10 ; n = n / 10 ; continue ; } if ( prev == n % 10 ) { flag = false ; break ; } if ( prev > n % 10 ) { type = 1 ; prev = n % 10 ; n = n / 10 ; continue ; } prev = n % 10 ; n = n / 10 ; } else { if ( prev == n % 10 ) { flag = false ; break ; } if ( prev < n % 10 ) { flag = false ; break ; } prev = n % 10 ; n = n / 10 ; } } return flag ; }
"static boolean checkDivisibility ( String num ) { int length = num . length ( ) ; if ( length == 1 && num . charAt ( 0 ) == '0' ) return true ; if ( length % 3 == 1 ) { num += ""00"" ; length += 2 ; } else if ( length % 3 == 2 ) { num += ""0"" ; length += 1 ; } int sum = 0 , p = 1 ; for ( int i = length - 1 ; i >= 0 ; i -- ) { int group = 0 ; group += num . charAt ( i -- ) - '0' ; group += ( num . charAt ( i -- ) - '0' ) * 10 ; group += ( num . charAt ( i ) - '0' ) * 100 ; sum = sum + group * p ; p *= ( - 1 ) ; } sum = Math . abs ( sum ) ; return ( sum % 13 == 0 ) ; }"
"public static int calculateDifference ( int [ ] arr , int n ) { int max_val = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; boolean [ ] prime = new boolean [ max_val + 1 ] ; Arrays . fill ( prime , true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int P1 = 1 , P2 = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { P1 *= arr [ i ] ; } else if ( arr [ i ] != 1 ) { P2 *= arr [ i ] ; } } return Math . abs ( P2 - P1 ) ; }"
"static int solve ( int N , int M , int cp [ ] , int sp [ ] ) { Integer [ ] profit = new Integer [ N ] ; for ( int i = 0 ; i < N ; i ++ ) profit [ i ] = sp [ i ] - cp [ i ] ; Arrays . sort ( profit , Collections . reverseOrder ( ) ) ; int sum = 0 ; for ( int i = 0 ; i < M ; i ++ ) { if ( profit [ i ] > 0 ) sum += profit [ i ] ; else break ; } return sum ; }"
"static char findExtraCharcter ( String strA , String strB ) { int res = 0 , i ; for ( i = 0 ; i < strA . length ( ) ; i ++ ) { res ^= strA . charAt ( i ) ; } for ( i = 0 ; i < strB . length ( ) ; i ++ ) { res ^= strB . charAt ( i ) ; } return ( ( char ) ( res ) ) ; }"
"static void nondecdigits ( String s ) { int m = s . length ( ) ; int [ ] a = new int [ m + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) a [ i ] = ( int ) s . charAt ( i ) - ( int ) '0' ; int level = m - 1 ; for ( int i = m - 1 ; i > 0 ; i -- ) { if ( a [ i ] < a [ i - 1 ] ) { a [ i - 1 ] -- ; level = i - 1 ; } } if ( a [ 0 ] != 0 ) { for ( int i = 0 ; i <= level ; i ++ ) System . out . print ( a [ i ] ) ; for ( int i = level + 1 ; i < m ; i ++ ) System . out . print ( ""9"" ) ; } else { for ( int i = 1 ; i < level ; i ++ ) System . out . print ( a [ i ] ) ; for ( int i = level + 1 ; i < m ; i ++ ) System . out . print ( ""9"" ) ; } }"
"static int minDaysToEmpty ( int C , int l ) { if ( l >= C ) return C ; double eq_root = ( Math . sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2 ; return ( int ) ( Math . ceil ( eq_root ) + l ) ; }"
static long calculateSum ( int n ) { long sum = 0 ; for ( int row = 0 ; row < n ; row ++ ) { sum = sum + ( 1 << row ) ; } return sum ; }
"static int findIndex ( int n ) { if ( n <= 1 ) return n ; int a = 0 , b = 1 , c = 1 ; int res = 1 ; while ( c < n ) { c = a + b ; res ++ ; a = b ; b = c ; } return res ; }"
"static void isPossible ( int [ ] A , int n , int k ) { int countOfTwo = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] % 2 == 0 ) { countOfTwo ++ ; } } if ( k == 0 && countOfTwo == n ) System . out . print ( ""NO"" ) ; else if ( countOfTwo >= k ) { System . out . print ( ""YES"" ) ; } else System . out . print ( ""No"" ) ; }"
"static int maxProfit ( int [ ] price , int n , int k ) { int [ ] [ ] profit = new int [ k + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= k ; i ++ ) profit [ i ] [ 0 ] = 0 ; for ( int j = 0 ; j <= n ; j ++ ) profit [ 0 ] [ j ] = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { int max_so_far = 0 ; for ( int m = 0 ; m < j ; m ++ ) max_so_far = Math . max ( max_so_far , price [ j ] - price [ m ] + profit [ i - 1 ] [ m ] ) ; profit [ i ] [ j ] = Math . max ( profit [ i ] [ j - 1 ] , max_so_far ) ; } } return profit [ k ] [ n - 1 ] ; }"
static int heptagonalNumber ( int n ) { return ( ( 5 * n * n ) - ( 3 * n ) ) / 2 ; }
"static void printElements ( int arr [ ] , int n ) { for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] && arr [ i ] > arr [ i + 1 ] ) System . out . print ( arr [ i ] + "" "" ) ; } }"
"static int setKthBit ( int n , int k ) { return ( ( 1 << k ) | n ) ; }"
"static int findevenPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( A [ i ] % 2 != 0 ) count ++ ; int oddCount = count * ( count - 1 ) / 2 ; return ( N * ( N - 1 ) / 2 ) - oddCount ; }"
"static int minInsertionStepToSortArray ( int arr [ ] , int N ) { int [ ] lis = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) lis [ i ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] >= arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; int max = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ; return ( N - max ) ; }"
"static int MinDeletion ( int a [ ] , int n ) { Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( a [ i ] ) ) { mp . put ( a [ i ] , mp . get ( a [ i ] ) + 1 ) ; } else { mp . put ( a [ i ] , 1 ) ; } } int ans = 0 ; for ( Map . Entry < Integer , Integer > i : mp . entrySet ( ) ) { int x = i . getKey ( ) ; int frequency = i . getValue ( ) ; if ( x <= frequency ) { ans += ( frequency - x ) ; } else ans += frequency ; } return ans ; }"
"static void solve ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; if ( k == 1 && arr [ n - 2 ] != arr [ n - 1 ] ) { System . out . println ( arr [ n - 1 ] ) ; return ; } int count = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] == arr [ i + 1 ] ) count ++ ; else count = 1 ; if ( count == k && ( i == 0 || ( arr [ i - 1 ] != arr [ i ] ) ) ) { System . out . println ( arr [ i ] ) ; return ; } } System . out . println ( ""No such element"" ) ; }"
"static void findNormal ( int A , int x , int y ) { int dif = A - x * 2 ; if ( y == ( 2 * x - x * x ) ) { if ( dif < 0 ) System . out . print ( ( 0 - dif ) + ""y = "" + ""x"" + ( ( 0 - x ) + ( y * dif ) ) ) ; else if ( dif > 0 ) System . out . print ( dif + ""y = "" + ""-x+"" + ( x + dif * y ) ) ; else System . out . print ( ""x = "" + x ) ; } else System . out . println ( ""Not possible"" ) ; }"
static int swapNibbles ( int x ) { return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 ) ; }
"static long calculateSum ( int n , int k ) { int res = 1 ; int MOD = 1000000007 ; while ( k > 0 ) { if ( ( k & 1 ) == 1 ) res = ( res * n ) % MOD ; k = k / 2 ; n = ( n * n ) % MOD ; } return res ; }"
"static void findCart ( int arr1 [ ] , int arr2 [ ] , int n , int n1 ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n1 ; j ++ ) System . out . print ( ""{"" + arr1 [ i ] + "", "" + arr2 [ j ] + ""}, "" ) ; }"
"static void printReverseFloyd ( int n ) { int curr_val = n * ( n + 1 ) / 2 ; for ( int i = n ; i >= 1 ; i -- ) { for ( int j = i ; j >= 1 ; j -- ) { System . out . printf ( ""%2d "" , curr_val -- ) ; } System . out . println ( """" ) ; } }"
"static void findMaxGuests ( int arrl [ ] , int exit [ ] , int n ) { Arrays . sort ( arrl ) ; Arrays . sort ( exit ) ; int guests_in = 1 , max_guests = 1 , time = arrl [ 0 ] ; int i = 1 , j = 0 ; while ( i < n && j < n ) { if ( arrl [ i ] <= exit [ j ] ) { guests_in ++ ; if ( guests_in > max_guests ) { max_guests = guests_in ; time = arrl [ i ] ; } i ++ ; } else { guests_in -- ; j ++ ; } } System . out . println ( ""Maximum Number of Guests = "" + max_guests + "" at time "" + time ) ; }"
"boolean isProduct ( int arr [ ] , int n , int x ) { for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] * arr [ j ] == x ) return true ; return false ; }"
"int binarySearch ( int arr [ ] , int x ) { int l = 0 , r = arr . length - 1 ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( arr [ m ] == x ) return m ; if ( arr [ m ] < x ) l = m + 1 ; else r = m - 1 ; } return - 1 ; }"
public static void sortSquares ( int arr [ ] ) { int n = arr . length ; int k ; for ( k = 0 ; k < n ; k ++ ) { if ( arr [ k ] >= 0 ) break ; } int i = k - 1 ; int j = k ; int ind = 0 ; int [ ] temp = new int [ n ] ; while ( i >= 0 && j < n ) { if ( arr [ i ] * arr [ i ] < arr [ j ] * arr [ j ] ) { temp [ ind ] = arr [ i ] * arr [ i ] ; i -- ; } else { temp [ ind ] = arr [ j ] * arr [ j ] ; j ++ ; } ind ++ ; } while ( i >= 0 ) { temp [ ind ++ ] = arr [ i ] * arr [ i ] ; i -- ; } while ( j < n ) { temp [ ind ++ ] = arr [ j ] * arr [ j ] ; j ++ ; } for ( int x = 0 ; x < n ; x ++ ) arr [ x ] = temp [ x ] ; }
"static float geometricMean ( int arr [ ] , int n ) { float product = 1 ; for ( int i = 0 ; i < n ; i ++ ) product = product * arr [ i ] ; float gm = ( float ) Math . pow ( product , ( float ) 1 / n ) ; return gm ; }"
"static void printArray ( int [ ] a , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( a [ i ] + "" "" ) ; System . out . println ( ) ; }"
"static int findpos ( String n ) { int k = 0 , pos = 0 , i = 0 ; while ( k != n . length ( ) ) { switch ( n . charAt ( i ) ) { case '4' : pos = pos * 2 + 1 ; break ; case '7' : pos = pos * 2 + 2 ; break ; } i ++ ; k ++ ; } return pos ; }"
"static String compute ( String str , int n ) { String reverseAlphabet = ""zyxwvutsrqponmlkjihgfedcba"" ; int l = str . length ( ) ; String answer = """" ; for ( int i = 0 ; i < n ; i ++ ) answer = answer + str . charAt ( i ) ; for ( int i = n ; i < l ; i ++ ) answer = answer + reverseAlphabet . charAt ( str . charAt ( i ) - 'a' ) ; return answer ; }"
"public static int gcdExtended ( int a , int b , int x , int y ) { if ( a == 0 ) { x = 0 ; y = 1 ; return b ; } int x1 = 1 , y1 = 1 ; int gcd = gcdExtended ( b % a , a , x1 , y1 ) ; x = y1 - ( b / a ) * x1 ; y = x1 ; return gcd ; }"
"static int getMissingNo ( int a [ ] , int n ) { int i , total ; total = ( n + 1 ) * ( n + 2 ) / 2 ; for ( i = 0 ; i < n ; i ++ ) total -= a [ i ] ; return total ; }"
"static int nthTerm ( int n ) { return 4 * ( int ) Math . pow ( n , 2 ) - 3 * n + 2 ; }"
"static void findNumberOfDigits ( long n , int base ) { int dig = ( int ) ( Math . floor ( Math . log ( n ) / Math . log ( base ) ) + 1 ) ; System . out . println ( ""The Number of digits of Number "" + n + "" in base "" + base + "" is "" + dig ) ; }"
static boolean checkSame ( int n ) { int set = 0 ; int unset = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 1 ) set ++ ; else unset ++ ; n = n >> 1 ; } if ( set == unset ) return true ; else return false ; }
"static void MinimumValue ( int x , int y ) { if ( x > y ) { int temp = x ; x = y ; y = temp ; } int a = 1 ; int b = x - 1 ; int c = y - b ; System . out . print ( a + "" "" + b + "" "" + c ) ; }"
"public static int calculateSum ( String arr [ ] , int n ) { if ( n == 0 ) return 0 ; String s = arr [ 0 ] ; int value = Integer . parseInt ( s ) ; int sum = value ; for ( int i = 2 ; i < n ; i = i + 2 ) { s = arr [ i ] ; value = Integer . parseInt ( s ) ; char operation = arr [ i - 1 ] . charAt ( 0 ) ; if ( operation == '+' ) sum += value ; else sum -= value ; } return sum ; }"
"static int highestPowerof2 ( int n ) { int p = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; return ( int ) Math . pow ( 2 , p ) ; }"
"static void removeDuplicates ( int arr [ ] , int n ) { int st = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n - 2 && arr [ i ] == arr [ i + 1 ] && arr [ i ] == arr [ i + 2 ] ) continue ; else { arr [ st ] = arr [ i ] ; st ++ ; } } System . out . print ( ""{"" ) ; for ( int i = 0 ; i < st ; i ++ ) { System . out . print ( arr [ i ] ) ; if ( i != st - 1 ) System . out . print ( "", "" ) ; } System . out . print ( ""}"" ) ; }"
"static int nthXorFib ( int n , int a , int b ) { if ( n == 0 ) return a ; if ( n == 1 ) return b ; if ( n == 2 ) return ( a ^ b ) ; return nthXorFib ( n % 3 , a , b ) ; }"
"static boolean check ( String s , int l ) { int freq [ ] = new int [ 26 ] ; Arrays . fill ( freq , 0 ) ; for ( int i = 0 ; i < l ; i ++ ) { freq [ s . charAt ( i ) - 'a' ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] >= 2 ) return true ; } return false ; }"
"int equilibrium ( int arr [ ] , int n ) { int i , j ; int leftsum , rightsum ; for ( i = 0 ; i < n ; ++ i ) { leftsum = 0 ; for ( j = 0 ; j < i ; j ++ ) leftsum += arr [ j ] ; rightsum = 0 ; for ( j = i + 1 ; j < n ; j ++ ) rightsum += arr [ j ] ; if ( leftsum == rightsum ) return i ; } return - 1 ; }"
"static int minimumValue ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int answer = 0 ; for ( int i = 0 ; i < k ; i ++ ) answer += arr [ i ] * arr [ i ] ; return answer * ( 2 * k - 2 ) ; }"
"static void countFreq ( int a [ ] , int n ) { int hm [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) hm [ a [ i ] ] ++ ; int cumul = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cumul += hm [ a [ i ] ] ; if ( hm [ a [ i ] ] != 0 ) { System . out . println ( a [ i ] + ""->"" + cumul ) ; } hm [ a [ i ] ] = 0 ; } }"
"static int findElement ( int arr [ ] , int n , int key ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == key ) return i ; return - 1 ; }"
static int getValueOfF ( int n ) { if ( n == 1 ) return 0 ; if ( n == 2 ) return 1 ; int cnt = 0 ; while ( n % 2 == 0 ) { cnt += 1 ; n /= 2 ; } return 2 * cnt ; }
"static long getChicks ( int n ) { int size = Math . max ( n , 7 ) ; long [ ] dp = new long [ size ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i < 6 ; i ++ ) { dp [ i ] = dp [ i - 1 ] * 3 ; } dp [ 6 ] = 726 ; for ( int i = 8 ; i <= n ; i ++ ) { dp [ i ] = ( dp [ i - 1 ] - ( 2 * dp [ i - 6 ] / 3 ) ) * 3 ; } return dp [ n ] ; }"
static long fifthPowerSum ( int n ) { return ( ( 2 * n * n * n * n * n * n ) + ( 6 * n * n * n * n * n ) + ( 5 * n * n * n * n ) - ( n * n ) ) / 12 ; }
"static int Nth_Term ( int n ) { return ( int ) ( 3 * Math . pow ( n , 2 ) - n + 2 ) / ( 2 ) ; }"
"static int getMissingNo ( int a [ ] , int n ) { int total = 1 ; for ( int i = 2 ; i <= ( n + 1 ) ; i ++ ) { total += i ; total -= a [ i - 2 ] ; } return total ; }"
"static void getIndex ( int n , int shuffle [ ] [ ] ) { for ( int i = 0 ; i < 3 ; i ++ ) { if ( shuffle [ i ] [ 0 ] == n ) n = shuffle [ i ] [ 1 ] ; else if ( shuffle [ i ] [ 1 ] == n ) n = shuffle [ i ] [ 0 ] ; } System . out . println ( n ) ; }"
public static double floatError ( double no ) { double sum = 0.0 ; for ( int i = 0 ; i < 10 ; i ++ ) { sum = sum + no ; } return sum ; }
"static char NthCharacter ( int n ) { String s = """" ; int c = 1 ; for ( int i = 1 ; ; i ++ ) { if ( c < 10 ) s += Integer . toString ( c ) ; else { String s1 = """" ; int dup = c ; while ( dup > 0 ) { s1 += Integer . toString ( dup % 10 ) ; dup /= 10 ; } StringBuilder temp = new StringBuilder ( ) ; temp . append ( s1 ) ; temp = temp . reverse ( ) ; s += temp ; } c ++ ; if ( s . length ( ) >= n ) { return s . charAt ( n - 1 ) ; } } }"
static int fnMod ( int n ) { if ( n % 5 == 1 ) return 4 ; else return 0 ; }
"static int maxCost ( int a [ ] , int n , int l , int r ) { int mx = 0 , k ; for ( int i = 0 ; i < n ; ++ i ) mx = Math . max ( mx , a [ i ] ) ; int [ ] count = new int [ mx + 1 ] ; for ( int i = 0 ; i < count . length ; i ++ ) count [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) count [ a [ i ] ] ++ ; int [ ] res = new int [ mx + 1 ] ; res [ 0 ] = 0 ; l = Math . min ( l , r ) ; for ( int num = 1 ; num <= mx ; num ++ ) { k = Math . max ( num - l - 1 , 0 ) ; res [ num ] = Math . max ( res [ num - 1 ] , num * count [ num ] + res [ k ] ) ; } return res [ mx ] ; }"
"static int min_changes ( int a [ ] , int n ) { int ans_a = 0 , ans_b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { if ( a [ i ] == 0 ) ans_a ++ ; else ans_b ++ ; } else { if ( a [ i ] == 0 ) ans_b ++ ; else ans_a ++ ; } } return Math . min ( ans_a , ans_b ) ; }"
public static int nthTerm ( int n ) { return ( n * n ) + ( n * n * n ) ; }
static int CenteredDodecahedral_num ( int n ) { return ( 2 * n + 1 ) * ( 5 * n * n + 5 * n + 1 ) ; }
"static Boolean divisibleBy20 ( String num ) { int lastTwoDigits = Integer . parseInt ( num . substring ( num . length ( ) - 2 , num . length ( ) ) ) ; return ( ( lastTwoDigits % 5 == 0 ) && ( lastTwoDigits % 4 == 0 ) ) ; }"
"static int minimumCostOfBreaking ( Integer X [ ] , Integer Y [ ] , int m , int n ) { int res = 0 ; Arrays . sort ( X , Collections . reverseOrder ( ) ) ; Arrays . sort ( Y , Collections . reverseOrder ( ) ) ; int hzntl = 1 , vert = 1 ; int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( X [ i ] > Y [ j ] ) { res += X [ i ] * vert ; hzntl ++ ; i ++ ; } else { res += Y [ j ] * hzntl ; vert ++ ; j ++ ; } } int total = 0 ; while ( i < m ) total += X [ i ++ ] ; res += total * vert ; total = 0 ; while ( j < n ) total += Y [ j ++ ] ; res += total * hzntl ; return res ; }"
"static int StrictlyPositiveXor ( int [ ] A , int N ) { int allxor = 0 ; boolean checkallzero = true ; for ( int i = 0 ; i < N ; i += 1 ) { allxor ^= A [ i ] ; if ( A [ i ] > 0 ) checkallzero = false ; } if ( allxor != 0 ) return N ; if ( checkallzero ) return - 1 ; int l = N , r = - 1 ; for ( int i = 0 ; i < N ; i += 1 ) { if ( A [ i ] > 0 ) { l = i + 1 ; break ; } } for ( int i = N - 1 ; i >= 0 ; i -= 1 ) { if ( A [ i ] > 0 ) { r = i + 1 ; break ; } } return Math . max ( N - l , r - 1 ) ; }"
"static int Race ( int B , int C ) { int result = 0 ; result = ( ( C * 100 ) / B ) ; return 100 - result ; }"
static int countDigits ( int n ) { return ( int ) ( n * Math . log10 ( 2 ) + 1 ) ; }
"static int xor_triplet ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j ; k < n ; k ++ ) { int xor1 = 0 , xor2 = 0 ; for ( int x = i ; x < j ; x ++ ) { xor1 ^= arr [ x ] ; } for ( int x = j ; x <= k ; x ++ ) { xor2 ^= arr [ x ] ; } if ( xor1 == xor2 ) { ans ++ ; } } } } return ans ; }"
"static int xorOfSum ( int a [ ] , int n ) { int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) answer ^= ( a [ i ] + a [ j ] ) ; } return answer ; }"
"static double Perimeter ( double s , int n ) { double perimeter = 1 ; perimeter = n * s ; return perimeter ; }"
"static String check ( int [ ] Arr , int n , int M , int K ) { int flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( Arr [ i ] == 0 ) flag = 1 ; } if ( K % 2 != 0 && flag == 0 ) return ""No"" ; else return ""Yes"" ; }"
static int findS ( int s ) { int sum = 0 ; for ( int n = 1 ; sum < s ; n ++ ) { sum += n * n * n ; if ( sum == s ) return n ; } return - 1 ; }
"static int Segment ( int x [ ] , int l [ ] , int n ) { if ( n == 1 ) return 1 ; int ans = 2 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( x [ i ] - l [ i ] > x [ i - 1 ] ) ans ++ ; else if ( x [ i ] + l [ i ] < x [ i + 1 ] ) { x [ i ] = x [ i ] + l [ i ] ; ans ++ ; } } return ans ; }"
static int findSum ( int N ) { return ( 2 * N * ( N + 1 ) * ( 4 * N + 17 ) + 54 * N ) / 6 ; }
public static int firstSetBit ( int n ) { int x = n & ( n - 1 ) ; return ( n ^ x ) ; }
"static int sumFirst ( int a [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < > ( ) ; int suf = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { suf += a [ i ] ; mp . put ( suf , i ) ; } int pre = 0 , maxi = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { pre += a [ i ] ; if ( mp . containsKey ( pre ) && mp . get ( pre ) > i ) { if ( pre > maxi ) { maxi = pre ; } } } if ( maxi == - 1 ) return 0 ; else return maxi ; }"
"static void printPermutation ( int N , int K ) { Vector < Integer > res = new Vector < > ( ) ; int l = 1 , r = N , flag = 0 ; for ( int i = 0 ; i < K ; i ++ ) { if ( flag == 0 ) { res . add ( l ) ; l ++ ; } else { res . add ( r ) ; r -- ; } flag ^= 1 ; } if ( flag != 1 ) { for ( int i = r ; i >= l ; i -- ) { res . add ( i ) ; } } else { for ( int i = l ; i <= r ; i ++ ) { res . add ( i ) ; } } for ( Integer i : res ) { System . out . print ( i + "" "" ) ; } }"
static boolean check ( int a ) { char [ ] A = String . valueOf ( a ) . toCharArray ( ) ; char [ ] B = new char [ A . length ] ; for ( int i = 0 ; i < A . length ; i ++ ) { B [ i ] = A [ A . length - i - 1 ] ; } int b = Integer . parseInt ( String . valueOf ( B ) ) ; return a == b ; }
"static int multiply ( int a [ ] , int n ) { if ( n == 0 ) return ( a [ n ] ) ; else return ( a [ n ] * multiply ( a , n - 1 ) ) ; }"
public static int findNth ( int n ) { int count = 0 ; for ( int curr = 1 ; ; curr ++ ) { int sum = 0 ; for ( int x = curr ; x > 0 ; x = x / 10 ) sum = sum + x % 10 ; if ( sum == 10 ) count ++ ; if ( count == n ) return curr ; } }
static float hexagonside ( float a ) { if ( a < 0 ) return - 1 ; float x = a / 3 ; return x ; }
static long fib ( int n ) { if ( n == 0 ) return 1 ; else if ( n == 1 ) return 1 ; long val = 2 ; long val_pre = 1 ; long val_prepre = 1 ; for ( int i = 2 ; i < n ; i ++ ) { val_prepre = val_pre ; val_pre = val ; val = val_pre + val_prepre ; } return val ; }
static int pairs ( int n ) { int [ ] [ ] c = new int [ 10 ] [ 10 ] ; int tmp = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i >= tmp * 10 ) tmp *= 10 ; c [ i / tmp ] [ i % 10 ] ++ ; } int ans = 0 ; for ( int i = 1 ; i < 10 ; i ++ ) for ( int j = 1 ; j < 10 ; j ++ ) ans += c [ i ] [ j ] * c [ j ] [ i ] ; return ans ; }
"static int binomialCoeff ( int n , int k ) { if ( k == 0 || k == n ) return 1 ; return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ; }"
"static int countDistictSubarray ( int arr [ ] , int n ) { HashMap < Integer , Integer > vis = new HashMap < Integer , Integer > ( ) { @ Override public Integer get ( Object key ) { if ( ! containsKey ( key ) ) return 0 ; return super . get ( key ) ; } }; for ( int i = 0 ; i < n ; ++ i ) vis . put ( arr [ i ] , 1 ) ; int k = vis . size ( ) ; vis . clear ( ) ; int ans = 0 , right = 0 , window = 0 ; for ( int left = 0 ; left < n ; ++ left ) { while ( right < n && window < k ) { vis . put ( arr [ right ] , vis . get ( arr [ right ] ) + 1 ) ; if ( vis . get ( arr [ right ] ) == 1 ) ++ window ; ++ right ; } if ( window == k ) ans += ( n - right + 1 ) ; vis . put ( arr [ left ] , vis . get ( arr [ left ] ) - 1 ) ; if ( vis . get ( arr [ left ] ) == 0 ) -- window ; } return ans ; }"
"static int product ( int ar [ ] , int n ) { int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) result = result * ar [ i ] ; return result ; }"
"static int findMaximum ( int arr [ ] , int low , int high ) { int max = arr [ low ] ; int i ; for ( i = low ; i <= high ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } return max ; }"
"static void equal_xor_sum ( int arr [ ] , int n ) { int Sum = 0 ; int Xor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { Sum = Sum + arr [ i ] ; Xor = Xor ^ arr [ i ] ; } if ( Sum == Xor ) System . out . println ( ""YES"" ) ; else System . out . println ( ""NO"" ) ; }"
"static int countSubarrays ( int a [ ] , int n , int m ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int odd = 0 ; for ( int j = i ; j < n ; j ++ ) { if ( a [ j ] % 2 == 0 ) odd ++ ; if ( odd == m ) count ++ ; } } return count ; }"
"static void printOtherSides ( int n ) { if ( n % 2 != 0 ) { if ( n == 1 ) System . out . println ( ""-1"" ) ; else { int b = ( n * n - 1 ) / 2 ; int c = ( n * n + 1 ) / 2 ; System . out . println ( ""b = "" + b + "", c = "" + c ) ; } } else { if ( n == 2 ) System . out . println ( ""-1"" ) ; else { int b = n * n / 4 - 1 ; int c = n * n / 4 + 1 ; System . out . println ( ""b = "" + b + "", c = "" + c ) ; } } }"
"static void printPattern ( int n ) { int line_no = 1 ; int curr_star = 0 ; for ( line_no = 1 ; line_no <= n ; ) { if ( curr_star < line_no ) { System . out . print ( ""* "" ) ; curr_star ++ ; continue ; } if ( curr_star == line_no ) { System . out . println ( """" ) ; line_no ++ ; curr_star = 0 ; } } }"
"static void right_left ( int a [ ] , int n ) { Map < Integer , Integer > total = new HashMap < > ( ) ; Map < Integer , Integer > left = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) total . put ( a [ i ] , total . get ( a [ i ] ) == null ? 1 : total . get ( a [ i ] ) + 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( ( total . get ( a [ i ] ) - 1 - ( 2 * ( left . containsKey ( a [ i ] ) == true ? left . get ( a [ i ] ) : 0 ) ) ) + "" "" ) ; left . put ( a [ i ] , left . get ( a [ i ] ) == null ? 1 : left . get ( a [ i ] ) + 1 ) ; } }"
static boolean checkYear ( int year ) { return ( ( ( year % 4 == 0 ) && ( year % 100 != 0 ) ) || ( year % 400 == 0 ) ) ; }
"static int minCost ( int coin [ ] , int n , int k ) { Arrays . sort ( coin ) ; int coins_needed = ( int ) Math . ceil ( 1.0 * n / ( k + 1 ) ) ; int ans = 0 ; for ( int i = 0 ; i <= coins_needed - 1 ; i ++ ) ans += coin [ i ] ; return ans ; }"
"static void findIndex ( int a [ ] , int n , int key ) { int start = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == key ) { start = i ; break ; } } if ( start == - 1 ) { System . out . println ( ""Key not present in array"" ) ; return ; } int end = start ; for ( int i = n - 1 ; i >= start ; i -- ) { if ( a [ i ] == key ) { end = i ; break ; } } if ( start == end ) System . out . println ( ""Only one key is present at index : "" + start ) ; else { System . out . println ( ""Start index: "" + start ) ; System . out . println ( ""Last index: "" + end ) ; } }"
"int maxLen ( int arr [ ] , int n ) { HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ; int sum = 0 ; int max_len = 0 ; int ending_index = - 1 ; int start_index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = ( arr [ i ] == 0 ) ? - 1 : 1 ; } for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum == 0 ) { max_len = i + 1 ; ending_index = i ; } if ( hM . containsKey ( sum + n ) ) { if ( max_len < i - hM . get ( sum + n ) ) { max_len = i - hM . get ( sum + n ) ; ending_index = i ; } } else hM . put ( sum + n , i ) ; } for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = ( arr [ i ] == - 1 ) ? 0 : 1 ; } int end = ending_index - max_len + 1 ; System . out . println ( end + "" to "" + ending_index ) ; return max_len ; }"
"static void solution ( int a , int b , int n ) { for ( int i = 0 ; i * a <= n ; i ++ ) { if ( ( n - ( i * a ) ) % b == 0 ) { System . out . println ( ""x = "" + i + "", y = "" + ( n - ( i * a ) ) / b ) ; return ; } } System . out . println ( ""No solution"" ) ; }"
static int countPairs ( int n ) { int count = 0 ; for ( int x = 1 ; x < n ; x ++ ) { for ( int y = x + 1 ; y <= n ; y ++ ) { if ( ( y * x ) % ( y + x ) == 0 ) count ++ ; } } return count ; }
