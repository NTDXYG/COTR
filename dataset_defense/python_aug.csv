python
"def printStringAlternate ( string ) : occ = { } i = 0 while i in list ( range ( len ( string ) ) ) : temp = string [ i ].lower ( ) occ [ temp ] = occ.get ( temp , 0 ) + 1 if occ [ temp ] & 1 : print ( string [ i ] , end = """" ) i += 1 print ( )"
"def digitsNum ( N ) : if ( N == 0 ) : print ( ""0"" , end = """" ) if ( N % 9 != 0 ) : print ( N % 9 , end = """" ) i = 1 while i in list ( range ( int ( N / 9 ) + 1 ) ) : print ( ""9"" , end = """" ) i += 1 for i in range ( 1 , N + 1 ) : print ( ""0"" , end = """" ) print ( )"
"def arraySum ( arr , n ) : _sum = 0 i = 0 while i in list ( range ( n ) ) : _sum = _sum + arr [ i ] i += 1 return _sum"
"def thirdLargest ( arr , arr_size ) : if ( arr_size < 3 ) : print ( ""InvalidInput"" ) return first = arr [ 0 ] i = 1 while i in list ( range ( arr_size ) ) : if ( arr [ i ] > first ) : first = arr [ i ] i += 1 second = - sys.maxsize for i in range ( 0 , arr_size ) : if ( arr [ i ] > second and arr [ i ] < first ) : second = arr [ i ] third = - sys.maxsize for i in range ( 0 , arr_size ) : if ( arr [ i ] > third and arr [ i ] < second ) : third = arr [ i ] print ( ""TheThirdLargest"" , ""elementis"" , third )"
"def isPossibleToZero ( a , n ) : even = 0 odd = 0 i = 0 while i in list ( range ( n ) ) : if ( i & 1 ) : odd += a [ i ] else : even += a [ i ] i += 1 return ( odd == even )"
"def maxElement ( a , n ) : if n < 3 : return - 1 maxElement = a [ 0 ] maxProd = a [ n - 1 ] * a [ 1 ] i = 1 while i in list ( range ( n ) ) : currprod = a [ i - 1 ] * a [ ( i + 1 ) % n ] if currprod > maxProd : maxProd = currprod maxElement = a [ i ] elif currprod == maxProd : maxElement = max ( maxElement , a [ i ] ) i += 1 return maxElement"
"def CountSubSet ( arr , n , X ) : N = 2 ** n count = 0 for i in range ( N ) : j = 0 while j in list ( range ( n ) ) : if ( i & ( 1 << j ) ) : if ( arr [ j ] == X ) : count += 1 j += 1 return count"
def removeRecur ( n ) : prev_digit = n % 10 pow = 10 res = prev_digit while ( n ) : curr_digit = n % 10 if ( curr_digit != prev_digit ) : res = res + curr_digit * pow prev_digit = curr_digit pow *= 10 n = int ( n / 10 ) return res
"def asciiToSentence ( string , length ) : num = 0 i = 0 while i in list ( range ( length ) ) : num = num * 10 + ( ord ( string [ i ] ) - ord ( '0' ) ) if ( num >= 32 and num <= 122 ) : ch = chr ( num ) print ( ch , end = """" ) num = 0 i += 1"
"def findWinner ( x , y , n ) : dp = [ 0 for i in range ( n + 1 ) ] dp [ 0 ] = False dp [ 1 ] = True i = 2 while i in list ( range ( n + 1 ) ) : if ( i - 1 >= 0 and not dp [ i - 1 ] ) : dp [ i ] = True elif ( i - x >= 0 and not dp [ i - x ] ) : dp [ i ] = True elif ( i - y >= 0 and not dp [ i - y ] ) : dp [ i ] = True else : dp [ i ] = False i += 1 return dp [ n ]"
"def countOfSubstringWithKOnes ( s , K ) : N = len ( s ) res = 0 countOfOne = 0 freq = [ 0 for i in range ( N + 1 ) ] freq [ 0 ] = 1 i = 0 while i in list ( range ( N ) ) : countOfOne += ord ( s [ i ] ) - ord ( '0' ) if ( countOfOne >= K ) : res += freq [ countOfOne - K ] freq [ countOfOne ] += 1 i += 1 return res"
def countSetBits ( n ) : i = 0 ans = 0 while ( ( 1 << i ) <= n ) : k = 0 change = 1 << i j = 0 while j in list ( range ( n + 1 ) ) : ans += k if change == 1 : k = not k change = 1 << i else : change -= 1 j += 1 i += 1 return ans
def findS ( s ) : l = 1 r = int ( s / 2 ) + 1 while ( l <= r ) : mid = int ( ( l + r ) / 2 ) sum = int ( mid * ( mid + 1 ) / 2 ) if ( sum == s ) : return mid elif ( s < sum ) : r = mid - 1 else : l = mid + 1 return - 1
def findY ( x ) : if ( 2 < x ) : return x - 2 return x + 2
"def findUniquePair ( arr , n ) : XOR = arr [ 0 ] i = 1 while i in list ( range ( n ) ) : XOR = XOR ^ arr [ i ] i += 1 set_bit_no = XOR & ~ ( XOR - 1 ) x = 0 y = 0 for i in range ( 0 , n ) : if ( arr [ i ] & set_bit_no ) : x = x ^ arr [ i ] else : y = y ^ arr [ i ] print ( ""Theuniquepairis("" , x , "","" , y , "")"" , sep = """" )"
def solve ( x ) : y = 0 j = 1 while y < x : y += j if y == x : return ( j ) j += 1 if y - x != 1 : return ( j - 1 ) else : return ( j )
"def check ( arr , n ) : i = 0 while i in list ( range ( n ) ) : if arr [ i ] & 1 : i += 1 return True i += 1 return False"
"def minProduct ( arr , n , k ) : heapq.heapify ( arr ) count = 0 ans = 1 while ( arr ) and k > count : x = heapq.heappop ( arr ) ans = ans * x count = count + 1 return ans"
"def countNonDecreasing ( n ) : dp = [ [ 0 for i in range ( n + 1 ) ] for i in range ( 10 ) ] i = 0 while i in list ( range ( 10 ) ) : dp [ i ] [ 1 ] = 1 i += 1 for digit in range ( 10 ) : for len in range ( 2 , n + 1 ) : for x in range ( digit + 1 ) : dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] count = 0 for i in range ( 10 ) : count += dp [ i ] [ n ] return count"
def countPairs ( n ) : if ( 2 == n ) : return 4 num = ( ( n // 2 ) + 1 ) max = n % num count = n - max return count
"def minOperations ( arr , n ) : mp = dict.fromkeys ( arr , 0 ) i = 0 while i in list ( range ( n ) ) : mp [ arr [ i ] ] += 1 i += 1 maxFreq = - ( sys.maxsize - 1 ) for key in mp : maxFreq = max ( maxFreq , mp [ key ] ) return ( n - maxFreq )"
def countSolutions ( n ) : x = 0 res = 0 yCount = 0 while ( yCount * yCount < n ) : yCount = yCount + 1 while ( yCount != 0 ) : res = res + yCount x = x + 1 while ( 0 != yCount and ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) : yCount = yCount - 1 return res
"def countSubArrays ( arr , n , K ) : count = 0 i = 0 while i in list ( range ( n ) ) : for j in range ( i , n ) : bitwise_or = 0 for k in range ( i , j + 1 ) : bitwise_or = bitwise_or | arr [ k ] if ( bitwise_or >= K ) : count += 1 i += 1 return count"
"def CheckArray ( arr , n ) : prod = 1 for i in range ( 0 , n , 1 ) : prod *= arr [ i ] i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] == prod / arr [ i ] ) : i += 1 return True i += 1 return False"
"def printRepeating ( arr , size ) : count = [ 0 ] * size print ( ""Repeatingelementsare"" , end = """" ) i = 0 while i in list ( range ( size ) ) : if ( count [ arr [ i ] ] == 1 ) : print ( arr [ i ] , end = """" ) else : count [ arr [ i ] ] = count [ arr [ i ] ] + 1 i += 1"
"def answer ( n ) : m = 2 ans = 1 r = 1 while r < n : r = ( int ) ( ( pow ( 2 , m ) - 1 ) * ( pow ( 2 , m - 1 ) ) ) if n > r : ans = r m = m + 1 return ans"
"def rectanglearea ( a , b ) : if a < 0 or 0 > b : return - 1 return 2 * a * b"
"def maxAvgSubArray ( a , n , x , y ) : prefix = [ 0 ] * n prefix [ 0 ] = a [ 0 ] for i in range ( 1 , n ) : prefix [ i ] = prefix [ i - 1 ] + a [ i ] maximum = 0 i = 0 while i in list ( range ( n ) ) : j = i + x - 1 while ( j < i + y and j < n ) : sum = prefix [ j ] if ( i > 0 ) : sum -= prefix [ i - 1 ] current = sum / ( j - i + 1 ) maximum = max ( maximum , current ) j += 1 i += 1 return maximum"
"def countPairs ( arr , n , k ) : cnt = 0 for i in range ( n - 1 ) : j = i + 1 while j in list ( range ( n ) ) : if ( ( arr [ i ] - arr [ j ] + k ) % k == 0 ) : cnt += 1 j += 1 print ( cnt )"
"def getOddOccurrence ( arr , arr_size ) : i = 0 while i in list ( range ( arr_size ) ) : count = 0 for j in range ( 0 , arr_size ) : if arr [ i ] == arr [ j ] : count += 1 if ( count % 2 != 0 ) : i += 1 return arr [ i ] i += 1 return - 1"
"def checkCount ( arr , n , k ) : i = 0 while i in list ( range ( n ) ) : count = 0 for j in range ( n ) : if arr [ j ] == arr [ i ] : count += 1 if count > 2 * k : i += 1 return False i += 1 return True"
"def possibleOrNot ( a1 , a2 , b1 , b2 , c1 , c2 ) : dis1 = ( pow ( b1 - a1 , 2 ) + pow ( b2 - a2 , 2 ) ) dis2 = ( pow ( c1 - b1 , 2 ) + pow ( c2 - b2 , 2 ) ) if ( dis1 != dis2 ) : print ( ""No"" ) elif ( ( ( a1 + c1 ) // 2.0 ) == b1 and b2 == ( ( a2 + c2 ) // 2.0 ) ) : print ( ""No"" ) else : print ( ""Yes"" )"
"def checkEvenOdd ( arr , n ) : i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] % 2 == 0 ) : print ( ""Even"" , end = """" ) i += 1 return i += 1 print ( ""Odd"" , end = """" )"
"def countSubStr ( strr , lenn ) : ans = 0 i = 0 while i in list ( range ( lenn ) ) : if ( strr [ i ] == '0' ) : ans += ( i + 1 ) i += 1 return ans"
"def find ( n ) : b = n a = b * ( n - 1 ) if a * b > n and n > a // b : print ( ""a={},b={}"".format ( a , b ) ) else : print ( - 1 )"
"def countPairs ( a , n ) : count = 0 for i in range ( 0 , n ) : j = i + 1 while j in list ( range ( n ) ) : if ( a [ i ] & a [ j ] ) == 0 : count += 2 j += 1 return count"
"def getPairs ( a , n ) : visited1 = set ( ) un = [ 0 ] * n un [ n - 1 ] = 0 count = 0 i = n - 1 while i in list ( range ( - 1 ) ) : if ( a [ i ] in visited1 ) : un [ i - 1 ] = count else : count += 1 un [ i - 1 ] = count visited1.add ( a [ i ] ) i += - 1 visited2 = set ( ) answer = 0 for i in range ( n - 1 ) : if ( a [ i ] in visited2 ) : continue answer += un [ i ] visited2.add ( a [ i ] ) return answer"
def sumOfSeries ( num ) : res = 0 fact = 1 i = 1 while i in list ( range ( num + 1 ) ) : fact *= i res = res + ( i / fact ) i += 1 return res
"def subarrayPossible ( arr , n ) : sum = 0 i = 0 while i in list ( range ( n ) ) : sum += arr [ i ] if ( sum <= 0 ) : i += 1 return True i += 1 sum = 0 for i in range ( n - 1 , - 1 , - 1 ) : sum += arr [ i ] if ( sum <= 0 ) : return True return False"
"def PowerOFPINnfactorial ( n , p ) : ans = 0 temp = p while ( temp <= n ) : ans = ans + n / temp temp = temp * p return ans"
"def getMinimumOps ( ar ) : n = len ( ar ) small = min ( ar ) large = max ( ar ) dp = [ [ 0 for i in range ( large + 1 ) ] for i in range ( n ) ] for j in range ( small , large + 1 ) : dp [ 0 ] [ j ] = abs ( ar [ 0 ] - j ) i = 1 while i in list ( range ( n ) ) : minimum = 10 ** 9 for j in range ( small , large + 1 ) : minimum = min ( minimum , dp [ i - 1 ] [ j ] ) dp [ i ] [ j ] = minimum + abs ( ar [ i ] - j ) i += 1 ans = 10 ** 9 for j in range ( small , large + 1 ) : ans = min ( ans , dp [ n - 1 ] [ j ] ) return ans"
def findNthTerm ( n ) : n = n * 2 a = 1 b = 1 c = - 1 * n d = b * b - 4 * a * c sqrt_val = math.sqrt ( abs ( d ) ) x1 = ( - b + sqrt_val ) // ( 2 * a ) x2 = ( - b - sqrt_val ) // ( 2 * a ) x1 = int ( x1 ) x2 = int ( x2 ) if ( 1 <= x1 ) : print ( chr ( 97 + x1 ) ) elif ( x2 >= 1 ) : print ( chr ( 97 + x2 ) )
"def count ( a , b , m , n ) : if ( ( m == 0 and n == 0 ) or n == 0 ) : return 1 if ( 0 == m ) : return 0 if ( a [ m - 1 ] == b [ n - 1 ] ) : return ( count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ) else : return count ( a , b , m - 1 , n )"
"def evaluate ( n ) : if ( n == 1 or n == 2 ) : print ( ""NoPythagoras"" + ""Tripletexists"" ) elif ( n % 2 == 0 ) : var = n * n / 4 print ( ""PythagorasTriplets"" + ""existi.e."" , end = """" ) print ( int ( n ) , """" , int ( var - 1 ) , """" , int ( var + 1 ) ) elif ( 0 != n % 2 ) : var = n * n + 1 print ( ""PythagorasTriplets"" + ""existi.e."" , end = """" ) print ( int ( n ) , """" , int ( var / 2 - 1 ) , """" , int ( var / 2 ) )"
"def maxTripletSum ( arr , n ) : sm = - 1000000 for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : k = j + 1 while k in list ( range ( n ) ) : if ( sm < ( arr [ i ] + arr [ j ] + arr [ k ] ) ) : sm = arr [ i ] + arr [ j ] + arr [ k ] k += 1 return sm"
"def maxSum ( arr , n ) : res = - sys.maxsize i = 0 while i in list ( range ( n ) ) : curr_sum = 0 for j in range ( 0 , n ) : index = int ( ( i + j ) % n ) curr_sum += j * arr [ index ] res = max ( res , curr_sum ) i += 1 return res"
"def reversDigits ( num ) : negativeFlag = False if ( num < 0 ) : negativeFlag = True num = - num prev_rev_num = 0 rev_num = 0 while ( num != 0 ) : curr_digit = num % 10 rev_num = ( rev_num * 10 ) + curr_digit if ( rev_num >= 2147483647 or rev_num <= - 2147483648 ) : rev_num = 0 if ( ( rev_num - curr_digit ) // 10 != prev_rev_num ) : print ( ""WARNINGOVERFLOWED!!!"" ) return 0 prev_rev_num = rev_num num = num // 10 return - rev_num if ( True == negativeFlag ) else rev_num"
"def findNumber ( n , d ) : ans = """" if ( d != 10 ) : ans = ans + str ( d ) for i in range ( 1 , n ) : ans = ans + '0' else : if ( n == 1 ) : ans = ans + ""Impossible"" else : ans = ans + '1' for i in range ( 1 , n ) : ans = ans + '0' return ans"
"def countMaxSetBits ( left , right ) : max_count = - 1 i = left while i in list ( range ( right + 1 ) ) : temp = i cnt = 0 while temp : if temp & 1 : cnt += 1 temp = temp >> 1 if cnt > max_count : max_count = cnt num = i i += 1 return num"
"def countWays ( n , arr , k ) : if ( 0 >= k or k >= n ) : return 0 s = set ( ) for element in arr : s.add ( element ) if ( len ( s ) <= k ) : return 0 return len ( s ) - k"
"def printCubeFree ( n ) : cubFree = [ 1 ] * ( n + 1 ) i = 2 while ( i * i * i <= n ) : if ( cubFree [ i ] == 1 ) : multiple = 1 while ( i * i * i * multiple <= n ) : cubFree [ i * i * i * multiple ] = 0 multiple += 1 i += 1 i = 2 while i in list ( range ( n + 1 ) ) : if ( cubFree [ i ] == 1 ) : print ( i , end = """" ) i += 1"
"def longestSubstring ( s ) : cnt = 1 maxi = 1 n = len ( s ) i = 1 while i in list ( range ( n ) ) : if ( s [ i ] != s [ i - 1 ] ) : cnt += 1 else : maxi = max ( cnt , maxi ) cnt = 1 i += 1 maxi = max ( cnt , maxi ) return maxi"
"def maxSum ( arr , n ) : if ( n < 2 ) : return - 1 ans = arr [ 0 ] + arr [ 1 ] i = 1 while i in list ( range ( n - 1 ) ) : ans = min ( ans , ( arr [ i ] + arr [ i + 1 ] ) ) i += 1 return ans"
"def checkPalindrome ( num ) : string = str ( num ) l = 0 r = len ( string ) - 1 while ( l < r ) : if ( string [ r ] != string [ l ] ) : print ( ""No"" ) return l = l + 1 r = r - 1 print ( ""Yes"" ) return"
"def palindrome ( arr , n ) : flag = 0 i = 0 while ( n // 2 >= i and n != 0 ) : if ( arr [ i ] != arr [ n - i - 1 ] ) : flag = 1 break i += 1 if ( flag == 1 ) : print ( ""NotPalindrome"" ) else : print ( ""Palindrome"" )"
"def nextWord ( s ) : if ( s == """" ) : return ""a"" i = len ( s ) - 1 while ( 'z' == s [ i ] and i >= 0 ) : i -= 1 if ( i == - 1 ) : s = s + 'a' else : s = s.replace ( s [ i ] , chr ( ord ( s [ i ] ) + 1 ) , 1 ) return s"
"def knapSack ( W , wt , val , n ) : maxratio = - sys.maxsize - 1 maxindex = 0 i = 0 while i in list ( range ( n ) ) : if ( ( val [ i ] / wt [ i ] ) > maxratio ) : maxratio = ( val [ i ] / wt [ i ] ) maxindex = i i += 1 return ( W * maxratio )"
"def checkSubarraySum ( arr , n , k , sum ) : for i in range ( n - k + 1 ) : current_sum = 0 j = 0 while j in list ( range ( k ) ) : current_sum = ( current_sum + arr [ i + j ] ) j += 1 if ( current_sum == sum ) : return True return False"
"def findMinimumDeletion ( l , r , dp , s ) : if l > r : return 0 if l == r : return 1 if dp [ l ] [ r ] != - 1 : return dp [ l ] [ r ] res = 1 + findMinimumDeletion ( l + 1 , r , dp , s ) i = l + 1 while i in list ( range ( r + 1 ) ) : if s [ l ] == s [ i ] : res = min ( res , findMinimumDeletion ( l + 1 , i - 1 , dp , s ) + findMinimumDeletion ( i , r , dp , s ) ) i += 1 dp [ l ] [ r ] = res return res"
"def ZigZag ( rows , columns , numbers ) : k = 0 arr = [ [ 0 for i in range ( columns ) ] for j in range ( rows ) ] i = 0 while i in list ( range ( rows ) ) : if ( i % 2 == 0 ) : j = 0 while j < columns and numbers [ k ] > 0 : arr [ i ] [ j ] = k + 1 numbers [ k ] -= 1 if numbers [ k ] == 0 : k += 1 j += 1 else : j = columns - 1 while j >= 0 and numbers [ k ] > 0 : arr [ i ] [ j ] = k + 1 numbers [ k ] -= 1 if numbers [ k ] == 0 : k += 1 j -= 1 i += 1 for i in arr : for j in i : print ( j , end = """" ) print ( )"
"def ReplaceElements ( arr , n ) : min_ele = arr [ 0 ] arr [ 0 ] = - 1 i = 1 while i in list ( range ( n ) ) : if ( min_ele < arr [ i ] ) : arr [ i ] = min_ele elif ( min_ele >= arr [ i ] ) : temp = arr [ i ] arr [ i ] = min_ele min_ele = temp i += 1"
"def first ( a , b , c ) : a %= b i = 1 while i in list ( range ( b + 1 ) ) : a = a * 10 if int ( a / b ) == c : i += 1 return i a %= b i += 1 return - 1"
"def getSum ( n , d ) : sum = 0 i = 0 while i in list ( range ( n + 1 ) ) : if ( i % 10 == d ) : sum += i i += 1 return sum"
"def countNegative ( M , n , m ) : count = 0 i = 0 j = m - 1 while j >= 0 and n > i : if M [ i ] [ j ] < 0 : count += ( j + 1 ) i += 1 else : j -= 1 return count"
"def factorize ( n ) : count = 0 while ( ( n % 2 > 0 ) == False ) : n >>= 1 count += 1 if ( count > 0 ) : print ( 2 , count ) i = 3 while i in list ( range ( int ( math.sqrt ( n ) ) + 1 ) ) : count = 0 while ( n % i == 0 ) : count += 1 n = int ( n / i ) if ( count > 0 ) : print ( i , count ) i += 2 i += 1 if ( n > 2 ) : print ( n , 1 )"
"def countXorPair ( arr , n ) : odd = 0 even = 0 i = 0 while i in list ( range ( n ) ) : if arr [ i ] % 2 == 0 : even += 1 else : odd += 1 i += 1 return odd * even"
"def check ( n , marks ) : x = max ( marks ) bonus = 100 - x c = 0 i = 0 while i in list ( range ( n ) ) : if ( marks [ i ] + bonus >= 50 ) : c += 1 i += 1 return c"
"def minSwaps ( str1 , str2 ) : count = 0 i = 0 while i in list ( range ( len ( str1 ) ) ) : if str1 [ i ] != str2 [ i ] : count += 1 i += 1 if count % 2 == 0 : print ( count // 2 ) else : print ( ""NotPossible"" )"
def xorCalc ( k ) : if ( 1 == k ) : return 2 if ( ( ( k + 1 ) & k ) == 0 ) : return k / 2 return 1
"def minSpacePreferLarge ( w , m , n ) : num_m = 0 num_n = 0 rem = w p = 0 q = 0 r = 0 while ( n <= w ) : p = w / m r = w % m if ( r <= rem ) : num_m = p num_n = q rem = r q += 1 w -= n print ( str ( int ( num_m ) ) + """" + str ( num_n ) + """" + str ( rem ) )"
"def maxSum ( arr , n ) : sum = 0 arr.sort ( ) i = 0 while i in list ( range ( int ( n / 2 ) ) ) : sum -= ( 2 * arr [ i ] ) sum += ( 2 * arr [ n - i - 1 ] ) i += 1 return sum"
"def printKDistinct ( arr , n , k ) : dist_count = 0 i = 0 while i in list ( range ( n ) ) : j = 0 while j < n : if ( i != j and arr [ j ] == arr [ i ] ) : i += 1 break j += 1 if ( j == n ) : dist_count += 1 if ( dist_count == k ) : i += 1 return arr [ i ] i += 1 return - 1"
def checking ( s ) : c = 0 n = len ( s ) i = n - 1 while ( i >= 0 ) : if ( s [ i ] == '0' ) : c += 1 if ( 6 <= c and s [ i ] == '1' ) : return True i -= 1 return False
"def printCollatz ( n ) : while 1 != n : print ( n , end = '' ) if n & 1 : n = 3 * n + 1 else : n = n // 2 print ( n )"
"def fun ( marks , n ) : dp = [ 1 for i in range ( 0 , n ) ] i = 0 while i in list ( range ( n - 1 ) ) : if marks [ i ] > marks [ i + 1 ] : temp = i while True : if marks [ temp ] > marks [ temp + 1 ] and temp >= 0 : if dp [ temp ] > dp [ temp + 1 ] : temp -= 1 i += 1 continue else : dp [ temp ] = dp [ temp + 1 ] + 1 temp -= 1 else : i += 1 break elif marks [ i ] < marks [ i + 1 ] : dp [ i + 1 ] = dp [ i ] + 1 i += 1 return ( sum ( dp ) )"
"def sortUsingHash ( a , n ) : Max = max ( a ) Hash = [ 0 ] * ( Max + 1 ) for i in range ( 0 , n ) : Hash [ a [ i ] ] += 1 i = 0 while i in list ( range ( Max + 1 ) ) : if Hash [ i ] != 0 : for j in range ( 0 , Hash [ i ] ) : print ( i , end = """" ) i += 1"
"def check ( s1 , s2 ) : n = len ( s1 ) m = len ( s2 ) dp = ( [ [ False for i in range ( m + 1 ) ] for i in range ( n + 1 ) ] ) dp [ 0 ] [ 0 ] = True i = 0 while i in list ( range ( len ( s1 ) ) ) : for j in range ( len ( s2 ) + 1 ) : if ( dp [ i ] [ j ] ) : if ( ( j < len ( s2 ) and ( s1 [ i ].upper ( ) == s2 [ j ] ) ) ) : dp [ i + 1 ] [ j + 1 ] = True if ( s1 [ i ].isupper ( ) == False ) : dp [ i + 1 ] [ j ] = True i += 1 return ( dp [ n ] [ m ] )"
"def Vertices ( x , y ) : val = abs ( x ) + abs ( y ) if x < 0 : x = - 1 else : x = 1 print ( val * x , ""0"" , end = """" ) if 0 > y : y = - 1 else : y = 1 print ( ""0"" , val * y )"
"def decToBin ( n ) : if ( n == 0 ) : return ""0"" bin = """" while ( n > 0 ) : if ( 0 == n & 1 ) : bin = '0' + bin else : bin = '1' + bin n = n >> 1 return bin"
def calcMaxValue ( str ) : res = ord ( str [ 0 ] ) - 48 i = 1 while i in list ( range ( len ( str ) ) ) : if ( str [ i ] == '0' or str [ i ] == '1' or res < 2 ) : res += ord ( str [ i ] ) - 48 else : res *= ord ( str [ i ] ) - 48 i += 1 return res
"def parallel ( n , a ) : x = True y = True i = 0 while i in list ( range ( n - 1 ) ) : for j in range ( 2 ) : if ( a [ i ] [ 0 ] != a [ i + 1 ] [ 0 ] ) : x = False if ( a [ i ] [ 1 ] != a [ i + 1 ] [ 1 ] ) : y = False i += 1 if ( x ) : print ( ""ParalleltoXAxis"" ) elif ( y ) : print ( ""ParalleltoYAxis"" ) else : print ( ""NotParalleltoXandYAxis"" )"
"def fix ( A , len ) : i = 0 while i in list ( range ( len ) ) : if ( A [ i ] != - 1 and A [ i ] != i ) : x = A [ i ] while ( A [ x ] != - 1 and A [ x ] != x ) : y = A [ x ] A [ x ] = x x = y A [ x ] = x if ( A [ i ] != i ) : A [ i ] = - 1 i += 1"
"def number_of_tower ( house , r , n ) : house.sort ( ) numOfTower = 0 i = 0 while ( i < n ) : numOfTower += 1 loc = house [ i ] + r while ( i < n and house [ i ] <= loc ) : i += 1 i -= 1 loc = house [ i ] + r while ( i < n and loc >= house [ i ] ) : i += 1 return numOfTower"
def cal_minimum_time ( X ) : t = 0 sum = 0 while ( X > sum ) : t = t + 1 sum = sum + t return t
"def gcd ( a , b ) : if ( 0 == a or b == 0 ) : False if ( a == b ) : return a if ( a > b ) : return gcd ( a - b , b ) return gcd ( a , b - a )"
def findRemainder ( n ) : l = n % 10 while ( 10 <= n ) : n //= 10 f = n remainder = f % l print ( remainder )
def nth_term ( n ) : a = 1 b = 1 c = 1 i = 0 while i in list ( range ( n ) ) : c = a + b a = b b = c i += 1 return c
"def findXorSum ( arr , n ) : Sum = 0 mul = 1 for i in range ( 30 ) : c_odd = 0 odd = 0 for j in range ( n ) : if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) : odd = ( ~ odd ) if ( odd ) : c_odd += 1 j = 0 while j in list ( range ( n ) ) : Sum += ( mul * c_odd ) if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) : c_odd = ( n - j - c_odd ) j += 1 mul *= 2 return Sum"
"def countNum ( arr , n ) : s = dict ( ) count , maxm , minm = 0 , - 10 ** 9 , 10 ** 9 for i in range ( n ) : s [ arr [ i ] ] = 1 if ( arr [ i ] < minm ) : minm = arr [ i ] if ( arr [ i ] > maxm ) : maxm = arr [ i ] i = minm while i in list ( range ( maxm + 1 ) ) : if i not in s.keys ( ) : count += 1 i += 1 return count"
"def psuedoBinary ( n ) : while ( n > 0 ) : temp = n m = 0 p = 1 while ( temp ) : rem = temp % 10 temp = int ( temp / 10 ) if ( rem != 0 ) : m = m + p p *= 10 print ( m , end = """" ) n = n - m"
def isMultipleof5 ( n ) : while ( n > 0 ) : n = n - 5 if ( 0 == n ) : return 1 return 0
"def countUnique ( arr , n ) : s = set ( ) i = 0 while i in list ( range ( n ) ) : s.add ( arr [ i ] ) i += 1 count = pow ( len ( s ) , 2 ) return count"
"def subArray ( arr , n , m ) : i = 0 mp = dict ( ) i = 0 while i in list ( range ( n ) ) : mp [ arr [ i ] ] = i + 1 i += 1 sumcur = 0 p = 10 ** 9 ans = [ ] for i in range ( 1 , m + 1 ) : sumcur += mp [ i ] p = min ( p , mp [ i ] ) val = p * i - i + ( i * ( i + 1 ) ) / 2 if ( i == m ) : if ( val == sumcur ) : return True else : return False"
"def printSorted ( arr , start , end ) : if end < start : return printSorted ( arr , start * 2 + 1 , end ) print ( arr [ start ] , end = """" ) printSorted ( arr , start * 2 + 2 , end )"
"def MinCostTree ( arr , n ) : ans = 0 st = [ 2 ** 32 ] i = 0 while i in list ( range ( n ) ) : while ( st [ - 1 ] <= arr [ i ] ) : x = st [ - 1 ] st.pop ( ) ans += x * min ( st [ - 1 ] , arr [ i ] ) st.append ( arr [ i ] ) i += 1 for i in range ( 2 , len ( st ) ) : ans += st [ i ] * st [ i - 1 ] return ans"
"def sumOfLastDig ( n , m ) : sum = 0 k = n // m arr = [ 0 ] * 10 i = 0 while i in list ( range ( 10 ) ) : arr [ i ] = m * ( i + 1 ) % 10 sum += arr [ i ] i += 1 rem = k % 10 ans = ( k // 10 ) * sum for i in range ( rem ) : ans += arr [ i ] return ans"
"def countUnvisited ( n , m ) : i = 0 X = ( m * n ) - m - n queue = [ ] queue.append ( X ) count = 0 while ( len ( queue ) > 0 ) : curr = queue [ 0 ] queue.remove ( queue [ 0 ] ) count += 1 if ( 0 < curr - m ) : queue.append ( curr - m ) if ( curr - n > 0 ) : queue.append ( curr - n ) return count"
"def MaxSumDifference ( a , n ) : np.sort ( a ) j = 0 finalSequence = [ 0 for x in range ( n ) ] for i in range ( 0 , int ( n / 2 ) ) : finalSequence [ j ] = a [ i ] finalSequence [ j + 1 ] = a [ n - i - 1 ] j = j + 2 MaximumSum = 0 i = 0 while i in list ( range ( n - 1 ) ) : MaximumSum = ( MaximumSum + abs ( finalSequence [ i ] - finalSequence [ i + 1 ] ) ) i += 1 MaximumSum = ( MaximumSum + abs ( finalSequence [ n - 1 ] - finalSequence [ 0 ] ) ) print ( MaximumSum )"
"def findNthRoot ( x , n ) : x = float ( x ) n = int ( n ) if ( 0 <= x and x <= 1 ) : low = x high = 1 else : low = 1 high = x epsilon = 0.00000001 guess = ( low + high ) / 2 while abs ( guess ** n - x ) >= epsilon : if guess ** n > x : high = guess else : low = guess guess = ( low + high ) / 2 print ( guess )"
"def solve ( A , B , n ) : cnt = 0 for i in range ( n ) : j = i while j in list ( range ( n ) ) : c = A [ i ] & A [ j ] if ( bin ( c ).count ( '1' ) == B [ j ] ) : cnt += 1 j += 1 return cnt"
"def checkValidity ( a , b , c ) : if ( a + b <= c ) or ( b >= a + c ) or ( b + c <= a ) : return False else : return True"
def factorial ( n ) : return 1 if ( 1 == n or n == 0 ) else n * factorial ( n - 1 )
"def exponential ( n , x ) : sum = 1.0 i = n while i in list ( range ( 0 ) ) : sum = 1 + x * sum / i i += - 1 print ( ""e^x="" , sum )"
"def equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 , x , y , z ) : a1 = x2 - x1 b1 = y2 - y1 c1 = z2 - z1 a2 = x3 - x1 b2 = y3 - y1 c2 = z3 - z1 a = b1 * c2 - b2 * c1 b = a2 * c1 - a1 * c2 c = a1 * b2 - b1 * a2 d = ( - a * x1 - b * y1 - c * z1 ) if ( 0 == a * x + b * y + c * z + d ) : print ( ""Coplanar"" ) else : print ( ""NotCoplanar"" )"
"def countOddRotations ( n ) : odd_count = 0 ; even_count = 0 while 0 != n : digit = n % 10 if digit % 2 == 0 : odd_count += 1 else : even_count += 1 n = n // 10 print ( ""Odd="" , odd_count ) print ( ""Even="" , even_count )"
"def countSubSeq ( strr , lenn ) : ans = 0 mul = 1 i = 0 while i in list ( range ( lenn ) ) : if ( strr [ i ] == '0' ) : ans += mul mul *= 2 i += 1 return ans"
"def minSet ( nums ) : A = [ ] nums.sort ( ) sum = 0 for i in range ( 0 , len ( nums ) ) : sum += nums [ i ] temp = 0 i = len ( nums ) - 1 while i in list ( range ( - 1 ) ) : if ( temp > sum / 2 ) : i += - 1 break A.append ( nums [ i ] ) temp += nums [ i ] i += - 1 for i in range ( 0 , len ( A ) ) : print ( A [ i ] , end = '' )"
def isOsiris ( n ) : a = n % 10 b = ( n // 10 ) % 10 c = n // 100 digit_sum = a + b + c if ( ( 2 * ( digit_sum ) * 11 ) == n ) : return True return False
"def twoWaySort ( arr , n ) : i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] & 1 ) : arr [ i ] *= - 1 i += 1 arr.sort ( ) for i in range ( 0 , n ) : if ( arr [ i ] & 1 ) : arr [ i ] *= - 1"
"def modInverse ( a , m ) : a = a % m x = 1 while x in list ( range ( m ) ) : if ( ( a * x ) % m == 1 ) : x += 1 return x x += 1 return 1"
"def maxLines ( n , x1 , y1 , x2 , y2 ) : s = [ ] slope = sys.maxsize i = 0 while i in list ( range ( n ) ) : if ( x1 [ i ] == x2 [ i ] ) : slope = sys.maxsize else : slope = ( y2 [ i ] - y1 [ i ] ) * 1.0 / ( x2 [ i ] - x1 [ i ] ) * 1.0 s.append ( slope ) i += 1 return len ( s )"
"def printKDistinct ( arr , size , KthIndex ) : dict = { } vect = [ ] i = 0 while i in list ( range ( size ) ) : if ( arr [ i ] in dict ) : dict [ arr [ i ] ] = dict [ arr [ i ] ] + 1 else : dict [ arr [ i ] ] = 1 i += 1 for i in range ( size ) : if ( dict [ arr [ i ] ] > 1 ) : continue else : KthIndex = KthIndex - 1 if ( KthIndex == 0 ) : return arr [ i ] return - 1"
def maxRepeating ( str ) : n = len ( str ) count = 0 res = str [ 0 ] cur_count = 1 i = 0 while i in list ( range ( n ) ) : if ( i < n - 1 and str [ i ] == str [ i + 1 ] ) : cur_count += 1 else : if cur_count > count : count = cur_count res = str [ i ] cur_count = 1 i += 1 return res
"def dealnnoy ( n , m ) : if ( m == 0 or 0 == n ) : return 1 return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 )"
"def longestsubarray ( arr , n , k ) : current_count = 0 max_count = 0 i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] % k == 0 ) : current_count += 1 else : current_count = 0 max_count = max ( current_count , max_count ) i += 1 return max_count"
"def SUM ( n , m ) : if ( 1 == m ) : return ( n * ( n + 1 ) / 2 ) sum = SUM ( n , m - 1 ) return int ( sum * ( sum + 1 ) / 2 )"
"def maxOR ( arr , n , k , x ) : preSum = [ 0 ] * ( n + 1 ) suffSum = [ 0 ] * ( n + 1 ) pow = 1 for i in range ( 0 , k ) : pow *= x preSum [ 0 ] = 0 for i in range ( 0 , n ) : preSum [ i + 1 ] = preSum [ i ] | arr [ i ] suffSum [ n ] = 0 i = n - 1 while i in list ( range ( - 1 ) ) : suffSum [ i ] = suffSum [ i + 1 ] | arr [ i ] i += - 1 res = 0 for i in range ( 0 , n ) : res = max ( res , preSum [ i ] | ( arr [ i ] * pow ) | suffSum [ i + 1 ] ) return res"
def findDuplicateparenthesis ( string ) : Stack = [ ] for ch in string : if ch != ')' : Stack.append ( ch ) else : top = Stack.pop ( ) elementsInside = 0 while top != '(' : elementsInside += 1 top = Stack.pop ( ) if elementsInside < 1 : return True return False
def countDigit ( n ) : if 0 == n : return 0 return 1 + countDigit ( n // 10 )
"def findNthOccur ( string , ch , N ) : occur = 0 i = 0 while i in list ( range ( len ( string ) ) ) : if ( string [ i ] == ch ) : occur += 1 if ( occur == N ) : i += 1 return i i += 1 return - 1"
"def minNum ( num , k ) : len_ = len ( num ) if len_ == 0 or k == 0 : return num if 1 == len_ : return ""0"" if num [ 0 ] != '1' : num = '1' + num [ 1 : ] k -= 1 i = 1 while k > 0 and i < len_ : if num [ i ] != '0' : num = num [ : i ] + '0' + num [ i + 1 : ] k -= 1 i += 1 return num"
"def checkPandigital ( b , n ) : if ( len ( n ) < b ) : return 0 hash = [ 0 ] * b for i in range ( len ( n ) ) : if ( n [ i ] >= '0' and n [ i ] <= '9' ) : hash [ ord ( n [ i ] ) - ord ( '0' ) ] = 1 elif ( ord ( n [ i ] ) - ord ( 'A' ) <= b - 11 ) : hash [ ord ( n [ i ] ) - ord ( 'A' ) + 10 ] = 1 i = 0 while i in list ( range ( b ) ) : if ( hash [ i ] == 0 ) : i += 1 return 0 i += 1 return 1"
"def max_sum ( a , n ) : dp = [ 0 ] * n if ( n == 1 ) : dp [ 0 ] = max ( 0 , a [ 0 ] ) elif ( n == 2 ) : dp [ 0 ] = max ( 0 , a [ 0 ] ) dp [ 1 ] = max ( a [ 1 ] , dp [ 0 ] ) elif ( n >= 3 ) : dp [ 0 ] = max ( 0 , a [ 0 ] ) dp [ 1 ] = max ( a [ 1 ] , max ( 0 , a [ 0 ] ) ) dp [ 2 ] = max ( a [ 2 ] , max ( a [ 1 ] , max ( 0 , a [ 0 ] ) ) ) i = 3 while ( n > i ) : dp [ i ] = max ( dp [ i - 1 ] , a [ i ] + dp [ i - 3 ] ) i += 1 return dp [ n - 1 ]"
"def solve ( arr , n ) : b = [ 0 for i in range ( n ) ] p = 0 i = n - 1 while i >= 0 : b [ p ] = arr [ i ] i -= 1 if ( 0 <= i ) : b [ n - 1 - p ] = arr [ i ] p += 1 i -= 1 return b"
def countDigit ( n ) : count = 0 while 0 != n : n //= 10 count += 1 return count
"def maxSum ( arr , n ) : cum_sum = 0 for i in range ( 0 , n ) : cum_sum += arr [ i ] curr_val = 0 for i in range ( 0 , n ) : curr_val += i * arr [ i ] res = curr_val i = 1 while i in list ( range ( n ) ) : next_val = ( curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) ) curr_val = next_val res = max ( res , next_val ) i += 1 return res"
"def findIntegers ( n , x , y ) : ans = [ ] for i in range ( n - 1 ) : ans.append ( 1 ) if ( y - ( n - 1 ) <= 0 ) : print ( ""-1"" , end = """" ) return ans.append ( y - ( n - 1 ) ) store = 0 for i in range ( n ) : store += ans [ i ] * ans [ i ] if ( store < x ) : print ( ""-1"" , end = """" ) return i = 0 while i in list ( range ( n ) ) : print ( ans [ i ] , end = """" ) i += 1"
"def Minsteps ( n , m ) : ans = 0 while ( n < m ) : if ( m & 1 ) : m += 1 ans += 1 m //= 2 ans += 1 return ans + n - m"
"def findNature ( a , b , n ) : if ( n == 0 ) : return ( a & 1 ) if ( n == 1 ) : return ( b & 1 ) if ( ( a & 1 ) == 0 ) : if ( ( b & 1 ) == 0 ) : return False else : return True if ( n % 3 != 0 ) else False else : if ( ( b & 1 ) == 0 ) : return True if ( ( n - 1 ) % 3 != 0 ) else False else : return True if ( 0 != ( n + 1 ) % 3 ) else False"
"def minimumMoves ( n , a , s , t ) : x = s i = 1 while i in list ( range ( n + 1 ) ) : if x == t : i += 1 return i - 1 x = a [ x ] i += 1 return - 1"
"def printPattern ( n ) : var = 0 var = 1 for i in range ( 1 , n + 1 ) : if ( i % 2 != 0 ) : var = var + i - 1 for j in range ( 1 , i + 1 ) : if ( j == 1 ) : print ( var , end = """" ) else : print ( ""*"" , end = """" ) print ( var , end = """" ) var += 1 else : var1 = var + i - 1 j = 1 while j in list ( range ( i + 1 ) ) : if ( j == 1 ) : print ( var1 , end = """" ) else : print ( ""*"" , end = """" ) print ( var1 , end = """" ) var1 -= 1 j += 1 print ( )"
"def findoptimal ( N ) : if ( N <= 6 ) : return N screen = [ 0 ] * N n = 1 while n in list ( range ( 7 ) ) : screen [ n - 1 ] = n n += 1 for n in range ( 7 , N + 1 ) : screen [ n - 1 ] = max ( 2 * screen [ n - 4 ] , max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) return screen [ N - 1 ]"
def sumofoddFactors ( n ) : res = 1 while n % 2 == 0 : n = n // 2 i = 3 while i in list ( range ( int ( math.sqrt ( n ) + 1 ) ) ) : count = 0 curr_sum = 1 curr_term = 1 while n % i == 0 : count += 1 n = n // i curr_term *= i curr_sum += curr_term res *= curr_sum i += 1 if n >= 2 : res *= ( 1 + n ) return res
"def printKMissing ( arr , n , k ) : arr.sort ( ) i = 0 while ( i < n and 0 >= arr [ i ] ) : i = i + 1 count = 0 curr = 1 while ( count < k and i < n ) : if ( arr [ i ] != curr ) : print ( str ( curr ) + """" , end = '' ) count = count + 1 else : i = i + 1 curr = curr + 1 while ( count < k ) : print ( str ( curr ) + """" , end = '' ) curr = curr + 1 count = count + 1"
def smallestDivisor ( n ) : if ( 0 == n % 2 ) : return 2 i = 3 while ( i * i <= n ) : if ( n % i == 0 ) : return i i += 2 return n
"def print2largest ( arr , arr_size ) : if ( arr_size < 2 ) : print ( ""InvalidInput"" ) return first = second = - 2147483648 i = 0 while i in list ( range ( arr_size ) ) : if ( arr [ i ] > first ) : second = first first = arr [ i ] elif ( arr [ i ] > second and arr [ i ] != first ) : second = arr [ i ] i += 1 if ( second == - 2147483648 ) : print ( ""Thereisnosecondlargestelement"" ) else : print ( ""Thesecondlargestelementis"" , second )"
"def printGP ( a , r , n ) : i = 0 while i in list ( range ( n ) ) : curr_term = a * pow ( r , i ) print ( curr_term , end = """" ) i += 1"
"def subString ( Str , n ) : for Len in range ( 1 , n + 1 ) : for i in range ( n - Len + 1 ) : j = i + Len - 1 k = i while k in list ( range ( j + 1 ) ) : print ( Str [ k ] , end = """" ) k += 1 print ( )"
def isComposite ( n ) : if ( n <= 1 ) : return False if ( n <= 3 ) : return False if ( n % 2 == 0 or n % 3 == 0 ) : return True i = 5 while ( i * i <= n ) : if ( n % i == 0 or 0 == n % ( i + 2 ) ) : return True i = i + 6 return False
"def LexicographicalMaxString ( str ) : mx = """" i = 0 while i in list ( range ( len ( str ) ) ) : mx = max ( mx , str [ i : ] ) i += 1 return mx"
"def print_first_N_primes ( N ) : i , j , flag = 0 , 0 , 0 print ( ""Primenumbersbetween1and"" , N , ""are:"" ) for i in range ( 1 , N + 1 , 1 ) : if ( i == 1 or i == 0 ) : continue flag = 1 j = 2 while j in list ( range ( ( ( i // 2 ) + 1 ) ) ) : if ( i % j == 0 ) : flag = 0 j += 1 break j += 1 if ( flag == 1 ) : print ( i , end = """" )"
def isPerfectSquareString ( str ) : sum = 0 l = len ( str ) i = 0 while i in list ( range ( l ) ) : sum = sum + ord ( str [ i ] ) i += 1 squareRoot = math.sqrt ( sum ) return ( ( squareRoot - math.floor ( squareRoot ) ) == 0 )
"def NumberOfSolutions ( x , y , z , n ) : ans = 0 for i in range ( x + 1 ) : j = 0 while j in list ( range ( y + 1 ) ) : temp = n - i - j if temp >= 0 : temp = min ( temp , z ) ans += temp + 1 j += 1 return ans"
"def countWords ( str , l ) : count = 1 if ( l == 1 ) : return count if ( str [ 0 ] == str [ 1 ] ) : count *= 1 else : count *= 2 j = 1 while j in list ( range ( l - 1 ) ) : if ( str [ j ] == str [ j - 1 ] and str [ j ] == str [ j + 1 ] ) : count *= 1 elif ( str [ j ] == str [ j - 1 ] or str [ j ] == str [ j + 1 ] or str [ j - 1 ] == str [ j + 1 ] ) : count *= 2 else : count *= 3 j += 1 if ( str [ l - 1 ] == str [ l - 2 ] ) : count *= 1 else : count *= 2 return count"
"def maxLength ( s , n ) : dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] for i in range ( n - 1 ) : if ( s [ i ] == '(' and s [ i + 1 ] == ')' ) : dp [ i ] [ i + 1 ] = 2 for l in range ( 2 , n ) : i = - 1 j = l while j in list ( range ( n ) ) : i += 1 if ( s [ i ] == '(' and s [ j ] == ')' ) : dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] for k in range ( i , j ) : dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) j += 1 return dp [ 0 ] [ n - 1 ]"
def first ( str ) : i = 0 while i in list ( range ( len ( str ) ) ) : if ( str [ i ].istitle ( ) ) : i += 1 return str [ i ] i += 1 return 0
"def Remainder ( str , R ) : l = len ( str ) Rem = 0 i = 0 while i in list ( range ( l ) ) : Num = Rem * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) Rem = Num % R i += 1 return Rem"
def oddSum ( n ) : sum = 0 curr = 1 i = 0 while n > i : sum = sum + curr curr = curr + 2 i = i + 1 return sum
"def pattern ( n ) : k = 0 for i in range ( n - 1 , - 1 , - 1 ) : j = n - 1 while j in list ( range ( k ) ) : print ( '' , end = '' ) j += - 1 print ( chr ( i + 65 ) , end = '' ) for j in range ( 1 , k * 2 ) : print ( '' , end = '' ) if i < n - 1 : print ( chr ( i + 65 ) , end = '' ) print ( ) k += 1"
def countSubsequences ( s ) : aCount = 0 bCount = 0 cCount = 0 i = 0 while i in list ( range ( len ( s ) ) ) : if ( s [ i ] == 'a' ) : aCount = ( 1 + 2 * aCount ) elif ( s [ i ] == 'b' ) : bCount = ( aCount + 2 * bCount ) elif ( s [ i ] == 'c' ) : cCount = ( bCount + 2 * cCount ) i += 1 return cCount
"def sameOccurrence ( arr , n , x , y ) : result = 0 for i in range ( n ) : ctX = 0 ctY = 0 j = i while j in list ( range ( n ) ) : if ( arr [ j ] == x ) : ctX += 1 elif ( arr [ j ] == y ) : ctY += 1 if ( ctX == ctY ) : result += 1 j += 1 return ( result )"
"def max_xor ( arr , n ) : maxx = 0 mask = 0 se = set ( ) for i in range ( 30 , - 1 , - 1 ) : mask |= ( 1 << i ) newMaxx = maxx | ( 1 << i ) i = 0 while i in list ( range ( n ) ) : se.add ( arr [ i ] & mask ) i += 1 for prefix in se : if ( newMaxx ^ prefix ) in se : maxx = newMaxx break se.clear ( ) return maxx"
"def countGroups ( position , previous_sum , length , num ) : if ( position == length ) : return 1 res = 0 sum = 0 i = position while i in list ( range ( length ) ) : sum = sum + int ( num [ i ] ) if ( sum >= previous_sum ) : res = res + countGroups ( i + 1 , sum , length , num ) i += 1 return res"
"def findSet ( arr , k , m ) : arr_size = len ( arr ) remainder_set = [ 0 ] * k i = 0 while i in list ( range ( k ) ) : remainder_set [ i ] = [ ] i += 1 for i in range ( arr_size ) : rem = arr [ i ] % k remainder_set [ rem ].append ( arr [ i ] ) for i in range ( k ) : if ( len ( remainder_set [ i ] ) >= m ) : print ( ""Yes"" ) for j in range ( m ) : print ( remainder_set [ i ] [ j ] , end = """" ) print ( """" , end = """" ) return print ( ""No"" )"
"def Hex ( num ) : m = dict.fromkeys ( range ( 16 ) , 0 ) digit = ord ( '0' ) c = ord ( 'a' ) i = 0 while i in list ( range ( 16 ) ) : if ( i < 10 ) : m [ i ] = chr ( digit ) digit += 1 else : m [ i ] = chr ( c ) c += 1 i += 1 res = """" if ( not num ) : return ""0"" if ( num > 0 ) : while ( num ) : res = m [ num % 16 ] + res num //= 16 else : n = num + 2 ** 32 while ( n ) : res = m [ n % 16 ] + res n //= 16 return res"
"def minItems ( k , r ) : i = 1 while i in list ( range ( 10 ) ) : if ( ( i * k - r ) % 10 == 0 or ( i * k ) % 10 == 0 ) : i += 1 return i i += 1 return 10"
"def countNum ( N , arr ) : count = 0 i = 0 while i in list ( range ( N ) ) : Sum = 0 for j in range ( N ) : if ( i == j ) : i += 1 continue else : Sum += arr [ j ] if ( Sum % arr [ i ] == 0 ) : count += 1 i += 1 return count"
"def removeZeros ( a , n ) : ind = - 1 for i in range ( n ) : if ( a [ i ] != 0 ) : ind = i break if ( ind == - 1 ) : print ( ""Arrayhasleadingzerosonly"" ) return b = [ 0 ] * ( n - ind ) for i in range ( n - ind ) : b [ i ] = a [ ind + i ] i = 0 while i in list ( range ( n - ind ) ) : print ( b [ i ] , end = """" ) i += 1"
"def printPattern ( radius ) : i = 0 while i in list ( range ( ( 2 * radius ) + 1 ) ) : for j in range ( ( 2 * radius ) + 1 ) : dist = math.sqrt ( ( i - radius ) * ( i - radius ) + ( j - radius ) * ( j - radius ) ) if ( dist > radius - 0.5 and dist < radius + 0.5 ) : print ( ""*"" , end = """" ) else : print ( """" , end = """" ) print ( ) i += 1"
"def EqualNumbers ( a , n ) : i = 0 while i in list ( range ( n ) ) : while a [ i ] % 2 == 0 : a [ i ] //= 2 while a [ i ] % 3 == 0 : a [ i ] //= 3 if a [ i ] != a [ 0 ] : i += 1 return False i += 1 return True"
"def stoogesort ( arr , l , h ) : if l >= h : return if arr [ l ] > arr [ h ] : t = arr [ l ] arr [ l ] = arr [ h ] arr [ h ] = t if 2 < h - l + 1 : t = ( int ) ( ( h - l + 1 ) / 3 ) stoogesort ( arr , l , ( h - t ) ) stoogesort ( arr , l + t , ( h ) ) stoogesort ( arr , l , ( h - t ) )"
"def maxSubarrayXOR ( arr , n ) : ans = - 2147483648 i = 0 while i in list ( range ( n ) ) : curr_xor = 0 for j in range ( i , n ) : curr_xor = curr_xor ^ arr [ j ] ans = max ( ans , curr_xor ) i += 1 return ans"
def leonardo ( n ) : if ( n == 0 or 1 == n ) : return 1 return ( leonardo ( n - 1 ) + leonardo ( n - 2 ) + 1 )
"def nthprimedigitsnumber ( number ) : num = """" while ( number > 0 ) : rem = number % 4 if ( rem == 1 ) : num = num + '2' if ( rem == 2 ) : num = num + '3' if ( rem == 3 ) : num = num + '5' if ( rem == 0 ) : num = num + '7' if ( number % 4 == 0 ) : number = number - 1 number = number // 4 return num [ : : - 1 ]"
"def findMin ( arr , n ) : ans = 1 i = 0 while i in list ( range ( n ) ) : j = i + 1 while ( j < n and arr [ j ] >= arr [ j - 1 ] ) : j += 1 ans = max ( ans , j - i ) i = j - 1 i += 1 return n - ans"
"def sum ( a , b ) : sum = 0 i = 1 while i in list ( range ( min ( a , b ) ) ) : if ( a % i == 0 and b % i == 0 ) : sum += i i += 1 return sum"
"def smallestIndexsum ( arr , n ) : i = n - 1 while ( i >= 0 and arr [ i ] % 2 == 1 ) : i -= 1 sum = 0 j = 0 while j in list ( range ( i + 1 ) ) : sum += arr [ j ] j += 1 return sum"
"def canBecomeEmpty ( string , sub_str ) : while len ( string ) > 0 : idx = string.find ( sub_str ) if - 1 == idx : break string = string.replace ( sub_str , """" , 1 ) return ( len ( string ) == 0 )"
def sortArrays ( arr ) : length = len ( arr ) j = 0 while j < length - 1 : if ( arr [ j + 1 ] < arr [ j ] ) : temp = arr [ j ] arr [ j ] = arr [ j + 1 ] arr [ j + 1 ] = temp j = - 1 j += 1 return arr
"def check_elements ( arr , n , A , B ) : rangeV = B - A for i in range ( 0 , n ) : if ( abs ( arr [ i ] ) >= A and abs ( arr [ i ] ) <= B ) : z = abs ( arr [ i ] ) - A if ( arr [ z ] > 0 ) : arr [ z ] = arr [ z ] * - 1 count = 0 i = 0 while i in list ( range ( rangeV + 1 ) ) : if i >= n : i += 1 break if ( arr [ i ] > 0 ) : i += 1 return False else : count = count + 1 i += 1 if ( count != ( rangeV + 1 ) ) : return False return True"
"def sumBaseB ( a , b , base ) : len_a = len ( a ) len_b = len ( b ) s = """" sum = """" diff = abs ( len_a - len_b ) for i in range ( 1 , diff + 1 ) : s += ""0"" if ( len_a < len_b ) : a = s + a else : b = s + b carry = 0 i = max ( len_a , len_b ) - 1 while i in list ( range ( - 1 ) ) : curr = carry + ( ord ( a [ i ] ) - ord ( '0' ) ) + ( ord ( b [ i ] ) - ord ( '0' ) ) carry = curr // base curr = curr % base sum = chr ( curr + ord ( '0' ) ) + sum i += - 1 if ( carry > 0 ) : sum = chr ( carry + ord ( '0' ) ) + sum return sum"
def isDivBy9 ( n ) : if ( n == 0 or n == 9 ) : return True if ( 9 > n ) : return False return isDivBy9 ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 ) )
"def minimumOperations ( arr , n ) : brr = [ 0 , 0 , 0 , 0 ] for i in range ( n ) : brr [ arr [ i ] % 4 ] += 1 if ( ( brr [ 1 ] + 2 * brr [ 2 ] + 3 * brr [ 3 ] ) % 4 == 0 ) : min_opr = min ( brr [ 3 ] , brr [ 1 ] ) brr [ 3 ] -= min_opr brr [ 1 ] -= min_opr min_opr = min_opr + brr [ 2 ] // 2 brr [ 2 ] %= 2 if ( brr [ 2 ] ) : min_opr = min_opr + 2 brr [ 2 ] = 0 if ( brr [ 3 ] ) : brr [ 3 ] -= 2 if ( brr [ 1 ] ) : brr [ 1 ] -= 2 if ( brr [ 1 ] ) : min_opr = min_opr + ( brr [ 1 ] // 4 ) * 3 if ( brr [ 3 ] ) : min_opr = min_opr + ( brr [ 3 ] // 4 ) * 3 return min_opr return - 1"
"def countDivisors ( n , k ) : count = 0 i = 1 while i in list ( range ( int ( math.sqrt ( n ) ) + 1 ) ) : if ( n % i == 0 ) : if ( i % k == 0 ) : count += 1 if ( ( n // i ) % k == 0 ) : count += 1 i += 1 if ( ( i * i == n ) and ( i % k == 0 ) ) : count -= 1 return count"
"def lexicographicSubConcat ( s ) : n = len ( s ) sub_count = ( n * ( n + 1 ) ) // 2 arr = [ 0 ] * sub_count index = 0 i = 0 while i in list ( range ( n ) ) : for j in range ( 1 , n - i + 1 ) : arr [ index ] = s [ i : i + j ] index += 1 i += 1 arr.sort ( ) res = """" for i in range ( sub_count ) : res += arr [ i ] return res"
"def minInsertions ( H , n , K ) : inser = 0 i = 1 while i in list ( range ( n ) ) : diff = abs ( H [ i ] - H [ i - 1 ] ) if ( diff <= K ) : i += 1 continue else : inser += math.ceil ( diff / K ) - 1 i += 1 return inser"
def isOneFlip ( str ) : sum = 0 n = len ( str ) i = 0 while i in list ( range ( n ) ) : sum += int ( str [ i ] ) - int ( '0' ) i += 1 return ( sum == n - 1 or sum == 1 )
"def CalculatePairs ( a , n ) : cnt_zero = 0 cnt_one = 0 for i in range ( 0 , n ) : if ( a [ i ] % 2 == 0 ) : cnt_zero = cnt_zero + 1 else : cnt_one = cnt_one + 1 total_XOR_pairs = cnt_zero * cnt_one total_AND_pairs = ( cnt_one ) * ( cnt_one - 1 ) / 2 total_OR_pairs = cnt_zero * cnt_one + ( cnt_one ) * ( cnt_one - 1 ) / 2 print ( """" , int ( total_XOR_pairs ) ) print ( """" , int ( total_AND_pairs ) ) print ( """" , int ( total_OR_pairs ) )"
"def maxSubStr ( str , n ) : count0 = 0 count1 = 0 cnt = 0 i = 0 while i in list ( range ( n ) ) : if str [ i ] == '0' : count0 += 1 else : count1 += 1 if count0 == count1 : cnt += 1 i += 1 if count0 != count1 : return - 1 return cnt"
def LucasSum ( N ) : Sum = 0 a = 2 b = 1 c = 0 Sum = Sum + a while ( b <= N ) : Sum = Sum + b c = a + b a = b b = c return Sum
"def sortit ( arr , n ) : i = 0 while i in list ( range ( n ) ) : arr [ i ] = i + 1 i += 1"
"def findElements ( arr , n ) : first = - sys.maxsize second = - sys.maxsize i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] > first ) : second = first first = arr [ i ] elif ( arr [ i ] > second ) : second = arr [ i ] i += 1 for i in range ( 0 , n ) : if ( arr [ i ] < second ) : print ( arr [ i ] , end = """" )"
"def spiralPrint ( m , n , a ) : k = 0 l = 0 while ( k < m and l < n ) : for i in range ( l , n ) : print ( a [ k ] [ i ] , end = """" ) k += 1 for i in range ( k , m ) : print ( a [ i ] [ n - 1 ] , end = """" ) n -= 1 if ( k < m ) : for i in range ( n - 1 , ( l - 1 ) , - 1 ) : print ( a [ m - 1 ] [ i ] , end = """" ) m -= 1 if ( l < n ) : i = m - 1 while i in list ( range ( k - 1 ) ) : print ( a [ i ] [ l ] , end = """" ) i += - 1 l += 1"
"def smallestString ( N , A ) : ch = 'a' S = """" if ( N < 1 or A [ 0 ] != 1 ) : S = ""-1"" return S S += str ( ch ) ch = chr ( ord ( ch ) + 1 ) i = 1 while i in list ( range ( N ) ) : diff = A [ i ] - A [ i - 1 ] if ( diff > 1 or diff < 0 or A [ i ] > 26 ) : S = ""-1"" i += 1 return S elif ( diff == 0 ) : S += 'a' else : S += ch ch = chr ( ord ( ch ) + 1 ) i += 1 return S"
"def getSum ( n , d ) : if ( d > n ) : return 0 while ( n % 10 != d ) : n -= 1 k = n // 10 return ( ( k + 1 ) * d + ( k * 10 + 10 * k * k ) // 2 )"
"def SubarraysWithSumS ( n , k , s ) : i = 0 while i in list ( range ( k ) ) : print ( s , end = """" ) i += 1 for i in range ( k , n ) : print ( s + 1 , end = """" )"
"def maxDiff ( arr , n ) : SubsetSum_1 = 0 SubsetSum_2 = 0 i = 0 while i in list ( range ( n ) ) : isSingleOccurance = True for j in range ( i + 1 , n ) : if ( arr [ i ] == arr [ j ] ) : isSingleOccurance = False arr [ i ] = arr [ j ] = 0 i += 1 break if ( isSingleOccurance == True ) : if ( arr [ i ] > 0 ) : SubsetSum_1 += arr [ i ] else : SubsetSum_2 += arr [ i ] i += 1 return abs ( SubsetSum_1 - SubsetSum_2 )"
"def printmaxSubseq ( arr , n ) : i = 0 while i in list ( range ( n - 1 ) ) : if ( arr [ i ] < arr [ i + 1 ] ) : print ( arr [ i ] , end = """" ) else : print ( arr [ i ] ) i += 1 print ( arr [ n - 1 ] )"
"def translate ( st ) : i = 1 while i in list ( range ( len ( st ) ) ) : if ( st [ i - 1 ] == 'A' and st [ i ] == 'B' ) : st [ i - 1 ] = 'C' for j in range ( i , len ( st ) - 1 ) : st [ j ] = st [ j + 1 ] st [ len ( st ) - 1 ] = '' i += 1 return"
def findRotations ( str ) : tmp = str + str n = len ( str ) i = 1 while i in list ( range ( n + 1 ) ) : substring = tmp [ i : n ] if ( str == substring ) : i += 1 return i i += 1 return n
"def countPair ( a , b ) : s = str ( b ) i = 0 while ( len ( s ) ) > i : if ( s [ i ] != '9' ) : break i += 1 result = 0 if ( i == len ( s ) ) : result = a * len ( s ) else : result = a * ( len ( s ) - 1 ) return result"
"def DivisibleBy41 ( first , second , c , n ) : digit = [ 0 ] * n digit [ 0 ] = first digit [ 1 ] = second for i in range ( 2 , n ) : digit [ i ] = ( digit [ i - 1 ] * c + digit [ i - 2 ] ) % 10 ans = digit [ 0 ] i = 1 while i in list ( range ( n ) ) : ans = ( ans * 10 + digit [ i ] ) % 41 i += 1 if ( ans % 41 == 0 ) : return True else : return False"
"def findSum ( N ) : ans = 0 for i in range ( 1 , N + 1 ) : j = 1 while j in list ( range ( N + 1 ) ) : ans += i // j j += 1 return ans"
"def countOccurrences ( arr , n , x ) : res = 0 i = 0 while i in list ( range ( n ) ) : if x == arr [ i ] : res += 1 i += 1 return res"
"def countSub ( arr , n ) : count = [ 0 for i in range ( 10 ) ] for i in range ( n ) : j = arr [ i ] - 1 while j in list ( range ( - 1 ) ) : count [ arr [ i ] ] += count [ j ] j += - 1 count [ arr [ i ] ] += 1 result = 0 for i in range ( 10 ) : result += count [ i ] return result"
"def minAdjDifference ( arr , n ) : if ( n < 2 ) : return res = abs ( arr [ 1 ] - arr [ 0 ] ) i = 2 while i in list ( range ( n ) ) : res = min ( res , abs ( arr [ i ] - arr [ i - 1 ] ) ) i += 1 res = min ( res , abs ( arr [ n - 1 ] - arr [ 0 ] ) ) print ( ""MinDifference="" , res )"
"def reverse ( string , length , l , r ) : if ( 0 > l or r >= length or l > r ) : return string string = list ( string ) while ( l < r ) : c = string [ l ] string [ l ] = string [ r ] string [ r ] = c l += 1 r -= 1 return """".join ( string )"
"def countPairs ( arr , n ) : result = 0 Hash = set ( ) i = 0 while i in list ( range ( n ) ) : Hash.add ( arr [ i ] ) i += 1 for i in range ( n ) : for j in range ( i + 1 , n ) : product = arr [ i ] * arr [ j ] if product in ( Hash ) : result += 1 return result"
"def count_pairs ( n , a ) : frequency = dict.fromkeys ( a , 0 ) i = 0 while i in list ( range ( n ) ) : frequency [ a [ i ] ] += 1 i += 1 count = 0 for f in frequency.values ( ) : count += f * ( f - 1 ) // 2 return ( ( n * ( n - 1 ) ) // 2 ) - count"
"def freqPairs ( arr , n ) : max = arr [ 0 ] for i in range ( len ( arr ) ) : if arr [ i ] > max : max = arr [ i ] freq = [ 0 for i in range ( max + 1 ) ] count = 0 for i in range ( n ) : freq [ arr [ i ] ] += 1 for i in range ( n ) : j = 2 * arr [ i ] while j in list ( range ( max + 1 ) ) : if ( freq [ j ] >= 1 ) : count += freq [ j ] j += arr [ i ] if ( freq [ arr [ i ] ] > 1 ) : count += freq [ arr [ i ] ] - 1 freq [ arr [ i ] ] -= 1 return count"
"def log_a_to_base_b ( a , b ) : rslt = ( 1 + log_a_to_base_b ( a // b , b ) ) if ( ( b - 1 ) < a ) else 0 return rslt"
def findS ( s ) : _sum = 0 n = 1 while ( s > _sum ) : _sum += n * n n += 1 n -= 1 if _sum == s : return n return - 1
"def possibleTripletInRange ( L , R ) : flag = False possibleA = 0 possibleB = 0 possibleC = 0 numbersInRange = ( R - L + 1 ) if ( numbersInRange < 3 ) : flag = False elif ( numbersInRange > 3 ) : flag = True if ( ( L % 2 ) > 0 ) : L += 1 possibleA = L possibleB = L + 1 possibleC = L + 2 else : if ( ( L % 2 ) == 0 ) : flag = True possibleA = L possibleB = L + 1 possibleC = L + 2 else : flag = False if ( flag != True ) : print ( ""NoSuchTripletexistsbetween"" , L , ""and"" , R ) else : print ( ""("" , possibleA , "","" , possibleB , "","" , possibleC , "")isonesuch"" , ""possibletripletbetween"" , L , ""and"" , R )"
def findSum ( n ) : sum = 0 i = 1 while ( ( 1 << i ) < n ) : j = 0 while j in list ( range ( i ) ) : num = ( 1 << i ) + ( 1 << j ) if ( num <= n ) : sum += num j += 1 i += 1 return sum
"def KnapSack ( val , wt , n , W ) : dp = [ 0 ] * ( W + 1 ) for i in range ( n ) : j = W while j in list ( range ( wt [ i ] ) ) : dp [ j ] = max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) j += - 1 return dp [ W ]"
def findNth ( n ) : nthElement = 19 + ( n - 1 ) * 9 outliersCount = int ( math.log10 ( nthElement ) ) - 1 nthElement = nthElement + 9 * outliersCount return nthElement
"def isPossible ( w , h , x , y ) : if ( x * 2 == w and h == y * 2 ) : return True return False"
"def countPairs ( N ) : count = 0 i = 1 while i in list ( range ( int ( math.pow ( N , 1 / 3 ) + 1 ) ) ) : cb = i * i * i diff = N - cb cbrtDiff = int ( math.pow ( diff , 1 / 3 ) ) if ( cbrtDiff * cbrtDiff * cbrtDiff == diff ) : count += 1 i += 1 return count"
"def rearrangeArr ( arr , n ) : evenPos = int ( n / 2 ) oddPos = n - evenPos tempArr = np.empty ( n , dtype = object ) for i in range ( 0 , n ) : tempArr [ i ] = arr [ i ] tempArr.sort ( ) j = oddPos - 1 i = 0 while i in list ( range ( n ) ) : arr [ i ] = tempArr [ j ] j = j - 1 i += 2 j = oddPos for i in range ( 1 , n , 2 ) : arr [ i ] = tempArr [ j ] j = j + 1 for i in range ( 0 , n ) : print ( arr [ i ] , end = '' )"
"def printTwins ( low , high ) : prime = [ True ] * ( high + 1 ) twin = False prime [ 0 ] = prime [ 1 ] = False p = 2 while p in list ( range ( int ( math.floor ( math.sqrt ( high ) ) + 2 ) ) ) : if ( prime [ p ] ) : for i in range ( p * 2 , high + 1 , p ) : prime [ i ] = False p += 1 for i in range ( low , high + 1 ) : if ( prime [ i ] and prime [ i + 2 ] ) : print ( ""Smallesttwinsingivenrange:("" , i , "","" , ( i + 2 ) , "")"" ) twin = True break if ( twin == False ) : print ( ""Nosuchpairexists"" )"
"def minCoins ( coins , m , V ) : if ( V == 0 ) : return 0 res = sys.maxsize i = 0 while i in list ( range ( m ) ) : if ( coins [ i ] <= V ) : sub_res = minCoins ( coins , m , V - coins [ i ] ) if ( sub_res != sys.maxsize and sub_res + 1 < res ) : res = sub_res + 1 i += 1 return res"
"def powerSet ( str1 , index , curr ) : n = len ( str1 ) if ( index == n ) : return print ( curr ) i = index + 1 while i in list ( range ( n ) ) : curr += str1 [ i ] powerSet ( str1 , i , curr ) curr = curr.replace ( curr [ len ( curr ) - 1 ] , """" ) i += 1 return"
"def longestSubseqWithDiffOne ( arr , n ) : dp = [ 1 for i in range ( n ) ] i = 0 while i in list ( range ( n ) ) : for j in range ( i ) : if ( ( arr [ i ] == arr [ j ] + 1 ) or ( arr [ i ] == arr [ j ] - 1 ) ) : dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) i += 1 result = 1 for i in range ( n ) : if ( result < dp [ i ] ) : result = dp [ i ] return result"
"def NumberOfRectangles ( n , m ) : if ( 0 == n % 2 ) : return ( n / 2 ) * m elif ( m % 2 == 0 ) : return ( m // 2 ) * n return ( n * m - 1 ) // 2"
"def minDiff ( arr , n , k ) : result = + 2147483647 arr.sort ( ) i = 0 while i in list ( range ( n - k + 1 ) ) : result = int ( min ( result , arr [ i + k - 1 ] - arr [ i ] ) ) i += 1 return result"
"def policeThief ( arr , n , k ) : i = 0 l = 0 r = 0 res = 0 thi = [ ] pol = [ ] while n > i : if arr [ i ] == 'P' : pol.append ( i ) elif arr [ i ] == 'T' : thi.append ( i ) i += 1 while l < len ( thi ) and r < len ( pol ) : if ( abs ( thi [ l ] - pol [ r ] ) <= k ) : res += 1 l += 1 r += 1 elif thi [ l ] < pol [ r ] : l += 1 else : r += 1 return res"
"def maxProduct ( arr , n ) : if ( n < 2 ) : print ( ""Nopairsexists"" ) return a = arr [ 0 ] b = arr [ 1 ] for i in range ( 0 , n ) : j = i + 1 while j in list ( range ( n ) ) : if ( arr [ i ] * arr [ j ] > a * b ) : a = arr [ i ] b = arr [ j ] j += 1 print ( ""Maxproductpairis{"" , a , "","" , b , ""}"" , sep = """" )"
def checkYear ( year ) : if ( year % 4 ) == 0 : if 0 == ( year % 100 ) : if ( year % 400 ) == 0 : return True else : return False else : return True else : return False
"def perfectCube ( N ) : cube_root = round ( N ** ( 1 / 3 ) ) if cube_root * cube_root * cube_root != N : print ( ""NO"" ) return else : print ( ""Yes"" ) return"
"def polygonArea ( X , Y , n ) : area = 0.0 j = n - 1 i = 0 while i in list ( range ( n ) ) : area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) j = i i += 1 return int ( abs ( area / 2.0 ) )"
"def binarySearch ( arr , l , r , x ) : if l <= r : mid = l + ( r - l ) // 2 if arr [ mid ] == x : return mid elif arr [ mid ] > x : return binarySearch ( arr , l , mid - 1 , x ) else : return binarySearch ( arr , mid + 1 , r , x ) else : return - 1"
"def countTriangles ( a , n ) : cnt = 0 pairs = 0 i = n - 1 while i in list ( range ( - 1 ) ) : pairs += a [ i ] // 2 if ( a [ i ] % 2 == 1 and pairs > 0 ) : cnt += 1 pairs -= 1 i += - 1 cnt += ( 2 * pairs ) // 3 return cnt"
"def minimumChanges ( n , a ) : sf = [ 0 ] * ( n + 1 ) sf [ n ] = 0 for i in range ( n - 1 , - 1 , - 1 ) : sf [ i ] = sf [ i + 1 ] if ( a [ i ] <= 0 ) : sf [ i ] += 1 pos = 0 mn = n i = 0 while i in list ( range ( n - 1 ) ) : if ( a [ i ] >= 0 ) : pos += 1 mn = min ( mn , pos + sf [ i + 1 ] ) i += 1 return mn"
"def isOdd ( arr , n ) : flag = 0 ; flag1 = 0 ; sum = 0 i = 0 while i in list ( range ( n ) ) : sum += arr [ i ] if ( arr [ i ] % 2 == 0 and flag == 0 ) : flag = 1 l = arr [ i ] if ( arr [ i ] % 2 != 0 and flag1 == 0 ) : r = arr [ i ] flag1 = 1 i += 1 if ( sum % 2 != 0 ) : return True else : if ( flag1 == 1 and flag == 1 ) : return True else : return False"
def stringReduction ( str ) : n = len ( str ) count = [ 0 ] * 3 i = 0 while i in list ( range ( n ) ) : count [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1 i += 1 if ( count [ 0 ] == n or count [ 1 ] == n or count [ 2 ] == n ) : return n if ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) and ( count [ 1 ] % 2 ) == ( count [ 2 ] % 2 ) ) : return 2 return 1
"def minMoves ( arr , n ) : expectedItem = n i = n - 1 while i in list ( range ( - 1 ) ) : if ( arr [ i ] == expectedItem ) : expectedItem -= 1 i += - 1 return expectedItem"
"def NthSmallest ( K ) : Q = [ ] for i in range ( 1 , 10 ) : Q.append ( i ) i = 1 while i in list ( range ( K + 1 ) ) : x = Q [ 0 ] Q.remove ( Q [ 0 ] ) if ( x % 10 != 0 ) : Q.append ( x * 10 + x % 10 - 1 ) Q.append ( x * 10 + x % 10 ) if ( x % 10 != 9 ) : Q.append ( x * 10 + x % 10 + 1 ) i += 1 return x"
def sumDigits ( no ) : return 0 if 0 == no else int ( no % 10 ) + sumDigits ( int ( no / 10 ) )
"def maxcoefficientvalue ( n ) : C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] for i in range ( n + 1 ) : for j in range ( min ( i , n ) + 1 ) : if ( j == 0 or j == i ) : C [ i ] [ j ] = 1 else : C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) maxvalue = 0 i = 0 while i in list ( range ( n + 1 ) ) : maxvalue = max ( maxvalue , C [ n ] [ i ] ) i += 1 return maxvalue"
"def findRepeatFirstN2 ( s ) : p = - 1 i = 0 while i in list ( range ( len ( s ) ) ) : for j in range ( i + 1 , len ( s ) ) : if ( s [ i ] == s [ j ] ) : p = i i += 1 break if ( p != - 1 ) : i += 1 break i += 1 return p"
"def checkPoint ( radius , x , y , percent , startAngle ) : endAngle = 360 / percent + startAngle polarradius = math.sqrt ( x * x + y * y ) Angle = math.atan ( y / x ) if ( Angle >= startAngle and Angle <= endAngle and radius > polarradius ) : print ( ""Point("" , x , "","" , y , "")"" ""existinthecirclesector"" ) else : print ( ""Point("" , x , "","" , y , "")"" ""doesnotexistinthecirclesector"" )"
"def pushZerosToEnd ( arr , n ) : count = 0 i = 0 while i in list ( range ( n ) ) : if arr [ i ] != 0 : arr [ count ] = arr [ i ] count += 1 i += 1 while count < n : arr [ count ] = 0 count += 1"
"def findCount ( m , n ) : num1 = 0 i = 0 while i in list ( range ( m ) ) : num1 = ( num1 * 10 ) + 9 i += 1 num2 = 0 for i in range ( 0 , ( m - 1 ) ) : num2 = ( num2 * 10 ) + 9 return int ( ( num1 / n ) - ( num2 / n ) )"
"def orgazineInOrder ( vec , op , n ) : result = [ 0 ] * n vec.sort ( ) i = 0 j = n - 1 k = 0 while ( i <= j and k <= n - 2 ) : if ( op [ k ] != '<' ) : result [ k ] = vec [ j ] j -= 1 else : result [ k ] = vec [ i ] i += 1 k += 1 result [ n - 1 ] = vec [ i ] return result"
def removeAlternate ( n ) : if ( 1 == n ) : return 1 if ( n % 2 == 0 ) : return 2 * removeAlternate ( n / 2 ) - 1 else : return 2 * removeAlternate ( ( ( n - 1 ) / 2 ) ) + 1
"def myCopy ( s1 , s2 ) : i = 0 while i in list ( range ( len ( s1 ) ) ) : s2 [ i ] = s1 [ i ] i += 1"
"def findPairs ( arr1 , arr2 , n , m , x ) : i = 0 while i in list ( range ( n ) ) : for j in range ( 0 , m ) : if ( arr1 [ i ] + arr2 [ j ] == x ) : print ( arr1 [ i ] , arr2 [ j ] ) i += 1"
"def encode ( s , k ) : newS = """" i = 0 while i in list ( range ( len ( s ) ) ) : val = ord ( s [ i ] ) dup = k if val + k > 122 : k -= ( 122 - val ) k = k % 26 newS += chr ( 96 + k ) else : newS += chr ( val + k ) k = dup i += 1 print ( newS )"
"def getMod ( _str , n , k ) : pwrTwo = [ 0 ] * n pwrTwo [ 0 ] = 1 % k i = 1 while i in list ( range ( n ) ) : pwrTwo [ i ] = pwrTwo [ i - 1 ] * ( 2 % k ) pwrTwo [ i ] %= k i += 1 res = 0 i = 0 j = n - 1 while ( i < n ) : if ( _str [ j ] == '1' ) : res += ( pwrTwo [ i ] ) res %= k i += 1 j -= 1 return res"
"def makePolygon ( a ) : n = 360 / ( 180 - a ) if int ( n ) == n : print ( ""YES"" ) else : print ( ""NO"" )"
"def nthElement ( a , b , n ) : seq = [ ] i = 1 while i in list ( range ( n + 1 ) ) : seq.append ( a * i ) i += 1 seq.sort ( ) i = 1 k = n while ( i <= n and k > 0 ) : try : z = seq.index ( b * i ) except ValueError : seq.append ( b * i ) seq.sort ( ) k -= 1 i += 1 return seq [ n - 1 ]"
def count ( n ) : if ( n < 4 ) : return - 1 rem = n % 4 if ( rem == 0 ) : return n // 4 if ( rem == 1 ) : if ( n < 9 ) : return - 1 return ( n - 9 ) // 4 + 1 if ( rem == 2 ) : return ( n - 6 ) // 4 + 1 if ( 3 == rem ) : if ( n < 15 ) : return - 1 return ( n - 15 ) // 4 + 2
"def findProduct ( arr , n , k ) : prod = 1 i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] % k == 0 ) : prod *= arr [ i ] i += 1 return prod"
"def gcd ( m , n ) : if 0 == n : return m else : return gcd ( n , m % n )"
"def Valid ( a , b , c , d ) : if ( 360 == a + b + c + d ) : return True return False"
"def coutSubSeq ( A , N , M ) : sum = 0 ans = 0 for i in range ( 0 , N ) : for j in range ( i + 1 , N ) : k = j + 1 while k in list ( range ( N ) ) : sum = A [ i ] + A [ j ] + A [ k ] if ( sum % M == 0 ) : ans = ans + 1 k += 1 return ans"
"def constructArr ( arr , pair , n ) : arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) // 2 i = 1 while i in list ( range ( n ) ) : arr [ i ] = pair [ i - 1 ] - arr [ 0 ] i += 1"
def countSetBits ( n ) : if ( 0 == n ) : return 0 else : return 1 + countSetBits ( n & ( n - 1 ) )
def inProportion ( arr ) : n = 4 arr.sort ( ) extremes = arr [ 0 ] * arr [ 3 ] means = arr [ 1 ] * arr [ 2 ] if ( means == extremes ) : return True return False
"def offeringNumber ( n , templeHeight ) : sum = 0 i = 0 while i in list ( range ( n ) ) : left = 0 right = 0 for j in range ( i - 1 , - 1 , - 1 ) : if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) : left += 1 else : i += 1 break for j in range ( i + 1 , n ) : if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) : right += 1 else : i += 1 break sum += max ( right , left ) + 1 i += 1 return sum"
"def maxLengthSubSeq ( a , n ) : temp = [ 0 for i in range ( n ) ] print1 = [ 0 for i in range ( n ) ] y = 0 i = 0 while i in list ( range ( n ) ) : j = 0 x = 0 temp [ j ] = a [ x ] j += 1 x = a [ x ] + x while ( x < n ) : temp [ j ] = a [ x ] j += 1 x = a [ x ] + x if ( y < j ) : for k in range ( 0 , j , 1 ) : print1 [ k ] = temp [ k ] y = j i += 1 for i in range ( 0 , y , 1 ) : print ( print1 [ i ] , end = """" )"
"def minSum ( arr , n ) : sm = arr [ 0 ] i = 1 while i in list ( range ( n ) ) : if arr [ i ] == arr [ i - 1 ] : j = i while j < n and arr [ j ] <= arr [ j - 1 ] : arr [ j ] = arr [ j ] + 1 j += 1 sm = sm + arr [ i ] i += 1 return sm"
"def numbersWith3Divisors ( n ) : prime = [ True ] * ( n + 1 ) prime [ 0 ] = prime [ 1 ] = False p = 2 while ( p * p <= n ) : if ( prime [ p ] == True ) : i = p * 2 while i in list ( range ( n + 1 ) ) : prime [ i ] = False i += p p += 1 print ( ""Numberswith3divisors:"" ) i = 0 while ( i * i <= n ) : if ( prime [ i ] ) : print ( i * i , end = """" ) i += 1"
"def findMinimumAdjacentSwaps ( arr , N ) : visited = [ False ] * ( N + 1 ) minimumSwaps = 0 for i in range ( 2 * N ) : if ( visited [ arr [ i ] ] == False ) : visited [ arr [ i ] ] = True count = 0 j = i + 1 while j in list ( range ( 2 * N ) ) : if ( visited [ arr [ j ] ] == False ) : count += 1 elif ( arr [ i ] == arr [ j ] ) : minimumSwaps += count j += 1 return minimumSwaps"
"def waysToKAdjacentSetBits ( n , k , currentIndex , adjacentSetBits , lastBit ) : if ( currentIndex == n ) : if ( adjacentSetBits == k ) : return 1 return 0 noOfWays = 0 if ( lastBit == 1 ) : noOfWays = noOfWays + waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits + 1 , 1 ) noOfWays = noOfWays + waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) elif ( lastBit != 1 ) : noOfWays = noOfWays + waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 1 ) noOfWays = noOfWays + waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) return noOfWays"
"def isPower ( n ) : if ( n == 1 ) : return True x = 2 while x in list ( range ( ( int ) ( math.sqrt ( n ) ) + 1 ) ) : y = 2 p = ( int ) ( math.pow ( x , y ) ) while ( p <= n and p > 0 ) : if ( p == n ) : x += 1 return True y = y + 1 p = math.pow ( x , y ) x += 1 return False"
"def toDecimal ( binary , i = 0 ) : n = len ( binary ) if ( n - 1 == i ) : return int ( binary [ i ] ) - 0 return ( ( ( int ( binary [ i ] ) - 0 ) << ( n - i - 1 ) ) + toDecimal ( binary , i + 1 ) )"
"def isHeterogram ( s , n ) : hash = [ 0 ] * 26 i = 0 while i in list ( range ( n ) ) : if s [ i ] != '' : if hash [ ord ( s [ i ] ) - ord ( 'a' ) ] == 0 : hash [ ord ( s [ i ] ) - ord ( 'a' ) ] = 1 else : i += 1 return False i += 1 return True"
"def isSubSequence ( str1 , str2 , m , n ) : j = 0 i = 0 while j < m and i < n : if str1 [ j ] == str2 [ i ] : j = j + 1 i = i + 1 return m == j"
"def getCount ( a , b , c ) : count = 0 i = 1 while i in list ( range ( 82 ) ) : cr = b * pow ( i , a ) + c tmp = cr sm = 0 while ( tmp ) : sm += tmp % 10 tmp //= 10 if ( sm == i and cr < 10 ** 9 ) : count += 1 i += 1 return count"
def isEven ( n ) : return ( 0 == n % 2 )
"def calcFunction ( n , r ) : finalDenominator = 1 mx = max ( r , n - r ) i = mx + 1 while i in list ( range ( n + 1 ) ) : denominator = pow ( i , i ) numerator = pow ( i - mx , i - mx ) finalDenominator = ( finalDenominator * denominator ) // numerator i += 1 return finalDenominator"
def printCountDP ( dist ) : count = [ 0 ] * ( dist + 1 ) count [ 0 ] = 1 count [ 1 ] = 1 count [ 2 ] = 2 i = 3 while i in list ( range ( dist + 1 ) ) : count [ i ] = ( count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] ) i += 1 return count [ dist ]
def countTrees ( n ) : BT = [ 0 ] * ( n + 1 ) BT [ 0 ] = BT [ 1 ] = 1 i = 2 while i in list ( range ( n + 1 ) ) : for j in range ( i ) : BT [ i ] += BT [ j ] * BT [ i - j - 1 ] i += 1 return BT [ n ]
"def leafNode ( preorder , n ) : s = [ ] i = 0 j = 1 while j in list ( range ( n ) ) : found = False if preorder [ i ] > preorder [ j ] : s.append ( preorder [ i ] ) else : while len ( s ) != 0 : if preorder [ j ] > s [ - 1 ] : s.pop ( - 1 ) found = True else : j += 1 break if found : print ( preorder [ i ] , end = """" ) i += 1 j += 1 print ( preorder [ n - 1 ] )"
"def countFact ( low , high ) : fact = 1 x = 1 while ( fact < low ) : fact = fact * x x += 1 res = 0 while ( high >= fact ) : res += 1 fact = fact * x x += 1 return res"
"def maximumOccurrence ( s ) : n = len ( s ) freq = { } for i in s : temp = """" temp += i freq [ temp ] = freq.get ( temp , 0 ) + 1 for i in range ( n ) : j = i + 1 while j in list ( range ( n ) ) : temp = """" temp += s [ i ] temp += s [ j ] freq [ temp ] = freq.get ( temp , 0 ) + 1 j += 1 answer = - 10 ** 9 for it in freq : answer = max ( answer , freq [ it ] ) return answer"
"def flipsPossible ( a , n ) : count_odd = 0 count_even = 0 i = 0 while i in list ( range ( n ) ) : if ( a [ i ] & 1 ) : count_odd += 1 else : count_even += 1 i += 1 if ( count_odd % 2 and count_even % 2 ) : return False else : return True"
"def printFirstNegativeInteger ( arr , n , k ) : for i in range ( 0 , ( n - k + 1 ) ) : flag = False j = 0 while j in list ( range ( k ) ) : if ( arr [ i + j ] < 0 ) : print ( arr [ i + j ] , end = """" ) flag = True j += 1 break j += 1 if ( not ( flag ) ) : print ( ""0"" , end = """" )"
"def power ( n , r ) : count = 0 ; i = r while ( ( n / i ) >= 1 ) : count = count + n / i i = i * r return int ( count )"
"def minimumCost ( cost , n ) : dp1 = 0 dp2 = 0 i = 0 while i in list ( range ( n ) ) : dp0 = cost [ i ] + min ( dp1 , dp2 ) dp2 = dp1 dp1 = dp0 i += 1 return min ( dp1 , dp2 )"
"def minAbsSumPair ( arr , arr_size ) : inv_count = 0 if arr_size < 2 : print ( ""InvalidInput"" ) return min_l = 0 min_r = 1 min_sum = arr [ 0 ] + arr [ 1 ] l = 0 while l in list ( range ( arr_size - 1 ) ) : for r in range ( l + 1 , arr_size ) : sum = arr [ l ] + arr [ r ] if abs ( min_sum ) > abs ( sum ) : min_sum = sum min_l = l min_r = r l += 1 print ( ""Thetwoelementswhosesumisminimumare"" , arr [ min_l ] , ""and"" , arr [ min_r ] )"
"def nCr ( n , r ) : fac = list ( ) fac.append ( 1 ) i = 1 while i in list ( range ( n + 1 ) ) : fac.append ( fac [ i - 1 ] * i ) i += 1 ans = fac [ n ] / ( fac [ n - r ] * fac [ r ] ) return ans"
"def findCount ( arr , n ) : countOdd = 0 i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] % 2 == 1 ) : countOdd += 1 i += 1 if ( countOdd % 2 == 0 ) : return 1 else : return 0"
"def jumpSearch ( arr , x , n ) : step = math.sqrt ( n ) prev = 0 while arr [ int ( min ( step , n ) - 1 ) ] < x : prev = step step = step + math.sqrt ( n ) if prev >= n : return - 1 while arr [ int ( prev ) ] < x : prev = prev + 1 if prev == min ( step , n ) : return - 1 if arr [ int ( prev ) ] == x : return prev return - 1"
"def difference ( arr , n ) : d1 = 0 d2 = 0 i = 0 while i in list ( range ( n ) ) : d1 = d1 + arr [ i ] [ i ] d2 = d2 + arr [ i ] [ n - i - 1 ] i += 1 return abs ( d1 - d2 )"
"def findMissing ( a , b , n , m ) : i = 0 while i in list ( range ( n ) ) : for j in range ( m ) : if ( a [ i ] == b [ j ] ) : i += 1 break if ( j == m - 1 ) : print ( a [ i ] , end = """" ) i += 1"
"def minOps ( arr , n , k ) : max1 = max ( arr ) res = 0 i = 0 while i in list ( range ( n ) ) : if ( ( max1 - arr [ i ] ) % k != 0 ) : i += 1 return - 1 else : res += ( max1 - arr [ i ] ) / k i += 1 return int ( res )"
"def findSetBits ( n ) : dp = [ 0 ] * ( n + 1 ) print ( dp [ 0 ] , end = """" ) i = 1 while i in list ( range ( n + 1 ) ) : if ( i % 2 == 0 ) : dp [ i ] = dp [ i // 2 ] else : dp [ i ] = dp [ i // 2 ] + 1 print ( dp [ i ] , end = """" ) i += 1"
def isPerfectSquare ( n ) : i = 1 while ( i * i <= n ) : if ( ( 0 == n % i ) and ( n / i == i ) ) : return True i = i + 1 return False
"def sumNth ( A , B , m , n ) : res = 0 if ( n == 1 ) : for i in range ( m ) : res = res + A [ i ] elif ( n == 2 ) : for i in range ( m ) : res = res + B [ i ] * m else : f = [ 0 ] * n f [ 0 ] = 0 f [ 1 ] = 1 i = 2 while i in list ( range ( n ) ) : f [ i ] = f [ i - 1 ] + f [ i - 2 ] i += 1 for i in range ( m ) : res = ( res + ( m * ( B [ i ] * f [ n - 1 ] ) ) + ( m * ( A [ i ] * f [ n - 2 ] ) ) ) return res"
"def maxHamming ( arr , n ) : brr = [ 0 ] * ( 2 * n + 1 ) for i in range ( n ) : brr [ i ] = arr [ i ] for i in range ( n ) : brr [ n + i ] = arr [ i ] maxHam = 0 i = 1 while i in list ( range ( n ) ) : currHam = 0 k = 0 for j in range ( i , i + n ) : if brr [ j ] != arr [ k ] : currHam += 1 k = k + 1 if currHam == n : i += 1 return n maxHam = max ( maxHam , currHam ) i += 1 return maxHam"
"def findPermutation ( n ) : res = [ ] en , on = 2 , 1 if ( n % 2 == 0 ) : for i in range ( n ) : if ( i % 2 == 0 ) : res.append ( en ) en = en + 2 else : res.append ( on ) on = on + 2 else : for i in range ( n - 2 ) : if ( i % 2 == 0 ) : res.append ( en ) en = en + 2 else : res.append ( on ) on = on + 2 res.append ( n ) res.append ( n - 2 ) for i in range ( n ) : print ( res [ i ] , end = """" ) print ( )"
"def minRemovalsDP ( arr , n ) : longest_start = - 1 longest_end = 0 start = 0 while start in list ( range ( n ) ) : min = sys.maxsize max = - sys.maxsize for end in range ( start , n ) : val = arr [ end ] if ( val < min ) : min = val if ( val > max ) : max = val if ( 2 * min <= max ) : start += 1 break if ( end - start > longest_end - longest_start or longest_start == - 1 ) : longest_start = start longest_end = end start += 1 if ( longest_start == - 1 ) : return n return ( n - ( longest_end - longest_start + 1 ) )"
"def printRoots ( n ) : theta = math.pi * 2 / n k = 0 while k in list ( range ( n ) ) : real = math.cos ( k * theta ) img = math.sin ( k * theta ) print ( real , end = """" ) if ( img >= 0 ) : print ( ""+i"" , end = """" ) else : print ( ""-i"" , end = """" ) print ( abs ( img ) ) k += 1"
"def FindMinNumber ( arr , n , k ) : i = 0 j = 0 min_num = 10 ** 9 found = False Sum = 0 while ( i < n ) : Sum = Sum + arr [ i ] if ( Sum == k ) : min_num = min ( min_num , ( ( n - ( i + 1 ) ) + j ) ) found = True elif ( k < Sum ) : while ( Sum > k ) : Sum = Sum - arr [ j ] j += 1 if ( Sum == k ) : min_num = min ( min_num , ( ( n - ( i + 1 ) ) + j ) ) found = True i += 1 if ( found ) : return min_num return - 1"
def countWays ( n ) : A = [ 0 ] * ( n + 1 ) B = [ 0 ] * ( n + 1 ) A [ 0 ] = 1 A [ 1 ] = 0 B [ 0 ] = 0 B [ 1 ] = 1 i = 2 while i in list ( range ( n + 1 ) ) : A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ] B [ i ] = A [ i - 1 ] + B [ i - 2 ] i += 1 return A [ n ]
"def dayofweek ( d , m , y ) : t = [ 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 ] y -= 3 > m return ( ( y + int ( y / 4 ) - int ( y / 100 ) + int ( y / 400 ) + t [ m - 1 ] + d ) % 7 )"
"def search ( arr , low , high ) : if high < low : return None if low == high : return arr [ low ] mid = low + ( high - low ) / 2 if mid % 2 == 0 : if arr [ mid ] == arr [ mid + 1 ] : return search ( arr , mid + 2 , high ) else : return search ( arr , low , mid ) else : if arr [ mid ] == arr [ mid - 1 ] : return search ( arr , mid + 1 , high ) else : return search ( arr , low , mid - 1 )"
"def productSumDivisible ( n , size ) : sum = 0 product = 1 while ( n > 0 ) : if ( size % 2 != 0 ) : sum += n % 10 else : product *= n % 10 n = n // 10 size -= 1 if ( product % sum == 0 ) : return True return False"
"def replace_elements ( arr , n ) : pos = 0 for i in range ( 0 , n ) : arr [ pos ] = arr [ i ] pos = pos + 1 while ( pos > 1 and arr [ pos - 2 ] == arr [ pos - 1 ] ) : pos -= 1 arr [ pos - 1 ] += 1 i = 0 while i in list ( range ( pos ) ) : print ( arr [ i ] , end = """" ) i += 1"
"def CheckArray ( arr , n ) : prod = 1 freq = [ ] i = 0 while i in list ( range ( n ) ) : freq.append ( arr [ i ] ) prod *= arr [ i ] i += 1 root = math.sqrt ( prod ) if ( root * root == prod ) : if root in freq : return True return False"
"def minElements ( arr , n ) : halfSum = 0 i = 0 while i in list ( range ( n ) ) : halfSum = halfSum + arr [ i ] i += 1 halfSum = int ( halfSum / 2 ) arr.sort ( reverse = True ) res = 0 curr_sum = 0 for i in range ( n ) : curr_sum += arr [ i ] res += 1 if curr_sum > halfSum : return res return res"
"def specialNumber ( n ) : if ( n < 10 or 99 < n ) : print ( ""InvalidInput!Number"" , ""shouldhave2digitsonly"" ) else : first = n // 10 last = n % 10 sum = first + last pro = first * last if ( ( sum + pro ) == n ) : print ( n , ""isaSpecial"" , ""Two-DigitNumber"" ) else : print ( n , ""isNota"" , ""SpecialTwo-DigitNumber"" )"
"def countDigit ( n ) : temp = n sum = 0 product = 1 while ( temp != 0 ) : d = temp % 10 temp //= 10 if ( 0 < d and n % d == 0 ) : sum += d product *= d print ( ""Sum="" , sum ) print ( ""Product="" , product )"
"def findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) : for i in range ( 0 , n1 ) : j = 0 while j in list ( range ( n2 ) ) : for k in range ( 0 , n3 ) : if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) : j += 1 return True j += 1 return False"
"def binomialCoeffSum ( n ) : C = [ [ 0 ] * ( n + 2 ) for i in range ( 0 , n + 2 ) ] for i in range ( 0 , n + 1 ) : j = 0 while j in list ( range ( min ( i , n ) + 1 ) ) : if ( j == 0 or j == i ) : C [ i ] [ j ] = 1 else : C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] j += 1 sum = 0 for i in range ( 0 , n + 1 ) : sum += C [ n ] [ i ] return sum"
"def colourVisible ( height , colour , K ) : arr = [ 0 for i in range ( K + 1 ) ] visible = 0 max = height [ K - 1 ] arr [ colour [ K - 1 ] ] = 1 i = K - 2 while ( i >= 0 ) : if ( height [ i ] > max ) : max = height [ i ] arr [ colour [ i ] ] = 1 i -= 1 i = 1 while i in list ( range ( K + 1 ) ) : if ( arr [ i ] == 1 ) : visible += 1 i += 1 return visible"
"def removeSpecialCharacter ( s ) : i = 0 while len ( s ) > i : if ( ord ( s [ i ] ) < ord ( 'A' ) or ord ( s [ i ] ) > ord ( 'Z' ) and ord ( s [ i ] ) < ord ( 'a' ) or ord ( s [ i ] ) > ord ( 'z' ) ) : del s [ i ] i -= 1 i += 1 print ( """".join ( s ) )"
"def ladder_pattern ( N ) : i = 0 while i in list ( range ( N + 1 ) ) : print ( ""**"" ) print ( ""**"" ) if ( i < N ) : print ( ""*****"" ) i += 1"
"def countEndless ( input_mat , n ) : row = np.zeros ( ( n , n ) ) col = np.zeros ( ( n , n ) ) j = 0 while j in list ( range ( n ) ) : isEndless = 1 for i in range ( n - 1 , - 1 , - 1 ) : if ( input_mat [ i ] [ j ] == 0 ) : isEndless = 0 col [ i ] [ j ] = isEndless j += 1 for i in range ( n ) : isEndless = 1 for j in range ( n - 1 , - 1 , - 1 ) : if ( input_mat [ i ] [ j ] == 0 ) : isEndless = 0 row [ i ] [ j ] = isEndless ans = 0 for i in range ( n ) : for j in range ( 1 , n ) : if ( row [ i ] [ j ] and col [ i ] [ j ] ) : ans += 1 return ans"
def floorSqrt ( x ) : if ( x == 0 or x == 1 ) : return x start = 1 end = x while ( start <= end ) : mid = ( start + end ) // 2 if ( mid * mid == x ) : return mid if ( x > mid * mid ) : start = mid + 1 ans = mid else : end = mid - 1 return ans
"def LCSubStr ( X , Y ) : m = len ( X ) n = len ( Y ) result = 0 len_mat = np.zeros ( ( 2 , n ) ) currRow = 0 i = 0 while i in list ( range ( m ) ) : for j in range ( n ) : if ( i == 0 | j == 0 ) : len_mat [ currRow ] [ j ] = 0 elif ( X [ i - 1 ] == Y [ j - 1 ] ) : len_mat [ currRow ] [ j ] = len_mat [ 1 - currRow ] [ j - 1 ] + 1 result = max ( result , len_mat [ currRow ] [ j ] ) else : len_mat [ currRow ] [ j ] = 0 currRow = 1 - currRow i += 1 return result"
def maxZeros ( n ) : if ( n == 0 or ( n & ( n - 1 ) ) == 0 ) : return - 1 setBit = 1 prev = 0 i = 1 while ( i < 33 ) : prev += 1 if ( ( n & setBit ) == setBit ) : setBit = setBit << 1 break setBit = setBit << 1 max0 = - 10 ** 9 cur = prev j = i + 1 while j in list ( range ( 33 ) ) : cur += 1 if ( ( n & setBit ) == setBit ) : if ( max0 < ( cur - prev - 1 ) ) : max0 = cur - prev - 1 prev = cur setBit = setBit << 1 j += 1 return max0
"def factors ( n , i ) : if ( i <= n ) : if ( 0 == n % i ) : print ( i , end = """" ) factors ( n , i + 1 )"
def countRect ( n ) : ans = 0 length = 1 while length in list ( range ( int ( math.sqrt ( n ) ) + 1 ) ) : height = length while ( height * length <= n ) : ans += 1 height += 1 length += 1 return ans
def findCount ( str ) : result = 0 i = 0 while i in list ( range ( len ( str ) ) ) : if ( ( i == ord ( str [ i ] ) - ord ( 'a' ) ) or ( i == ord ( str [ i ] ) - ord ( 'A' ) ) ) : result += 1 i += 1 return result
"def FindRank ( arr , length ) : print ( 1 , end = """" ) for i in range ( 1 , length ) : rank = 1 j = 0 while j in list ( range ( i ) ) : if ( arr [ j ] > arr [ i ] ) : rank = rank + 1 j += 1 print ( rank , end = """" )"
"def OctToBin ( octnum ) : binary = """" while octnum != 0 : d = int ( octnum % 10 ) if d == 0 : binary = """".join ( [ ""000"" , binary ] ) elif 1 == d : binary = """".join ( [ ""001"" , binary ] ) elif d == 2 : binary = """".join ( [ ""010"" , binary ] ) elif d == 3 : binary = """".join ( [ ""011"" , binary ] ) elif d == 4 : binary = """".join ( [ ""100"" , binary ] ) elif d == 5 : binary = """".join ( [ ""101"" , binary ] ) elif d == 6 : binary = """".join ( [ ""110"" , binary ] ) elif d == 7 : binary = """".join ( [ ""111"" , binary ] ) else : binary = ""InvalidOctalDigit"" break octnum = int ( octnum / 10 ) return binary"
"def countWaysToJump ( arr , n ) : count_jump = [ 0 for i in range ( n ) ] i = n - 2 while i in list ( range ( - 1 ) ) : if ( arr [ i ] >= n - i - 1 ) : count_jump [ i ] += 1 j = i + 1 while ( j < n - 1 and j <= arr [ i ] + i ) : if ( count_jump [ j ] != - 1 ) : count_jump [ i ] += count_jump [ j ] j += 1 if ( count_jump [ i ] == 0 ) : count_jump [ i ] = - 1 i += - 1 for i in range ( n ) : print ( count_jump [ i ] , end = """" )"
"def maxSumIS ( arr , n ) : max = 0 msis = [ 0 for x in range ( n ) ] for i in range ( n ) : msis [ i ] = arr [ i ] for i in range ( 1 , n ) : j = 0 while j in list ( range ( i ) ) : if ( arr [ i ] > arr [ j ] and msis [ i ] < msis [ j ] + arr [ i ] ) : msis [ i ] = msis [ j ] + arr [ i ] j += 1 for i in range ( n ) : if max < msis [ i ] : max = msis [ i ] return max"
"def findWord ( c , n ) : co = 0 s = [ 0 ] * n i = 0 while i in list ( range ( n ) ) : if ( i < n / 2 ) : co += 1 else : co = n - i if ( ord ( c [ i ] ) + co <= 122 ) : s [ i ] = chr ( ord ( c [ i ] ) + co ) else : s [ i ] = chr ( ord ( c [ i ] ) + co - 26 ) i += 1 print ( * s , sep = """" )"
"def countSubstrs ( str , i , j , n ) : if ( 1 == n ) : return 1 if ( n <= 0 ) : return 0 res = ( countSubstrs ( str , i + 1 , j , n - 1 ) + countSubstrs ( str , i , j - 1 , n - 1 ) - countSubstrs ( str , i + 1 , j - 1 , n - 2 ) ) if ( str [ i ] == str [ j ] ) : res += 1 return res"
"def countPairs ( arr1 , arr2 , m , n , x ) : count , l , r = 0 , 0 , n - 1 while ( m > l and r >= 0 ) : if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) : l += 1 r -= 1 count += 1 elif ( ( arr1 [ l ] + arr2 [ r ] ) < x ) : l += 1 else : r -= 1 return count"
def isPalindrome ( n ) : if 0 == n % 11 : return True return False
"def subsetPairNotDivisibleByK ( arr , N , K ) : f = [ 0 for i in range ( K ) ] i = 0 while i in list ( range ( N ) ) : f [ arr [ i ] % K ] += 1 i += 1 if ( K % 2 == 0 ) : f [ K // 2 ] = min ( f [ K // 2 ] , 1 ) res = min ( f [ 0 ] , 1 ) for i in range ( 1 , ( K // 2 ) + 1 ) : res += max ( f [ i ] , f [ K - i ] ) return res"
"def subset ( ar , n ) : res = 0 ar.sort ( ) for i in range ( 0 , n ) : count = 1 i = 0 while i in list ( range ( n - 1 ) ) : if ar [ i ] == ar [ i + 1 ] : count += 1 else : i += 1 break i += 1 res = max ( res , count ) return res"
"def checksum ( n ) : n = int ( n ) if 0 == n % 5 : print ( int ( n / 5 - 2 ) , """" , int ( n / 5 - 1 ) , """" , int ( n / 5 ) , """" , int ( n / 5 + 1 ) , """" , int ( n / 5 + 2 ) ) else : print ( ""-1"" )"
"def findSum ( str1 ) : temp = """" Sum = 0 for ch in str1 : if ( ch.isdigit ( ) ) : temp = temp + ch else : Sum = Sum + int ( temp ) temp = """" return Sum + int ( temp )"
"def twoParts ( string ) : flag = 0 a = """" i = 0 while i in list ( range ( len ( string ) ) ) : if ( string [ i ] == '4' ) : string [ i ] = '3' a += '1' flag = 1 elif ( flag ) : a += '0' i += 1 string = """".join ( string ) print ( string , a )"
"def isPerfectSquare ( arr , n ) : umap = dict.fromkeys ( arr , n ) for key in arr : umap [ key ] += 1 for key in arr : if ( 1 == umap [ key ] % 2 ) : return False return True"
def nobleInteger ( arr ) : arr.sort ( ) n = len ( arr ) i = 0 while i in list ( range ( n - 1 ) ) : if arr [ i ] == arr [ i + 1 ] : i += 1 continue if arr [ i ] == n - i - 1 : i += 1 return arr [ i ] i += 1 if arr [ n - 1 ] == 0 : return arr [ n - 1 ] return - 1
"def find ( a ) : count_odd = 0 for i in a : if ( i % 2 != 0 ) : count_odd = count_odd + 1 result = pow ( 2 , len ( a ) ) - 1 result = result - ( pow ( 2 , count_odd ) - 1 ) print ( result )"
"def countNumbers ( n ) : c = 0 limit = int ( n ** ( 0.5 ) ) prime = [ i for i in range ( limit + 1 ) ] i = 2 while i * i <= limit : if prime [ i ] == i : for j in range ( i * i , limit + 1 , i ) : if prime [ j ] == j : prime [ j ] = i i += 1 i = 2 while i in list ( range ( limit + 1 ) ) : p = prime [ i ] q = prime [ i // prime [ i ] ] if p * q == i and q != 1 and p != q : c += 1 elif prime [ i ] == i : if i ** 8 <= n : c += 1 i += 1 return c"
"def printRotatedString ( string ) : n = len ( string ) temp = string + string i = 0 while i in list ( range ( n ) ) : for j in range ( n ) : print ( temp [ i + j ] , end = """" ) print ( ) i += 1"
"def minCost ( arr , cost , n ) : costThree = 10 ** 9 for j in range ( n ) : costI = 10 ** 9 costK = 10 ** 9 i = 0 while i in list ( range ( j ) ) : if ( arr [ i ] < arr [ j ] ) : costI = min ( costI , cost [ i ] ) i += 1 for k in range ( j + 1 , n ) : if ( arr [ k ] > arr [ j ] ) : costK = min ( costK , cost [ k ] ) if ( costI != 10 ** 9 and costK != 10 ** 9 ) : costThree = min ( costThree , cost [ j ] + costI + costK ) if ( costThree == 10 ** 9 ) : return - 1 return costThree"
def squareRoot ( n ) : x = n y = 1 while ( y < x ) : x = ( x + y ) / 2 y = n / x return x
"def count ( n ) : table = [ 0 for i in range ( n + 1 ) ] table [ 0 ] = 1 for i in range ( 3 , n + 1 ) : table [ i ] += table [ i - 3 ] i = 5 while i in list ( range ( n + 1 ) ) : table [ i ] += table [ i - 5 ] i += 1 for i in range ( 10 , n + 1 ) : table [ i ] += table [ i - 10 ] return table [ n ]"
"def minSwaps ( arr , n ) : numberOfOnes = 0 for i in range ( 0 , n ) : if ( arr [ i ] == 1 ) : numberOfOnes = numberOfOnes + 1 x = numberOfOnes count_ones = 0 maxOnes = 0 i = 0 while i in list ( range ( x ) ) : if ( arr [ i ] == 1 ) : count_ones = count_ones + 1 i += 1 maxOnes = count_ones for i in range ( 1 , ( n - x + 1 ) ) : if ( arr [ i - 1 ] == 1 ) : count_ones = count_ones - 1 if ( arr [ i + x - 1 ] == 1 ) : count_ones = count_ones + 1 if ( maxOnes < count_ones ) : maxOnes = count_ones numberOfZeroes = x - maxOnes return numberOfZeroes"
"def modFact ( n , p ) : if n >= p : return 0 result = 1 i = 1 while i in list ( range ( n + 1 ) ) : result = ( result * i ) % p i += 1 return result"
"def findTangent ( A , x , y ) : dif = A - x * 2 if y == ( 2 * x - x * x ) : if 0 > dif : print ( ""y="" , dif , ""x"" , ( x * dif ) + ( y ) ) elif dif > 0 : print ( ""y="" , dif , ""x+"" , - x * dif + y ) else : print ( ""NotPossible"" )"
"def printIntersection ( arr1 , arr2 , m , n ) : i , j = 0 , 0 while i < m and j < n : if arr2 [ j ] > arr1 [ i ] : i += 1 elif arr2 [ j ] < arr1 [ i ] : j += 1 else : print ( arr2 [ j ] ) j += 1 i += 1"
"def maxAND ( arr , n ) : res = 0 for i in range ( 0 , n ) : j = i + 1 while j in list ( range ( n ) ) : res = max ( res , arr [ i ] & arr [ j ] ) j += 1 return res"
"def findElement ( arr , size ) : right_mul = 1 left_mul = 1 i = 1 while i in list ( range ( size ) ) : right_mul = right_mul * arr [ i ] i += 1 for i , j in zip ( range ( 0 , size ) , range ( 1 , size , 1 ) ) : right_mul = right_mul / arr [ j ] left_mul = left_mul * arr [ i ] if ( left_mul == right_mul ) : return arr [ i + 1 ] return - 1"
"def max_element ( a , n ) : pre = [ 0 ] * n pre [ 0 ] = a [ 0 ] for i in range ( 1 , n ) : pre [ i ] = max ( pre [ i - 1 ] , a [ i ] ) suf = [ 0 ] * n suf [ n - 1 ] = a [ n - 1 ] i = n - 2 while i in list ( range ( - 1 ) ) : suf [ i ] = max ( suf [ i + 1 ] , a [ i ] ) i += - 1 for i in range ( n ) : if ( i == 0 ) : print ( suf [ i + 1 ] , end = """" ) elif ( i == n - 1 ) : print ( pre [ i - 1 ] , end = """" ) else : print ( max ( pre [ i - 1 ] , suf [ i + 1 ] ) , end = """" )"
"def maxProd ( n ) : if ( n == 0 or n == 1 ) : return 0 max_val = 0 i = 1 while i in list ( range ( n - 1 ) ) : max_val = max ( max_val , max ( i * ( n - i ) , maxProd ( n - i ) * i ) ) i += 1 return max_val"
"def oppositeSigns ( x , y ) : return ( 0 > ( x ^ y ) )"
"def even_or_odd ( N ) : l = len ( N ) if ( N [ l - 1 ] == '0' or N [ l - 1 ] == '2' or '4' == N [ l - 1 ] or N [ l - 1 ] == '6' ) : return ( ""Even"" ) else : return ( ""Odd"" )"
def sumOfSeries ( n ) : res = 0.0 sum = 0 prod = 1 i = 1 while i in list ( range ( n + 1 ) ) : sum = sum + i prod = prod * i res = res + ( sum / prod ) i += 1 return res
"def count9s ( number ) : count = 0 n = len ( number ) i = 0 while i in list ( range ( n ) ) : sum = ord ( number [ i ] ) - ord ( '0' ) if ( number [ i ] == '9' ) : count += 1 for j in range ( i + 1 , n ) : sum = ( sum + ord ( number [ j ] ) - ord ( '0' ) ) % 9 if ( sum == 0 ) : count += 1 i += 1 return count"
"def findNumbers ( arr , n ) : sumN = ( n * ( n + 1 ) ) / 2 sumSqN = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 sum = 0 sumSq = 0 i = 0 while i in list ( range ( n ) ) : sum = sum + arr [ i ] sumSq = sumSq + ( math.pow ( arr [ i ] , 2 ) ) i += 1 B = ( ( ( sumSq - sumSqN ) / ( sum - sumN ) ) + sumN - sum ) / 2 A = sum - sumN + B print ( ""A="" , int ( A ) ) print ( ""B="" , int ( B ) )"
def isPalindrome ( s ) : return s [ : : - 1 ] == s
"def longSubarrWthSumDivByK ( arr , n , k ) : um = { i : 0 for i in range ( 8 ) } mod_arr = [ 0 for i in range ( n ) ] max = 0 curr_sum = 0 i = 0 while i in list ( range ( n ) ) : curr_sum += arr [ i ] mod_arr [ i ] = ( ( curr_sum % k ) + k ) % k i += 1 for i in range ( n ) : if ( mod_arr [ i ] == 0 ) : max = i + 1 elif ( mod_arr [ i ] in um ) : um [ mod_arr [ i ] ] = i else : if ( max < ( i - um [ mod_arr [ i ] ] ) ) : max = i - um [ mod_arr [ i ] ] return max"
"def findMinimumAngle ( arr , n ) : l = 0 _sum = 0 ans = 360 i = 0 while i in list ( range ( n ) ) : _sum += arr [ i ] while _sum >= 180 : ans = min ( ans , 2 * abs ( 180 - _sum ) ) _sum -= arr [ l ] l += 1 ans = min ( ans , 2 * abs ( 180 - _sum ) ) i += 1 return ans"
"def calculate ( x , k , m ) : result = x k = k - 1 while ( k ) : result = math.pow ( result , x ) if ( m < result ) : result = result % m k = k - 1 return int ( result )"
def isPerfectSquare ( x ) : sr = math.sqrt ( x ) return ( 0 == ( sr - math.floor ( sr ) ) )
"def find_digit ( s , n ) : first_digit = - 1 i = n - 1 while i in list ( range ( - 1 ) ) : if s [ i ] < '0' or s [ i ] > '9' : first_digit = i i += - 1 break i += - 1 first_digit += 1 s_len = first_digit num = 0 pw = 1 i = n - 1 while i >= 0 : if s [ i ] >= '0' and s [ i ] <= '9' : digit = ord ( s [ i ] ) - ord ( '0' ) num = num + ( pw * digit ) if num >= s_len : return - 1 pw = pw * 10 i -= 1 num = num * 10 req = s_len - num if req > 9 or req < 0 : return - 1 return req"
"def numOfWhiteHats ( arr , n ) : freq = [ 0 for i in range ( n + 1 + 1 ) ] for i in range ( n ) : if ( arr [ i ] >= n ) : return - 1 freq [ arr [ i ] ] += 1 diffFreq = 0 i = n - 1 while i in list ( range ( - 1 ) ) : if ( freq [ i ] ) : diffFreq += 1 i += - 1 if ( diffFreq == 1 and freq [ n - 1 ] == n ) : return n if ( diffFreq == 1 and freq [ 0 ] == n ) : return 0 if ( diffFreq != 2 ) : return - 1 for k in range ( n - 1 , 0 , - 1 ) : if ( freq [ k ] ) : break if ( freq [ k - 1 ] == k and freq [ k ] + k == n ) : return freq [ k - 1 ] else : return - 1"
def exactPrimeFactorCount ( n ) : count = 0 if ( n % 2 == 0 ) : count = count + 1 while ( n % 2 == 0 ) : n = int ( n / 2 ) i = 3 while ( i <= int ( math.sqrt ( n ) ) ) : if ( n % i == 0 ) : count = count + 1 while ( 0 == n % i ) : n = int ( n / i ) i = i + 2 if ( n > 2 ) : count = count + 1 return count
"def vowelOrConsonant ( x ) : if ( x == 'a' or x == 'e' or x == 'i' or x == 'o' or x == 'u' or x == 'A' or x == 'E' or 'I' == x or x == 'O' or x == 'U' ) : print ( ""Vowel"" ) else : print ( ""Consonant"" )"
"def ceilSearch ( arr , low , high , x ) : if x <= arr [ low ] : return low if x > arr [ high ] : return - 1 mid = ( low + high ) / 2 if arr [ mid ] == x : return mid elif arr [ mid ] < x : if mid + 1 <= high and x <= arr [ mid + 1 ] : return mid + 1 else : return ceilSearch ( arr , mid + 1 , high , x ) else : if low <= mid - 1 and x > arr [ mid - 1 ] : return mid else : return ceilSearch ( arr , low , mid - 1 , x )"
"def pow ( a , b ) : if ( b == 0 ) : return 1 answer = a increment = a for i in range ( 1 , b ) : j = 1 while j in list ( range ( a ) ) : answer += increment j += 1 increment = answer return answer"
"def sumBetweenTwoKth ( arr , n , k1 , k2 ) : arr.sort ( ) result = 0 i = k1 while i in list ( range ( k2 - 1 ) ) : result += arr [ i ] i += 1 return result"
def longestPrefixSuffix ( s ) : n = len ( s ) res = n // 2 while res in list ( range ( 0 ) ) : prefix = s [ 0 : res ] suffix = s [ n - res : n ] if ( prefix == suffix ) : res += - 1 return res res += - 1 return 0
"def canMake ( n , ar ) : sum = 0 ; maxx = - 1 i = 0 while i in list ( range ( n ) ) : sum += ar [ i ] maxx = max ( maxx , ar [ i ] ) i += 1 if ( n == 1 or sum % 2 == 1 or sum - maxx < maxx ) : print ( ""No"" ) else : print ( ""Yes"" )"
"def printUncommon ( str1 , str2 ) : a1 = 0 ; a2 = 0 for i in range ( len ( str1 ) ) : ch = ord ( str1 [ i ] ) - ord ( 'a' ) a1 = a1 | ( 1 << ch ) i = 0 while i in list ( range ( len ( str2 ) ) ) : ch = ord ( str2 [ i ] ) - ord ( 'a' ) a2 = a2 | ( 1 << ch ) i += 1 ans = a1 ^ a2 i = 0 while ( i < 26 ) : if ( ans % 2 == 1 ) : print ( chr ( ord ( 'a' ) + i ) , end = """" ) ans = ans // 2 i += 1"
"def bubbleSort ( arr ) : n = len ( arr ) for i in range ( n ) : swapped = False j = 0 while j in list ( range ( n - i - 1 ) ) : if arr [ j ] > arr [ j + 1 ] : arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ] swapped = True j += 1 if swapped == False : break"
"def findElement ( arr , n ) : prefixSum = [ 0 ] * n prefixSum [ 0 ] = arr [ 0 ] i = 1 while i in list ( range ( n ) ) : prefixSum [ i ] = prefixSum [ i - 1 ] + arr [ i ] i += 1 suffixSum = [ 0 ] * n suffixSum [ n - 1 ] = arr [ n - 1 ] for i in range ( n - 2 , - 1 , - 1 ) : suffixSum [ i ] = suffixSum [ i + 1 ] + arr [ i ] for i in range ( 1 , n - 1 , 1 ) : if prefixSum [ i ] == suffixSum [ i ] : return arr [ i ] return - 1"
def product ( N ) : ans = 1 val = 2 ** ( N - 1 ) i = 1 while i in list ( range ( N + 1 ) ) : ans *= ( i ** val ) i += 1 return ans
"def kPrimeFactor ( n , k ) : while ( n % 2 == 0 ) : k = k - 1 n = n / 2 if ( k == 0 ) : return 2 i = 3 while i <= math.sqrt ( n ) : while ( 0 == n % i ) : if ( k == 1 ) : return i k = k - 1 n = n / i i = i + 2 if ( n > 2 and k == 1 ) : return n return - 1"
"def unique ( mat , n , m ) : maximum = 0 flag = 0 for i in range ( 0 , n ) : j = 0 while j in list ( range ( m ) ) : if ( maximum < mat [ i ] [ j ] ) : maximum = mat [ i ] [ j ] j += 1 uniqueElementDict = [ 0 ] * ( maximum + 1 ) for i in range ( 0 , n ) : for j in range ( 0 , m ) : uniqueElementDict [ mat [ i ] [ j ] ] += 1 for key in range ( maximum + 1 ) : if uniqueElementDict [ key ] == 1 : print ( key , end = """" ) flag = 1 if ( flag == 0 ) : print ( ""Nouniqueelementinthematrix"" )"
"def checkIfPowerIsolated ( num ) : input1 = num count = 0 factor = [ 0 ] * ( num + 1 ) if ( num % 2 == 0 ) : while ( num % 2 == 0 ) : count += 1 num //= 2 factor [ 2 ] = count i = 3 while ( i * i <= num ) : count = 0 while ( num % i == 0 ) : count += 1 num //= i if ( count > 0 ) : factor [ i ] = count i += 2 if ( num > 1 ) : factor [ num ] = 1 product = 1 i = 0 while i in list ( range ( len ( factor ) ) ) : if ( factor [ i ] > 0 ) : product = product * factor [ i ] * i i += 1 if ( product == input1 ) : print ( ""Power-isolatedInteger"" ) else : print ( ""NotaPower-isolatedInteger"" )"
"def printThreeParts ( N ) : if ( 0 == N % 3 ) : print ( ""x=1,y=1,z="" , N - 2 ) else : print ( ""x=1,y=2,z="" , N - 3 )"
"def sameSetBits ( arr , n ) : v = [ ] i = 0 while i in list ( range ( n ) ) : v.append ( bin ( arr [ i ] ).count ( '1' ) ) i += 1 current_count = 1 max_count = 1 for i in range ( 1 , len ( v ) - 1 , 1 ) : if ( v [ i + 1 ] == v [ i ] ) : current_count += 1 else : current_count = 1 max_count = max ( max_count , current_count ) return max_count"
"def remove ( arr , n ) : m = dict.fromkeys ( arr , 0 ) i = 0 while i in list ( range ( n ) ) : m [ arr [ i ] ] += 1 i += 1 for i in range ( n ) : if ( ( m [ arr [ i ] ] & 1 ) ) : continue print ( arr [ i ] , end = "","" )"
"def countNumbers ( X , Y , N ) : count = 0 i = 1 while i in list ( range ( N + 1 ) ) : if ( ( i % X == 0 ) and ( i % Y != 0 ) ) : count += 1 i += 1 return count"
def isPowerOfFour ( n ) : if ( 0 == n ) : return False while ( n != 1 ) : if ( n % 4 != 0 ) : return False n = n // 4 return True
"def arcLength ( diameter , angle ) : if angle < 360 : arc = ( 3.142857142857143 * diameter ) * ( angle / 360.0 ) return arc else : print ( ""Anglecannotbeformed"" ) return 0"
def findNth ( N ) : b = 14 i = 2 while i in list ( range ( N + 1 ) ) : if ( i % 2 == 0 ) : b = b * 2 else : b = b - 8 i += 1 return b
"def search ( arr , n , x ) : front = 0 ; back = n - 1 while ( front <= back ) : if ( x == arr [ front ] or arr [ back ] == x ) : return True front += 1 back -= 1 return False"
"def maximumChars ( str ) : n = len ( str ) res = - 1 i = 0 while i in list ( range ( n - 1 ) ) : for j in range ( i + 1 , n ) : if ( str [ i ] == str [ j ] ) : res = max ( res , abs ( j - i - 1 ) ) i += 1 return res"
"def countOccurrances ( n , d ) : count = 0 while ( n > 0 ) : if ( d == n % 10 ) : count = count + 1 n = n // 10 return count"
"def count_carry ( a , b ) : carry = 0 count = 0 len_a = len ( a ) len_b = len ( b ) while ( len_a != 0 or len_b != 0 ) : x = 0 y = 0 if ( len_a > 0 ) : x = int ( a [ len_a - 1 ] ) + int ( '0' ) len_a -= 1 if ( len_b > 0 ) : y = int ( b [ len_b - 1 ] ) + int ( '0' ) len_b -= 1 sum = x + y + carry if ( 10 <= sum ) : carry = 1 count += 1 else : carry = 0 return count"
"def countSubSeq ( arr , n , k ) : count = 0 i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] % k == 0 ) : count += 1 i += 1 return ( 2 ** count - 1 )"
"def getNumToAdd ( arr , n ) : arr.sort ( reverse = False ) d = arr [ 1 ] - arr [ 0 ] numToAdd = - 1 numAdded = False i = 2 while i in list ( range ( n ) ) : diff = arr [ i ] - arr [ i - 1 ] if ( diff != d ) : if ( numAdded ) : i += 1 return - 1 if ( diff == 2 * d ) : numToAdd = arr [ i ] - d numAdded = True else : i += 1 return - 1 i += 1 if ( numToAdd == - 1 ) : return ( arr [ n - 1 ] + d ) return numToAdd"
def countDigit ( n ) : prime = [ False ] * 10 prime [ 2 ] = True prime [ 3 ] = True prime [ 5 ] = True prime [ 7 ] = True temp = n count = 0 while ( temp != 0 ) : d = temp % 10 temp //= 10 if ( d > 0 and 0 == n % d and prime [ d ] ) : count += 1 return count
def printCountRec ( dist ) : if 0 > dist : return 0 if dist == 0 : return 1 return ( printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) )
def findSum ( n ) : multiTerms = n * ( n + 1 ) // 2 sm = multiTerms i = 2 while i in list ( range ( n + 1 ) ) : multiTerms = multiTerms - ( i - 1 ) sm = sm + multiTerms * i i += 1 return sm
"def printPrevGreater ( arr , n ) : s = set ( ) i = 0 while i in list ( range ( n ) ) : it = [ x for x in s if x >= arr [ i ] ] if len ( it ) == 0 : print ( ""-1"" , end = """" ) else : print ( min ( it ) , end = """" ) s.add ( arr [ i ] ) i += 1"
"def checkIfAllTogether ( s , c ) : oneSeen = False i = 0 n = len ( s ) while ( i < n ) : if ( c == s [ i ] ) : if ( oneSeen == True ) : return False while ( i < n and s [ i ] == c ) : i = i + 1 oneSeen = True else : i = i + 1 return True"
"def insertionSortRecursive ( arr , n ) : if 1 >= n : return insertionSortRecursive ( arr , n - 1 ) last = arr [ n - 1 ] j = n - 2 while ( j >= 0 and arr [ j ] > last ) : arr [ j + 1 ] = arr [ j ] j = j - 1 arr [ j + 1 ] = last"
"def bonacciseries ( n , m ) : a = [ 0 for i in range ( m ) ] a [ n - 1 ] = 1 a [ n ] = 1 for i in range ( n + 1 , m ) : a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ] i = 0 while i in list ( range ( m ) ) : print ( a [ i ] , end = """" ) i += 1"
"def generateArr ( arr , n ) : if ( n == 1 ) : print ( arr [ 0 ] ) return barr = [ 0 ] * n barr [ 0 ] = arr [ 0 ] & arr [ 1 ] barr [ n - 1 ] = arr [ n - 1 ] & arr [ n - 2 ] i = 1 while i in list ( range ( n - 1 ) ) : barr [ i ] = arr [ i - 1 ] & arr [ i + 1 ] i += 1 for i in range ( n ) : print ( barr [ i ] , end = """" )"
"def maxvolume ( s ) : maxvalue = 0 i = 1 i = 0 while i in list ( range ( s - 1 ) ) : j = 1 for j in range ( s ) : k = s - i - j maxvalue = max ( maxvalue , i * j * k ) i += 1 return maxvalue"
def isPowerOfTwo ( n ) : if ( n == 0 ) : return False while ( 1 != n ) : if ( n % 2 != 0 ) : return False n = n // 2 return True
"def leastValue ( P , A , N , a ) : ans = - 1 tmp = float ( 'inf' ) i = 0 while i in list ( range ( N ) ) : t = P - a [ i ] * 0.006 if abs ( t - A ) < tmp : tmp = abs ( t - A ) ans = i i += 1 return a [ ans ]"
"def survival ( S , N , M ) : if ( ( ( N * 6 ) < ( M * 7 ) and 6 < S ) or M > N ) : print ( ""No"" ) else : days = ( M * S ) / N if ( ( ( M * S ) % N ) != 0 ) : days += 1 print ( ""Yes"" ) , print ( days )"
"def gcd ( a , b ) : if ( 0 == a ) : return b if ( b == 0 ) : return a k = 0 while ( ( ( a | b ) & 1 ) == 0 ) : a = a >> 1 b = b >> 1 k = k + 1 while ( ( a & 1 ) == 0 ) : a = a >> 1 while ( b != 0 ) : while ( ( b & 1 ) == 0 ) : b = b >> 1 if ( a > b ) : temp = a a = b b = temp b = ( b - a ) return ( a << k )"
"def maxProduct ( arr , n , p ) : minVal = arr [ 0 ] maxVal = arr [ 0 ] maxProduct = arr [ 0 ] i = 1 while i in list ( range ( n ) ) : if ( arr [ i ] < 0 ) : maxVal , minVal = minVal , maxVal maxVal = max ( arr [ i ] , maxVal * arr [ i ] ) minVal = min ( arr [ i ] , minVal * arr [ i ] ) if ( minVal == p or maxVal == p ) : i += 1 return True maxProduct = max ( maxProduct , maxVal ) i += 1 return False"
def isMultipleOf3 ( n ) : odd_count = 0 even_count = 0 if ( n < 0 ) : n = - n if ( 0 == n ) : return 1 if ( n == 1 ) : return 0 while ( n ) : if ( n & 1 ) : odd_count += 1 if ( n & 2 ) : even_count += 1 n = n >> 2 return isMultipleOf3 ( abs ( odd_count - even_count ) )
"def getPassingCars ( A , n ) : countOne = 0 ; result = 0 while n >= 1 : if 1 == A [ n - 1 ] : countOne += 1 else : result += countOne n -= 1 return result"
"def isMember ( a , d , x ) : if 0 == d : return x == a return ( ( x - a ) % d == 0 & int ( ( x - a ) / d ) >= 0 )"
"def countPairs ( arr , n ) : odd = 0 even = 0 i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] % 2 == 0 ) : even += 1 else : odd += 1 i += 1 odd_pairs = odd * ( n - 1 ) even_pairs = even * ( n - 1 ) print ( odd_pairs ) print ( even_pairs )"
"def findMaxDiff ( a , n ) : if ( n < 2 ) : print ( ""Invalid"" ) return 0 min_val = sys.maxsize max_val = - sys.maxsize - 1 i = 0 while i in list ( range ( n ) ) : if ( ( a [ i ] - i ) > max_val ) : max_val = a [ i ] - i if ( ( a [ i ] - i ) < min_val ) : min_val = a [ i ] - i i += 1 return ( max_val - min_val )"
"def costToPanagram ( string , cost ) : n = len ( string ) occurrences = [ 0 ] * 26 i = 0 while i in list ( range ( n ) ) : occurrences [ ord ( string [ i ] ) - ord ( 'a' ) ] += 1 i += 1 gain = 0 for i in range ( 26 ) : if occurrences [ i ] == 0 : gain -= 2 * cost [ i ] elif occurrences [ i ] > 1 : gain += cost [ i ] * ( occurrences [ i ] - 1 ) if gain >= 0 : return 0 return gain * - 1"
"def findRepeating ( arr , n ) : missingElement = 0 i = 0 while i in list ( range ( n ) ) : element = arr [ abs ( arr [ i ] ) ] if ( element < 0 ) : missingElement = arr [ i ] i += 1 break arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] i += 1 return abs ( missingElement )"
"def getMedian ( ar1 , ar2 , n ) : i = 0 j = 0 m1 = - 1 m2 = - 1 count = 0 while count < n + 1 : count += 1 if i == n : m1 = m2 m2 = ar2 [ 0 ] break elif j == n : m1 = m2 m2 = ar1 [ 0 ] break if ar1 [ i ] >= ar2 [ j ] : m1 = m2 m2 = ar2 [ j ] j += 1 else : m1 = m2 m2 = ar1 [ i ] i += 1 return ( m1 + m2 ) / 2"
"def findMaximumNum ( arr , n ) : i = n while ( i >= 1 ) : count = 0 j = 0 while j in list ( range ( n ) ) : if ( i <= arr [ j ] ) : count += 1 j += 1 if ( count >= i ) : return i i -= 1 return 1"
"def printCoins ( arr , n ) : oddSum = 0 for i in range ( 0 , n , 2 ) : oddSum += arr [ i ] evenSum = 0 i = 1 while i in list ( range ( n ) ) : evenSum += arr [ i ] i += 2 if oddSum > evenSum : start = 0 else : start = 1 for i in range ( start , n , 2 ) : print ( arr [ i ] , end = """" )"
"def Add ( x , y ) : while ( 0 != y ) : carry = x & y x = x ^ y y = carry << 1 return x"
"def find_Centroid ( v ) : ans = [ 0 , 0 ] n = len ( v ) signedArea = 0 i = 0 while i in list ( range ( len ( v ) ) ) : x0 = v [ i ] [ 0 ] y0 = v [ i ] [ 1 ] x1 = v [ ( i + 1 ) % n ] [ 0 ] y1 = v [ ( i + 1 ) % n ] [ 1 ] A = ( x0 * y1 ) - ( x1 * y0 ) signedArea += A ans [ 0 ] += ( x0 + x1 ) * A ans [ 1 ] += ( y0 + y1 ) * A i += 1 signedArea *= 0.5 ans [ 0 ] = ( ans [ 0 ] ) / ( 6 * signedArea ) ans [ 1 ] = ( ans [ 1 ] ) / ( 6 * signedArea ) return ans"
"def maxRemoval ( arr , n ) : count = 0 cummulative_sum = 0 arr.sort ( ) i = 0 while i in list ( range ( n ) ) : if arr [ i ] >= cummulative_sum : count += 1 cummulative_sum += arr [ i ] i += 1 return count"
"def sum ( x , n ) : total = 1.0 multi = x i = 1 while i in list ( range ( n + 1 ) ) : total = total + multi / i multi = multi * x i += 1 return total"
def countOnes ( n ) : count = 1 rem = 1 while ( 0 != rem ) : rem = ( rem * 10 + 1 ) % n count = count + 1 return count
"def NthArmstrong ( n ) : count = 0 i = 1 while i in list ( range ( sys.maxsize ) ) : num = i rem = 0 digit = 0 sum = 0 num = i digit = int ( math.log10 ( num ) + 1 ) while ( num > 0 ) : rem = num % 10 sum = sum + pow ( rem , digit ) num = num // 10 if ( i == sum ) : count += 1 if ( count == n ) : i += 1 return i i += 1"
"def harmonicMean ( arr , n ) : sm = 0 i = 0 while i in list ( range ( n ) ) : sm = sm + ( 1 ) / arr [ i ] i += 1 return n / sm"
"def CntcontSubs ( a , n ) : c = 0 d = 0 sum = 1 i = 0 while i in list ( range ( n ) ) : if ( a [ i ] % 2 != 0 or a [ i ] % 4 == 0 ) : d += 1 sum = a [ i ] for j in range ( i + 1 , n ) : sum = sum * a [ j ] if ( sum % 2 != 0 or sum % 4 == 0 ) : c += 1 sum = 1 i += 1 return c + d"
"def maxOnesIndex ( arr , n ) : max_count = 0 max_index = 0 prev_zero = - 1 prev_prev_zero = - 1 curr = 0 while curr in list ( range ( n ) ) : if ( arr [ curr ] == 0 ) : if ( curr - prev_prev_zero > max_count ) : max_count = curr - prev_prev_zero max_index = prev_zero prev_prev_zero = prev_zero prev_zero = curr curr += 1 if ( n - prev_prev_zero > max_count ) : max_index = prev_zero return max_index"
"def turnOffK ( n , k ) : if ( 0 >= k ) : return n return ( n & ~ ( 1 << ( k - 1 ) ) )"
"def result ( N ) : num = 0 while num in list ( range ( N ) ) : if num % 3 == 0 and num % 5 == 0 : print ( str ( num ) + """" , end = """" ) else : pass num += 1"
"def findCountOfSolutions ( n , p ) : ans = 0 x = 1 while x in list ( range ( p ) ) : if ( ( x * x ) % p == 1 ) : last = x + p * ( n / p ) if ( last > n ) : last -= p ans += ( ( last - x ) / p + 1 ) x += 1 return int ( ans )"
"def largestSubset ( a , n ) : a.sort ( ) dp = [ 0 for i in range ( n ) ] dp [ n - 1 ] = 1 for i in range ( n - 2 , - 1 , - 1 ) : mxm = 0 j = i + 1 while j in list ( range ( n ) ) : if a [ j ] % a [ i ] == 0 : mxm = max ( mxm , dp [ j ] ) j += 1 dp [ i ] = 1 + mxm return max ( dp )"
"def getSum ( arr , n ) : sum = 0 i = 0 while i in list ( range ( n ) ) : sqrtCurrent = math.sqrt ( arr [ i ] ) for j in range ( 0 , n ) : x = arr [ j ] if ( x == sqrtCurrent ) : sum += ( sqrtCurrent * sqrtCurrent ) i += 1 break i += 1 return int ( sum )"
"def zigzag ( n , k ) : if ( 0 == n and k == 0 ) : return 1 if ( k == 0 ) : return 0 return zigzag ( n , k - 1 ) + zigzag ( n - 1 , n - k )"
"def isSubset ( arr1 , arr2 , m , n ) : i = 0 j = 0 if m < n : return 0 arr1.sort ( ) arr2.sort ( ) while n > i and j < m : if arr1 [ j ] < arr2 [ i ] : j += 1 elif arr1 [ j ] == arr2 [ i ] : j += 1 i += 1 elif arr1 [ j ] > arr2 [ i ] : return 0 return False if i < n else True"
"def minNumber ( a , n , x ) : l = 0 h = 0 e = 0 i = 0 while i in list ( range ( n ) ) : if a [ i ] == x : e += 1 elif a [ i ] > x : h += 1 elif a [ i ] < x : l += 1 i += 1 ans = 0 if l > h : ans = l - h elif l < h : ans = h - l - 1 return ans + 1 - e"
"def recursiveFun ( n ) : if ( 1 == n ) : return ""int"" return ""gcd(int,"" + recursiveFun ( n - 1 ) + "")"""
"def printNonDivisible ( A , B , n , m ) : maxB = 0 for i in range ( 0 , m , 1 ) : if ( B [ i ] > maxB ) : maxB = B [ i ] mark = [ 0 for i in range ( maxB ) ] for i in range ( 0 , n , 1 ) : x = A [ i ] while x in list ( range ( maxB ) ) : mark [ x ] += 1 x += A [ i ] for i in range ( 0 , m - 1 , 1 ) : if ( mark [ B [ i ] ] == 0 ) : print ( B [ i ] )"
"def lastKDigits ( a , n , k ) : num = ( int ) ( math.pow ( 10 , k ) ) mul = a [ 0 ] % num i = 1 while i in list ( range ( n ) ) : a [ i ] = a [ i ] % num mul = ( a [ i ] * mul ) % num i += 1 return mul"
"def maximumXor ( arr : list , n : int ) -> int : sForward , sBackward = [ ] , [ ] ans = - 1 i = 0 while i in list ( range ( n ) ) : while len ( sForward ) > 0 and arr [ i ] < arr [ sForward [ - 1 ] ] : ans = max ( ans , arr [ i ] ^ arr [ sForward [ - 1 ] ] ) sForward.pop ( ) sForward.append ( i ) while len ( sBackward ) > 0 and arr [ n - i - 1 ] < arr [ sBackward [ - 1 ] ] : ans = max ( ans , arr [ n - i - 1 ] ^ arr [ sBackward [ - 1 ] ] ) sBackward.pop ( ) sBackward.append ( n - i - 1 ) i += 1 return ans"
"def minCost ( N , P , Q ) : cost = 0 while ( 0 < N ) : if ( N & 1 ) : cost += P N -= 1 else : temp = N // 2 if ( temp * P > Q ) : cost += Q else : cost += P * temp N //= 2 return cost"
"def count_element ( N , K , arr ) : mp = dict ( ) i = 0 while i in list ( range ( N ) ) : mp [ arr [ i ] ] = mp.get ( arr [ i ] , 0 ) + 1 i += 1 answer = 0 for i in mp : if i + K in mp : answer += mp [ i ] return answer"
"def distinctCount ( arr , n ) : count = n i = 0 ; j = n - 1 ; sum = 0 while ( i < j ) : while ( i != j and arr [ i ] == arr [ i + 1 ] ) : count = count - 1 i = i + 1 while ( j != i and arr [ j ] == arr [ j - 1 ] ) : count = count - 1 j = j - 1 if ( i == j ) : break sum = arr [ i ] + arr [ j ] if ( sum == 0 ) : count = count - 1 i = i + 1 j = j - 1 elif ( sum < 0 ) : i = i + 1 else : j = j - 1 return count"
def countUnsetBits ( n ) : cnt = 0 i = 1 while i in list ( range ( n + 1 ) ) : temp = i while ( temp ) : if ( temp % 2 == 0 ) : cnt += 1 temp = temp // 2 i += 1 return cnt
"def findNumbers ( n , b ) : even = 0 odd = 0 if ( b % 2 != 0 ) : even = pow ( b , n ) - 1 odd = pow ( b , n ) - 2 else : even = pow ( b , n ) - 2 odd = pow ( b , n ) - 1 print ( ""EvenNumber="" , int ( even ) ) print ( ""OddNumber="" , int ( odd ) )"
"def countRotations ( arr , n ) : min = arr [ 0 ] i = 0 while i in list ( range ( n ) ) : if ( min > arr [ i ] ) : min = arr [ i ] min_index = i i += 1 return min_index"
"def MaxTotalRectangleArea ( a , n ) : a.sort ( reverse = True ) sum = 0 flag = False len = 0 i = 0 while ( i < n - 1 ) : if ( i != 0 ) : i = i + 1 if ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and flag == False ) : flag = True len = a [ i + 1 ] i = i + 1 elif ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and True == flag ) : sum = sum + a [ i + 1 ] * len flag = False i = i + 1 return sum"
def findMaxValue ( ) : res = 2 fact = 2 while ( True ) : if ( fact < 0 or sys.maxsize < fact ) : break res += 1 fact = fact * res return res - 1
def findNthEvenDigitNumber ( n ) : count = 0 i = 0 while ( True ) : curr = i isCurrEvenDigit = True while ( curr != 0 ) : if ( curr % 10 == 1 or curr % 10 == 3 or curr % 10 == 5 or curr % 10 == 7 or curr % 10 == 9 ) : isCurrEvenDigit = False curr = curr // 10 if ( True == isCurrEvenDigit ) : count += 1 if ( count == n ) : return i i += 1
"def Triplets ( n ) : ans = 0 i = 1 while i in list ( range ( n + 1 ) ) : for j in range ( i , n + 1 ) : x = i * i + j * j y = int ( math.sqrt ( x ) ) if ( y * y == x and y <= n ) : ans += 1 i += 1 return ans"
"def doesContainB ( a , b , c ) : if ( a == b ) : return True if ( ( b - a ) * c > 0 and 0 == ( b - a ) % c ) : return True return False"
def mySort ( arr ) : n = len ( arr ) arr1 = arr [ : n // 2 ] arr2 = arr [ n // 2 : ] arr1.sort ( ) arr2.sort ( ) arr = arr1 + arr2 low = n // 2 high = n - 1 while ( high > low ) : temp = arr [ low ] arr [ low ] = arr [ high ] arr [ high ] = temp low += 1 high -= 1 return arr
"def check ( arr , N , K ) : unique = dict ( ) i = 0 while i in list ( range ( N ) ) : unique [ arr [ i ] ] = 1 i += 1 if len ( unique ) == K : return True return False"
"def CountAllPairs ( N , K ) : count = 0 if ( N > K ) : count = N - K i = K + 1 while i in list ( range ( N + 1 ) ) : count = count + ( ( N - K ) // i ) i += 1 return count"
"def findNumbers ( N ) : v = [ ] while ( N ) : n , m , p = N , 0 , 1 while ( n ) : if ( n % 10 ) : m += p n //= 10 p *= 10 v.append ( m ) N -= m i = 0 while i in list ( range ( len ( v ) ) ) : print ( v [ i ] , end = """" ) i += 1"
"def getRemainder ( num , divisor ) : while ( divisor <= num ) : num -= divisor return num"
def largestCoprime ( N ) : if N == 6 : return 1 elif N % 4 == 0 : return N // 2 - 1 elif 0 == N % 2 : return N // 2 - 2 else : return ( N - 1 ) // 2
"def query ( s , i , j ) : n = len ( s ) i %= n j %= n print ( ""Yes"" ) if s [ j ] == s [ i ] else print ( ""No"" )"
"def difference ( arr , n ) : largest = arr [ 0 ] i = 0 for i in range ( n ) : if ( largest < arr [ i ] ) : largest = arr [ i ] i = 0 while i in list ( range ( n ) ) : arr [ i ] = largest - arr [ i ] i += 1 for i in range ( n ) : print ( arr [ i ] , end = """" )"
"def FindMinNum ( arr , n ) : pre = [ 0 for i in range ( n ) ] pre [ 0 ] = arr [ 0 ] i = 1 while i in list ( range ( n ) ) : pre [ i ] = pre [ i - 1 ] + arr [ i ] i += 1 k = sys.maxsize for i in range ( n - 1 ) : rightSum = pre [ n - 1 ] - pre [ i ] if ( rightSum >= pre [ i ] ) : k = min ( k , rightSum - pre [ i ] ) if ( k != sys.maxsize ) : return k return - 1"
"def sumDivisibles ( A , B , M ) : sum = 0 i = A while i in list ( range ( B + 1 ) ) : if ( i % M == 0 ) : sum += i i += 1 return sum"
def countCoins ( n ) : c = 0 if ( n < 10 ) : return n if ( n > 9 and n < 25 ) : c = n // 10 + n % 10 return c if ( n > 24 ) : c = n // 25 if ( 10 > n % 25 ) : c = c + n % 25 return c if ( n % 25 > 9 ) : c = ( c + ( n % 25 ) // 10 + ( n % 25 ) % 10 ) return c
"def getRemainder ( num , divisor ) : if ( divisor == 0 ) : return False if ( divisor < 0 ) : divisor = - divisor if ( num < 0 ) : num = - num i = 1 product = 0 while ( num >= product ) : product = divisor * i i += 1 return num - ( product - divisor )"
"def checkTypeOfTriangle ( a , b , c ) : sqa = pow ( a , 2 ) sqb = pow ( b , 2 ) sqc = pow ( c , 2 ) if ( sqa + sqb == sqa or sqb == sqa + sqc or sqc == sqa + sqb ) : print ( ""Right-angledTriangle"" ) elif ( sqa > sqc + sqb or sqb > sqa + sqc or sqc > sqa + sqb ) : print ( ""Obtuse-angledTriangle"" ) else : print ( ""Acute-angledTriangle"" )"
"def canBeEqual ( a , b , n ) : A = [ ] B = [ ] i = 0 while i in list ( range ( n ) ) : if a [ i ] != b [ i ] : A.append ( a [ i ] ) B.append ( b [ i ] ) i += 1 if len ( A ) == len ( B ) == 0 : return True if len ( A ) == len ( B ) == 2 : if A [ 0 ] == A [ 1 ] and B [ 0 ] == B [ 1 ] : return True return False"
"def maximumFixedPoints ( a , n ) : pos = [ None ] * n count , swapped = 0 , 0 i = 0 while i in list ( range ( n ) ) : pos [ a [ i ] ] = i i += 1 for i in range ( 0 , n ) : if a [ i ] == i : count += 1 elif swapped == 0 and pos [ i ] == a [ i ] : count += 2 swapped = 1 if swapped == 0 and count < n - 1 : count += 1 return count"
"def countPattern ( n , pat ) : pattern_int = 0 power_two = 1 all_ones = 0 i = len ( pat ) - 1 while ( i >= 0 ) : current_bit = ord ( pat [ i ] ) - ord ( '0' ) pattern_int += ( power_two * current_bit ) all_ones = all_ones + power_two power_two = power_two * 2 i -= 1 count = 0 while ( 0 != n and n >= pattern_int ) : if ( ( n & all_ones ) == pattern_int ) : count += 1 n = n >> 1 return count"
"def sumEqualProduct ( a , n ) : zero = 0 two = 0 i = 0 while i in list ( range ( n ) ) : if a [ i ] == 0 : zero += 1 if a [ i ] == 2 : two += 1 i += 1 cnt = ( zero * ( zero - 1 ) ) // 2 + ( two * ( two - 1 ) ) // 2 return cnt"
"def replace ( s , c1 , c2 ) : l = len ( s ) i = 0 while i in list ( range ( l ) ) : if ( s [ i ] == c1 ) : s = s [ 0 : i ] + c2 + s [ i + 1 : ] elif ( s [ i ] == c2 ) : s = s [ 0 : i ] + c1 + s [ i + 1 : ] i += 1 return s"
"def printXYZ ( n ) : if 1 == n : print ( - 1 ) else : print ( ""xis"" , n ) print ( ""yis"" , n + 1 ) print ( ""zis"" , n * ( n + 1 ) )"
def minPerimeter ( n ) : l = math.sqrt ( n ) sq = l * l if ( sq == n ) : return l * 4 else : row = n / l perimeter = 2 * ( l + row ) if ( n % l != 0 ) : perimeter = perimeter + 2 return perimeter
"def bitsAreInAltPatrnInGivenTRange ( n , l , r ) : num = n >> ( l - 1 ) prev = num & 1 num = num >> 1 i = 1 while i in list ( range ( ( r - l ) ) ) : curr = num & 1 if ( curr == prev ) : i += 1 return False prev = curr num = num >> 1 i += 1 return True"
def sumofseries ( n ) : res = 0 i = 1 while i in list ( range ( n + 1 ) ) : res += ( i ) * ( i + 1 ) * ( i + 2 ) i += 1 return res
"def getTotalXorOfSubarrayXors ( arr , N ) : res = 0 i = 0 while i in list ( range ( N ) ) : freq = ( i + 1 ) * ( N - i ) if ( freq % 2 == 1 ) : res = res ^ arr [ i ] i += 1 return res"
"def Area ( a , b ) : if ( 0 > a and b < 0 ) : return - 1 h = math.sqrt ( ( ( pow ( a , 2 ) + pow ( b , 2 ) ) / ( pow ( a , 2 ) * pow ( b , 2 ) ) ) ) A = 0.70477 * pow ( h , 2 ) return A"
"def nonDecNums ( n ) : a = np.zeros ( ( n + 1 , 10 ) ) for i in range ( 10 ) : a [ 0 ] [ i ] = 1 i = 1 while i in list ( range ( n + 1 ) ) : a [ i ] [ 9 ] = 1 i += 1 for i in range ( 1 , n + 1 ) : for j in range ( 8 , - 1 , - 1 ) : a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] return int ( a [ n ] [ 0 ] )"
"def isSubstring ( s1 , s2 ) : M = len ( s1 ) N = len ( s2 ) for i in range ( N - M + 1 ) : j = 0 while j in list ( range ( M ) ) : if ( s2 [ i + j ] != s1 [ j ] ) : j += 1 break j += 1 if j + 1 == M : return i return - 1"
"def printArray ( N , SUM , K ) : minSum = ( N * ( N + 1 ) ) / 2 maxSum = ( N * K ) - ( N * ( N - 1 ) ) / 2 if ( minSum > SUM or maxSum < SUM ) : print ( ""NotPossible"" ) return arr = [ 0 for i in range ( N + 1 ) ] for i in range ( 1 , N + 1 , 1 ) : arr [ i ] = i sum = minSum i = N while ( i >= 1 ) : x = sum + ( K - i ) if ( x < SUM ) : sum = sum + ( K - i ) arr [ i ] = K K -= 1 else : arr [ i ] += ( SUM - sum ) sum = SUM break i -= 1 i = 1 while i in list ( range ( N + 1 ) ) : print ( int ( arr [ i ] ) , end = """" ) i += 1"
"def checkcircle ( r , R , r1 , x1 , y1 ) : dis = int ( math.sqrt ( x1 * x1 + y1 * y1 ) ) return ( R <= dis - r1 and dis + r1 <= r )"
"def recaman ( n ) : if ( n <= 0 ) : return print ( 0 , "","" , end = '' ) s = set ( [ ] ) s.add ( 0 ) prev = 0 i = 1 while i in list ( range ( n ) ) : curr = prev - i if ( curr < 0 or curr in s ) : curr = prev + i s.add ( curr ) print ( curr , "","" , end = '' ) prev = curr i += 1"
"def subsequence ( s , t , n , k ) : last = 0 cnt = 0 new_last = 0 size = 0 string = 'zyxwvutsrqponmlkjihgfedcba' for ch in string : cnt = 0 i = last while i in list ( range ( n ) ) : if s [ i ] == ch : cnt += 1 i += 1 if cnt >= k : for i in range ( last , n ) : if s [ i ] == ch : t [ size ] = ch new_last = i size += 1 last = new_last"
"def longestString ( str1 , str2 ) : count1 = [ 0 ] * 26 count2 = [ 0 ] * 26 for i in range ( len ( str1 ) ) : count1 [ ord ( str1 [ i ] ) - ord ( 'a' ) ] += 1 for i in range ( len ( str2 ) ) : count2 [ ord ( str2 [ i ] ) - ord ( 'a' ) ] += 1 result = """" i = 0 while i in list ( range ( 26 ) ) : for j in range ( 1 , min ( count1 [ i ] , count2 [ i ] ) + 1 ) : result = result + chr ( ord ( 'a' ) + i ) i += 1 print ( result )"
"def countSquares ( m , n ) : if ( m > n ) : temp = m m = n n = temp return n * ( n + 1 ) * ( 3 * m - n + 1 ) // 6"
"def productArray ( arr , n ) : if ( n == 1 ) : print ( 0 ) return left = [ 0 ] * n right = [ 0 ] * n prod = [ 0 ] * n left [ 0 ] = 1 right [ n - 1 ] = 1 for i in range ( 1 , n ) : left [ i ] = arr [ i - 1 ] * left [ i - 1 ] for j in range ( n - 2 , - 1 , - 1 ) : right [ j ] = arr [ j + 1 ] * right [ j + 1 ] i = 0 while i in list ( range ( n ) ) : prod [ i ] = left [ i ] * right [ i ] i += 1 for i in range ( n ) : print ( prod [ i ] , end = '' )"
"def gcd ( a , b ) : while 0 != b : a , b = b , a % b return a"
"def subarrayCount ( arr , n ) : result = 0 fast , slow = 0 , 0 i = 1 while i in list ( range ( n ) ) : if ( arr [ i ] - arr [ i - 1 ] == 1 ) : fast += 1 else : length = fast - slow + 1 result += length * ( length - 1 ) // 2 fast = i slow = i i += 1 if ( fast != slow ) : length = fast - slow + 1 result += length * ( length - 1 ) // 2 return result"
"def maxRowDiff ( mat , m , n ) : rowSum = [ 0 ] * m i = 0 while i in list ( range ( m ) ) : sum = 0 for j in range ( 0 , n ) : sum += mat [ i ] [ j ] rowSum [ i ] = sum i += 1 max_diff = rowSum [ 1 ] - rowSum [ 0 ] min_element = rowSum [ 0 ] for i in range ( 1 , m ) : if ( rowSum [ i ] - min_element > max_diff ) : max_diff = rowSum [ i ] - min_element if ( rowSum [ i ] < min_element ) : min_element = rowSum [ i ] return max_diff"
"def countOcc ( s ) : cnt = 0 for i in range ( 0 , len ( s ) - 3 ) : c , l , a , p = 0 , 0 , 0 , 0 j = i while j in list ( range ( i + 4 ) ) : if s [ j ] == 'c' : c += 1 elif s [ j ] == 'l' : l += 1 elif s [ j ] == 'a' : a += 1 elif s [ j ] == 'p' : p += 1 j += 1 if c == 1 and l == 1 and a == 1 and p == 1 : cnt += 1 return cnt"
"def isValidString ( str , n ) : idx = str.find ( ""b"" ) if ( 0 == idx ) : return False while ( idx != - 1 ) : if ( str [ idx - 1 ] != 'a' ) : return False if ( idx + 1 < n and str [ idx + 1 ] != 'b' ) : return False if ( idx + 2 < n and str [ idx + 2 ] == 'b' ) : return False if ( idx == n - 1 ) : return False idx = str.find ( ""b"" , idx + 2 ) return True"
"def countInRange ( arr , n , x , y ) : count = 0 i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] >= x and arr [ i ] <= y ) : count += 1 i += 1 return count"
"def longest_substring ( s , k ) : n = len ( s ) if ( k > 1 ) : s = s + s n *= 2 ans = 0 i = 0 while ( i < n ) : x = 0 while ( i < n and s [ i ] == '' ) : x , i = x + 1 , i + 1 ans = max ( ans , x ) i = i + 1 if ( k == 1 or ans != n ) : return ans else : return ( ans // 2 ) * k"
"def bresenham ( x1 , y1 , x2 , y2 ) : m_new = 2 * ( y2 - y1 ) slope_error_new = m_new - ( x2 - x1 ) y = y1 x = x1 while x in list ( range ( x2 + 1 ) ) : print ( ""("" , x , "","" , y , "")\n"" ) slope_error_new = slope_error_new + m_new if ( slope_error_new >= 0 ) : y = y + 1 slope_error_new = slope_error_new - 2 * ( x2 - x1 ) x += 1"
"def countTotalDistinct ( string ) : cnt = 0 items = set ( ) i = 0 while i in list ( range ( len ( string ) ) ) : temp = """" ans = set ( ) for j in range ( i , len ( string ) ) : temp = temp + string [ j ] ans.add ( string [ j ] ) if temp not in items : items.add ( temp ) cnt += len ( ans ) i += 1 return cnt"
def maxGameByWinner ( N ) : dp = [ 0 for i in range ( N ) ] dp [ 0 ] = 1 dp [ 1 ] = 2 i = 1 while N >= dp [ i ] : i = i + 1 dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] return ( i - 1 )
"def findSmallest ( arr , n ) : res = 1 i = 0 while i in list ( range ( n ) ) : if arr [ i ] <= res : res = res + arr [ i ] else : i += 1 break i += 1 return res"
"def multipleOfThree ( K , dig0 , dig1 ) : sum = 0 temp = ( dig0 + dig1 ) % 10 sum = dig0 + dig1 if ( K == 2 ) : if ( sum % 3 == 0 ) : return True else : return False sum = sum + temp numberofGroups = ( K - 3 ) // 4 remNumberofDigits = ( K - 3 ) % 4 sum = sum + ( numberofGroups * 20 ) for i in range ( remNumberofDigits ) : temp = ( 2 * temp ) % 10 sum = sum + temp if ( sum % 3 == 0 ) : return True else : return False"
"def findMaxNum ( arr , n ) : arr.sort ( reverse = True ) num = arr [ 0 ] i = 1 while i in list ( range ( n ) ) : num = num * 10 + arr [ i ] i += 1 return num"
"def kth ( arr1 , arr2 , m , n , k ) : sorted1 = [ 0 ] * ( m + n ) i = 0 j = 0 d = 0 while ( i < m and j < n ) : if ( arr1 [ i ] < arr2 [ j ] ) : sorted1 [ d ] = arr1 [ i ] i += 1 else : sorted1 [ d ] = arr2 [ j ] j += 1 d += 1 while ( i < m ) : sorted1 [ d ] = arr1 [ i ] d += 1 i += 1 while ( n > j ) : sorted1 [ d ] = arr2 [ j ] d += 1 j += 1 return sorted1 [ k - 1 ]"
"def maxSubArraySum ( a , size ) : max_so_far = a [ 0 ] curr_max = a [ 0 ] i = 1 while i in list ( range ( size ) ) : curr_max = max ( a [ i ] , curr_max + a [ i ] ) max_so_far = max ( max_so_far , curr_max ) i += 1 return max_so_far"
"def farey ( n ) : x1 = 0 y1 = 1 x2 = 1 y2 = n print ( x1 , end = """" ) print ( ""/"" , end = """" ) print ( y1 , x2 , end = """" ) print ( ""/"" , end = """" ) print ( y2 , end = """" ) x = 0 y = 0 while ( 1.0 != y ) : x = math.floor ( ( y1 + n ) / y2 ) * x2 - x1 y = math.floor ( ( y1 + n ) / y2 ) * y2 - y1 print ( x , end = """" ) print ( ""/"" , end = """" ) print ( y , end = """" ) x1 = x2 x2 = x y1 = y2 y2 = y"
"def findEqualPoint ( arr , n ) : distArr = [ 0 ] * n i = 0 di = 0 while ( i < n ) : distArr [ di ] = i di += 1 i += 1 while ( n > i and arr [ i ] == arr [ i - 1 ] ) : i += 1 return distArr [ di >> 1 ] if ( di & 1 ) else - 1"
"def printString ( Str1 , n ) : ones = 0 i = 0 while i in list ( range ( n ) ) : if ( Str1 [ i ] == '1' ) : ones += 1 i += 1 used = False for i in range ( n ) : if ( Str1 [ i ] == '2' and used == False ) : used = 1 for j in range ( ones ) : print ( ""1"" , end = """" ) if ( Str1 [ i ] != '1' ) : print ( Str1 [ i ] , end = """" ) if ( used == False ) : for j in range ( ones ) : print ( ""1"" , end = """" )"
"def shortestLength ( n , x , y ) : answer = 0 i = 0 while n > 0 : if ( answer < x [ i ] + y [ i ] ) : answer = x [ i ] + y [ i ] i += 1 n -= 1 print ( ""Length->"" + str ( answer ) ) print ( ""Path->"" + ""(1,"" + str ( answer ) + "")"" + ""and("" + str ( answer ) + "",1)"" )"
"def solve ( n , m , grid ) : track_row = set ( ) track_col = set ( ) i = 0 while i in list ( range ( n ) ) : for j in range ( m ) : if grid [ i ] [ j ] == '1' : track_row.add ( i ) track_col.add ( j ) i += 1 min_moves_possible = min ( n - len ( track_row ) , m - len ( track_col ) ) return ""Ashish"" if min_moves_possible % 2 == 1 else ""Vivek"""
"def maxProduct ( a , n ) : product = [ 0 ] * n maxA = [ 0 ] * n maxProd = 0 maxArr = 0 i = 0 while i in list ( range ( n ) ) : product [ i ] = a [ ( i + 1 ) % n ] * a [ ( i + ( n - 1 ) ) % n ] if ( maxProd < product [ i ] ) : maxProd = product [ i ] i += 1 return maxProd"
"def sph ( r , R , h ) : if ( 0 > r and R < 0 and h < 0 ) : return - 1 x = r V = ( 4 * 3.14 * pow ( r , 3 ) ) / 3 return V"
"def findSubArr ( arr , n ) : i = 0 while i in list ( range ( n - 1 ) ) : if ( abs ( arr [ i ] - arr [ i + 1 ] ) >= 2 ) : print ( arr [ i ] , arr [ i + 1 ] , end = """" ) i += 1 return i += 1 print ( - 1 )"
def logicOfSequence ( N ) : if ( 0 == N % 2 ) : N = N * N else : N = N * N * N return N
"def maxCount ( A , N , K ) : maximum = 0 start = 0 end = 0 j = 0 A.sort ( ) i = 0 while i in list ( range ( N ) ) : while ( j < N and A [ j ] <= A [ i ] + K ) : j += 1 if maximum < ( j - i ) : maximum = ( j - i ) start = i end = j i += 1 return maximum"
def check ( s ) : freq = [ 0 ] * 26 n = len ( s ) i = 0 while i in list ( range ( n ) ) : freq [ ord ( s [ i ] ) - 97 ] += 1 i += 1 for i in range ( 26 ) : if ( freq [ i ] % 2 == 1 ) : return False return True
"def result ( s , n ) : st = set ( ) i = 0 while i in list ( range ( len ( s ) ) ) : ans = """" for j in range ( i , len ( s ) ) : ans += s [ j ] if ( len ( ans ) == n ) : st.add ( ans ) i += 1 break i += 1 for it in st : print ( it , end = """" )"
"def solve ( A , B ) : count = 0 i = 0 while i in list ( range ( 32 ) ) : if ( ( ( A >> i ) & 1 ) != ( ( B >> i ) & 1 ) ) : count = count + 1 i += 1 print ( ""Numberofdifferentbits:"" , count )"
def numberOfSolutions ( n ) : c = 0 x = 0 while x in list ( range ( n + 1 ) ) : if ( n == ( x + ( n ^ x ) ) ) : c += 1 x += 1 return c
"def findNums ( arr , n ) : S = 0 ; X = 0 i = 0 while i in list ( range ( n ) ) : S += arr [ i ] X ^= arr [ i ] i += 1 print ( X , X + S )"
def ProdOfPrimes ( n ) : prime = [ True for i in range ( n + 1 ) ] p = 2 while ( p * p <= n ) : if ( prime [ p ] == True ) : i = p * 2 while ( i <= n ) : prime [ i ] = False i += p p += 1 prod = 1 i = 2 while i in list ( range ( n + 1 ) ) : if ( prime [ i ] ) : prod *= i i += 1 return prod
"def possibleToReach ( a , b ) : c = np.cbrt ( a * b ) re1 = a // c re2 = b // c if ( ( re1 * re1 * re2 == a ) and ( b == re2 * re2 * re1 ) ) : return True else : return False"
"def printRepeating ( arr , size ) : print ( ""Repeatingelementsare"" , end = '' ) i = 0 while i in list ( range ( size ) ) : for j in range ( i + 1 , size ) : if arr [ i ] == arr [ j ] : print ( arr [ i ] , end = '' ) i += 1"
"def divide ( a , b ) : i = 2 while i in list ( range ( min ( a , b ) + 1 ) ) : while ( a % i == 0 and b % i == 0 ) : a = a // i b = b // i i += 1 print ( ""A="" , a , "",B="" , b )"
"def printOrder ( arr , n , k ) : len1 = k len2 = n - k arr1 = [ 0 ] * k arr2 = [ 0 ] * ( n - k ) for i in range ( k ) : arr1 [ i ] = arr [ i ] for i in range ( k , n ) : arr2 [ i - k ] = arr [ i ] arr1.sort ( ) arr2.sort ( ) for i in range ( n ) : if ( i < k ) : arr [ i ] = arr1 [ i ] else : arr [ i ] = arr2 [ len2 - 1 ] len2 -= 1 i = 0 while i in list ( range ( n ) ) : print ( arr [ i ] , end = """" ) i += 1"
"def isRectangle ( m ) : rows = len ( m ) if ( rows == 0 ) : return False columns = len ( m [ 0 ] ) for y1 in range ( rows ) : x1 = 0 while x1 in list ( range ( columns ) ) : if ( m [ y1 ] [ x1 ] == 1 ) : for y2 in range ( y1 + 1 , rows ) : for x2 in range ( x1 + 1 , columns ) : if ( m [ y1 ] [ x2 ] == 1 and m [ y2 ] [ x1 ] == 1 and m [ y2 ] [ x2 ] == 1 ) : x1 += 1 return True x1 += 1 return False"
"def printNumberWithDR ( k , d ) : if d == 0 and 1 != k : print ( - 1 , end = """" ) else : print ( d , end = """" ) k -= 1 while k : print ( 0 , end = """" ) k -= 1"
"def countGreater ( arr , n , k ) : l = 0 r = n - 1 leftGreater = n while ( r >= l ) : m = int ( l + ( r - l ) / 2 ) if ( arr [ m ] > k ) : leftGreater = m r = m - 1 else : l = m + 1 return ( n - leftGreater )"
"def circle ( x1 , y1 , x2 , y2 , r1 , r2 ) : distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) radSumSq = ( r1 + r2 ) * ( r1 + r2 ) if ( radSumSq == distSq ) : return 1 elif ( distSq > radSumSq ) : return - 1 else : return 0"
"def findMin ( arr , n ) : m = 0 for i in range ( n ) : m = max ( m , arr [ i ] ) cnt = [ 0 ] * ( m + 2 ) for i in range ( n ) : j = 1 while j * j <= arr [ i ] : if ( arr [ i ] % j == 0 ) : if ( j * j == arr [ i ] ) : cnt [ j ] += 1 else : cnt [ j ] += 1 cnt [ arr [ i ] // j ] += 1 j += 1 i = 1 while i in list ( range ( m + 2 ) ) : if ( cnt [ i ] == 0 ) : i += 1 return i i += 1 return - 1"
"def Area ( a ) : if ( 0 > a ) : return - 1 x = 0.464 * a A = 0.70477 * pow ( x , 2 ) return A"
"def modularEquation ( a , b ) : if ( a < b ) : print ( ""Nosolutionpossible"" ) return if ( a == b ) : print ( ""InfiniteSolutionpossible"" ) return count = 0 n = a - b y = ( int ) ( math.sqrt ( a - b ) ) i = 1 while i in list ( range ( y + 1 ) ) : if ( n % i == 0 ) : if ( n / i > b ) : count = count + 1 if ( i > b ) : count = count + 1 i += 1 if ( y * y == n and y > b ) : count = count - 1 print ( count )"
def numberOfTriangles ( n ) : answer = [ None ] * ( n + 1 ) answer [ 0 ] = 1 i = 1 while n >= i : answer [ i ] = answer [ i - 1 ] * 3 + 2 i = i + 1 return answer [ n ]
"def printMinIndexChar ( Str , patt ) : minIndex = 10 ** 9 m = len ( Str ) n = len ( patt ) for i in range ( n ) : j = 0 while j in list ( range ( m ) ) : if ( patt [ i ] == Str [ j ] and j < minIndex ) : minIndex = j j += 1 break j += 1 if ( minIndex != 10 ** 9 ) : print ( ""MinimumIndexCharacter="" , Str [ minIndex ] ) else : print ( ""Nocharacterpresent"" )"
def rearrange ( n ) : global arr if ( n % 2 == 1 ) : return currIdx = int ( ( n - 1 ) / 2 ) while ( 0 < currIdx ) : count = currIdx swapIdx = currIdx while ( count > 0 ) : temp = arr [ swapIdx + 1 ] arr [ swapIdx + 1 ] = arr [ swapIdx ] arr [ swapIdx ] = temp swapIdx = swapIdx + 1 count = count - 1 currIdx = currIdx - 1
"def magicIndex ( arr , start , end ) : if ( start > end ) : return - 1 midIndex = int ( ( start + end ) / 2 ) midValue = arr [ midIndex ] if ( midValue == midIndex ) : return midIndex left = magicIndex ( arr , start , min ( midValue , midIndex - 1 ) ) if ( left >= 0 ) : return left return magicIndex ( arr , max ( midValue , midIndex + 1 ) , end )"
"def minRange ( arr , n , k ) : l = 0 r = n for i in range ( n ) : s = [ ] j = i while j in list ( range ( n ) ) : s.append ( arr [ j ] ) if ( len ( s ) == k ) : if ( ( j - i ) < ( r - l ) ) : r = j l = i j += 1 break j += 1 if ( j == n ) : break if ( l == 0 and r == n ) : print ( ""Invalidk"" ) else : print ( l , r )"
"def find_maximum ( a , n , k ) : b = dict ( ) for i in range ( n ) : x = a [ i ] d = min ( 1 + i , n - i ) if x not in b.keys ( ) : b [ x ] = d else : b [ x ] = min ( d , b [ x ] ) ans = 10 ** 9 i = 0 while i in list ( range ( n ) ) : x = a [ i ] if ( x != ( k - x ) and ( k - x ) in b.keys ( ) ) : ans = min ( max ( b [ x ] , b [ k - x ] ) , ans ) i += 1 return ans"
"def countOp ( arr , n , k ) : operations = 0 i = 1 while i in list ( range ( n ) ) : if ( abs ( arr [ i ] - arr [ i - 1 ] ) > k ) : absDiff = abs ( arr [ i ] - arr [ i - 1 ] ) currOp = absDiff - k if ( arr [ i ] < arr [ i - 1 ] ) : arr [ i ] += currOp else : arr [ i ] -= currOp operations += currOp i += 1 return operations"
"def NextFit ( blockSize , m , processSize , n ) : allocation = [ - 1 ] * n j = 0 for i in range ( n ) : while j < m : if blockSize [ j ] >= processSize [ i ] : allocation [ i ] = j blockSize [ j ] -= processSize [ i ] break j = ( j + 1 ) % m print ( ""ProcessNo.ProcessSizeBlockno."" ) i = 0 while i in list ( range ( n ) ) : print ( i + 1 , """" , processSize [ i ] , end = """" ) if allocation [ i ] != - 1 : print ( allocation [ i ] + 1 ) else : print ( ""NotAllocated"" ) i += 1"
def nextGreater ( num1 ) : l = len ( num1 ) num = list ( num1 ) i = l - 1 while ( i >= 0 ) : if ( num [ i ] != '0' ) : num [ i ] = '0' else : num [ i ] = '1' break i -= 1 num1 = ''.join ( num ) if ( i < 0 ) : num1 = '1' + num1 return num1
def pairWiseConsecutive ( s ) : aux = [ ] while ( len ( s ) != 0 ) : aux.append ( s [ - 1 ] ) s.pop ( ) result = True while ( 1 < len ( aux ) ) : x = aux [ - 1 ] aux.pop ( ) y = aux [ - 1 ] aux.pop ( ) if ( abs ( x - y ) != 1 ) : result = False s.append ( x ) s.append ( y ) if ( len ( aux ) == 1 ) : s.append ( aux [ - 1 ] ) return result
"def Sum ( N ) : SumOfPrimeDivisors = [ 0 ] * ( N + 1 ) i = 2 while i in list ( range ( N + 1 ) ) : if ( SumOfPrimeDivisors [ i ] == 0 ) : for j in range ( i , N + 1 , i ) : SumOfPrimeDivisors [ j ] += i i += 1 return SumOfPrimeDivisors [ N ]"
"def findMinDiff ( arr , n , m ) : if ( m == 0 or n == 0 ) : return 0 arr.sort ( ) if ( m > n ) : return - 1 min_diff = sys.maxsize first = 0 last = 0 i = 0 while ( i + m - 1 < n ) : diff = arr [ i + m - 1 ] - arr [ i ] if ( diff < min_diff ) : min_diff = diff first = i last = i + m - 1 i += 1 return ( arr [ last ] - arr [ first ] )"
"def check ( A , B , N ) : pq1 = [ ] pq2 = [ ] for i in range ( N ) : heapq.heappush ( pq1 , - A [ i ] ) for i in range ( N ) : heapq.heappush ( pq2 , - B [ i ] ) c = 0 i = 0 while i in list ( range ( N ) ) : if - pq1 [ 0 ] > - pq2 [ 0 ] : c += 1 heapq.heappop ( pq1 ) heapq.heappop ( pq2 ) else : if len ( pq2 ) == 0 : i += 1 break heapq.heappop ( pq2 ) i += 1 return ( c )"
"def printStrings ( s , l , m ) : c = set ( ) s = s + s i = 0 while i in list ( range ( l ) ) : c.add ( s [ i : i + m ] ) i += 1 for i in c : print ( i , end = """" )"
"def findNextWord ( s , m ) : m += 97 n = len ( s ) i = len ( s ) - 1 s [ i ] = chr ( ord ( s [ i ] ) + 1 ) while i >= 0 and i <= n - 1 : if ord ( s [ i ] ) >= m : s [ i ] = 'a' i -= 1 s [ i ] = chr ( ord ( s [ i ] ) + 1 ) elif s [ i - 1 ] == s [ i ] or s [ i ] == s [ i - 2 ] : s [ i ] = chr ( ord ( s [ i ] ) + 1 ) else : i += 1 if i <= - 1 : print ( ""-1"" ) else : print ( ''.join ( s ) )"
"def shuffle ( N , key ) : NO_OF_BITS = N reverse_num = 0 i = 0 while i in list ( range ( NO_OF_BITS ) ) : temp = ( key & ( 1 << i ) ) if ( temp ) : reverse_num |= ( 1 << ( ( NO_OF_BITS - 1 ) - i ) ) i += 1 print ( reverse_num )"
def countWords ( str ) : count = 1 i = 1 while i in list ( range ( len ( str ) - 1 ) ) : if ( str [ i ].isupper ( ) ) : count += 1 i += 1 return count
"def pairORSum ( arr , n ) : ans = 0 for i in range ( 0 , 32 ) : k1 = 0 k0 = 0 j = 0 while j in list ( range ( n ) ) : if ( ( arr [ j ] & ( 1 << i ) ) ) : k1 = k1 + 1 else : k0 = k0 + 1 j += 1 ans = ans + ( 1 << i ) * ( k1 * ( k1 - 1 ) // 2 ) + ( 1 << i ) * ( k1 * k0 ) return ans"
"def MaxDotProduct ( A , B , m , n ) : dp = [ [ 0 for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] for i in range ( 1 , n + 1 , 1 ) : j = i while j in list ( range ( m + 1 ) ) : dp [ i ] [ j ] = max ( ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ) , dp [ i ] [ j - 1 ] ) j += 1 return dp [ n ] [ m ]"
"def isPrime ( N ) : isPrime = True arr = [ 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 ] if ( N < 2 ) : isPrime = False if ( N % 2 == 0 or N % 3 == 0 or N % 5 == 0 ) : isPrime = False i = 0 while i in list ( range ( int ( math.sqrt ( N ) ) ) ) : for c in arr : if ( c > int ( math.sqrt ( N ) ) ) : i += 30 break else : if ( N % ( c + i ) == 0 ) : isPrime = False i += 30 break if ( not isPrime ) : i += 30 break i += 30 if ( isPrime ) : print ( ""PrimeNumber"" ) else : print ( ""NotaPrimeNumber"" )"
"def printRLE ( s ) : i = 0 while ( i < len ( s ) - 1 ) : count = 1 while s [ i ] == s [ i + 1 ] : i += 1 count += 1 if len ( s ) == i + 1 : break print ( str ( s [ i ] ) + str ( count ) , end = """" ) i += 1 print ( )"
"def sortedAfterSwap ( A , B , n ) : for i in range ( 0 , n - 1 ) : if ( B [ i ] == 1 ) : j = i while ( B [ j ] == 1 ) : j = j + 1 A = A [ 0 : i ] + sorted ( A [ i : j + 1 ] ) + A [ j + 1 : ] i = j i = 0 while i in list ( range ( n ) ) : if ( A [ i ] != i + 1 ) : i += 1 return False i += 1 return True"
"def checkEVENodd ( arr , n , l , r ) : if ( 1 == arr [ r ] ) : print ( ""odd"" ) else : print ( ""even"" )"
"def answer ( n ) : dp = [ [ 0 for x in range ( 10 ) ] for y in range ( n + 1 ) ] if ( n == 1 ) : return 10 for j in range ( 10 ) : dp [ 1 ] [ j ] = 1 i = 2 while i in list ( range ( n + 1 ) ) : for j in range ( 10 ) : if ( j == 0 ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] elif ( j == 9 ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) i += 1 sum = 0 for j in range ( 1 , 10 ) : sum = sum + dp [ n ] [ j ] return sum"
"def minDist ( arr , n , x , y ) : min_dist = sys.maxsize i = 0 while i in list ( range ( n ) ) : if arr [ i ] == x or arr [ i ] == y : prev = i i += 1 break i += 1 while i < n : if arr [ i ] == x or arr [ i ] == y : if arr [ prev ] != arr [ i ] and ( i - prev ) < min_dist : min_dist = i - prev prev = i else : prev = i i += 1 return min_dist"
"def areEqual ( arr1 , arr2 , n , m ) : if ( n != m ) : return False arr1.sort ( ) arr2.sort ( ) i = 0 while i in list ( range ( n - 1 ) ) : if ( arr1 [ i ] != arr2 [ i ] ) : i += 1 return False i += 1 return True"
"def rhombusarea ( l , b ) : if ( 0 > l or b < 0 ) : return - 1 return ( l * b ) / 2"
"def findPairs ( arr , n , x ) : l = 0 ; r = n - 1 result = 0 while ( r > l ) : if ( arr [ l ] + arr [ r ] < x ) : result += ( r - l ) l += 1 else : r -= 1 return result"
"def permutatedRows ( mat , m , n , r ) : s = set ( ) for j in range ( n ) : s.add ( mat [ r ] [ j ] ) i = 0 while i in list ( range ( m ) ) : if i == r : i += 1 continue for j in range ( n ) : if mat [ i ] [ j ] not in s : j = j - 2 i += 1 break if j + 1 != n : i += 1 continue print ( i ) i += 1"
"def productAtKthLevel ( tree , k ) : level = - 1 product = 1 n = len ( tree ) i = 0 while i in list ( range ( n ) ) : if ( tree [ i ] == '(' ) : level += 1 elif ( tree [ i ] == ')' ) : level -= 1 else : if ( level == k ) : product *= ( int ( tree [ i ] ) - int ( '0' ) ) i += 1 return product"
"def checkSquare ( s1 , s2 ) : c = int ( s1 + s2 ) d = math.sqrt ( c ) if ( d * d != c ) : print ( ""No"" ) else : print ( ""Yes"" )"
"def findLIS ( A , n ) : hash = dict ( ) LIS_size , LIS_index = 1 , 0 hash [ A [ 0 ] ] = 1 i = 1 while i in list ( range ( n ) ) : if A [ i ] - 1 not in hash : hash [ A [ i ] - 1 ] = 0 hash [ A [ i ] ] = hash [ A [ i ] - 1 ] + 1 if LIS_size < hash [ A [ i ] ] : LIS_size = hash [ A [ i ] ] LIS_index = A [ i ] i += 1 print ( ""LIS_size="" , LIS_size ) print ( ""LIS:"" , end = """" ) start = LIS_index - LIS_size + 1 while start <= LIS_index : print ( start , end = """" ) start += 1"
"def canBeBalanced ( s , n ) : count = 0 count_1 = 0 i = 0 while i in list ( range ( n ) ) : if ( s [ i ] == '(' ) : count += 1 else : count -= 1 count_1 = min ( count_1 , count ) i += 1 if ( count_1 >= - 1 and count == 0 ) : return True return False"
"def findMinSwaps ( arr , n ) : noOfZeroes = [ 0 ] * n count = 0 noOfZeroes [ n - 1 ] = 1 - arr [ n - 1 ] for i in range ( n - 2 , - 1 , - 1 ) : noOfZeroes [ i ] = noOfZeroes [ i + 1 ] if ( arr [ i ] == 0 ) : noOfZeroes [ i ] = noOfZeroes [ i ] + 1 i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] == 1 ) : count = count + noOfZeroes [ i ] i += 1 return count"
def number_of_digits ( n ) : i = 4 res = 1 sum = 0 while ( True ) : i *= 4 res = res + 1 sum = sum + i if ( sum >= n ) : break return res
"def myCopy ( s1 , s2 , index ) : s2 [ index ] = s1 [ index ] if ( len ( s1 ) - 1 == index ) : return myCopy ( s1 , s2 , index + 1 )"
"def negProdSubArr ( arr , n ) : positive = 1 negative = 0 i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] > 0 ) : arr [ i ] = 1 else : arr [ i ] = - 1 if ( i > 0 ) : arr [ i ] *= arr [ i - 1 ] if ( arr [ i ] == 1 ) : positive += 1 else : negative += 1 i += 1 return ( positive * negative )"
"def oddIntegers ( n , k ) : if ( n % 2 != k % 2 ) : print ( ""-1"" ) return sum = 0 i = 1 j = 1 while ( k > j ) : sum += i print ( i , end = """" ) i += 2 j += 1 finalOdd = n - sum print ( finalOdd )"
"def kthOdd ( arr , n , k ) : i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] % 2 == 1 ) : k -= 1 if ( k == 0 ) : i += 1 return arr [ i ] i += 1 return - 1"
"def fib ( n , a = 0 , b = 1 ) : if 0 == n : return a if n == 1 : return b return fib ( n - 1 , b , a + b )"
def ellipsearea ( r ) : if ( 0 > r ) : return - 1 a = ( 3.14 * r * r ) / 4 return a
"def findPair ( arr , n ) : s = { i : 1 for i in arr } found = False for i in range ( n ) : j = i + 1 while j in list ( range ( n ) ) : if arr [ i ] + arr [ j ] in s.keys ( ) : print ( arr [ i ] , arr [ j ] ) found = True j += 1 if found == False : print ( ""Notexist"" )"
"def pattern ( nos , i , space ) : prt = '$' for s in range ( nos , 0 , - 1 ) : print ( end = """" ) j = 1 while j in list ( range ( i + 1 ) ) : if ( space != 0 ) : if ( i == 9 and j == 1 ) : j += 1 continue if ( i == 1 or i == 9 ) : print ( prt , end = """" ) elif ( j == 1 or j == i ) : print ( prt , end = """" ) else : print ( end = """" ) j += 1"
"def interLeaveQueue ( q ) : if ( q.qsize ( ) % 2 != 0 ) : print ( ""Inputevennumberofintegers."" ) s = [ ] halfSize = int ( q.qsize ( ) / 2 ) for i in range ( halfSize ) : s.append ( q.queue [ 0 ] ) q.get ( ) while len ( s ) != 0 : q.put ( s [ - 1 ] ) s.pop ( ) for i in range ( halfSize ) : q.put ( q.queue [ 0 ] ) q.get ( ) i = 0 while i in list ( range ( halfSize ) ) : s.append ( q.queue [ 0 ] ) q.get ( ) i += 1 while len ( s ) != 0 : q.put ( s [ - 1 ] ) s.pop ( ) q.put ( q.queue [ 0 ] ) q.get ( )"
"def countways ( n ) : if ( n == 1 ) : return 0 elif ( 0 == n % 2 ) : return 1 + countways ( n / 2 ) else : return 1 + min ( countways ( n - 1 ) , countways ( n + 1 ) )"
"def countSubarrWithEqualZeroAndOne ( arr , n ) : um = dict ( ) curr_sum = 0 i = 0 while i in list ( range ( n ) ) : curr_sum += ( - 1 if ( arr [ i ] == 0 ) else arr [ i ] ) if um.get ( curr_sum ) : um [ curr_sum ] += 1 else : um [ curr_sum ] = 1 i += 1 count = 0 for itr in um : if um [ itr ] > 1 : count += ( ( um [ itr ] * int ( um [ itr ] - 1 ) ) / 2 ) if um.get ( 0 ) : count += um [ 0 ] return int ( count )"
"def perfectCube ( N ) : cube = 0 i = 0 while i in list ( range ( N + 1 ) ) : cube = i * i * i if ( cube == N ) : print ( ""Yes"" ) i += 1 return elif ( cube > N ) : print ( ""NO"" ) i += 1 return i += 1"
def solve ( n ) : if ( n == 1 ) : print ( - 1 ) else : num = 2 i = 0 while i in list ( range ( n - 1 ) ) : num = ( num * 10 ) + 3 i += 1 print ( num )
"def findPairs ( arr1 , arr2 , n , m , x ) : s = set ( ) for i in range ( 0 , n ) : s.add ( arr1 [ i ] ) j = 0 while j in list ( range ( m ) ) : if ( ( x - arr2 [ j ] ) in s ) : print ( ( x - arr2 [ j ] ) , '' , arr2 [ j ] ) j += 1"
"def findArea ( arr , n ) : arr.sort ( reverse = True ) dimension = [ 0 , 0 ] i = 0 j = 0 while ( i < n - 1 and j < 2 ) : if ( arr [ i + 1 ] == arr [ i ] ) : dimension [ j ] = arr [ i ] j += 1 i += 1 i += 1 return ( dimension [ 0 ] * dimension [ 1 ] )"
"def minTime ( n , k , a ) : a.sort ( reverse = True ) minTime = 0 i = 0 while i in list ( range ( n ) ) : minTime += ( 2 * a [ i ] ) i += k return minTime"
def findLeft ( str ) : n = len ( str ) - 1 while ( 0 < n ) : if ( str [ n ] == 'd' ) : str = str [ 0 : n ] + 'c' + str [ n + 1 : ] break if ( str [ n ] == 'b' ) : str = str [ 0 : n ] + 'a' + str [ n + 1 : ] break if ( str [ n ] == 'a' ) : str = str [ 0 : n ] + 'b' + str [ n + 1 : ] elif ( str [ n ] == 'c' ) : str = str [ 0 : n ] + 'd' + str [ n + 1 : ] n -= 1 return str
def fact ( n ) : if ( 0 == n ) : return 1 return n * fact ( n - 1 )
"def maxTeams ( N1 , N2 ) : count = 0 while ( N1 > 0 and 0 < N2 and N1 + N2 >= 3 ) : if ( N1 > N2 ) : N1 -= 2 N2 -= 1 else : N1 -= 1 N2 -= 2 count = count + 1 return count"
"def printUnion ( arr1 , arr2 , m , n ) : i , j = 0 , 0 while i < m and n > j : if arr1 [ i ] < arr2 [ j ] : print ( arr1 [ i ] ) i += 1 elif arr2 [ j ] < arr1 [ i ] : print ( arr2 [ j ] ) j += 1 else : print ( arr2 [ j ] ) j += 1 i += 1 while i < m : print ( arr1 [ i ] ) i += 1 while j < n : print ( arr2 [ j ] ) j += 1"
"def findLength ( string ) : n = len ( string ) maxlen = 0 Sum = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] i = 0 while i in list ( range ( n ) ) : Sum [ i ] [ i ] = int ( string [ i ] ) i += 1 for length in range ( 2 , n + 1 ) : for i in range ( 0 , n - length + 1 ) : j = i + length - 1 k = length // 2 Sum [ i ] [ j ] = ( Sum [ i ] [ j - k ] + Sum [ j - k + 1 ] [ j ] ) if ( length % 2 == 0 and Sum [ i ] [ j - k ] == Sum [ ( j - k + 1 ) ] [ j ] and length > maxlen ) : maxlen = length return maxlen"
"def toNegativeBase ( n , negBase ) : if ( n == 0 ) : return """" converted = """" while ( n != 0 ) : remainder = n % ( negBase ) n = int ( n / negBase ) if ( remainder < 0 ) : remainder = remainder + ( ( - 1 ) * negBase ) n = n + 1 converted = str ( remainder ) + converted return converted"
"def noOfTriples ( arr , n ) : arr.sort ( ) count = 0 i = 0 while i in list ( range ( n ) ) : if arr [ i ] == arr [ 2 ] : count += 1 i += 1 if arr [ 0 ] == arr [ 2 ] : return ( count - 2 ) * ( count - 1 ) * ( count ) / 6 elif arr [ 1 ] == arr [ 2 ] : return ( count - 1 ) * ( count ) / 2 return count"
"def makePermutation ( a , n ) : count = dict ( ) for i in range ( n ) : if count.get ( a [ i ] ) : count [ a [ i ] ] += 1 else : count [ a [ i ] ] = 1 next_missing = 1 i = 0 while i in list ( range ( n ) ) : if count [ a [ i ] ] != 1 or a [ i ] > n or a [ i ] < 1 : count [ a [ i ] ] -= 1 while count.get ( next_missing ) : next_missing += 1 a [ i ] = next_missing count [ next_missing ] = 1 i += 1"
"def findString ( n , k ) : res = """" i = 0 while i in list ( range ( k ) ) : res = res + chr ( ord ( 'a' ) + i ) i += 1 count = 0 for i in range ( n - k ) : res = res + chr ( ord ( 'a' ) + count ) count += 1 if ( count == k ) : count = 0 return res"
"def isValidNesbitt ( a , b , c ) : A = a / ( b + c ) B = b / ( a + c ) C = c / ( a + b ) inequality = A + B + C return ( 1.5 <= inequality )"
"def countCommon ( mat , n ) : res = 0 i = 0 while i in list ( range ( n ) ) : if mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] : res = res + 1 i += 1 return res"
"def encrypt ( text , s ) : result = """" i = 0 while i in list ( range ( len ( text ) ) ) : char = text [ i ] if ( char.isupper ( ) ) : result += chr ( ( ord ( char ) + s - 65 ) % 26 + 65 ) else : result += chr ( ( ord ( char ) + s - 97 ) % 26 + 97 ) i += 1 return result"
"def count ( n , x ) : cnt = 0 i = 1 while i in list ( range ( n + 1 ) ) : if i <= x : if x // i <= n and x % i == 0 : cnt += 1 i += 1 return cnt"
"def encryptString ( string , n ) : i , cnt = 0 , 0 encryptedStr = """" while i < n : cnt = i + 1 while 0 < cnt : encryptedStr += string [ i ] cnt -= 1 i += 1 return encryptedStr"
"def getmax ( arr , n , x ) : s = 0 i = 0 while i in list ( range ( n ) ) : s = s + arr [ i ] i += 1 print ( min ( s , x ) )"
"def NumberOfSolutions ( a , b , c , d ) : ans = 0 i = a while i in list ( range ( b + 1 ) ) : if d >= max ( c , i + 1 ) : ans += d - max ( c , i + 1 ) + 1 i += 1 return ans"
def isMagic ( n ) : sum = 0 while ( 0 < n or sum > 9 ) : if ( n == 0 ) : n = sum sum = 0 sum = sum + n % 10 n = int ( n / 10 ) return True if ( sum == 1 ) else False
"def sumAtKthLevel ( tree , k ) : level = - 1 sum = 0 n = len ( tree ) i = 0 while i in list ( range ( n ) ) : if ( tree [ i ] == '(' ) : level += 1 elif ( tree [ i ] == ')' ) : level -= 1 else : if ( level == k ) : sum += ( ord ( tree [ i ] ) - ord ( '0' ) ) i += 1 return sum"
"def findLargestd ( S , n ) : found = False S.sort ( ) for i in range ( n - 1 , - 1 , - 1 ) : j = 0 while j in list ( range ( n ) ) : if ( i == j ) : j += 1 continue for k in range ( j + 1 , n ) : if ( i == k ) : j += 1 continue for l in range ( k + 1 , n ) : if ( i == l ) : j += 1 continue if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) : found = True j += 1 return S [ i ] j += 1 if ( found == False ) : return - 1"
"def deleteElements ( arr , n , k ) : st = [ ] st.append ( arr [ 0 ] ) top = 0 count = 0 i = 1 while i in list ( range ( n ) ) : while ( len ( st ) != 0 and count < k and st [ top ] < arr [ i ] ) : st.pop ( ) count += 1 top -= 1 st.append ( arr [ i ] ) top += 1 i += 1 for i in range ( 0 , len ( st ) ) : print ( st [ i ] , """" , end = """" )"
"def countCharacterType ( str ) : vowels = 0 consonant = 0 specialChar = 0 digit = 0 i = 0 while i in list ( range ( len ( str ) ) ) : ch = str [ i ] if ( ( ch >= 'a' and ch <= 'z' ) or ( ch >= 'A' and ch <= 'Z' ) ) : ch = ch.lower ( ) if ( ch == 'a' or ch == 'e' or ch == 'i' or ch == 'o' or ch == 'u' ) : vowels += 1 else : consonant += 1 elif ( ch >= '0' and ch <= '9' ) : digit += 1 else : specialChar += 1 i += 1 print ( ""Vowels:"" , vowels ) print ( ""Consonant:"" , consonant ) print ( ""Digit:"" , digit ) print ( ""SpecialCharacter:"" , specialChar )"
"def operations ( op , n , k ) : i , count = 0 , 0 nVal = 0 minimum = 10 ** 9 for i in range ( n ) : nVal += op [ i ] minimum = min ( minimum , nVal ) if ( ( k + nVal ) <= 0 ) : return ( i + 1 ) if ( nVal >= 0 ) : return - 1 times = ( k - abs ( minimum ) ) // abs ( nVal ) k = ( k - ( times * abs ( nVal ) ) ) count = ( times * n ) while ( k > 0 ) : i = 0 while i in list ( range ( n ) ) : k = k + op [ i ] count += 1 if ( k <= 0 ) : i += 1 break i += 1 return count"
"def solve ( i , x , dp ) : if ( i < 0 ) : return x == 3 if ( - 1 != dp [ i ] [ x ] ) : return dp [ i ] [ x ] dp [ i ] [ x ] = solve ( i - 1 , 0 , dp ) dp [ i ] [ x ] += solve ( i - 1 , x + 1 , dp ) return dp [ i ] [ x ]"
"def findOddPair ( A , N ) : count = 0 i = 0 while i in list ( range ( N ) ) : if ( A [ i ] % 2 == 0 ) : count += 1 i += 1 return count * ( N - count )"
"def countFreq ( arr , n ) : visited = [ False for i in range ( n ) ] for i in range ( n ) : if ( visited [ i ] == True ) : continue count = 1 j = i + 1 while j in list ( range ( n ) ) : if ( arr [ i ] == arr [ j ] ) : visited [ j ] = True count += 1 j += 1 print ( arr [ i ] , count )"
"def findSum ( n , a , b ) : sum = 0 i = 0 while i in list ( range ( n ) ) : if ( i % a == 0 or i % b == 0 ) : sum += i i += 1 return sum"
"def isPossible ( a , n ) : k = 0 i = 0 while i in list ( range ( n ) ) : if ( a [ i ] != i + 1 ) : k += 1 i += 1 if ( k <= 2 ) : return True return False"
"def findPairs ( arr , n ) : cntEven = 0 ; cntOdd = 0 for i in range ( n ) : if ( arr [ i ] % 2 == 0 ) : cntEven = cntEven + 1 else : cntOdd = cntOdd + 1 evenPairs = 0 evenPairs = evenPairs + ( ( cntEven * ( cntEven - 1 ) ) // 2 ) evenPairs = evenPairs + ( ( cntOdd * ( cntOdd - 1 ) ) // 2 ) oddPairs = 0 oddPairs = oddPairs + ( cntEven * cntOdd ) print ( """" , oddPairs ) print ( """" , evenPairs )"
"def equilibrium ( arr ) : total_sum = sum ( arr ) leftsum = 0 for i , num in enumerate ( arr ) : total_sum -= num if total_sum == leftsum : return i leftsum += num return - 1"
def nonFibonacci ( n ) : prevPrev = 1 prev = 2 curr = 3 while 0 < n : prevPrev = prev prev = curr curr = prevPrev + prev n = n - ( curr - prev - 1 ) n = n + ( curr - prev - 1 ) return prev + n
"def dealnnoy ( n , m ) : dp = [ [ 0 for x in range ( n + 1 ) ] for x in range ( m + 1 ) ] for i in range ( m ) : dp [ 0 ] [ i ] = 1 i = 1 while i in list ( range ( m + 1 ) ) : dp [ i ] [ 0 ] = 1 i += 1 for i in range ( 1 , m + 1 ) : for j in range ( 1 , n + 1 ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] return dp [ m ] [ n ]"
"def printPattern ( n ) : for i in range ( 1 , n + 1 ) : j = 1 while j in list ( range ( 2 * n ) ) : if ( j == ( n - i + 1 ) or j == ( n + i - 1 ) ) : print ( ""*"" , end = """" ) elif ( ( i >= 4 and i <= n - 4 ) and ( j == n - i + 4 or j == n + i - 4 ) ) : print ( ""*"" , end = """" ) elif ( i == n or ( i == n - 4 and j >= n - ( n - 2 * 4 ) and j <= n + n - 2 * 4 ) ) : print ( ""*"" , end = """" ) else : print ( """" + """" , end = """" ) j += 1 print ( )"
"def arrange ( N ) : if ( N == 1 ) : print ( ""1"" ) return if ( N == 2 or N == 3 ) : print ( ""-1"" ) return even = - 1 odd = - 1 if ( N % 2 != 0 ) : odd = N even = N - 1 else : even = N odd = N - 1 while ( odd >= 1 ) : print ( odd , end = """" ) odd = odd - 2 while ( even >= 2 ) : print ( even , end = """" ) even = even - 2"
"def minOperations ( A , n ) : if n & 1 : return - 1 zeros , consZeros , ones = 0 , 0 , 0 i = 0 while i in list ( range ( n ) ) : if A [ i ] : zeros += 1 else : ones += 1 if ( i + 1 < n ) : if A [ i ] == 0 and A [ i + 1 ] == 0 : consZeros += 1 i += 1 if A [ 0 ] == A [ n - 1 ] and A [ 0 ] == 0 : consZeros += 1 if zeros == ones : return consZeros else : return - 1"
def check ( st ) : n = len ( st ) if ( ( ( int ) ( st [ n - 1 ] ) % 2 ) != 0 ) : return False digitSum = 0 i = 0 while i in list ( range ( n ) ) : digitSum = digitSum + ( int ) ( st [ i ] ) i += 1 return ( digitSum % 3 == 0 )
"def isNumBalanced ( N ) : st = str ( N ) isBalanced = True freq = [ 0 ] * 10 n = len ( st ) for i in range ( 0 , n ) : freq [ int ( st [ i ] ) ] += 1 for i in range ( 0 , 9 ) : if freq [ i + 1 ] != freq [ i ] : isBalanced = False if isBalanced : return True else : return False"
"def printDiamond ( n ) : print ( """" ) j = 0 for i in range ( 0 , n ) : for j in range ( i , n ) : print ( ""*"" , end = """" ) for j in range ( 0 , 2 * i + 1 ) : print ( """" , end = """" ) j = i while j in list ( range ( n ) ) : print ( ""*"" , end = """" ) j += 1 print ( """" ) for i in range ( 0 , n - 1 ) : for j in range ( 0 , i + 2 ) : print ( ""*"" , end = """" ) for j in range ( 0 , 2 * ( n - 1 - i ) - 1 ) : print ( """" , end = """" ) for j in range ( 0 , i + 2 ) : print ( ""*"" , end = """" ) print ( """" ) print ( """" )"
"def isSubsetSum ( set , n , sum ) : if ( sum == 0 ) : return True if ( n == 0 and 0 != sum ) : return False if ( set [ n - 1 ] > sum ) : return isSubsetSum ( set , n - 1 , sum ) return isSubsetSum ( set , n - 1 , sum ) or isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] )"
"def K_String ( s , k ) : n = len ( s ) fre = [ 0 ] * 26 for i in range ( n ) : fre [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1 str = """" i = 0 while i in list ( range ( 26 ) ) : if ( fre [ i ] % k == 0 ) : x = fre [ i ] // k while ( x ) : str += chr ( i + ord ( 'a' ) ) x -= 1 else : i += 1 return ""-1"" i += 1 return str"
"def reArrange ( words , n ) : mp = { } for i in range ( n ) : mp [ words [ i ] ] = i + 1 words.sort ( ) i = 0 while i in list ( range ( n ) ) : print ( mp [ words [ i ] ] , end = """" ) i += 1"
def RSF ( n ) : while ( n >= 10 ) : x = n l = 0 while ( n > 0 ) : n = n // 10 l += 1 a = [ 0 ] * l i = l - 1 while ( x > 0 ) : a [ i ] = x % 10 x = x // 10 i -= 1 j = 0 while j in list ( range ( l - 1 ) ) : n = n * 10 + abs ( a [ j ] - a [ j + 1 ] ) j += 1 return n
def topsyTurvy ( string ) : i = 0 while i in list ( range ( len ( string ) ) ) : if ( string [ i ] == '2' or string [ i ] == '4' or string [ i ] == '5' or string [ i ] == '6' or string [ i ] == '7' or string [ i ] == '9' ) : i += 1 return False i += 1 return True
"def getCount ( N ) : if ( N % 2 == 1 ) : return ""0"" result = ""9"" i = 1 while i in list ( range ( N // 2 ) ) : result = result + ""0"" i += 1 return result"
"def get_maximum ( s , a ) : s = list ( s ) n = len ( s ) i = 0 while i in list ( range ( n ) ) : if ( ord ( s [ i ] ) - ord ( '0' ) < a [ ord ( s [ i ] ) - ord ( '0' ) ] ) : j = i while ( j < n and ( ord ( s [ j ] ) - ord ( '0' ) <= a [ ord ( s [ j ] ) - ord ( '0' ) ] ) ) : s [ j ] = chr ( ord ( '0' ) + a [ ord ( s [ j ] ) - ord ( '0' ) ] ) j += 1 i += 1 return """".join ( s ) i += 1 return s"
"def calculateSum ( n , k ) : res = 1 MOD = 1000000007 i = 0 while i in list ( range ( k ) ) : res = ( res * n ) % MOD i += 1 return res"
"def printDiagonalSums ( mat , n ) : principal = 0 secondary = 0 for i in range ( 0 , n ) : principal = principal + mat [ i ] [ i ] secondary = secondary + mat [ i ] [ n - i - 1 ] print ( """" , principal ) print ( """" , secondary )"
def longest_gap ( N ) : distance = 0 count = 0 first_1 = - 1 last_1 = - 1 while ( N > 0 ) : count += 1 r = N & 1 if ( r == 1 ) : if first_1 == - 1 : first_1 = count else : first_1 = first_1 last_1 = count N = N // 2 if ( last_1 > first_1 ) : distance = last_1 - first_1 - 1 return distance else : return - 1
"def productDivisible ( n , k ) : product = 1 position = 1 while n > 0 : if position % 2 == 0 : product *= n % 10 n = n / 10 position += 1 if 0 == product % k : return True return False"
def isTwoAlter ( s ) : i = 0 while i in list ( range ( len ( s ) - 2 ) ) : if ( s [ i ] != s [ i + 2 ] ) : i += 1 return False i += 1 if ( s [ 0 ] == s [ 1 ] ) : return False return True
"def fib ( n ) : a = 0 b = 1 if ( n >= 0 ) : print ( a , end = '' ) if ( n >= 1 ) : print ( b , end = '' ) i = 2 while i in list ( range ( n + 1 ) ) : print ( a + b , end = '' ) b = a + b a = b - a i += 1"
def isMajority ( a ) : mp = { } for i in a : if i in mp : mp [ i ] += 1 else : mp [ i ] = 1 for x in mp : if len ( a ) // 2 <= mp [ x ] : return True return False
"def findCombinations ( string , index , out ) : if index == len ( string ) : print ( out ) i = index while i in list ( range ( len ( string ) ) ) : findCombinations ( string , i + 1 , out + ""("" + string [ index : i + 1 ] + "")"" ) i += 1"
def productEqual ( n ) : if n < 10 : return False prodOdd = 1 ; prodEven = 1 while n > 0 : digit = n % 10 prodOdd *= digit n = n // 10 if n == 0 : break digit = n % 10 prodEven *= digit n = n // 10 if prodEven == prodOdd : return True return False
"def minValue ( A , B , n ) : sorted ( A ) sorted ( B ) result = 0 i = 0 while i in list ( range ( n ) ) : result += ( A [ i ] * B [ n - i - 1 ] ) i += 1 return result"
"def isSubSequence ( string1 , string2 , m , n ) : if m == 0 : return True if 0 == n : return False if string1 [ m - 1 ] == string2 [ n - 1 ] : return isSubSequence ( string1 , string2 , m - 1 , n - 1 ) return isSubSequence ( string1 , string2 , m , n - 1 )"
"def minSum ( arr , n ) : sum = arr [ 0 ] ; prev = arr [ 0 ] i = 1 while i in list ( range ( n ) ) : if arr [ i ] <= prev : prev = prev + 1 sum = sum + prev else : sum = sum + arr [ i ] prev = arr [ i ] i += 1 return sum"
"def countSubstr ( s , k ) : n = len ( s ) l = n - 1 r = n - 1 arr = [ 0 ] * n last_indexof1 = - 1 for i in range ( n ) : if ( s [ i ] == '1' ) : arr [ i ] = i last_indexof1 = i else : arr [ i ] = last_indexof1 no_of_substr = 0 r = n - 1 while r in list ( range ( - 1 ) ) : l = r while ( l >= 0 and ( r - l + 1 ) <= 64 and int ( s [ l : r + 1 ] , 2 ) < k ) : l -= 1 if ( r - l + 1 <= 64 ) : no_of_substr += l + 1 else : no_of_substr += arr [ l + 1 ] + 1 r += - 1 return no_of_substr"
"def CheckSubarray ( arr , N ) : presum = [ 0 for i in range ( N + 1 ) ] i = 1 while i in list ( range ( N + 1 ) ) : presum [ i ] = presum [ i - 1 ] + arr [ i - 1 ] i += 1 moduloclass = [ [ ] ] * N for i in range ( 1 , N + 1 , 1 ) : moduloclass [ presum [ i ] % N ].append ( i - 1 ) if ( len ( moduloclass [ 0 ] ) > 0 ) : print ( 0 + 1 , moduloclass [ 0 ] [ 0 ] + 2 ) return for i in range ( 1 , N ) : if ( len ( moduloclass [ i ] ) >= 2 ) : print ( moduloclass [ i ] [ 0 ] + 1 , moduloclass [ i ] [ 1 ] ) return"
"def xorGivenSetBits ( arr , n , k ) : v = [ ] for i in range ( 0 , n , 1 ) : if ( bin ( arr [ i ] ).count ( '1' ) == k ) : v.append ( arr [ i ] ) result = v [ 0 ] i = 1 while i in list ( range ( len ( v ) ) ) : result = result ^ v [ i ] i += 1 return result"
"def areElementsContiguous ( arr , n ) : max1 = max ( arr ) min1 = min ( arr ) m = max1 - min1 + 1 if ( m > n ) : return False visited = [ 0 ] * m for i in range ( 0 , n ) : visited [ arr [ i ] - min1 ] = True i = 0 while i in list ( range ( m ) ) : if ( visited [ i ] == False ) : i += 1 return False i += 1 return True"
"def findBalance ( x , bal ) : if ( x % 10 == 0 and bal >= ( x + 1.50 ) ) : print ( round ( bal - x - 1.50 , 2 ) ) else : print ( round ( bal , 2 ) )"
"def maxProductSum ( string , m ) : n = len ( string ) maxProd , maxSum = ( - ( sys.maxsize ) - 1 , - ( sys.maxsize ) - 1 ) i = 0 while i in list ( range ( n - m ) ) : product , sum = 1 , 0 for j in range ( i , m + i ) : product = product * ( ord ( string [ j ] ) - ord ( '0' ) ) sum = sum + ( ord ( string [ j ] ) - ord ( '0' ) ) maxProd = max ( maxProd , product ) maxSum = max ( maxSum , sum ) i += 1 print ( ""MaximumProduct="" , maxProd ) print ( ""Maximumsum="" , maxSum )"
"def max_sum ( a , n ) : dp = [ [ 0 for i in range ( 2 ) ] for j in range ( n + 1 ) ] dp [ 0 ] [ 0 ] = 0 ; dp [ 0 ] [ 1 ] = - 999999 i = 0 while i in list ( range ( n ) ) : dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 0 ] + a [ i ] , dp [ i ] [ 1 ] - a [ i ] ) dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] - a [ i ] , dp [ i ] [ 1 ] + a [ i ] ) i += 1 return dp [ n ] [ 0 ]"
"def countPairs ( arr , k ) : arr.sort ( ) pair = 0 index = 0 while ( index < len ( arr ) - 1 ) : if arr [ index + 1 ] - arr [ index ] <= k : pair = pair + 1 index = index + 2 else : index = index + 1 return pair"
"def solve ( a , b ) : if ( a > 0 and b > 0 ) : print ( ""Positive"" ) elif ( a <= 0 and b >= 0 ) : print ( ""Zero"" ) else : n = abs ( a - b ) + 1 if ( 0 == n % 2 ) : print ( ""Positive"" ) else : print ( ""Negative"" )"
"def createSorted ( a : list , n : int ) : b = [ ] j = 0 while j in list ( range ( n ) ) : if len ( b ) == 0 : b.append ( a [ j ] ) else : start = 0 end = len ( b ) - 1 pos = 0 while start <= end : mid = start + ( end - start ) // 2 if b [ mid ] == a [ j ] : b.insert ( max ( 0 , mid + 1 ) , a [ j ] ) j += 1 break elif b [ mid ] > a [ j ] : pos = end = mid - 1 else : pos = start = mid + 1 if start > end : pos = start b.insert ( max ( 0 , pos ) , a [ j ] ) j += 1 break j += 1 for i in range ( n ) : print ( b [ i ] , end = """" )"
"def minRemove ( arr , n ) : LIS = [ 0 for i in range ( n ) ] len = 0 for i in range ( n ) : LIS [ i ] = 1 for i in range ( 1 , n ) : j = 0 while j in list ( range ( i ) ) : if ( arr [ i ] > arr [ j ] and ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) : LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) j += 1 len = max ( len , LIS [ i ] ) return ( n - len )"
def fib ( n ) : if ( 1 >= n ) : return n return fib ( n - 1 ) + fib ( n - 2 )
"def power ( n , r , mod = 10 ** 9 + 7 ) : if 0 == r : return 1 if r % 2 == 0 : return power ( n * n % mod , r // 2 , mod ) % mod if r % 2 == 1 : return n * power ( n , r - 1 , mod ) % mod"
"def xorOdd ( arr , n ) : m = dict.fromkeys ( arr , 0 ) i = 0 while i in list ( range ( n ) ) : m [ arr [ i ] ] += 1 i += 1 xorArr = 0 for key , value in m.items ( ) : if ( value & 1 ) : xorArr ^= key return xorArr"
"def find ( list1 , list2 ) : res = [ ] max_possible_sum = len ( list1 ) + len ( list2 ) - 2 for sum in range ( max_possible_sum + 1 ) : for i in range ( sum + 1 ) : if ( i < len ( list1 ) and ( sum - i ) < len ( list2 ) and list1 [ i ] == list2 [ sum - i ] ) : res.append ( list1 [ i ] ) if ( len ( res ) > 0 ) : break i = 0 while i in list ( range ( len ( res ) ) ) : print ( res [ i ] , end = """" ) i += 1"
def countDyckPaths ( n ) : res = 1 i = 0 while i in list ( range ( n ) ) : res *= ( 2 * n - i ) res /= ( i + 1 ) i += 1 return res / ( n + 1 )
def check ( n ) : return 0 == 1162261467 % n
"def check ( a , y ) : sum = 0 i = 0 while i in list ( range ( len ( a ) ) ) : x = math.sqrt ( a [ i ] ) if ( math.floor ( x ) == math.ceil ( x ) ) : sum = sum + a [ i ] i += 1 if ( sum % y == 0 ) : return True else : return False"
"def printInSortedOrder ( arr , n ) : index = [ 0 ] * n for i in range ( n ) : index [ i ] = i for i in range ( n - 1 ) : min = i j = i + 1 while j in list ( range ( n ) ) : if ( arr [ index [ min ] ] > arr [ index [ j ] ] ) : min = j j += 1 if ( min != i ) : index [ min ] , index [ i ] = index [ i ] , index [ min ] for i in range ( n ) : print ( arr [ index [ i ] ] , end = """" )"
"def findLength ( string , n ) : Sum = [ 0 ] * ( n + 1 ) for i in range ( 1 , n + 1 ) : Sum [ i ] = ( Sum [ i - 1 ] + int ( string [ i - 1 ] ) ) ans = 0 length = 2 while length in list ( range ( n + 1 ) ) : for i in range ( 0 , n - length + 1 ) : j = i + length - 1 if ( Sum [ i + length // 2 ] - Sum [ i ] == Sum [ i + length ] - Sum [ i + length // 2 ] ) : ans = max ( ans , length ) length += 2 return ans"
"def SectorArea ( radius , angle ) : pi = 22 / 7 if 360 <= angle : print ( ""Anglenotpossible"" ) return else : sector = ( pi * radius ** 2 ) * ( angle / 360 ) print ( sector ) return"
"def sumOfDigitsFrom1ToN ( n ) : if ( n < 10 ) : return ( n * ( n + 1 ) / 2 ) d = ( int ) ( math.log10 ( n ) ) a = [ 0 ] * ( d + 1 ) a [ 0 ] = 0 a [ 1 ] = 45 i = 2 while i in list ( range ( d + 1 ) ) : a [ i ] = a [ i - 1 ] * 10 + 45 * ( int ) ( math.ceil ( math.pow ( 10 , i - 1 ) ) ) i += 1 p = ( int ) ( math.ceil ( math.pow ( 10 , d ) ) ) msd = n // p return ( int ) ( msd * a [ d ] + ( msd * ( msd - 1 ) // 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToN ( n % p ) )"
"def countDivisibles ( A , B , M ) : if ( 0 == A % M ) : return ( ( B / M ) - ( A / M ) ) + 1 return ( ( B / M ) - ( A / M ) )"
"def totalSum ( a , n ) : sum = 0 i = 0 while i in list ( range ( n ) ) : sum1 = 0 for j in range ( i , n ) : sum1 = ( sum1 | a [ j ] ) sum = sum + sum1 i += 1 return sum"
"def countSubstr ( str , n , x , y ) : tot_count = 0 count_x = 0 i = 0 while i in list ( range ( n ) ) : if str [ i ] == x : count_x += 1 if str [ i ] == y : tot_count += count_x i += 1 return tot_count"
"def findMinSum ( a , b , n ) : a.sort ( ) b.sort ( ) sum = 0 i = 0 while i in list ( range ( n ) ) : sum = sum + abs ( a [ i ] - b [ i ] ) i += 1 return sum"
"def missingK ( a , k , n ) : difference = 0 ans = 0 count = k flag = 0 i = 0 while i in list ( range ( n - 1 ) ) : difference = 0 if ( ( a [ i ] + 1 ) != a [ i + 1 ] ) : difference += ( a [ i + 1 ] - a [ i ] ) - 1 if ( difference >= count ) : ans = a [ i ] + count flag = 1 i += 1 break else : count -= difference i += 1 if ( flag ) : return ans else : return - 1"
"def findNum ( div , rem , N ) : num = rem [ N - 1 ] i = N - 2 while ( 0 <= i ) : num = num * div [ i ] + rem [ i ] i -= 1 return num"
"def minTimeForWritingChars ( N , insrt , remov , cpy ) : if N == 0 : return 0 if N == 1 : return insrt dp = [ 0 ] * ( N + 1 ) i = 1 while i in list ( range ( N + 1 ) ) : if i % 2 == 0 : dp [ i ] = min ( dp [ i - 1 ] + insrt , dp [ i // 2 ] + cpy ) else : dp [ i ] = min ( dp [ i - 1 ] + insrt , dp [ ( i + 1 ) // 2 ] + cpy + remov ) i += 1 return dp [ N ]"
"def search ( arr , n , x ) : i = 0 while ( n > i ) : if ( arr [ i ] == x ) : return i i = i + abs ( arr [ i ] - x ) print ( ""numberisnotpresent!"" ) return - 1"
"def floorAndCeil ( arr , n , x ) : fDist = sys.maxsize cDist = sys.maxsize i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] >= x and cDist > ( arr [ i ] - x ) ) : cInd = i cDist = arr [ i ] - x if ( arr [ i ] <= x and fDist > ( x - arr [ i ] ) ) : fInd = i fDist = x - arr [ i ] i += 1 if ( fDist == sys.maxsize ) : print ( ""Floordoesn'texist"" ) else : print ( ""Flooris"" + str ( arr [ fInd ] ) ) if ( cDist == sys.maxsize ) : print ( ""Ceildoesn'texist"" ) else : print ( ""Ceilis"" + str ( arr [ cInd ] ) )"
"def encodedChar ( str , k ) : expand = """" freq = 0 i = 0 while ( i < len ( str ) ) : temp = """" freq = 0 while ( i < len ( str ) and ord ( str [ i ] ) >= ord ( '' ) and ord ( str [ i ] ) <= ord ( '' ) ) : temp = temp + str [ i ] i = i + 1 while ( i < len ( str ) and ord ( str [ i ] ) >= ord ( '' ) and ord ( str [ i ] ) <= ord ( '' ) ) : freq = freq * 10 + ord ( str [ i ] ) - ord ( '' ) i = i + 1 for j in range ( 1 , freq + 1 , 1 ) : expand = expand + temp if ( freq == 0 ) : expand = expand + temp return expand [ k - 1 ]"
"def findDivisors ( n ) : div = [ 0 for i in range ( n + 1 ) ] for i in range ( 1 , n + 1 ) : j = 1 while j in list ( range ( n + 1 ) ) : if j * i <= n : div [ i * j ] += 1 j += 1 for i in range ( 1 , n + 1 ) : print ( div [ i ] , end = """" )"
"def averageOdd ( n ) : if ( 0 == n % 2 ) : print ( ""InvalidInput"" ) return - 1 return ( n + 1 ) // 2"
"def countWays ( n ) : counter = 0 for i in range ( 1 , n ) : for j in range ( i , n ) : for k in range ( j , n ) : l = k while l in list ( range ( n ) ) : if ( i + j + k + l == n ) : counter += 1 l += 1 return counter"
"def find_set ( n ) : if ( 2 >= n ) : print ( ""-1"" ) return sum1 = ( n * ( n - 1 ) ) / 2 sum2 = n print ( sum1 , """" , sum2 )"
"def checkIfSortRotated ( arr , n ) : minEle = sys.maxsize maxEle = - sys.maxsize - 1 minIndex = - 1 for i in range ( n ) : if arr [ i ] < minEle : minEle = arr [ i ] minIndex = i flag1 = 1 i = 1 while i in list ( range ( minIndex ) ) : if arr [ i ] < arr [ i - 1 ] : flag1 = 0 i += 1 break i += 1 flag2 = 2 for i in range ( minIndex + 1 , n ) : if arr [ i ] < arr [ i - 1 ] : flag2 = 0 break if ( flag1 and flag2 and arr [ n - 1 ] < arr [ minIndex - 1 ] ) : print ( ""YES"" ) else : print ( ""NO"" )"
"def printbinomial ( max ) : for m in range ( max + 1 ) : print ( '%2d' % m , end = '' ) binom = 1 x = 0 while x in list ( range ( m + 1 ) ) : if m != 0 and x != 0 : binom = binom * ( m - x + 1 ) / x print ( '%4d' % binom , end = '' ) x += 1 print ( ""\n"" , end = '' )"
def printSeriesSum ( N ) : sum = 0 i = 1 while i in list ( range ( N + 1 ) ) : if ( i & 1 ) : sum += i / ( i + 1 ) else : sum -= i / ( i + 1 ) i += 1 print ( sum )
def avoidObstacles ( obs ) : obs = sorted ( obs ) jump_dist = 1 obstacle_hit = True while ( obstacle_hit ) : obstacle_hit = False jump_dist += 1 i = 0 while i in list ( range ( len ( obs ) ) ) : if obs [ i ] % jump_dist == 0 : obstacle_hit = True i += 1 break i += 1 return jump_dist
"def swap ( xp , yp ) : if ( yp [ 0 ] == xp [ 0 ] ) : return xp [ 0 ] = xp [ 0 ] + yp [ 0 ] yp [ 0 ] = xp [ 0 ] - yp [ 0 ] xp [ 0 ] = xp [ 0 ] - yp [ 0 ]"
"def minimunMoves ( arr , n ) : ans = sys.maxsize for i in range ( n ) : curr_count = 0 j = 0 while j in list ( range ( n ) ) : tmp = arr [ j ] + arr [ j ] index = tmp.find ( arr [ i ] ) if ( index == len ( arr [ i ] ) ) : j += 1 return - 1 curr_count += index j += 1 ans = min ( curr_count , ans ) return ans"
"def maxRevenue ( m , x , revenue , n , t ) : maxRev = [ 0 ] * ( m + 1 ) nxtbb = 0 i = 1 while i in list ( range ( m + 1 ) ) : if ( nxtbb < n ) : if ( x [ nxtbb ] != i ) : maxRev [ i ] = maxRev [ i - 1 ] else : if ( i <= t ) : maxRev [ i ] = max ( maxRev [ i - 1 ] , revenue [ nxtbb ] ) else : maxRev [ i ] = max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) nxtbb += 1 else : maxRev [ i ] = maxRev [ i - 1 ] i += 1 return maxRev [ m ]"
def check ( st ) : n = len ( st ) digitSum = 0 i = 0 while i in list ( range ( n ) ) : digitSum = digitSum + ( int ) ( st [ i ] ) i += 1 return ( digitSum % 9 == 0 )
"def distancesum ( x , y , n ) : sum = 0 i = 0 while i in list ( range ( n ) ) : for j in range ( i + 1 , n ) : sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) ) i += 1 return sum"
def canMakeAllSame ( str ) : zeros = 0 ones = 0 i = 0 while i in list ( range ( len ( str ) ) ) : ch = str [ i ] if ( ch == '0' ) : zeros = zeros + 1 else : ones = ones + 1 i += 1 return ( zeros == 1 or ones == 1 )
"def sumKRepeating ( arr , n , k ) : Sum = 0 mp = dict ( ) i = 0 while i in list ( range ( n ) ) : if arr [ i ] in mp.keys ( ) : mp [ arr [ i ] ] += 1 else : mp [ arr [ i ] ] = 1 i += 1 for x in mp : if ( mp [ x ] == k ) : Sum += x return Sum"
def findPattern ( n ) : prev = n % 2 n = n // 2 while ( 0 < n ) : curr = n % 2 if ( curr == prev ) : return False prev = curr n = n // 2 return True
"def remove_row_col ( arr , n , x ) : for i in range ( x , n ) : j = x while j in list ( range ( n ) ) : print ( arr [ i ] [ j ] , end = """" ) j += 1 print ( )"
"def maxProd ( N ) : if ( 0 == N ) : return 1 if ( N < 10 ) : return N return max ( maxProd ( N // 10 ) * ( N % 10 ) , maxProd ( N // 10 - 1 ) * 9 )"
"def check ( degree , n ) : deg_sum = sum ( degree ) if ( deg_sum == 2 * ( n - 1 ) ) : return True else : return False"
"def average ( a , n ) : sum = 0 i = 0 while i in list ( range ( n ) ) : sum += a [ i ] i += 1 return sum / n"
"def countPairs ( arr , n ) : countZero = 0 countTwo = 0 i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] == 0 ) : countZero += 1 elif ( arr [ i ] == 2 ) : countTwo += 1 i += 1 pair0 = ( countZero * ( countZero - 1 ) ) // 2 pair2 = ( countTwo * ( countTwo - 1 ) ) // 2 return pair0 + pair2"
"def solve ( s ) : m = dict ( ) for i in range ( len ( s ) ) : if s [ i ] in m : m [ s [ i ] ] = m [ s [ i ] ] + 1 else : m [ s [ i ] ] = 1 new_string = """" i = 0 while i in list ( range ( len ( s ) ) ) : if m [ s [ i ] ] % 2 == 0 : i += 1 continue new_string = new_string + s [ i ] i += 1 print ( new_string )"
"def bubble_sort ( N , A ) : cnt = 0 last = N - 1 while last > 0 : k = 0 while k in list ( range ( last ) ) : if A [ k ] > A [ k + 1 ] : A [ k ] , A [ k + 1 ] = A [ k + 1 ] , A [ k ] cnt += 1 k += 1 last -= 1 return cnt"
"def LowerInsertionPoint ( arr , n , X ) : if ( X < arr [ 0 ] ) : return 0 elif ( X > arr [ n - 1 ] ) : return n lowerPnt = 0 i = 1 while ( i < n and arr [ i ] < X ) : lowerPnt = i i = i * 2 while ( lowerPnt < n and X > arr [ lowerPnt ] ) : lowerPnt += 1 return lowerPnt"
"def segregate0and1 ( arr , size ) : type0 = 0 type1 = size - 1 while ( type0 < type1 ) : if ( arr [ type0 ] != 1 ) : type0 += 1 else : ( arr [ type0 ] , arr [ type1 ] ) = ( arr [ type1 ] , arr [ type0 ] ) type1 -= 1"
"def countIntervals ( arr , V , N ) : count = 0 i = 0 while i in list ( range ( N ) ) : li = arr [ i ] [ 0 ] ri = arr [ i ] [ 1 ] if ( V >= li and V <= ri ) : count += 1 i += 1 return count"
"def printPrevSmaller ( arr , n ) : S = list ( ) i = 0 while i in list ( range ( n ) ) : while ( len ( S ) > 0 and S [ - 1 ] >= arr [ i ] ) : S.pop ( ) if ( len ( S ) == 0 ) : print ( ""_,"" , end = """" ) else : print ( S [ - 1 ] , end = "","" ) S.append ( arr [ i ] ) i += 1"
def isPrime ( p ) : checkNumber = 2 ** p - 1 nextval = 4 % checkNumber i = 1 while i in list ( range ( p - 1 ) ) : nextval = ( nextval * nextval - 2 ) % checkNumber i += 1 if ( nextval == 0 ) : return True else : return False
"def find ( n , k ) : if ( k <= n + 1 ) : return ( k - 1 ) else : return ( 2 * n + 1 - k )"
def longestPrefixSuffix ( s ) : n = len ( s ) lps = [ 0 ] * n l = 0 i = 1 while ( i < n ) : if ( s [ i ] != s [ l ] ) : if ( l != 0 ) : l = lps [ l - 1 ] else : lps [ i ] = 0 i = i + 1 else : l = l + 1 lps [ i ] = l i = i + 1 res = lps [ n - 1 ] if ( res > n / 2 ) : return n // 2 else : return res
def binaryToDecimal ( n ) : num = n dec_value = 0 base1 = 1 len1 = len ( num ) i = len1 - 1 while i in list ( range ( - 1 ) ) : if ( num [ i ] == '1' ) : dec_value += base1 base1 = base1 * 2 i += - 1 return dec_value
"def checkUnimodal ( arr , n ) : i = 1 while ( n > i and arr [ i ] > arr [ i - 1 ] ) : i += 1 while ( i < n and arr [ i ] == arr [ i - 1 ] ) : i += 1 while ( i < n and arr [ i ] < arr [ i - 1 ] ) : i += 1 return ( i == n )"
def octalToDecimal ( n ) : num = n dec_value = 0 base = 1 temp = num while ( temp ) : last_digit = temp % 10 temp = int ( temp / 10 ) dec_value = dec_value + last_digit * base base = base * 8 return dec_value
"def decToHexa ( n ) : hexaDeciNum = [ '0' ] * 100 i = 0 while ( n != 0 ) : temp = 0 temp = n % 16 if ( temp < 10 ) : hexaDeciNum [ i ] = chr ( temp + 48 ) i = i + 1 else : hexaDeciNum [ i ] = chr ( temp + 55 ) i = i + 1 n = int ( n / 16 ) j = i - 1 while ( 0 <= j ) : print ( ( hexaDeciNum [ j ] ) , end = """" ) j = j - 1"
"def product ( a , n ) : ans = 1 val = pow ( 2 , n - 1 ) i = 0 while i in list ( range ( n ) ) : ans *= pow ( a [ i ] , val ) i += 1 return ans"
"def count_unique ( s , n ) : if ( s.count ( n ) ) : return s.append ( n ) n = n + 1 while ( n % 10 == 0 ) : n = n // 10 count_unique ( s , n )"
"def chordCnt ( A ) : n = 2 * A dpArray = [ 0 ] * ( n + 1 ) dpArray [ 0 ] = 1 dpArray [ 2 ] = 1 for i in range ( 4 , n + 1 , 2 ) : j = 0 while j in list ( range ( i - 1 ) ) : dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 - j ] ) j += 2 return int ( dpArray [ n ] )"
"def pattern ( n ) : k = 1 for i in range ( 1 , n + 1 ) : p = k j = 1 while j in list ( range ( i + 1 ) ) : print ( p , end = """" ) p = p - ( n + j - i ) j += 1 print ( """" ) k = k + 1 + n - i"
def isDivisibleBy10 ( bin ) : n = len ( bin ) if ( bin [ n - 1 ] == '1' ) : return False sum = 0 i = n - 2 while i >= 0 : if ( bin [ i ] == '1' ) : posFromRight = n - i - 1 if ( posFromRight % 4 == 1 ) : sum = sum + 2 elif ( posFromRight % 4 == 2 ) : sum = sum + 4 elif ( 3 == posFromRight % 4 ) : sum = sum + 8 elif ( posFromRight % 4 == 0 ) : sum = sum + 6 i = i - 1 if ( sum % 10 == 0 ) : return True return False
"def substringConversions ( s , k , b ) : l = len ( s ) i = 0 while i in list ( range ( l ) ) : if ( ( i + k ) < l + 1 ) : sub = s [ i : i + k ] sum , counter = 0 , 0 for i in range ( len ( sub ) - 1 , - 1 , - 1 ) : sum = sum + ( ( ord ( sub [ i ] ) - ord ( '0' ) ) * pow ( b , counter ) ) counter += 1 print ( sum , end = """" ) i += 1"
"def isProduct ( arr , n , x ) : if n < 2 : return False s = set ( ) i = 0 while i in list ( range ( n ) ) : if arr [ i ] == 0 : if x == 0 : i += 1 return True else : i += 1 continue if x % arr [ i ] == 0 : if x // arr [ i ] in s : i += 1 return True s.add ( arr [ i ] ) i += 1 return False"
"def isPossible ( l , m , x , y ) : if ( x + y == l * m ) : return True return False"
"def calc ( x , k ) : i = 0 ans = 0 while x >= k ** i : ans = ans + x // ( k ** i ) i = i + 1 return ans"
"def countPaths ( n , m ) : if ( 0 == n or m == 0 ) : return 1 return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) )"
"def solve ( dp , wt , K , M , used ) : if ( wt < 0 ) : return 0 if ( wt == 0 ) : if ( used ) : return 1 return 0 if ( dp [ wt ] [ used ] != - 1 ) : return dp [ wt ] [ used ] ans = 0 i = 1 while i in list ( range ( K + 1 ) ) : if ( i >= M ) : ans += solve ( dp , wt - i , K , M , used | 1 ) else : ans += solve ( dp , wt - i , K , M , used ) i += 1 dp [ wt ] [ used ] = ans return ans"
def evenFibSum ( limit ) : if ( limit < 2 ) : return 0 ef1 = 0 ef2 = 2 sm = ef1 + ef2 while ( limit >= ef2 ) : ef3 = 4 * ef2 + ef1 if ( ef3 > limit ) : break ef1 = ef2 ef2 = ef3 sm = sm + ef2 return sm
def isDivisiblePalindrome ( n ) : hash = [ 0 ] * 10 digitSum = 0 while ( n ) : digitSum += n % 10 hash [ n % 10 ] += 1 n //= 10 if ( digitSum % 3 != 0 ) : return False oddCount = 0 i = 0 while i in list ( range ( 10 ) ) : if ( hash [ i ] % 2 != 0 ) : oddCount += 1 i += 1 if ( oddCount > 1 ) : return False else : return True
def TrialDivision ( N ) : i = 2 k = int ( N ** 0.5 ) while ( i <= k ) : if ( N % i == 0 ) : return 0 i = i + 1 return 1
"def findGreatest ( arr , n ) : result = - 1 for i in range ( n ) : j = 0 while j in list ( range ( n - 1 ) ) : for k in range ( j + 1 , n ) : if ( arr [ j ] * arr [ k ] == arr [ i ] ) : result = max ( result , arr [ i ] ) j += 1 return result"
"def indexOfFirstOne ( arr , low , high ) : while ( low <= high ) : mid = int ( ( low + high ) / 2 ) if ( arr [ mid ] == 1 and ( mid == 0 or 0 == arr [ mid - 1 ] ) ) : return mid elif ( arr [ mid ] == 1 ) : high = mid - 1 else : low = mid + 1 return - 1"
"def antiSpiralTraversal ( m , n , a ) : k = 0 l = 0 stk = [ ] while ( k <= m and l <= n ) : i = l while i in list ( range ( n + 1 ) ) : stk.append ( a [ k ] [ i ] ) i += 1 k += 1 for i in range ( k , m + 1 ) : stk.append ( a [ i ] [ n ] ) n -= 1 if ( k <= m ) : for i in range ( n , l - 1 , - 1 ) : stk.append ( a [ m ] [ i ] ) m -= 1 if ( l <= n ) : for i in range ( m , k - 1 , - 1 ) : stk.append ( a [ i ] [ l ] ) l += 1 while len ( stk ) != 0 : print ( str ( stk [ - 1 ] ) , end = """" ) stk.pop ( )"
"def isPrime ( a , lower , upper ) : n = 0 i = lower - 1 while i in list ( range ( upper ) ) : n = n + a [ i ] i += 1 if ( n <= 1 ) : return False for i in range ( 2 , n ) : if ( n % i == 0 ) : return False return True"
def count ( n ) : dp = [ 0 for _ in range ( n + 1 ) ] i = 1 while i in list ( range ( n + 1 ) ) : if i <= 3 : dp [ i ] = 1 elif i == 4 : dp [ i ] = 2 else : dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] i += 1 return dp [ n ]
"def maxTripletSum ( arr , n ) : maxA = - 100000000 maxB = - 100000000 maxC = - 100000000 i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] > maxA ) : maxC = maxB maxB = maxA maxA = arr [ i ] elif ( arr [ i ] > maxB ) : maxC = maxB maxB = arr [ i ] elif ( arr [ i ] > maxC ) : maxC = arr [ i ] i += 1 return ( maxA + maxB + maxC )"
"def minSwaps ( s1 , s2 ) : c0 = 0 ; c1 = 0 i = 0 while i in list ( range ( len ( s1 ) ) ) : if ( s1 [ i ] == '0' and s2 [ i ] == '1' ) : c0 += 1 elif ( s1 [ i ] == '1' and s2 [ i ] == '0' ) : c1 += 1 i += 1 ans = c0 // 2 + c1 // 2 if ( c0 % 2 == 0 and c1 % 2 == 0 ) : return ans elif ( ( c0 + c1 ) % 2 == 0 ) : return ans + 2 else : return - 1"
"def checkEqualNo ( m , n , a , b ) : if ( m <= n ) : if ( ( n - m ) % ( a + b ) != 0 ) : return False else : return True else : return False"
"def kthdigit ( a , b , k ) : p = a ** b count = 0 while ( p > 0 and k > count ) : rem = p % 10 count = count + 1 if ( count == k ) : return rem p = p / 10"
def checkPalindrome ( str ) : n = len ( str ) count = 0 i = 0 while i in list ( range ( int ( n / 2 ) ) ) : if ( str [ i ] != str [ n - i - 1 ] ) : count = count + 1 i += 1 if ( count <= 1 ) : return True else : return False
"def findRadiusOfcircumcircle ( l , b ) : if ( l < 0 or 0 > b ) : return - 1 radius = ( math.sqrt ( pow ( l , 2 ) + pow ( b , 2 ) ) / 2 ) return radius"
def allCharactersSame ( s ) : n = len ( s ) i = 1 while i in list ( range ( n ) ) : if s [ i ] != s [ 0 ] : i += 1 return False i += 1 return True
"def countDivisibleSubseq ( str , n ) : l = len ( str ) dp = [ [ 0 for x in range ( l ) ] for y in range ( n ) ] dp [ 0 ] [ ( ord ( str [ 0 ] ) - ord ( '0' ) ) % n ] += 1 for i in range ( 1 , l ) : dp [ i ] [ ( ord ( str [ i ] ) - ord ( '0' ) ) % n ] += 1 j = 0 while j in list ( range ( n ) ) : dp [ i ] [ j ] += dp [ i - 1 ] [ j ] dp [ i ] [ ( j * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) ) % n ] += dp [ i - 1 ] [ j ] j += 1 return dp [ l - 1 ] [ 0 ]"
"def LCM ( arr , n ) : max_num = 0 for i in range ( n ) : if ( max_num < arr [ i ] ) : max_num = arr [ i ] res = 1 x = 2 while ( x <= max_num ) : indexes = [ ] j = 0 while j in list ( range ( n ) ) : if ( arr [ j ] % x == 0 ) : indexes.append ( j ) j += 1 if ( len ( indexes ) >= 2 ) : for j in range ( len ( indexes ) ) : arr [ indexes [ j ] ] = int ( arr [ indexes [ j ] ] / x ) res = res * x else : x += 1 for i in range ( n ) : res = res * arr [ i ] return res"
"def Divide ( a , b ) : dividend = a divisor = b sign = - 1 if ( ( dividend < 0 ) ^ ( divisor < 0 ) ) else 1 dividend = abs ( dividend ) divisor = abs ( divisor ) if ( divisor == 0 ) : print ( ""CannotDivideby0"" ) if ( 0 == dividend ) : print ( a , ""/"" , b , ""isequalto:"" , 0 ) if ( divisor == 1 ) : print ( a , ""/"" , b , ""isequalto:"" , ( sign * dividend ) ) print ( a , ""/"" , b , ""isequalto:"" , math.floor ( sign * math.exp ( math.log ( dividend ) - math.log ( divisor ) ) ) )"
"def powerSet ( string , index , curr ) : if len ( string ) == index : print ( curr ) return powerSet ( string , index + 1 , curr + string [ index ] ) powerSet ( string , index + 1 , curr )"
"def leastPrimeFactor ( n ) : least_prime = [ 0 ] * ( n + 1 ) least_prime [ 1 ] = 1 for i in range ( 2 , n + 1 ) : if ( least_prime [ i ] == 0 ) : least_prime [ i ] = i j = 2 * i while j in list ( range ( n + 1 ) ) : if ( least_prime [ j ] == 0 ) : least_prime [ j ] = i j += i for i in range ( 1 , n + 1 ) : print ( ""LeastPrimefactorof"" , i , "":"" , least_prime [ i ] )"
"def minRotation ( input , unlock_code ) : rotation = 0 while ( input > 0 or 0 < unlock_code ) : input_digit = input % 10 code_digit = unlock_code % 10 rotation += min ( abs ( input_digit - code_digit ) , 10 - abs ( input_digit - code_digit ) ) input = int ( input / 10 ) unlock_code = int ( unlock_code / 10 ) return rotation"
"def getMaxGold ( gold , m , n ) : goldTable = [ [ 0 for i in range ( n ) ] for j in range ( m ) ] for col in range ( n - 1 , - 1 , - 1 ) : row = 0 while row in list ( range ( m ) ) : if ( col == n - 1 ) : right = 0 else : right = goldTable [ row ] [ col + 1 ] if ( row == 0 or col == n - 1 ) : right_up = 0 else : right_up = goldTable [ row - 1 ] [ col + 1 ] if ( row == m - 1 or col == n - 1 ) : right_down = 0 else : right_down = goldTable [ row + 1 ] [ col + 1 ] goldTable [ row ] [ col ] = gold [ row ] [ col ] + max ( right , right_up , right_down ) row += 1 res = goldTable [ 0 ] [ 0 ] for i in range ( 1 , m ) : res = max ( res , goldTable [ i ] [ 0 ] ) return res"
"def findCountOfPairs ( a , b , n ) : ans = 0 ans = ans + n * int ( a / n ) * int ( b / n ) ans = ans + int ( a / n ) * ( b % n ) ans = ans + ( a % n ) * int ( b / n ) ans = ans + int ( ( ( a % n ) + ( b % n ) ) / n ) return ans"
def getPeriod ( n ) : rem = 1 i = 1 while i in list ( range ( n + 2 ) ) : rem = ( 10 * rem ) % n i += 1 d = rem count = 0 rem = ( 10 * rem ) % n count += 1 while rem != d : rem = ( 10 * rem ) % n count += 1 return count
"def printDistinct ( arr , n ) : s = dict ( ) i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] not in s.keys ( ) ) : s [ arr [ i ] ] = arr [ i ] print ( arr [ i ] , end = """" ) i += 1"
"def findExtra ( arr1 , arr2 , n ) : i = 0 while i in list ( range ( n ) ) : if ( arr1 [ i ] != arr2 [ i ] ) : i += 1 return i i += 1 return n"
"def geometricMean ( arr , n ) : sum = 0 i = 0 while i in list ( range ( n ) ) : sum = sum + math.log ( arr [ i ] ) i += 1 sum = sum / n return math.exp ( sum )"
"def countNumber ( n ) : result = 0 i = 1 while i in list ( range ( 10 ) ) : s = [ ] if ( i <= n ) : s.append ( i ) result += 1 while len ( s ) != 0 : tp = s [ - 1 ] s.pop ( ) for j in range ( tp % 10 , 10 ) : x = tp * 10 + j if ( x <= n ) : s.append ( x ) result += 1 i += 1 return result"
"def minimumMoves ( k , l , r ) : count = r - l + 1 if ( 0 == count % k ) : return 0 return ( k - ( count % k ) )"
"def checkConcurrent ( a1 , b1 , c1 , a2 , b2 , c2 , a3 , b3 , c3 ) : return ( 0 == a3 * ( b1 * c2 - b2 * c1 ) + b3 * ( c1 * a2 - c2 * a1 ) + c3 * ( a1 * b2 - a2 * b1 ) )"
"def kSmallestPair ( arr1 , n1 , arr2 , n2 , k ) : if ( k > n1 * n2 ) : print ( ""kpairsdon'texist"" ) return index2 = [ 0 for i in range ( n1 ) ] while ( k > 0 ) : min_sum = sys.maxsize min_index = 0 i1 = 0 while i1 in list ( range ( n1 ) ) : if ( index2 [ i1 ] < n2 and arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] < min_sum ) : min_index = i1 min_sum = arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] i1 += 1 print ( ""("" , arr1 [ min_index ] , "","" , arr2 [ index2 [ min_index ] ] , "")"" , end = """" ) index2 [ min_index ] += 1 k -= 1"
"def Series ( Arr , N , K ) : count = 0 i = 0 while i in list ( range ( N ) ) : if Arr [ i ] == 1 : count += 1 i += 1 if K >= ( N - count ) : return 1 return 0"
def trianglearea ( r ) : if 0 > r : return - 1 return r * r
"def missingNum ( arr , n ) : minvalue = min ( arr ) xornum = 0 i = 0 while i in list ( range ( n ) ) : xornum ^= ( minvalue ) ^ arr [ i ] minvalue = minvalue + 1 i += 1 return xornum ^ minvalue"
def countSeq ( n ) : nCr = 1 res = 1 r = 1 while r in list ( range ( n + 1 ) ) : nCr = ( nCr * ( n + 1 - r ) ) / r res += nCr * nCr r += 1 return res
"def minimumX ( n , k ) : mini = sys.maxsize i = 1 while n >= i * i : if ( n % i == 0 ) : fir = i sec = n // i num1 = fir * k + sec res = ( num1 // k ) * ( num1 % k ) if ( res == n ) : mini = min ( num1 , mini ) num2 = sec * k + fir res = ( num2 // k ) * ( num2 % k ) if ( res == n ) : mini = min ( num2 , mini ) i += 1 return mini"
"def printRepeating ( arr , n ) : i = 0 while i in list ( range ( n ) ) : index = arr [ i ] % n arr [ index ] += n i += 1 for i in range ( 0 , n ) : if ( arr [ i ] / n ) > 1 : print ( i , end = """" )"
"def distribution ( arr , n ) : arr.sort ( reverse = False ) count = 1 i = 1 while i in list ( range ( n ) ) : if ( arr [ i ] > arr [ i - 1 ] ) : count += 1 i += 1 return min ( count , n / 2 )"
"def Largercount ( arr1 , arr2 , m , n ) : count = 0 mp = dict ( ) for i in range ( m ) : mp [ arr1 [ i ] ] = mp.get ( arr1 [ i ] , 0 ) + 1 i = 0 while i in list ( range ( n ) ) : if ( arr2 [ i ] in mp.keys ( ) and mp [ arr2 [ i ] ] != 0 ) : mp [ arr2 [ i ] ] -= 1 i += 1 for i in range ( m ) : if ( mp [ arr1 [ i ] ] != 0 ) : count += 1 mp [ arr1 [ i ] ] = 0 return count"
"def cycleSort ( array ) : writes = 0 for cycleStart in range ( 0 , len ( array ) - 1 ) : item = array [ cycleStart ] pos = cycleStart i = cycleStart + 1 while i in list ( range ( len ( array ) ) ) : if array [ i ] < item : pos += 1 i += 1 if pos == cycleStart : continue while item == array [ pos ] : pos += 1 array [ pos ] , item = item , array [ pos ] writes += 1 while pos != cycleStart : pos = cycleStart for i in range ( cycleStart + 1 , len ( array ) ) : if array [ i ] < item : pos += 1 while item == array [ pos ] : pos += 1 array [ pos ] , item = item , array [ pos ] writes += 1 return writes"
"def maxOperations ( str ) : i , g , gk , gks = 0 , 0 , 0 , 0 i = 0 while i in list ( range ( len ( str ) ) ) : if ( str [ i ] == 'g' ) : g += 1 elif ( str [ i ] == 'k' ) : if ( g > 0 ) : g -= 1 gk += 1 elif ( str [ i ] == 's' ) : if ( gk > 0 ) : gk -= 1 gks += 1 i += 1 return gks"
"def solve ( numbers ) : max = - sys.maxsize i = 0 while i in list ( range ( len ( numbers ) ) ) : sum = 0 for j in range ( i , len ( numbers ) ) : sum += numbers [ j ] if sum > max : max = sum i += 1 return max"
"def uniqueNumbers ( arr , n ) : arr.sort ( ) freq = [ 0 ] * ( n + 2 ) for val in arr : if ( freq [ val - 1 ] == 0 ) : freq [ val - 1 ] += 1 elif ( freq [ val ] == 0 ) : freq [ val ] += 1 else : freq [ val + 1 ] += 1 unique = 0 for val in freq : if ( 0 < val ) : unique += 1 return unique"
"def Probability ( p , n ) : dp = np.zeros ( ( n + 1 , n + 1 ) ) i = 0 while i in list ( range ( n + 1 ) ) : for j in range ( n + 1 ) : dp [ i ] [ j ] = 0.0 i += 1 dp [ 0 ] [ 0 ] = 1.0 for i in range ( 1 , n + 1 ) : for j in range ( i + 1 ) : if ( j == 0 ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j ] * ( 1.0 - p [ i ] ) else : dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] * ( 1.0 - p [ i ] ) + dp [ i - 1 ] [ j - 1 ] * p [ i ] ) ans = 0.0 for i in range ( ( n + 1 ) // 2 , n + 1 ) : ans += dp [ n ] [ i ] return ans"
"def max_intersection ( center , length , k ) : center.sort ( ) if ( center [ 2 ] - center [ 0 ] >= 2 * k + length ) : return 0 elif ( 2 * k <= center [ 2 ] - center [ 0 ] ) : return ( 2 * k - ( center [ 2 ] - center [ 0 ] - length ) ) else : return length"
"def countMinimalReplacements ( s ) : n = len ( s ) cnt = 0 i = 1 while i in list ( range ( n ) ) : if ( s [ i ] == s [ i - 1 ] ) : cnt += 1 if ( i != ( n - 1 ) ) : s = list ( s ) for j in ""012"" : if ( j != s [ i + 1 ] and j != s [ i - 1 ] ) : s [ i ] = j i += 1 break s = ''.join ( s ) else : s = list ( s ) for k in ""012"" : if ( k != s [ i - 1 ] ) : s [ i ] = k i += 1 break s = ''.join ( s ) i += 1 return cnt"
def floorSqrt ( x ) : if ( x == 0 or x == 1 ) : return x i = 1 result = 1 while ( x >= result ) : i += 1 result = i * i return i - 1
"def minSwap ( arr , n , k ) : count = 0 i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] <= k ) : count = count + 1 i += 1 bad = 0 for i in range ( 0 , count ) : if ( arr [ i ] > k ) : bad = bad + 1 ans = bad j = count for i in range ( 0 , n ) : if ( j == n ) : break if ( arr [ i ] > k ) : bad = bad - 1 if ( arr [ j ] > k ) : bad = bad + 1 ans = min ( ans , bad ) j = j + 1 return ans"
"def isSubsetSum ( arr , n , sum ) : subset = [ [ False for j in range ( sum + 1 ) ] for i in range ( 3 ) ] for i in range ( n + 1 ) : j = 0 while j in list ( range ( sum + 1 ) ) : if ( j == 0 ) : subset [ i % 2 ] [ j ] = True elif ( i == 0 ) : subset [ i % 2 ] [ j ] = False elif ( arr [ i - 1 ] <= j ) : subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] or subset [ ( i + 1 ) % 2 ] [ j ] else : subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] j += 1 return subset [ n % 2 ] [ sum ]"
"def findSubsequenceCount ( S , T ) : m = len ( T ) n = len ( S ) if m > n : return 0 mat = [ [ 0 for _ in range ( n + 1 ) ] for __ in range ( m + 1 ) ] for i in range ( 1 , m + 1 ) : mat [ i ] [ 0 ] = 0 j = 0 while j in list ( range ( n + 1 ) ) : mat [ 0 ] [ j ] = 1 j += 1 for i in range ( 1 , m + 1 ) : for j in range ( 1 , n + 1 ) : if T [ i - 1 ] != S [ j - 1 ] : mat [ i ] [ j ] = mat [ i ] [ j - 1 ] else : mat [ i ] [ j ] = ( mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ) return mat [ m ] [ n ]"
"def isTriangular ( num ) : if ( num < 0 ) : return False c = ( - 2 * num ) b , a = 1 , 1 d = ( b * b ) - ( 4 * a * c ) if ( 0 > d ) : return False root1 = ( - b + math.sqrt ( d ) ) / ( 2 * a ) root2 = ( - b - math.sqrt ( d ) ) / ( 2 * a ) if ( root1 > 0 and math.floor ( root1 ) == root1 ) : return True if ( root2 > 0 and math.floor ( root2 ) == root2 ) : return True return False"
"def middleOfThree ( a , b , c ) : x = a - b y = b - c z = a - c if x * y > 0 : return b elif ( 0 < x * z ) : return else : return a"
"def CountingEvenOdd ( arr , arr_size ) : even_count = 0 odd_count = 0 i = 0 while i in list ( range ( arr_size ) ) : if ( arr [ i ] & 1 == 1 ) : odd_count += 1 else : even_count += 1 i += 1 print ( ""Numberofevenelements="" , even_count ) print ( ""Numberofoddelements="" , odd_count )"
"def maxSquareSubsetSum ( A , N ) : sub1 = 0 ; sub2 = 0 A.sort ( ) i = 0 while i in list ( range ( N ) ) : if ( i < ( N // 2 ) - 1 ) : sub1 += A [ i ] else : sub2 += A [ i ] i += 1 return sub1 * sub1 + sub2 * sub2"
"def Diffs ( a , k ) : out , inc , dec = [ ] , [ 0 ] * len ( a ) , [ 0 ] * len ( a ) inc_sum , dec_sum = 0 , 0 i = 0 while i in list ( range ( len ( a ) ) ) : j = i - 1 while ( j >= 0 and j > i - k and a [ j + 1 ] > a [ j ] ) : inc [ j ] += 1 inc_sum += 1 j -= 1 j = i - 1 while ( j >= 0 and j > i - k and a [ j + 1 ] < a [ j ] ) : dec [ j ] += 1 dec_sum += 1 j -= 1 if i >= k - 1 : if i >= k : inc_sum -= inc [ i - k ] dec_sum -= dec [ i - k ] out.append ( inc_sum - dec_sum ) i += 1 return out"
"def removeDuplicate ( str , n ) : index = 0 for i in range ( 0 , n ) : j = 0 while j in list ( range ( i + 1 ) ) : if ( str [ i ] == str [ j ] ) : j += 1 break j += 1 if ( j == i ) : str [ index ] = str [ i ] index += 1 return """".join ( str [ : index ] )"
def setBitNumber ( n ) : if ( n == 0 ) : return 0 msb = 0 while ( 0 < n ) : n = int ( n / 2 ) msb += 1 return ( 1 << msb )
"def TwentyoneMatchstick ( arr , N ) : i = 0 while i in list ( range ( N ) ) : print ( 5 - arr [ i ] , end = """" ) i += 1"
"def arraySortedOrNot ( arr , n ) : if ( n == 0 or n == 1 ) : return True i = 1 while i in list ( range ( n ) ) : if ( arr [ i - 1 ] > arr [ i ] ) : i += 1 return False i += 1 return True"
"def maxSumWO3Consec ( arr , n ) : sum = [ 0 for k in range ( n ) ] if n >= 1 : sum [ 0 ] = arr [ 0 ] if n >= 2 : sum [ 1 ] = arr [ 0 ] + arr [ 1 ] if n > 2 : sum [ 2 ] = max ( sum [ 1 ] , max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) i = 3 while i in list ( range ( n ) ) : sum [ i ] = max ( max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) i += 1 return sum [ n - 1 ]"
def isAnyNotPalindrome ( s ) : unique = set ( ) i = 0 while i in list ( range ( len ( s ) ) ) : unique.add ( s [ i ] ) i += 1 if ( len ( unique ) > 1 ) : return True else : return False
"def Count_subarray ( arr , n ) : total_sum = 0 count = 0 for i in range ( n ) : total_sum += arr [ i ] for i in range ( n ) : subarray_sum = 0 j = i while j in list ( range ( n ) ) : subarray_sum += arr [ j ] remaining_sum = total_sum - subarray_sum if ( subarray_sum > remaining_sum ) : count += 1 j += 1 return count"
"def printRepeating ( arr , size ) : xor = arr [ 0 ] n = size - 2 x = 0 y = 0 for i in range ( 1 , size ) : xor ^= arr [ i ] i = 1 while i in list ( range ( n + 1 ) ) : xor ^= i i += 1 set_bit_no = xor & ~ ( xor - 1 ) for i in range ( 0 , size ) : if ( arr [ i ] & set_bit_no ) : x = x ^ arr [ i ] else : y = y ^ arr [ i ] for i in range ( 1 , n + 1 ) : if ( i & set_bit_no ) : x = x ^ i else : y = y ^ i print ( ""Thetworepeating"" , ""elementsare"" , y , x )"
def countWays ( N ) : if ( N == 1 ) : return 4 countB = 1 countS = 1 i = 2 while i in list ( range ( N + 1 ) ) : prev_countB = countB prev_countS = countS countS = prev_countB + prev_countS countB = prev_countS i += 1 result = countS + countB return ( result * result )
"def pairAndSum ( arr , n ) : ans = 0 i = 0 while i in list ( range ( n ) ) : for j in range ( ( i + 1 ) , n ) : ans = ans + arr [ i ] & arr [ j ] i += 1 return ans"
"def minXOR ( arr , n ) : arr.sort ( ) min_xor = 999999 val = 0 i = 0 while i in list ( range ( n - 1 ) ) : for j in range ( i + 1 , n - 1 ) : val = arr [ i ] ^ arr [ j ] min_xor = min ( min_xor , val ) i += 1 return min_xor"
"def maxOR ( arr , n ) : maxVal = 0 for i in range ( n - 1 ) : j = i + 1 while j in list ( range ( n ) ) : maxVal = max ( maxVal , arr [ i ] | arr [ j ] ) j += 1 return maxVal"
"def generateSequence ( n , g ) : i = 1 while i in list ( range ( n + 1 ) ) : print ( i * g , end = """" ) i += 1"
"def squareRoot ( n , p ) : n = n % p x = 2 while x in list ( range ( p ) ) : if ( ( x * x ) % p == n ) : print ( ""Squarerootis"" , x ) x += 1 return x += 1 print ( ""Squarerootdoesn'texist"" )"
"def GetMinSubarrayLength ( a , n ) : ans = max ( a [ 0 ] , a [ n - 1 ] ) lo = 0 hi = n - 1 while ( lo < n and 0 == a [ lo ] % ans ) : lo += 1 while ( hi > lo and a [ hi ] % ans == 0 ) : hi -= 1 return ( hi - lo + 1 )"
def translate ( st ) : l = len ( st ) if ( l < 2 ) : return i = 0 j = 0 while ( j < l - 1 ) : if ( st [ j ] == 'A' and st [ j + 1 ] == 'B' ) : j += 2 st [ i ] = 'C' i += 1 continue st [ i ] = st [ j ] i += 1 j += 1 if ( l - 1 == j ) : st [ i ] = st [ j ] i += 1 st [ i ] = '' st [ l - 1 ] = ''
"def printIndex ( str , s ) : flag = False i = 0 while i in list ( range ( len ( str ) ) ) : if ( str [ i : i + len ( s ) ] == s ) : print ( i , end = """" ) flag = True i += 1 if ( flag == False ) : print ( ""NONE"" )"
"def area ( a , b ) : if ( a < 0 or 0 > b ) : return - 1 A = a * b return A"
"def longestSubarray ( a , n ) : hash = [ [ 0 for i in range ( 10 ) ] for j in range ( n ) ] for i in range ( n ) : num = a [ i ] while ( num ) : hash [ i ] [ num % 10 ] = 1 num = int ( num / 10 ) longest = - sys.maxsize - 1 count = 0 for i in range ( n - 1 ) : j = 0 while j in list ( range ( 10 ) ) : if ( hash [ i ] [ j ] and hash [ i + 1 ] [ j ] ) : count += 1 j += 1 break j += 1 if ( j == 10 ) : longest = max ( longest , count + 1 ) count = 0 longest = max ( longest , count + 1 ) return longest"
"def maxSumBitonicSubArr ( arr , n ) : msis = [ None ] * n msds = [ None ] * n max_sum = 0 msis [ 0 ] = arr [ 0 ] for i in range ( 1 , n ) : if ( arr [ i ] > arr [ i - 1 ] ) : msis [ i ] = msis [ i - 1 ] + arr [ i ] else : msis [ i ] = arr [ i ] msds [ n - 1 ] = arr [ n - 1 ] i = n - 2 while i in list ( range ( - 1 ) ) : if ( arr [ i ] > arr [ i + 1 ] ) : msds [ i ] = msds [ i + 1 ] + arr [ i ] else : msds [ i ] = arr [ i ] i += - 1 for i in range ( n ) : if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) : max_sum = ( msis [ i ] + msds [ i ] - arr [ i ] ) return max_sum"
"def minimumMoves ( a , n ) : operations = 0 a.sort ( reverse = False ) i = 0 while i in list ( range ( n ) ) : operations = operations + abs ( a [ i ] - ( i + 1 ) ) i += 1 return operations"
"def countMinimumMoves ( arr , n , k ) : for i in range ( k - 1 , n ) : if ( arr [ i ] != arr [ k - 1 ] ) : return - 1 i = k - 1 while i in list ( range ( - 1 ) ) : if ( arr [ i ] != arr [ k - 1 ] ) : i += - 1 return i + 1 i += - 1 return 0"
"def pad ( n ) : pPrevPrev , pPrev , pCurr , pNext = 1 , 1 , 1 , 1 i = 3 while i in list ( range ( n + 1 ) ) : pNext = pPrevPrev + pPrev pPrevPrev = pPrev pPrev = pCurr pCurr = pNext i += 1 return pNext"
"def SubArraySum ( arr , n ) : temp , result = 0 , 0 for i in range ( 0 , n ) : temp = 0 j = i while j in list ( range ( n ) ) : temp += arr [ j ] result += temp j += 1 return result"
"def maxSelectionCount ( a , n ) : res = 0 a.sort ( ) select = 1 i = 0 while i in list ( range ( n ) ) : if ( a [ i ] >= select ) : res += 1 select += 1 i += 1 return res"
def isDivisible ( n ) : while ( n // 100 ) : d = n % 10 n //= 10 n = n + d * 2 return ( 0 == n % 19 )
"def countNonIncreasing ( arr , n ) : cnt = 0 len = 1 i = 0 while i in list ( range ( n - 1 ) ) : if ( arr [ i + 1 ] >= arr [ i ] ) : len += 1 else : cnt += ( ( ( len + 1 ) * len ) / 2 ) len = 1 i += 1 if ( len > 1 ) : cnt += ( ( ( len - 1 ) * len ) / 2 ) return int ( cnt )"
"def oddEvenSort ( arr , n ) : isSorted = 0 while isSorted == 0 : isSorted = 1 temp = 0 i = 1 while i in list ( range ( n - 1 ) ) : if arr [ i ] > arr [ i + 1 ] : arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] isSorted = 0 i += 2 for i in range ( 0 , n - 1 , 2 ) : if arr [ i ] > arr [ i + 1 ] : arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] isSorted = 0 return"
"def smallest ( s ) : l = len ( s ) ans = """" for i in range ( l ) : if ( s [ i ] > s [ i + 1 ] ) : j = 0 while j in list ( range ( l ) ) : if ( i != j ) : ans += s [ j ] j += 1 return ans ans = s [ 0 : l - 1 ] return ans"
"def isTriangular ( num ) : if ( 0 > num ) : return False sum , n = 0 , 1 while ( sum <= num ) : sum = sum + n if ( sum == num ) : return True n += 1 return False"
"def countPair ( arr , n , k ) : cnt = 0 for i in range ( n ) : arr [ i ] = ( arr [ i ] + k ) % k hash = [ 0 ] * k for i in range ( n ) : hash [ arr [ i ] ] += 1 i = 0 while i in list ( range ( k ) ) : cnt += ( hash [ i ] * ( hash [ i ] - 1 ) ) / 2 i += 1 print ( int ( cnt ) )"
"def unitDigitXRaisedY ( x , y ) : res = 1 i = 0 while i in list ( range ( y ) ) : res = ( res * x ) % 10 i += 1 return res"
def isBinary ( number ) : while ( 0 < number ) : digit = number % 10 if ( digit > 1 ) : return False number //= 10 return True
def findNthOddDigitNumber ( n ) : count = 0 i = 1 while True : num = i isMadeOfOdd = True while num != 0 : if ( num % 10 == 0 or num % 10 == 2 or 4 == num % 10 or num % 10 == 6 or num % 10 == 8 ) : isMadeOfOdd = False break num /= 10 if isMadeOfOdd == True : count += 1 if count == n : return i i += 1
def square ( a ) : if ( 0 > a ) : return - 1 x = 0.464 * a return x
"def minRemove ( a , b , n , m ) : countA = dict ( ) countB = dict ( ) i = 0 while i in list ( range ( n ) ) : countA [ a [ i ] ] = countA.get ( a [ i ] , 0 ) + 1 i += 1 for i in range ( n ) : countB [ b [ i ] ] = countB.get ( b [ i ] , 0 ) + 1 res = 0 for x in countA : if x in countB.keys ( ) : res += min ( countA [ x ] , countB [ x ] ) return res"
"def reverse ( a , n , k ) : if ( k > n ) : print ( ""Invalidk"" ) return i = 0 while i in list ( range ( ( int ) ( k / 2 ) ) ) : temp = a [ i ] a [ i ] = a [ k - i - 1 ] a [ k - i - 1 ] = temp i += 1"
"def modularInverse ( n , prime ) : dp = [ 0 ] * ( n + 1 ) dp [ 0 ] = dp [ 1 ] = 1 for i in range ( 2 , n + 1 ) : dp [ i ] = dp [ prime % i ] * ( prime - prime // i ) % prime i = 1 while i in list ( range ( n + 1 ) ) : print ( dp [ i ] , end = """" ) i += 1"
"def getCount ( arr , n , num1 , num2 ) : for i in range ( 0 , n ) : if ( arr [ i ] == num1 ) : break if ( i >= n - 1 ) : return 0 j = n - 1 while j in list ( range ( i + 1 ) ) : if ( arr [ j ] == num2 ) : j += - 1 break j += - 1 if ( j == i ) : return 0 return ( j - i - 1 )"
"def countFreq ( arr , n ) : mp = { } for i in range ( n ) : if arr [ i ] not in mp : mp [ arr [ i ] ] = 0 mp [ arr [ i ] ] += 1 i = 0 while i in list ( range ( n ) ) : if ( mp [ arr [ i ] ] != - 1 ) : print ( arr [ i ] , mp [ arr [ i ] ] ) mp [ arr [ i ] ] = - 1 i += 1"
"def gnomeSort ( arr , n ) : index = 0 while index < n : if index == 0 : index = index + 1 if arr [ index - 1 ] <= arr [ index ] : index = index + 1 else : arr [ index ] , arr [ index - 1 ] = arr [ index - 1 ] , arr [ index ] index = index - 1 return arr"
"def printCount ( a , n , m , z , l ) : for i in range ( n ) : mp = dict ( ) j = 0 while j in list ( range ( m ) ) : mp [ a [ i ] [ j ] ] = 1 j += 1 count = 0 for j in range ( l ) : if z [ j ] in mp.keys ( ) : count += 1 print ( ""row"" , i + 1 , ""="" , count )"
"def maxSumArrangement ( A , R , N , M ) : count = [ 0 for i in range ( N ) ] for i in range ( M ) : l = R [ i ] [ 0 ] r = R [ i ] [ 1 ] + 1 l = l - 1 r = r - 1 count [ l ] = count [ l ] + 1 if ( r < N ) : count [ r ] = count [ r ] - 1 i = 1 while i in list ( range ( N ) ) : count [ i ] = count [ i ] + count [ i - 1 ] i += 1 ans = 0 count.sort ( ) A.sort ( ) for i in range ( N - 1 , - 1 , - 1 ) : ans = ans + A [ i ] * count [ i ] return ans"
"def tower ( n , sourcePole , destinationPole , auxiliaryPole ) : if ( n == 0 ) : return tower ( n - 1 , sourcePole , auxiliaryPole , destinationPole ) print ( ""Movethedisk"" , sourcePole , ""from"" , sourcePole , ""to"" , destinationPole ) tower ( n - 1 , auxiliaryPole , destinationPole , sourcePole )"
"def solve ( arr , n , k ) : m = { } for i in range ( 0 , n - 1 ) : if ( arr [ i ] in m.keys ( ) ) : m [ arr [ i ] ] += 1 else : m [ arr [ i ] ] = 1 i += 1 max = sys.maxsize i = 0 while i in list ( range ( n - 1 ) ) : if ( m [ arr [ i ] ] == k and max == sys.maxsize ) : max = arr [ i ] elif ( m [ arr [ i ] ] == k and max < arr [ i ] ) : max = arr [ i ] i += 1 i += 1 if ( max == sys.maxsize ) : print ( ""Nosuchelement"" ) else : print ( max )"
"def optimalStrategyOfGame ( arr , n ) : table = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] gap = 0 while gap in list ( range ( n ) ) : for j in range ( gap , n ) : i = j - gap x = 0 if ( ( i + 2 ) <= j ) : x = table [ i + 2 ] [ j ] y = 0 if ( ( i + 1 ) <= ( j - 1 ) ) : y = table [ i + 1 ] [ j - 1 ] z = 0 if ( i <= ( j - 2 ) ) : z = table [ i ] [ j - 2 ] table [ i ] [ j ] = max ( arr [ i ] + min ( x , y ) , arr [ j ] + min ( y , z ) ) gap += 1 return table [ 0 ] [ n - 1 ]"
"def discreteLogarithm ( a , b , m ) : n = int ( math.sqrt ( m ) + 1 ) an = 1 for i in range ( n ) : an = ( an * a ) % m value = [ 0 ] * m cur = an for i in range ( 1 , n + 1 ) : if ( value [ cur ] == 0 ) : value [ cur ] = i cur = ( cur * an ) % m cur = b i = 0 while i in list ( range ( n + 1 ) ) : if ( value [ cur ] > 0 ) : ans = value [ cur ] * n - i if ( ans < m ) : i += 1 return ans cur = ( cur * a ) % m i += 1 return - 1"
"def maxLengthArr ( x , y ) : ex = [ 0 ] * ( 1 << x ) ex [ 0 ] = 1 pre = [ 0 ] i = 1 while i in list ( range ( ( 1 << x ) ) ) : if ( ex [ i ^ y ] ) : i += 1 continue pre.append ( i ) ex [ i ] = 1 i += 1 if ( len ( pre ) == 1 ) : print ( ""-1"" , end = """" ) return for i in range ( 1 , len ( pre ) ) : print ( pre [ i ] ^ pre [ i - 1 ] , end = """" )"
"def subArraySum ( arr , n , sum ) : i = 0 while i in list ( range ( n ) ) : curr_sum = arr [ i ] j = i + 1 while j <= n : if curr_sum == sum : print ( ""Sumfoundbetween"" ) print ( ""indexes%dand%d"" % ( i , j - 1 ) ) i += 1 return 1 if curr_sum > sum or j == n : i += 1 break curr_sum = curr_sum + arr [ j ] j += 1 i += 1 print ( ""Nosubarrayfound"" ) return 0"
"def solve ( X , Y , N , K ) : count = [ 0 ] * ( N + 1 ) sol = 0 count [ 0 ] = 0 i = 1 while i in list ( range ( N + 1 ) ) : count [ i ] = ( count [ i - 1 ] + abs ( ord ( X [ i - 1 ] ) - ord ( Y [ i - 1 ] ) ) ) i += 1 j = 0 for i in range ( 1 , N + 1 ) : while ( ( count [ i ] - count [ j ] ) > K ) : j += 1 sol = max ( sol , i - j ) return sol"
"def findSumPairs ( a , n ) : mpp = { i : 0 for i in range ( 21 ) } for i in range ( n - 1 ) : j = i + 1 while j in list ( range ( n ) ) : mpp [ a [ i ] + a [ j ] ] += 1 j += 1 occur = 0 for key , value in mpp.items ( ) : if ( value > occur ) : occur = value for key , value in mpp.items ( ) : if ( value == occur ) : print ( key )"
"def getMinVal ( p , q ) : if 0 == q % p : return p return - 1"
def count ( N ) : sum = 0 i = 0 while i in list ( range ( N + 1 ) ) : sum += 7 * ( 8 ** ( i - 1 ) ) i += 1 return int ( sum )
def findDigits ( n ) : if ( n < 0 ) : return 0 if ( n <= 1 ) : return 1 digits = 0 i = 2 while i in list ( range ( n + 1 ) ) : digits += math.log10 ( i ) i += 1 return math.floor ( digits ) + 1
"def squareRoot ( number , precision ) : start = 0 end , ans = number , 1 while ( start <= end ) : mid = int ( ( start + end ) / 2 ) if ( mid * mid == number ) : ans = mid break if ( mid * mid < number ) : start = mid + 1 else : end = mid - 1 increment = 0.1 i = 0 while i in list ( range ( precision ) ) : while ( ans * ans <= number ) : ans += increment ans = ans - increment increment = increment / 10 i += 1 return ans"
"def stopping_station ( p , n ) : num = 1 dem = 1 s = p while p != 1 : dem *= p p -= 1 t = n - s + 1 while ( n - 2 * s + 1 ) != t : num *= t t -= 1 if ( n - s + 1 ) >= s : return int ( num / dem ) else : return - 1"
"def cntSubArrays ( arr , n , k ) : res = 0 i = 0 while ( i < n ) : j = i + 1 while ( j < n and arr [ j ] >= arr [ j - 1 ] ) : j = j + 1 res = res + max ( j - i - k + 1 , 0 ) i = j return res"
def countUnmarked ( N ) : if ( 0 == N % 2 ) : return N / 2 else : return N / 2 + 1
"def isPossible ( Str ) : freq = dict ( ) max_freq = 0 j = 0 while j in list ( range ( len ( Str ) ) ) : freq [ Str [ j ] ] = freq.get ( Str [ j ] , 0 ) + 1 if ( freq [ Str [ j ] ] > max_freq ) : max_freq = freq [ Str [ j ] ] j += 1 if ( max_freq <= ( len ( Str ) - max_freq + 1 ) ) : return True return False"
"def totalWays ( N , M , X ) : dp = [ [ 0 for i in range ( 2 ) ] for j in range ( N + 1 ) ] if ( X == 1 ) : dp [ 0 ] [ 0 ] = 1 else : dp [ 0 ] [ 1 ] = 0 if ( X == 1 ) : dp [ 1 ] [ 0 ] = 0 dp [ 1 ] [ 1 ] = M - 1 else : dp [ 1 ] [ 0 ] = 1 dp [ 1 ] [ 1 ] = ( M - 2 ) i = 2 while i in list ( range ( N ) ) : dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] * ( M - 1 ) + dp [ i - 1 ] [ 1 ] * ( M - 2 ) i += 1 return dp [ N - 1 ] [ 0 ]"
"def countDigits ( a , b ) : if ( 0 == a or b == 0 ) : return 1 return math.floor ( math.log10 ( abs ( a ) ) + math.log10 ( abs ( b ) ) ) + 1"
"def find ( s1 , s2 ) : len__ = len ( s1 ) len_1 = len ( s2 ) if ( len__ != len_1 ) : return False d = [ 0 for i in range ( len__ ) ] d [ 0 ] = ord ( s2 [ 0 ] ) - ord ( s1 [ 0 ] ) i = 1 while i in list ( range ( len__ ) ) : if ( s1 [ i ] > s2 [ i ] ) : i += 1 return False else : d [ i ] = ord ( s2 [ i ] ) - ord ( s1 [ i ] ) i += 1 for i in range ( len__ - 1 ) : if ( d [ i ] < d [ i + 1 ] ) : return False return True"
"def lexicoSmallestPermuatation ( arr , n ) : cnt = [ 0 for i in range ( n + 1 ) ] for i in range ( n ) : cnt [ arr [ i ] ] += 1 ele = 1 replacement = 0 vis = [ 0 for i in range ( n + 1 ) ] i = 0 while i in list ( range ( n ) ) : if ( cnt [ arr [ i ] ] == 1 ) : i += 1 continue while ( cnt [ ele ] ) : ele += 1 if ( ele > arr [ i ] and vis [ arr [ i ] ] == 0 ) : vis [ arr [ i ] ] = 1 else : cnt [ arr [ i ] ] -= 1 arr [ i ] = ele replacement += 1 ele += 1 i += 1 print ( replacement ) for i in range ( n ) : print ( arr [ i ] , end = """" )"
"def getCount ( l , r , p ) : cnt = 0 val = p while ( True ) : a = r // val b = ( l - 1 ) // val val *= p if ( a - b ) : cnt = cnt + ( a - b ) else : break return int ( cnt )"
"def EvenOddAbsoluteDifference ( arr , n ) : even = 0 odd = 0 i = 0 while i in list ( range ( n ) ) : if ( i % 2 == 0 ) : even = abs ( even - arr [ i ] ) else : odd = abs ( odd - arr [ i ] ) i += 1 print ( ""EvenIndexabsolutedifference:"" , even ) print ( ""OddIndexabsolutedifference:"" , odd )"
"def findLongestConseqSubseq ( arr , n ) : S = set ( ) for i in range ( n ) : S.add ( arr [ i ] ) ans = 0 i = 0 while i in list ( range ( n ) ) : if S.__contains__ ( arr [ i ] ) : j = arr [ i ] while ( S.__contains__ ( j ) ) : j += 1 ans = max ( ans , j - arr [ i ] ) i += 1 return ans"
def findNth ( n ) : count = 0 curr = 19 while ( True ) : sum = 0 x = curr while ( 0 < x ) : sum = sum + x % 10 x = int ( x / 10 ) if ( sum == 10 ) : count += 1 if ( count == n ) : return curr curr += 9 return - 1
def findStep ( n ) : if ( n == 1 or 0 == n ) : return 1 elif ( n == 2 ) : return 2 else : return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 )
"def findMaxAverage ( arr , n , k ) : if ( k > n ) : return - 1 sum = arr [ 0 ] for i in range ( 1 , k ) : sum += arr [ i ] max_sum = sum max_end = k - 1 i = k while i in list ( range ( n ) ) : sum = sum + arr [ i ] - arr [ i - k ] if ( sum > max_sum ) : max_sum = sum max_end = i i += 1 return max_end - k + 1"
def printSumSeries ( N ) : sum = 0 i = 1 while i in list ( range ( N + 1 ) ) : sum += 1.0 / ( 2 * i - 1 ) i += 1 print ( sum )
"def XorSum ( arr , n ) : result = 0 i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] % 2 != 0 ) : result += arr [ i ] i += 1 return result"
"def ReplaceElementsByFrequency ( arr , n ) : mp = { i : 0 for i in range ( len ( arr ) ) } i = 0 while i in list ( range ( n ) ) : mp [ arr [ i ] ] += 1 i += 1 for i in range ( n ) : arr [ i ] = mp [ arr [ i ] ]"
"def countSubstring ( S , n ) : ans = 0 i = 0 while ( i < n ) : cnt0 = 0 ; cnt1 = 0 if ( S [ i ] == '' ) : while ( i < n and S [ i ] == '' ) : cnt0 = cnt0 + 1 i = i + 1 j = i while ( j < n and S [ j ] == '' ) : cnt1 = cnt1 + 1 j = j + 1 else : while ( i < n and S [ i ] == '' ) : cnt1 = cnt1 + 1 i = i + 1 j = i while ( j < n and S [ j ] == '' ) : cnt0 = cnt0 + 1 j = j + 1 ans = ans + min ( cnt0 , cnt1 ) return ans"
def ispalindrome ( s ) : l = len ( s ) i = 0 j = l - 1 while i <= j : if ( s [ j ] != s [ i ] ) : return False i += 1 j -= 1 return True
"def max_sum ( arr , n , k ) : dp = [ 0 ] * n dp [ 0 ] = max ( 0 , arr [ 0 ] ) i = 1 while ( i < k ) : dp [ i ] = max ( dp [ i - 1 ] , arr [ i ] ) i += 1 i = k while ( n > i ) : dp [ i ] = max ( dp [ i - 1 ] , arr [ i ] + dp [ i - k ] ) i += 1 return dp [ n - 1 ]"
"def printPattern ( r ) : r = r // 2 count = r for i in range ( r ) : for j in range ( r , i , - 1 ) : if j != r : print ( ""*"" + str ( count ) , end = """" ) else : print ( count , end = """" ) count -= 1 print ( ) count += 1 for i in range ( r ) : j = 0 while j in list ( range ( i + 1 ) ) : if j != 0 : print ( ""*"" + str ( count ) , end = """" ) else : print ( count , end = """" ) j += 1 count += 1 print ( )"
"def MinOperation ( a , b , n ) : a.sort ( reverse = False ) b.sort ( reverse = False ) result = 0 i = 0 while i in list ( range ( n ) ) : if ( a [ i ] > b [ i ] ) : result = result + abs ( a [ i ] - b [ i ] ) elif ( a [ i ] < b [ i ] ) : result = result + abs ( a [ i ] - b [ i ] ) i += 1 return result"
"def maximumNumberDistinctPrimeRange ( m , n ) : factorCount = [ 0 ] * ( n + 1 ) prime = [ False ] * ( n + 1 ) for i in range ( n + 1 ) : factorCount [ i ] = 0 prime [ i ] = True for i in range ( 2 , n + 1 ) : if ( prime [ i ] == True ) : factorCount [ i ] = 1 for j in range ( i * 2 , n + 1 , i ) : factorCount [ j ] += 1 prime [ j ] = False max = factorCount [ m ] num = m i = m while i in list ( range ( n + 1 ) ) : if ( factorCount [ i ] > max ) : max = factorCount [ i ] num = i i += 1 return num"
"def even_or_odd ( N ) : l = len ( N ) if ( N [ l - 1 ] == '0' or N [ l - 1 ] == '2' or '4' == N [ l - 1 ] or N [ l - 1 ] == '6' or N [ l - 1 ] == '8' or N [ l - 1 ] == 'A' or N [ l - 1 ] == 'C' or N [ l - 1 ] == 'E' ) : return ( ""Even"" ) else : return ( ""Odd"" )"
def convertOpposite ( str ) : ln = len ( str ) i = 0 while i in list ( range ( ln ) ) : if str [ i ] >= 'a' and str [ i ] <= 'z' : str [ i ] = chr ( ord ( str [ i ] ) - 32 ) elif str [ i ] >= 'A' and str [ i ] <= 'Z' : str [ i ] = chr ( ord ( str [ i ] ) + 32 ) i += 1
"def minCoins ( coins , m , V ) : table = [ 0 for i in range ( V + 1 ) ] table [ 0 ] = 0 for i in range ( 1 , V + 1 ) : table [ i ] = sys.maxsize i = 1 while i in list ( range ( V + 1 ) ) : for j in range ( m ) : if ( coins [ j ] <= i ) : sub_res = table [ i - coins [ j ] ] if ( sub_res != sys.maxsize and sub_res + 1 < table [ i ] ) : table [ i ] = sub_res + 1 i += 1 return table [ V ]"
def findMax ( num ) : num_copy = num j = 4 * 8 - 1 i = 0 while ( i < j ) : m = ( num_copy >> i ) & 1 n = ( num_copy >> j ) & 1 if ( n < m ) : x = ( 1 << i | 1 << j ) num = num ^ x i += 1 j -= 1 return num
"def convert ( n , a , b ) : l = [ 0 ] * n i = 0 while i in list ( range ( n ) ) : if ( a [ i ] != b [ i ] ) : l [ i ] = 1 i += 1 cc = 0 vl = 0 for i in range ( n ) : if ( l [ i ] == 0 ) : if ( vl != 0 ) : cc += 1 vl = 0 else : vl += 1 if ( vl != 0 ) : cc += 1 print ( cc )"
"def k_sum ( a , n , k ) : r , sum = 0 , 0 ans = 0 l = 0 while l in list ( range ( n ) ) : while ( sum < k ) : if ( r == n ) : l += 1 break else : sum += a [ r ] r += 1 if ( sum < k ) : l += 1 break ans += n - r + 1 sum -= a [ l ] l += 1 return ans"
def isAlphabaticOrder ( s ) : n = len ( s ) c = [ s [ i ] for i in range ( len ( s ) ) ] c.sort ( reverse = False ) i = 0 while i in list ( range ( n ) ) : if ( c [ i ] != s [ i ] ) : i += 1 return False i += 1 return True
"def minProductSubset ( a , n ) : if ( n == 1 ) : return a [ 0 ] max_neg = float ( '-inf' ) min_pos = float ( 'inf' ) count_neg = 0 count_zero = 0 prod = 1 i = 0 while i in list ( range ( n ) ) : if ( a [ i ] == 0 ) : count_zero = count_zero + 1 i += 1 continue if ( a [ i ] < 0 ) : count_neg = count_neg + 1 max_neg = max ( max_neg , a [ i ] ) if ( a [ i ] > 0 ) : min_pos = min ( min_pos , a [ i ] ) prod = prod * a [ i ] i += 1 if ( count_zero == n or ( count_neg == 0 and count_zero > 0 ) ) : return 0 if ( count_neg == 0 ) : return min_pos if ( ( count_neg & 1 ) == 0 and count_neg != 0 ) : prod = int ( prod / max_neg ) return prod"
"def minCost ( A , n ) : cost = 0 A.sort ( ) K = A [ int ( n / 2 ) ] i = 0 while i in list ( range ( n ) ) : cost = cost + abs ( A [ i ] - K ) i += 1 if n % 2 == 0 : tempCost = 0 K = A [ int ( n / 2 ) - 1 ] for i in range ( 0 , n ) : tempCost = tempCost + abs ( A [ i ] - K ) cost = min ( cost , tempCost ) return cost"
"def maxUniqueNum ( a , N , M ) : maxUnique = 0 for i in range ( N - M ) : s = set ( ) j = 0 while j in list ( range ( M ) ) : s.add ( a [ i + j ] ) j += 1 if ( len ( s ) > maxUnique ) : maxUnique = len ( s ) return maxUnique"
"def countPairs ( s1 , n1 , s2 , n2 ) : freq1 = [ 0 ] * 26 freq2 = [ 0 ] * 26 count = 0 for i in range ( n1 ) : freq1 [ ord ( s1 [ i ] ) - ord ( 'a' ) ] += 1 for i in range ( n2 ) : freq2 [ ord ( s2 [ i ] ) - ord ( 'a' ) ] += 1 i = 0 while i in list ( range ( 26 ) ) : count += min ( freq1 [ i ] , freq2 [ i ] ) i += 1 return count"
"def countStrings ( n , k ) : dp = [ [ [ 0 , 0 ] for __ in range ( k + 1 ) ] for _ in range ( n + 1 ) ] dp [ 1 ] [ 0 ] [ 0 ] = 1 dp [ 1 ] [ 0 ] [ 1 ] = 1 for i in range ( 2 , n + 1 ) : j = 0 while j in list ( range ( k + 1 ) ) : dp [ i ] [ j ] [ 0 ] = ( dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ) dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] if j >= 1 : dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] j += 1 return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ]"
"def splitArr ( arr , n , k ) : for i in range ( 0 , k ) : x = arr [ 0 ] j = 0 while j in list ( range ( n - 1 ) ) : arr [ j ] = arr [ j + 1 ] j += 1 arr [ n - 1 ] = x"
"def findMaximum ( l , p , q , r ) : dp = [ - 1 ] * ( l + 1 ) dp [ 0 ] = 0 i = 0 while i in list ( range ( l + 1 ) ) : if ( dp [ i ] == - 1 ) : i += 1 continue if ( i + p <= l ) : dp [ i + p ] = ( max ( dp [ i + p ] , dp [ i ] + 1 ) ) if ( i + q <= l ) : dp [ i + q ] = ( max ( dp [ i + q ] , dp [ i ] + 1 ) ) if ( i + r <= l ) : dp [ i + r ] = ( max ( dp [ i + r ] , dp [ i ] + 1 ) ) i += 1 return dp [ l ]"
"def pattern ( n ) : i = n - 1 j = 1 for i in range ( n - 1 , - 1 , - 1 ) : for j in range ( n - 1 , i , - 1 ) : print ( '' , end = '' ) print ( chr ( i + 65 ) , end = '' ) j = 1 while j in list ( range ( i * 2 ) ) : print ( '' , end = '' ) j += 1 if ( i >= 1 ) : print ( chr ( i + 65 ) , end = '' ) print ( )"
def decdiagonal ( a ) : if ( 0 > a ) : return - 1 d = 1.902 * a return d
"def diagonalsquare ( mat , row , column ) : print ( ""Diagonalone:"" , end = """" ) for i in range ( 0 , row ) : print ( mat [ i ] [ i ] * mat [ i ] [ i ] , end = """" ) print ( ""\n\nDiagonaltwo:"" , end = """" ) i = 0 while i in list ( range ( row ) ) : print ( mat [ i ] [ row - i - 1 ] * mat [ i ] [ row - i - 1 ] , end = """" ) i += 1"
"def isKAlternating ( s , k ) : if ( len ( s ) < k ) : return False checker = 0 for i in range ( k ) : bitAtIndex = ord ( s [ i ] ) - ord ( 'a' ) if ( ( checker & ( 1 << bitAtIndex ) ) > 0 ) : return False checker = checker | ( 1 << bitAtIndex ) i = k while i in list ( range ( len ( s ) ) ) : if ( s [ i - k ] != s [ i ] ) : i += 1 return False i += 1 return True"
def countPaths ( n ) : zB = 1 zADC = 0 i = 1 while i in list ( range ( n + 1 ) ) : nzB = zADC * 3 nzADC = ( zADC * 2 + zB ) zB = nzB zADC = nzADC i += 1 return zB
"def check ( arr , N ) : even = 0 odd = 0 i = 0 while i in list ( range ( N ) ) : if ( arr [ i ] % 2 == 1 ) : odd += 1 else : even += 1 i += 1 if ( even == N or odd == N ) : print ( ""Yes"" ) else : print ( ""No"" )"
"def findElement ( arr , n ) : prefixMul = [ ] prefixMul.append ( arr [ 0 ] ) i = 1 while i in list ( range ( n ) ) : prefixMul.append ( prefixMul [ i - 1 ] * arr [ i ] ) i += 1 suffixMul = [ None for i in range ( 0 , n ) ] suffixMul [ n - 1 ] = arr [ n - 1 ] for i in range ( n - 2 , - 1 , - 1 ) : suffixMul [ i ] = suffixMul [ i + 1 ] * arr [ i ] for i in range ( 1 , n - 1 ) : if prefixMul [ i ] == suffixMul [ i ] : return arr [ i ] return - 1"
"def findremainder ( arr , lens , n ) : mul = 1 i = 0 while i in list ( range ( lens ) ) : mul = ( mul * ( arr [ i ] % n ) ) % n i += 1 return mul % n"
"def isHalfReducible ( arr , n , m ) : frequencyHash = [ 0 ] * ( m + 1 ) i = 0 while ( i < n ) : frequencyHash [ ( arr [ i ] % ( m + 1 ) ) ] += 1 i += 1 i = 0 while ( i <= m ) : if ( frequencyHash [ i ] >= ( n / 2 ) ) : break i += 1 if ( m >= i ) : print ( ""Yes"" ) else : print ( ""No"" )"
def countStrings ( n ) : a = [ 0 for i in range ( n ) ] b = [ 0 for i in range ( n ) ] a [ 0 ] = b [ 0 ] = 1 i = 1 while i in list ( range ( n ) ) : a [ i ] = a [ i - 1 ] + b [ i - 1 ] b [ i ] = a [ i - 1 ] i += 1 return a [ n - 1 ] + b [ n - 1 ]
"def findMaxNum ( arr , n ) : hash = [ 0 ] * 10 for i in range ( n ) : hash [ arr [ i ] ] += 1 i = 9 while i in list ( range ( - 1 ) ) : for j in range ( hash [ i ] ) : print ( i , end = """" ) i += - 1"
def squareFree ( n ) : cnt = 0 i = 1 while ( True ) : isSqFree = True j = 2 while ( i >= j * j ) : if ( i % ( j * j ) == 0 ) : isSqFree = False break j += 1 if ( isSqFree == True ) : cnt += 1 if ( cnt == n ) : return i i += 1 return 0
def doublefactorial ( n ) : res = 1 i = n while i in list ( range ( - 1 ) ) : if ( i == 0 or i == 1 ) : i += - 2 return res else : res *= i i += - 2
"def minSwaps ( arr , n ) : noOfOnes = 0 for i in range ( n ) : if ( arr [ i ] == 1 ) : noOfOnes = noOfOnes + 1 x = noOfOnes maxOnes = - 2147483648 preCompute = { } if ( arr [ 0 ] == 1 ) : preCompute [ 0 ] = 1 i = 1 while i in list ( range ( n ) ) : if ( arr [ i ] == 1 ) : preCompute [ i ] = preCompute [ i - 1 ] + 1 else : preCompute [ i ] = preCompute [ i - 1 ] i += 1 for i in range ( x - 1 , n ) : if ( i == ( x - 1 ) ) : noOfOnes = preCompute [ i ] else : noOfOnes = preCompute [ i ] - preCompute [ i - x ] if ( maxOnes < noOfOnes ) : maxOnes = noOfOnes noOfZeroes = x - maxOnes return noOfZeroes"
def nthHarmonic ( N ) : harmonic = 1.00 i = 2 while i in list ( range ( N + 1 ) ) : harmonic += 1 / i i += 1 return harmonic
"def printNumber ( holes ) : if ( holes == 0 ) : print ( ""1"" ) elif ( holes == 1 ) : print ( ""0"" , end = """" ) else : rem = 0 quo = 0 rem = holes % 2 quo = holes // 2 if ( rem == 1 ) : print ( ""4"" , end = """" ) i = 0 while i in list ( range ( quo ) ) : print ( ""8"" , end = """" ) i += 1"
"def min_visible_bottles ( arr , n ) : m = dict ( ) ans = 0 i = 0 while i in list ( range ( n ) ) : m [ arr [ i ] ] = m.get ( arr [ i ] , 0 ) + 1 ans = max ( ans , m [ arr [ i ] ] ) i += 1 print ( ""Minimumnumberof"" , ""VisibleBottlesare:"" , ans )"
def calculateLeaps ( n ) : if ( 0 == n ) : return 1 return ( 1 << ( n - 1 ) )
"def getMaxLength ( arr , n ) : start = 0 preCnt = 0 while ( start < n and arr [ start ] == 1 ) : preCnt = preCnt + 1 start = start + 1 end = n - 1 suffCnt = 0 while ( end >= 0 and arr [ end ] == 1 ) : suffCnt = suffCnt + 1 end = end - 1 if ( start > end ) : return n midCnt = 0 i = start result = 0 while ( i <= end ) : if ( arr [ i ] != 1 ) : midCnt = 0 else : midCnt = midCnt + 1 result = max ( result , midCnt ) i = i + 1 return max ( result , preCnt + suffCnt )"
"def balancedString ( str ) : count , i = 0 , 0 n = len ( str ) for i in range ( n ) : if ( str [ i ] == '(' ) : print ( str [ i ] , end = """" ) count += 1 elif ( str [ i ] == ')' and count != 0 ) : print ( str [ i ] , end = """" ) count -= 1 elif ( str [ i ] != ')' ) : print ( str [ i ] , end = """" ) if ( count != 0 ) : i = 0 while i in list ( range ( count ) ) : print ( "")"" , end = """" ) i += 1"
"def evenSum ( n ) : C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] i = 0 while i in list ( range ( n + 1 ) ) : for j in range ( 0 , min ( i , n + 1 ) ) : if j == 0 or j == i : C [ i ] [ j ] = 1 else : C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] i += 1 sum = 0 for i in range ( 0 , n + 1 ) : if n % 2 == 0 : sum = sum + C [ n ] [ i ] return sum"
"def assign ( a , n ) : a.sort ( ) ans = [ 0 ] * n p = 0 q = n - 1 i = 0 while i in list ( range ( n ) ) : if 0 == ( i + 1 ) % 2 : ans [ i ] = a [ q ] q = q - 1 else : ans [ i ] = a [ p ] i += 1"
"def findSmallestDifference ( A , B , m , n ) : A.sort ( ) B.sort ( ) a = 0 b = 0 result = sys.maxsize while ( a < m and b < n ) : if ( abs ( A [ a ] - B [ b ] ) < result ) : result = abs ( A [ a ] - B [ b ] ) if ( B [ b ] > A [ a ] ) : a += 1 else : b += 1 return result"
"def findString ( str , n , k ) : if ( k == 0 ) : print ( str ) return str2 = str p = 0 i = 0 while i in list ( range ( n ) ) : if ( str2 [ i ] != 'a' ) : str2 = str2.replace ( str2 [ i ] , 'a' ) p += 1 if ( p == k ) : i += 1 break i += 1 if ( p < k ) : i = n - 1 while ( i >= 0 ) : if ( str [ i ] == 'a' ) : str2 = str2.replace ( str2 [ i ] , 'b' ) p += 1 if ( p == k ) : break i -= 1 print ( str2 )"
def kthgroupsum ( k ) : cur = int ( ( k * ( k - 1 ) ) + 1 ) sum = 0 while k : sum = sum + cur cur = cur + 2 k = k - 1 return sum
"def isPermutedMatrix ( mat , n ) : str_cat = """" for i in range ( n ) : str_cat = str_cat + ""-"" + str ( mat [ 0 ] [ i ] ) str_cat = str_cat + str_cat for i in range ( 1 , n ) : curr_str = """" j = 0 while j in list ( range ( n ) ) : curr_str = curr_str + ""-"" + str ( mat [ i ] [ j ] ) j += 1 if ( str_cat.find ( curr_str ) ) : return True return False"
"def maxNumber ( string , n ) : freq = [ 0 , 0 ] i = 0 while i in list ( range ( n ) ) : if ( string [ i ] == 'z' ) : freq [ 0 ] += 1 elif ( string [ i ] == 'n' ) : freq [ 1 ] += 1 i += 1 num = """" for i in range ( freq [ 1 ] ) : num += '1' for i in range ( freq [ 0 ] ) : num += '0' return num"
"def countFriendsPairings ( n ) : a , b , c = 1 , 2 , 0 if ( n <= 2 ) : return n i = 3 while i in list ( range ( n + 1 ) ) : c = b + ( i - 1 ) * a a = b b = c i += 1 return c"
"def slopeOfNum ( num , n ) : slope = 0 i = 1 while i in list ( range ( n - 1 ) ) : if ( num [ i ] > num [ i - 1 ] and num [ i ] > num [ i + 1 ] ) : slope += 1 elif ( num [ i ] < num [ i - 1 ] and num [ i ] < num [ i + 1 ] ) : slope += 1 i += 1 return slope"
"def findMissing ( arr , n ) : l , h = 0 , n - 1 mid = 0 while ( h > l ) : mid = l + ( h - l ) // 2 if ( arr [ mid ] - mid == arr [ 0 ] ) : if ( 1 < arr [ mid + 1 ] - arr [ mid ] ) : return arr [ mid ] + 1 else : l = mid + 1 else : if ( arr [ mid ] - arr [ mid - 1 ] > 1 ) : return arr [ mid ] - 1 else : h = mid - 1 return - 1"
"def ReplaceElements ( arr , n ) : X = 0 for i in range ( n ) : X ^= arr [ i ] i = 0 while i in list ( range ( n ) ) : arr [ i ] = X ^ arr [ i ] i += 1"
def isSumDivides ( N ) : temp = N sum = 0 while ( temp ) : sum = sum + temp % 10 temp = int ( temp / 10 ) if ( N % sum == 0 ) : return 1 else : return 0
"def findCount ( n , sum ) : start = math.pow ( 10 , n - 1 ) end = math.pow ( 10 , n ) - 1 count = 0 i = start while ( i <= end ) : cur = 0 temp = i while ( temp != 0 ) : cur = cur + temp % 10 temp = temp // 10 if ( cur == sum ) : count = count + 1 i = i + 9 else : i = i + 1 print ( count )"
"def findMaximumBefore ( arr , n ) : i = 0 while i in list ( range ( n ) ) : currAns = - 1 for j in range ( i - 1 , - 1 , - 1 ) : if ( arr [ j ] > currAns and arr [ j ] < arr [ i ] ) : currAns = arr [ j ] print ( currAns , end = """" ) i += 1"
"def minimumBox ( arr , n ) : q = collections.deque ( [ ] ) arr.sort ( ) q.append ( arr [ 0 ] ) i = 1 while i in list ( range ( n ) ) : now = q [ 0 ] if ( arr [ i ] >= 2 * now ) : q.popleft ( ) q.append ( arr [ i ] ) i += 1 return len ( q )"
"def FindMinimumCost ( ind , a , n , k , dp ) : if ( ind == ( n - 1 ) ) : return 0 elif ( dp [ ind ] != - 1 ) : return dp [ ind ] else : ans = sys.maxsize i = 1 while i in list ( range ( k + 1 ) ) : if ( ind + i < n ) : ans = min ( ans , abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) else : i += 1 break i += 1 dp [ ind ] = ans return ans"
"def countSquares ( m , n ) : if ( m > n ) : temp = m m = n n = temp return ( ( m * ( m + 1 ) * ( 2 * m + 1 ) / 6 + ( n - m ) * m * ( m + 1 ) / 2 ) )"
"def getAverageCountArray ( a , x , N ) : map = { } avg = [ 0 ] * N for i in range ( N ) : if a [ i ] not in map : map [ a [ i ] ] = 1 else : map [ a [ i ] ] += 1 i = 0 while i in list ( range ( N ) ) : av = ( a [ i ] + x ) // 2 if av in map : val = map [ av ] avg [ i ] = val i += 1 for i in range ( N ) : print ( avg [ i ] , end = """" )"
"def decToOctal ( n ) : octalNum = [ 0 ] * 100 i = 0 while ( n != 0 ) : octalNum [ i ] = n % 8 n = int ( n / 8 ) i += 1 j = i - 1 while j in list ( range ( - 1 ) ) : print ( octalNum [ j ] , end = """" ) j += - 1"
"def countMinSwaps ( st ) : min_swaps = 0 odd_0 , even_0 = 0 , 0 odd_1 , even_1 = 0 , 0 n = len ( st ) i = 0 while i in list ( range ( n ) ) : if i % 2 == 0 : if st [ i ] == ""1"" : even_1 += 1 else : even_0 += 1 else : if st [ i ] == ""1"" : odd_1 += 1 else : odd_0 += 1 i += 1 cnt_swaps_1 = min ( even_0 , odd_1 ) cnt_swaps_2 = min ( even_1 , odd_0 ) return min ( cnt_swaps_1 , cnt_swaps_2 )"
"def remainderWith7 ( num ) : series = [ 1 , 3 , 2 , - 1 , - 3 , - 2 ] series_index = 0 result = 0 i = ( len ( num ) - 1 ) while i in list ( range ( - 1 ) ) : digit = ord ( num [ i ] ) - 48 result += digit * series [ series_index ] series_index = ( series_index + 1 ) % 6 result %= 7 i += - 1 if ( result < 0 ) : result = ( result + 7 ) % 7 return result"
"def binarySearch ( arr , low , high ) : if high >= low : mid = ( low + high ) // 2 if mid is arr [ mid ] : return mid if arr [ mid ] < mid : return binarySearch ( arr , ( mid + 1 ) , high ) else : return binarySearch ( arr , low , ( mid - 1 ) ) return - 1"
"def findTriplets ( arr , n ) : found = False for i in range ( n - 1 ) : s = set ( ) j = i + 1 while j in list ( range ( n ) ) : x = - ( arr [ i ] + arr [ j ] ) if x in s : print ( x , arr [ i ] , arr [ j ] ) found = True else : s.add ( arr [ j ] ) j += 1 if found == False : print ( ""NoTripletFound"" )"
"def findLength ( arr , n ) : x = 0 i = 0 while i in list ( range ( n ) ) : x = max ( x , arr [ i ] ) i += 1 ans = 0 for i in range ( n ) : if ( arr [ i ] != x ) : continue j = i while ( arr [ j ] == x ) : j += 1 if j >= n : break ans = max ( ans , j - i ) return ans"
"def findSubArray ( arr , n ) : sum = 0 maxsize = - 1 for i in range ( 0 , n - 1 ) : sum = - 1 if ( arr [ i ] == 0 ) else 1 j = i + 1 while j in list ( range ( n ) ) : sum = sum + ( - 1 ) if ( arr [ j ] == 0 ) else sum + 1 if ( sum == 0 and maxsize < j - i + 1 ) : maxsize = j - i + 1 startindex = i j += 1 if ( maxsize == - 1 ) : print ( ""Nosuchsubarray"" ) else : print ( startindex , ""to"" , startindex + maxsize - 1 ) return maxsize"
"def printLargestString ( s , l , r ) : freq = [ 0 ] * 26 l -= 1 r -= 1 i = min ( l , r ) while i in list ( range ( max ( l , r ) + 1 ) ) : freq [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1 i += 1 ans = """" for i in range ( 25 , - 1 , - 1 ) : while ( freq [ i ] ) : ans += chr ( ord ( 'a' ) + i ) freq [ i ] -= 1 return ans"
"def maximumSum ( arr , n , k ) : i = 1 while i in list ( range ( k + 1 ) ) : min = + 2147483647 index = - 1 for j in range ( n ) : if ( arr [ j ] < min ) : min = arr [ j ] index = j if ( min == 0 ) : i += 1 break arr [ index ] = - arr [ index ] i += 1 sum = 0 for i in range ( n ) : sum += arr [ i ] return sum"
"def printPermutation ( n ) : if ( n % 2 != 0 ) : print ( - 1 ) else : i = 1 while i in list ( range ( ( n // 2 ) + 1 ) ) : print ( ( 2 * i ) , ( 2 * i - 1 ) , end = """" ) i += 1"
"def findMinimumX ( a , n ) : st = set ( ) i = 0 while i in list ( range ( n ) ) : st.add ( a [ i ] ) i += 1 if ( len ( st ) == 1 ) : return 0 if ( len ( st ) == 2 ) : st = list ( st ) el1 = st [ 0 ] el2 = st [ 1 ] if ( ( el2 - el1 ) % 2 == 0 ) : return int ( ( el2 - el1 ) / 2 ) else : return ( el2 - el1 ) if ( len ( st ) == 3 ) : st = list ( st ) el1 = st [ 0 ] el2 = st [ 1 ] el3 = st [ 2 ] if ( ( el2 - el1 ) == ( el3 - el2 ) ) : return el2 - el1 else : return - 1 return - 1"
"def doMatch ( A , B ) : i = 0 while i in list ( range ( len ( A ) ) ) : if A [ i ] != '*' and B [ i ] != '*' : if A [ i ] != B [ i ] : i += 1 return False i += 1 return True"
"def getTotalXorOfSubarrayXors ( arr , N ) : res = 0 for i in range ( 0 , N ) : j = i while j in list ( range ( N ) ) : for k in range ( i , j + 1 ) : res = res ^ arr [ k ] j += 1 return res"
"def print_result ( a , n , k , m ) : v = [ [ ] for i in range ( m ) ] i = 0 while i in list ( range ( n ) ) : rem = a [ i ] % m v [ rem ].append ( a [ i ] ) if ( len ( v [ rem ] ) == k ) : for j in range ( 0 , k ) : print ( v [ rem ] [ j ] , end = """" ) i += 1 return i += 1 print ( - 1 )"
"def cntSplits ( s ) : if ( s [ len ( s ) - 1 ] == '1' ) : return 0 c_zero = 0 i = 0 while i in list ( range ( len ( s ) ) ) : c_zero += ( s [ i ] == '0' ) i += 1 return int ( pow ( 2 , c_zero - 1 ) )"
"def isDivisible ( arr , n ) : lastDigit = arr [ n - 1 ] % 10 if ( 0 == lastDigit ) : return True return False"
"def findSumofEle ( arr1 , m , arr2 , n , k ) : arraySum = 0 i = 0 while i in list ( range ( n ) ) : arraySum += arr2 [ i ] i += 1 mean = arraySum / n sumOfElements = 0 difference = 0 for i in range ( m ) : difference = arr1 [ i ] - mean if ( ( difference < 0 ) and ( k > ( - 1 ) * difference ) ) : sumOfElements += arr1 [ i ] if ( ( difference >= 0 ) and ( k > difference ) ) : sumOfElements += arr1 [ i ] return sumOfElements"
"def substringConversions ( str1 , k , b ) : i = 0 while i in list ( range ( len ( str1 ) - k + 1 ) ) : sub = str1 [ i : k + i ] Sum = 0 counter = 0 for i in range ( len ( sub ) - 1 , - 1 , - 1 ) : Sum = ( Sum + ( ( ord ( sub [ i ] ) - ord ( '0' ) ) * pow ( b , counter ) ) ) counter += 1 print ( Sum , end = """" ) i += 1"
"def cone ( a ) : if ( 0 > a ) : return - 1 r = ( a * math.sqrt ( 2 ) ) / 3 h = ( 2 * a ) / 3 V = 3.14 * math.pow ( r , 2 ) * h return V"
"def countWords ( stri , n ) : m = dict ( ) i = 0 while i in list ( range ( n ) ) : m [ stri [ i ] ] = m.get ( stri [ i ] , 0 ) + 1 i += 1 res = 0 for i in m.values ( ) : if i == 2 : res += 1 return res"
"def findEvenPair ( A , N ) : count = 0 i = 0 while i in list ( range ( N ) ) : if ( not ( A [ i ] & 1 ) ) : count += 1 i += 1 return count * ( count - 1 ) // 2"
"def maxCost ( mat , N ) : dp = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] for i in range ( 1 , N ) : dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] for i in range ( 1 , N ) : for j in range ( 1 , min ( i + 1 , N ) ) : dp [ i ] [ j ] = mat [ i ] [ j ] + max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) result = 0 i = 0 while i in list ( range ( N ) ) : if ( result < dp [ N - 1 ] [ i ] ) : result = dp [ N - 1 ] [ i ] i += 1 return result"
"def bellNumber ( n ) : bell = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] bell [ 0 ] [ 0 ] = 1 i = 1 while i in list ( range ( n + 1 ) ) : bell [ i ] [ 0 ] = bell [ i - 1 ] [ i - 1 ] for j in range ( 1 , i + 1 ) : bell [ i ] [ j ] = bell [ i - 1 ] [ j - 1 ] + bell [ i ] [ j - 1 ] i += 1 return bell [ n ] [ 0 ]"
"def printPattern ( n ) : if ( 0 == n or n < 0 ) : print ( n , end = "","" ) return print ( n , end = "","" ) printPattern ( n - 5 ) print ( n , end = "","" )"
def nextGreater ( N ) : power_of_2 = 1 shift_count = 0 while ( True ) : if ( 0 == ( ( N >> shift_count ) & 1 ) % 2 ) : break shift_count += 1 power_of_2 = power_of_2 * 2 return ( N + power_of_2 )
"def closetAND ( arr , n , k ) : ans = sys.maxsize for i in range ( n ) : X = arr [ i ] j = i while j in list ( range ( n ) ) : X &= arr [ j ] ans = min ( ans , abs ( k - X ) ) if ( X <= k ) : j += 1 break j += 1 return ans"
"def calcSum ( arr , n , k ) : sum = 0 i = 0 while i in list ( range ( k ) ) : sum += arr [ i ] i += 1 print ( sum , end = """" ) for i in range ( k , n ) : sum = ( sum - arr [ i - k ] ) + arr [ i ] print ( sum , end = """" )"
"def isPlusPossible ( arr , n ) : mp = dict ( ) i = 0 while i in list ( range ( n ) ) : mp [ arr [ i ] ] = mp.get ( arr [ i ] , 0 ) + 1 i += 1 foundModOne = False for x in mp : element = x frequency = mp [ x ] if ( frequency % 4 == 0 ) : continue if ( frequency % 4 == 1 ) : if ( foundModOne == True ) : return False foundModOne = True else : return False return True"
"def exponentMod ( A , B , C ) : if ( A == 0 ) : return 0 if ( B == 0 ) : return 1 y = 0 if ( B % 2 != 0 ) : y = A % C y = ( y * exponentMod ( A , B - 1 , C ) % C ) % C else : y = exponentMod ( A , B / 2 , C ) y = ( y * y ) % C return ( ( y + C ) % C )"
"def fibWord ( n ) : Sn_1 = ""0"" Sn = ""01"" tmp = """" i = 2 while i in list ( range ( n + 1 ) ) : tmp = Sn Sn += Sn_1 Sn_1 = tmp i += 1 return Sn"
"def numberOfSolutions ( n ) : c = 0 while ( n ) : c = c + n % 2 n //= 2 return int ( pow ( 2 , c ) )"
"def findMax ( a , n ) : dp = np.zeros ( ( n , 2 ) ) dp [ 0 ] [ 0 ] = a [ 0 ] + a [ 1 ] dp [ 0 ] [ 1 ] = a [ 0 ] * a [ 1 ] i = 1 while i in list ( range ( n - 1 ) ) : dp [ i ] [ 0 ] = max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + a [ i + 1 ] dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] - a [ i ] + a [ i ] * a [ i + 1 ] i += 1 print ( max ( dp [ n - 2 ] [ 0 ] , dp [ n - 2 ] [ 1 ] ) , end = """" )"
"def findQuadruples ( a , b , c , d , x , n ) : count = 0 i = 0 while i in list ( range ( n ) ) : for j in range ( n ) : for k in range ( n ) : for l in range ( n ) : if ( ( a [ i ] ^ b [ j ] ^ c [ k ] ^ d [ l ] ) == x ) : count += 1 i += 1 return count"
"def addToArrayForm ( A , K ) : v , ans = [ ] , [ ] rem , i = 0 , 0 for i in range ( len ( A ) - 1 , - 1 , - 1 ) : my = A [ i ] + ( K % 10 ) + rem if my > 9 : rem = 1 v.append ( my % 10 ) else : v.append ( my ) rem = 0 K = K // 10 while K > 0 : my = ( K % 10 ) + rem v.append ( my % 10 ) if my // 10 > 0 : rem = 1 else : rem = 0 K = K // 10 if rem > 0 : v.append ( rem ) i = len ( v ) - 1 while i in list ( range ( - 1 ) ) : ans.append ( v [ i ] ) i += - 1 return ans"
"def shufleArray ( a , n ) : n = n // 2 start = n + 1 j = n + 1 done = 0 while done in list ( range ( 2 * n - 2 ) ) : if ( start == j ) : start -= 1 j -= 1 i = j - n if j > n else j j = 2 * i if j > n else 2 * i - 1 a [ start ] , a [ j ] = a [ j ] , a [ start ] done += 1"
"def andOperator ( a , b ) : while ( b > a ) : b -= ( b & - b ) return b"
"def maxProductSubset ( a , n ) : if n == 1 : return a [ 0 ] max_neg = - 999999999999 count_neg = 0 count_zero = 0 prod = 1 i = 0 while i in list ( range ( n ) ) : if a [ i ] == 0 : count_zero += 1 i += 1 continue if a [ i ] < 0 : count_neg += 1 max_neg = max ( max_neg , a [ i ] ) prod = prod * a [ i ] i += 1 if count_zero == n : return 0 if count_neg & 1 : if ( count_neg == 1 and count_zero > 0 and count_zero + count_neg == n ) : return 0 prod = int ( prod / max_neg ) return prod"
"def printMinimumProduct ( arr , n ) : first_min = min ( arr [ 0 ] , arr [ 1 ] ) second_min = max ( arr [ 0 ] , arr [ 1 ] ) i = 2 while i in list ( range ( n ) ) : if ( arr [ i ] < first_min ) : second_min = first_min first_min = arr [ i ] elif ( arr [ i ] < second_min ) : second_min = arr [ i ] i += 1 return first_min * second_min"
"def cyl ( r , R , h ) : if ( 0 > h and r < 0 and R < 0 ) : return - 1 r1 = r h1 = h V = 3.14 * pow ( r1 , 2 ) * h1 return round ( V , 2 )"
def smallestX ( n ) : temp = [ 0 ] * 10 if ( n == 0 ) : return - 1 count = 0 x = 1 while ( count < 10 ) : y = x * n while ( y > 0 ) : if ( 0 == temp [ y % 10 ] ) : count += 1 temp [ y % 10 ] = 1 y = int ( y / 10 ) x += 1 return x - 1
def possible ( n ) : if ( 3 < n ) : sum = ( n * ( n + 1 ) ) // 2 if ( sum % 3 == 0 ) : return True return False
"def checkPair ( arr , n ) : s = set ( ) sum = 0 i = 0 while i in list ( range ( n ) ) : sum += arr [ i ] i += 1 if sum % 2 != 0 : return False sum = sum / 2 for i in range ( n ) : val = sum - arr [ i ] if arr [ i ] not in s : s.add ( arr [ i ] ) if val in s : print ( ""Pairelementsare"" , arr [ i ] , ""and"" , int ( val ) )"
def countReduce ( str ) : n = len ( str ) res = 0 i = 0 while i in list ( range ( int ( n / 2 ) ) ) : res += abs ( int ( ord ( str [ i ] ) ) - int ( ord ( str [ n - i - 1 ] ) ) ) i += 1 return res
def nthTerm ( N ) : nth = 0 ; first_term = 4 pi = 1 ; po = 1 n = N while ( 1 < n ) : pi *= n - 1 n -= 1 po *= 2 nth = ( first_term * pi ) // po return nth
def f ( n ) : if n % 2 != 0 : return 3 * n + 1 else : return n // 2
"def printPalindrome ( n ) : if ( n != 1 ) : print ( ""SmallestPalindrome:"" , int ( pow ( 10 , n - 1 ) ) + 1 ) print ( ""LargestPalindrome:"" , int ( pow ( 10 , n ) ) - 1 ) else : print ( ""SmallestPalindrome:0"" ) print ( ""LargestPalindrome:9"" )"
"def power ( x , y ) : if ( 0 == y ) : return 1 temp = power ( x , int ( y / 2 ) ) if ( y % 2 == 0 ) : return temp * temp else : if ( y > 0 ) : return x * temp * temp else : return ( temp * temp ) / x"
"def maxLevel ( boxes , n ) : boxes.sort ( ) ans = 1 prev_width = boxes [ 0 ] prev_count = 1 curr_count = 0 curr_width = 0 for i in range ( 1 , n ) : curr_width = curr_width + boxes [ i ] curr_count = curr_count + 1 if ( curr_width > prev_width and curr_count > prev_count ) : prev_width = curr_width prev_count = curr_count curr_count = 0 curr_width = 0 ans = ans + 1 return ans"
def isDivisible ( n ) : while n // 100 : d = n % 10 n //= 10 n = abs ( n - ( d * 3 ) ) return ( 0 == n % 31 )
def minimumSwaps ( arr ) : count = 0 i = 0 while ( len ( arr ) > i ) : if ( arr [ i ] != i + 1 ) : while ( arr [ i ] != i + 1 ) : temp = 0 temp = arr [ arr [ i ] - 1 ] arr [ arr [ i ] - 1 ] = arr [ i ] arr [ i ] = temp count += 1 i += 1 return count
"def canMake ( s ) : o = 0 ; z = 0 i = 0 while i in list ( range ( len ( s ) ) ) : if ( ord ( s [ i ] ) - ord ( '0' ) == 1 ) : o += 1 else : z += 1 i += 1 if ( o % 2 == 1 and z % 2 == 1 ) : return ""NO"" else : return ""YES"""
"def pairSum ( mat , n , sum ) : for i in range ( n ) : mat [ i ].sort ( ) for i in range ( n - 1 ) : j = i + 1 while j in list ( range ( n ) ) : left = 0 right = n - 1 while ( left < n and right >= 0 ) : if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum ) : print ( ""("" , mat [ i ] [ left ] , "","" , mat [ j ] [ right ] , ""),"" , end = """" ) left += 1 right -= 1 else : if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum ) : left += 1 else : right -= 1 j += 1"
"def sum ( x , n ) : total = 1.0 previous = 1.0 i = 1 while i in list ( range ( n + 1 ) ) : previous = ( previous * x ) / ( i + 1 ) total = total + previous i += 1 return total"
def odd_digits ( n ) : if ( n < 10 ) : return n elif ( n / 10 < 10 ) : return 9 elif ( n / 100 < 10 ) : return 9 + n - 99 elif ( 10 > n / 1000 ) : return 9 + 900 elif ( n / 10000 < 10 ) : return 909 + n - 9999 else : return 90909
"def countPairsWithDiffK ( arr , n , k ) : count = 0 for i in range ( 0 , n ) : j = i + 1 while j in list ( range ( n ) ) : if arr [ i ] - arr [ j ] == k or arr [ j ] - arr [ i ] == k : count += 1 j += 1 return count"
"def sumOfLargePrimeFactor ( n ) : prime = [ 0 ] * ( n + 1 ) sum = 0 max = int ( n / 2 ) for p in range ( 2 , max + 1 ) : if prime [ p ] == 0 : i = p * 2 while i in list ( range ( n + 1 ) ) : prime [ i ] = p i += p for p in range ( 2 , n + 1 ) : if prime [ p ] : sum += prime [ p ] else : sum += p return sum"
"def countP ( n , k ) : if ( n == 0 or k == 0 or k > n ) : return 0 if ( k == 1 or n == k ) : return 1 return ( k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) )"
"def solve ( a , b ) : length = len ( a ) half_length = length // 2 if ( a == b ) : return True elif 0 == ( len ( a ) % 2 ) : a1 = a [ : half_length ] a2 = a [ half_length : ] b1 = b [ : half_length ] b2 = b [ half_length : ] return ( ( solve ( a1 , b2 ) and solve ( a2 , b1 ) ) or ( solve ( a1 , b1 ) and solve ( a2 , b2 ) ) ) else : return False"
"def printSorted ( a , n ) : front = - 1 back = - 1 for i in range ( 1 , n , 1 ) : if ( a [ i ] < a [ i - 1 ] ) : front = i - 1 break i = n - 2 while ( i >= 0 ) : if ( a [ i ] > a [ i + 1 ] ) : back = i + 1 break i -= 1 if ( front == - 1 and back == - 1 ) : i = 0 while i in list ( range ( n ) ) : print ( a [ i ] , end = """" ) i += 1 return while ( front <= back ) : temp = a [ front ] a [ front ] = a [ back ] a [ back ] = temp front += 1 back -= 1 for i in range ( 0 , n , 1 ) : print ( a [ i ] , end = """" )"
def xorZero ( str ) : one_count = 0 zero_count = 0 n = len ( str ) i = 0 while i in list ( range ( n ) ) : if ( str [ i ] == '1' ) : one_count += 1 else : zero_count += 1 i += 1 if ( one_count % 2 == 0 ) : return zero_count return one_count
"def findOnBulbs ( numberOfBulbs ) : onBulbs = 0 bulb = 1 person = 1 for bulb in range ( 1 , numberOfBulbs + 1 ) : factors = 0 person = 1 while person in list ( range ( int ( numberOfBulbs ** ( 0.5 ) ) + 1 ) ) : if bulb % person == 0 : factors += 1 if bulb // person != person : factors += 1 person += 1 if factors % 2 == 1 : print ( ""Lightbulb"" , bulb , ""willbeon"" ) onBulbs += 1 return onBulbs"
"def CountTriangles ( A ) : n = len ( A ) A.sort ( ) count = 0 i = n - 1 while i in list ( range ( 0 ) ) : l = 0 r = i - 1 while ( l < r ) : if ( A [ l ] + A [ r ] > A [ i ] ) : count += r - l r -= 1 else : l += 1 i += - 1 print ( ""Noofpossiblesolutions:"" , count )"
"def isSubsetSum ( set , n , sum ) : subset = ( [ [ False for i in range ( sum + 1 ) ] for i in range ( n + 1 ) ] ) for i in range ( n + 1 ) : subset [ i ] [ 0 ] = True i = 1 while i in list ( range ( sum + 1 ) ) : subset [ 0 ] [ i ] = False i += 1 for i in range ( 1 , n + 1 ) : for j in range ( 1 , sum + 1 ) : if j < set [ i - 1 ] : subset [ i ] [ j ] = subset [ i - 1 ] [ j ] if j >= set [ i - 1 ] : subset [ i ] [ j ] = ( subset [ i - 1 ] [ j ] or subset [ i - 1 ] [ j - set [ i - 1 ] ] ) return subset [ n ] [ sum ]"
"def isHeap ( arr , n ) : i = 0 while i in list ( range ( int ( ( n - 2 ) / 2 ) + 1 ) ) : if arr [ 2 * i + 1 ] > arr [ i ] : i += 1 return False if ( 2 * i + 2 < n and arr [ 2 * i + 2 ] > arr [ i ] ) : i += 1 return False i += 1 return True"
"def printPascal ( n : int ) : arr = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] line = 0 while line in list ( range ( n ) ) : for i in range ( 0 , line + 1 ) : if ( i is 0 or i is line ) : arr [ line ] [ i ] = 1 print ( arr [ line ] [ i ] , end = """" ) else : arr [ line ] [ i ] = ( arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ) print ( arr [ line ] [ i ] , end = """" ) print ( ""\n"" , end = """" ) line += 1"
"def censor ( text , word ) : word_list = text.split ( ) result = '' stars = '' * len ( word ) count = 0 index = 0 for i in word_list : if i == word : word_list [ index ] = stars index = index + 1 result = ''.join ( word_list ) return result"
"def f ( X ) : res = 0 if X % 4 in [ 1 , 2 ] : res += 1 p = 4 for i in range ( 50 ) : if p // 2 <= X % p and ( X % p - p // 2 + 1 ) % 2 == 1 : res += 2 ** ( i + 1 ) p *= 2 return res"
"def findMissing ( arr , n , k , avg ) : sum = 0 i = 0 while i in list ( range ( n ) ) : sum += arr [ i ] i += 1 num = ( avg * ( n + k ) ) - sum den = k if ( num % den != 0 ) : return - 1 return ( int ) ( num / den )"
def countStrings ( s ) : sum = 1 i = 0 while i in list ( range ( len ( s ) ) ) : if ( i % 2 == 0 and s [ i ] == '$' ) : sum *= 21 elif ( s [ i ] == '$' ) : sum *= 5 i += 1 return sum
"def isInGivenBase ( Str , base ) : if ( base > 16 ) : return False elif ( base <= 10 ) : i = 0 while i in list ( range ( len ( Str ) ) ) : if ( Str [ i ].isnumeric ( ) and ( ord ( Str [ i ] ) >= ord ( '0' ) and ord ( Str [ i ] ) < ( ord ( '0' ) + base ) ) == False ) : i += 1 return False i += 1 else : for i in range ( len ( Str ) ) : if ( Str [ i ].isnumeric ( ) and ( ( ord ( Str [ i ] ) >= ord ( '0' ) and ord ( Str [ i ] ) < ( ord ( '0' ) + base ) ) or ( ord ( Str [ i ] ) >= ord ( 'A' ) and ord ( Str [ i ] ) < ( ord ( 'A' ) + base - 10 ) ) ) == False ) : return False return True"
"def check ( arr , n ) : count = 0 i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] & 1 ) : count = count + 1 i += 1 if ( count & 1 ) : return ""Odd"" else : return ""Even"""
"def mostFrequent ( arr , n ) : arr.sort ( ) max_count = 1 res = arr [ 0 ] curr_count = 1 i = 1 while i in list ( range ( n ) ) : if ( arr [ i ] == arr [ i - 1 ] ) : curr_count += 1 else : if ( curr_count > max_count ) : max_count = curr_count res = arr [ i - 1 ] curr_count = 1 i += 1 if ( curr_count > max_count ) : max_count = curr_count res = arr [ n - 1 ] return res"
"def checkForElement ( array , n ) : sum = 0 i = 0 while i in list ( range ( n ) ) : sum += array [ i ] i += 1 if ( sum % 2 ) : return False sum //= 2 start = 0 end = n - 1 while ( start <= end ) : mid = start + ( end - start ) // 2 if ( array [ mid ] == sum ) : return True elif ( array [ mid ] > sum ) : end = mid - 1 else : start = mid + 1 return False"
"def printMatrix ( n , k ) : i = 0 while i in list ( range ( n ) ) : for j in range ( n ) : if ( i == j ) : print ( k , end = """" ) else : print ( ""0"" , end = """" ) print ( ) i += 1"
"def modInverse ( a , m ) : m0 = m y = 0 x = 1 if ( m == 1 ) : return 0 while ( 1 < a ) : q = a // m t = m m = a % m a = t t = y y = x - q * y x = t if ( x < 0 ) : x = x + m0 return x"
"def subsetBitwiseORk ( arr , n , k ) : v = [ ] for i in range ( 0 , n ) : if ( ( arr [ i ] | k ) == k ) : v.append ( arr [ i ] ) ans = 0 for i in range ( 0 , len ( v ) ) : ans |= v [ i ] if ( ans != k ) : print ( ""Subsetdoesnotexist\n"" ) return i = 0 while i in list ( range ( len ( v ) ) ) : print ( ""{}"".format ( v [ i ] ) , end = """" ) i += 1"
"def productSubSeqCount ( arr , k ) : n = len ( arr ) dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( k + 1 ) ] i = 1 while i in list ( range ( k + 1 ) ) : for j in range ( 1 , n + 1 ) : dp [ i ] [ j ] = dp [ i ] [ j - 1 ] if arr [ j - 1 ] <= i and arr [ j - 1 ] > 0 : dp [ i ] [ j ] += dp [ i // arr [ j - 1 ] ] [ j - 1 ] + 1 i += 1 return dp [ k ] [ n ]"
"def CountSegments ( N , a ) : frequency = [ 0 ] * 10001 c = 0 for i in range ( N ) : frequency [ a [ i ] ] += 1 i = 0 while i in list ( range ( 10001 ) ) : c = max ( c , frequency [ i ] ) i += 1 print ( c )"
"def charCheck ( input_char ) : if ( ( int ( ord ( input_char ) ) >= 65 and int ( ord ( input_char ) ) <= 90 ) or ( 97 <= int ( ord ( input_char ) ) and int ( ord ( input_char ) ) <= 122 ) ) : print ( ""Alphabet"" ) elif ( int ( ord ( input_char ) ) >= 48 and int ( ord ( input_char ) ) <= 57 ) : print ( ""Digit"" ) else : print ( ""SpecialCharacter"" )"
"def countSubArrays ( arr , n , x ) : len = 0 count = 0 binaryArr = [ 0 for i in range ( n ) ] i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] <= x ) : binaryArr [ i ] = 1 else : binaryArr [ i ] = 0 i += 1 for i in range ( 0 , n , 1 ) : if ( binaryArr [ i ] == 1 ) : for j in range ( i + 1 , n , 1 ) : if ( binaryArr [ j ] != 1 ) : break len = j - i count += ( len ) * ( int ) ( ( len + 1 ) / 2 ) i = j return count"
"def printLogestIncSubArr ( arr , n ) : m = 1 l = 1 maxIndex = 0 for i in range ( 1 , n ) : if ( arr [ i ] > arr [ i - 1 ] ) : l = l + 1 else : if ( m < l ) : m = l maxIndex = i - m l = 1 if ( m < l ) : m = l maxIndex = n - m i = maxIndex while i in list ( range ( ( m + maxIndex ) ) ) : print ( arr [ i ] , end = """" ) i += 1"
"def first ( str , i ) : if ( '\0' == str [ i ] ) : return 0 if ( str [ i ].isupper ( ) ) : return str [ i ] return first ( str , i + 1 )"
def no_of_ways ( s ) : n = len ( s ) count_left = 0 count_right = 0 i = 0 while i in list ( range ( n ) ) : if ( s [ i ] == s [ 0 ] ) : count_left += 1 else : i += 1 break i += 1 i = n - 1 while ( i >= 0 ) : if ( s [ i ] == s [ n - 1 ] ) : count_right += 1 else : break i -= 1 if ( s [ 0 ] == s [ n - 1 ] ) : return ( ( count_left + 1 ) * ( count_right + 1 ) ) else : return ( count_left + count_right + 1 )
"def minDiff ( n , x , A ) : mn = A [ 0 ] mx = A [ 0 ] i = 0 while i in list ( range ( n ) ) : mn = min ( mn , A [ i ] ) mx = max ( mx , A [ i ] ) i += 1 return max ( 0 , mx - mn - 2 * x )"
def leonardo ( n ) : dp = [ ] dp.append ( 1 ) dp.append ( 1 ) i = 2 while i in list ( range ( n + 1 ) ) : dp.append ( dp [ i - 1 ] + dp [ i - 2 ] + 1 ) i += 1 return dp [ n ]
"def isDDM ( m , n ) : i = 0 while i in list ( range ( n ) ) : sum = 0 for j in range ( 0 , n ) : sum = sum + abs ( m [ i ] [ j ] ) sum = sum - abs ( m [ i ] [ i ] ) if ( abs ( m [ i ] [ i ] ) < sum ) : i += 1 return False i += 1 return True"
"def next ( arr , target ) : start = 0 end = len ( arr ) - 1 ans = - 1 while ( start <= end ) : mid = ( start + end ) // 2 if ( arr [ mid ] > target ) : ans = mid end = mid - 1 else : start = mid + 1 return ans"
"def calculate ( a , n ) : ans = 0 i = 0 while ( i < n ) : r = i + 1 j = r while j in list ( range ( n ) ) : if ( a [ i ] == a [ j ] ) : r = r + 1 else : j += 1 break j += 1 d = r - i ans = ans + ( d * ( d + 1 ) / 2 ) i = r - 1 i = i + 1 return int ( ans )"
"def findKHCF ( x , y , k ) : small = min ( x , y ) count = 1 i = 2 while i in list ( range ( small + 1 ) ) : if ( x % i == 0 and y % i == 0 ) : count = count + 1 if ( count == k ) : i += 1 return i i += 1 return - 1"
"def printGreater ( x , y ) : X = y * math.log ( x ) Y = x * math.log ( y ) if ( abs ( X - Y ) < 1e-9 ) : print ( ""Equal"" ) elif ( Y < X ) : print ( x , ""^"" , y ) else : print ( y , ""^"" , x )"
"def minSubarray ( A , n ) : minValue = min ( A ) maxValue = max ( A ) pos_min , pos_max , ans = - 1 , - 1 , sys.maxsize i = 0 while i in list ( range ( n ) ) : if A [ i ] == minValue : pos_min = i if A [ i ] == maxValue : pos_max = i if pos_max != - 1 and pos_min != - 1 : ans = min ( ans , abs ( pos_min - pos_max ) + 1 ) i += 1 return ans"
"def findGeometricTriplets ( arr , n ) : j = 1 while j in list ( range ( n - 1 ) ) : i = j - 1 k = j + 1 while ( i >= 0 and k <= n - 1 ) : while ( arr [ j ] % arr [ i ] == 0 and arr [ k ] % arr [ j ] == 0 and arr [ j ] // arr [ i ] == arr [ k ] // arr [ j ] ) : print ( arr [ i ] , """" , arr [ j ] , """" , arr [ k ] ) k += 1 i -= 1 if ( arr [ j ] % arr [ i ] == 0 and arr [ k ] % arr [ j ] == 0 ) : if ( arr [ j ] // arr [ i ] < arr [ k ] // arr [ j ] ) : i -= 1 else : k += 1 elif ( arr [ j ] % arr [ i ] == 0 ) : k += 1 else : i -= 1 j += 1"
"def dfs ( List , node , arrival ) : print ( node ) i = 0 while i in list ( range ( len ( List [ node ] ) ) ) : if ( List [ node ] [ i ] != arrival ) : dfs ( List , List [ node ] [ i ] , node ) i += 1"
"def binarySearch ( arr , l , r , x ) : if ( l <= r ) : mid = int ( l + ( r - l ) / 2 ) if ( arr [ mid ] == x ) : return mid if ( mid > l and arr [ mid - 1 ] == x ) : return ( mid - 1 ) if ( mid < r and arr [ mid + 1 ] == x ) : return ( mid + 1 ) if ( arr [ mid ] > x ) : return binarySearch ( arr , l , mid - 2 , x ) return binarySearch ( arr , mid + 2 , r , x ) return - 1"
"def maxProductSum ( str , m ) : n = len ( str ) product = 1 sum = 0 for i in range ( m ) : sum = sum + ( ord ( str [ i ] ) - ord ( '0' ) ) product *= ( ord ( str [ i ] ) - ord ( '' ) ) maxProd = product maxSum = sum for i in range ( m , n ) : product = ( product * ( ord ( str [ i ] ) - ord ( '' ) ) // ( ( ord ( str [ i - m ] ) ) - ord ( '' ) ) ) sum = ( sum + ( ord ( str [ i ] ) - ord ( '' ) ) - ( ( ord ( str [ i - m ] ) ) - ord ( '' ) ) ) maxProd = max ( maxProd , product ) maxSum = max ( maxSum , sum ) print ( """" , maxProd ) print ( """" , maxSum )"
def findMostOccurringChar ( string ) : hash = [ 0 ] * 26 for i in range ( len ( string ) ) : j = 0 while j in list ( range ( len ( string [ i ] ) ) ) : hash [ ord ( string [ i ] [ j ] ) - ord ( 'a' ) ] += 1 j += 1 max = 0 for i in range ( 26 ) : max = i if hash [ i ] > hash [ max ] else max print ( ( chr ) ( max + 97 ) )
"def getSteps ( arr , n ) : count = 0 modulus = [ 0 for i in range ( 4 ) ] Sum = 0 i = 0 for i in range ( n ) : mod = arr [ i ] % 4 Sum = Sum + mod modulus [ mod ] += 1 if ( Sum % 4 != 0 ) : return - 1 else : if ( modulus [ 1 ] > modulus [ 3 ] ) : count = count + modulus [ 3 ] else : count = count + modulus [ 1 ] modulus [ 1 ] -= count modulus [ 3 ] -= count modulus [ 2 ] += modulus [ 1 ] // 2 modulus [ 2 ] += modulus [ 3 ] // 2 count = count + modulus [ 1 ] // 2 count = count + modulus [ 3 ] // 2 count = count + modulus [ 2 ] // 2 return count"
"def minSteps ( arr , n ) : v = [ 0 for i in range ( n ) ] q = [ ] q.append ( 0 ) depth = 0 while ( len ( q ) != 0 ) : x = len ( q ) while ( 1 <= x ) : i = q [ 0 ] q.remove ( i ) x -= 1 if ( v [ i ] ) : continue if ( i == n - 1 ) : return depth v [ i ] = 1 if ( i + arr [ i ] < n ) : q.append ( i + arr [ i ] ) if ( i - arr [ i ] >= 0 ) : q.append ( i - arr [ i ] ) depth += 1 return - 1"
def minCost ( s ) : alphabets = [ False for i in range ( 26 ) ] i = 0 while i in list ( range ( len ( s ) ) ) : alphabets [ ord ( s [ i ] ) - 97 ] = True i += 1 count = 0 for i in range ( 26 ) : if ( alphabets [ i ] ) : count += 1 return count
"def printSubstrings ( n ) : s = int ( math.log10 ( n ) ) d = ( math.pow ( 10 , s ) ) k = d while ( n > 0 ) : while ( 0 < d ) : print ( int ( n // d ) ) d = int ( d / 10 ) n = int ( n % k ) k = int ( k // 10 ) d = k"
def sumofproduct ( n ) : ans = 0 x = 1 while x in list ( range ( n + 1 ) ) : y = int ( n / x ) ans += ( y * x ) x += 1 return ans
"def checkPermutation ( arr , n ) : sum = 0 for i in range ( n ) : sum += arr [ i ] prefix = [ 0 ] * ( n + 1 ) prefix [ 0 ] = arr [ 0 ] for i in range ( n ) : prefix [ i ] = prefix [ i - 1 ] + arr [ i ] i = 0 while i in list ( range ( n - 1 ) ) : lsum = prefix [ i ] rsum = sum - prefix [ i ] l_len = i + 1 r_len = n - i - 1 if ( ( ( 2 * lsum ) == ( l_len * ( l_len + 1 ) ) ) and ( ( 2 * rsum ) == ( r_len * ( r_len + 1 ) ) ) ) : i += 1 return True i += 1 return False"
"def MinimumX ( a , b , c , k ) : x = 10 ** 9 if ( c >= k ) : return 0 h = k - c l = 0 while ( l <= h ) : m = ( l + h ) // 2 if ( ( a * m * m ) + ( b * m ) > ( k - c ) ) : x = min ( x , m ) h = m - 1 elif ( ( a * m * m ) + ( b * m ) < ( k - c ) ) : l = m + 1 else : return m return x"
"def pointIsOnLine ( m , c , x , y ) : if ( ( ( m * x ) + c ) == y ) : return True return False"
"def rearrange ( a , size ) : positive = 0 negative = 1 while ( True ) : while ( positive < size and a [ positive ] >= 0 ) : positive = positive + 2 while ( negative < size and a [ negative ] <= 0 ) : negative = negative + 2 if ( size > positive and negative < size ) : temp = a [ positive ] a [ positive ] = a [ negative ] a [ negative ] = temp else : break"
def manipulateString ( str ) : i = 0 while i in list ( range ( len ( str ) ) ) : asc = ord ( str [ i ] ) rem = asc - ( 26 - ( ord ( str [ i ] ) - ord ( 'a' ) ) ) m = rem % 26 str [ i ] = chr ( m + ord ( 'a' ) ) i += 1 print ( ''.join ( str ) )
"def decToBinary ( n ) : binaryNum = [ 0 ] * n i = 0 while ( n > 0 ) : binaryNum [ i ] = n % 2 n = int ( n / 2 ) i += 1 j = i - 1 while j in list ( range ( - 1 ) ) : print ( binaryNum [ j ] , end = """" ) j += - 1"
"def printSeries ( N ) : ith_term = 0 i = 1 while i in list ( range ( N + 1 ) ) : ith_term = 0 if ( i % 2 == 0 ) : ith_term = 2 * i * i + 1 else : ith_term = 2 * i * i - 1 print ( ith_term , end = "","" ) i += 1"
"def Alphabet_N_Pattern ( N ) : Right = 1 Left = 1 Diagonal = 2 for index in range ( N ) : print ( Left , end = """" ) Left += 1 for side_index in range ( 0 , 2 * ( index ) , 1 ) : print ( """" , end = """" ) if ( index != 0 and index != N - 1 ) : print ( Diagonal , end = """" ) Diagonal += 1 else : print ( """" , end = """" ) side_index = 0 while side_index in list ( range ( 2 * ( N - index - 1 ) ) ) : print ( """" , end = """" ) side_index += 1 print ( Right , end = """" ) Right += 1 print ( ""\n"" , end = """" )"
"def printString ( str , ch , count ) : occ , i = 0 , 0 if ( count == 0 ) : print ( str ) i = 0 while i in list ( range ( len ( str ) ) ) : if ( str [ i ] == ch ) : occ += 1 if ( occ == count ) : i += 1 break i += 1 if ( i < len ( str ) - 1 ) : print ( str [ i + 1 : len ( str ) - i + 2 ] ) else : print ( ""Emptystring"" )"
"def possibleStrings ( n , r , b , g ) : fact = [ 0 for i in range ( n + 1 ) ] fact [ 0 ] = 1 for i in range ( 1 , n + 1 , 1 ) : fact [ i ] = fact [ i - 1 ] * i left = n - ( r + g + b ) sum = 0 i = 0 while i in list ( range ( left + 1 ) ) : for j in range ( 0 , left - i + 1 , 1 ) : k = left - ( i + j ) sum = ( sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ) i += 1 return sum"
"def printPattern ( n ) : j , k = 0 , 0 i = 1 while i in list ( range ( n + 1 ) ) : if i % 2 != 0 : for j in range ( k + 1 , k + i ) : print ( str ( j ) + ""*"" , end = """" ) j = k + i print ( j ) j += 1 k = j else : k = k + i - 1 for j in range ( k , k - i + 1 , - 1 ) : print ( str ( j ) + ""*"" , end = """" ) j = k - i + 1 print ( j ) i += 1"
def smallestNumber ( n ) : if ( n >= 0 and n <= 9 ) : return n digits = list ( ) i = 9 while i in list ( range ( 1 ) ) : while ( n % i == 0 ) : digits.append ( i ) n = n // i i += - 1 if ( n != 1 ) : return - 1 k = 0 while ( len ( digits ) != 0 ) : k = k * 10 + digits [ - 1 ] digits.pop ( ) return k
def isPalindrome ( string ) : l = 0 h = len ( string ) - 1 while h > l : l += 1 h -= 1 if string [ h + 1 ] != string [ l - 1 ] : return False return True
"def noOfDeletions ( string , k ) : ans = 0 ; cnt = 0 ; pos = 0 while ( pos < len ( string ) and string [ pos ] != k ) : pos += 1 i = pos while ( i < len ( string ) ) : while ( i < len ( string ) and k == string [ i ] ) : i = i + 1 ans = ans + cnt cnt = 0 while ( i < len ( string ) and string [ i ] != k ) : i = i + 1 cnt = cnt + 1 return ans"
def isDivisibleby17 ( n ) : if ( n == 0 or n == 17 ) : return True if ( 17 > n ) : return False return isDivisibleby17 ( ( int ) ( n >> 4 ) - ( int ) ( n & 15 ) )
"def replaceConsonants ( string ) : res = """" i = 0 ; count = 0 while ( i < len ( string ) ) : if ( string [ i ] != '' and string [ i ] != '' and string [ i ] != '' and string [ i ] != '' and string [ i ] != '' ) : i = i + 1 count = count + 1 else : if ( count > 0 ) : res = res + str ( count ) res = res + string [ i ] i = i + 1 count = 0 if ( count > 0 ) : res = res + str ( count ) return res"
"def getMaxLength ( arr , n ) : count = 0 result = 0 i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] == 0 ) : count = 0 else : count += 1 result = max ( result , count ) i += 1 return result"
"def maxProfit ( price , n , k ) : profit = [ [ 0 for i in range ( n + 1 ) ] for j in range ( k + 1 ) ] i = 1 while i in list ( range ( k + 1 ) ) : prevDiff = float ( '-inf' ) for j in range ( 1 , n ) : prevDiff = max ( prevDiff , profit [ i - 1 ] [ j - 1 ] - price [ j - 1 ] ) profit [ i ] [ j ] = max ( profit [ i ] [ j - 1 ] , price [ j ] + prevDiff ) i += 1 return profit [ k ] [ n - 1 ]"
"def maxXOR ( mat , N ) : max_xor = 0 for i in range ( N ) : r_xor = 0 c_xor = 0 j = 0 while j in list ( range ( N ) ) : r_xor = r_xor ^ mat [ i ] [ j ] c_xor = c_xor ^ mat [ j ] [ i ] j += 1 if ( max_xor < max ( r_xor , c_xor ) ) : max_xor = max ( r_xor , c_xor ) return max_xor"
"def dupLastIndex ( arr , n ) : if ( arr == None or n <= 0 ) : return i = n - 1 while i in list ( range ( 0 ) ) : if ( arr [ i ] == arr [ i - 1 ] ) : print ( ""Lastindex:"" , i , ""\nLast"" , ""duplicateitem:"" , arr [ i ] ) i += - 1 return i += - 1 print ( ""noduplicatefound"" )"
"def findMissingNo ( arr , n ) : i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] <= 0 or arr [ i ] > n ) : i += 1 continue val = arr [ i ] while ( arr [ val - 1 ] != val ) : nextval = arr [ val - 1 ] arr [ val - 1 ] = val val = nextval if ( val <= 0 or val > n ) : i += 1 break i += 1 for i in range ( n ) : if ( arr [ i ] != i + 1 ) : return i + 1 return n + 1"
"def maxOR ( L , R ) : maximum = - 10 ** 9 i = L while i in list ( range ( R ) ) : for j in range ( i + 1 , R + 1 ) : maximum = max ( maximum , ( i | j ) ) i += 1 return maximum"
def circlearea ( R ) : if ( 0 > R ) : return - 1 a = ( 3.14 * R * R ) / 4 return a
"def minDifferenceAmongMaxMin ( arr , N , K ) : arr.sort ( ) res = 2147483647 i = 0 while i in list ( range ( ( N - K ) + 1 ) ) : curSeqDiff = arr [ i + K - 1 ] - arr [ i ] res = min ( res , curSeqDiff ) i += 1 return res"
"def partSort ( arr , N , a , b ) : l = min ( a , b ) r = max ( a , b ) temp = [ 0 for i in range ( r - l + 1 ) ] j = 0 i = l while i in list ( range ( r + 1 ) ) : temp [ j ] = arr [ i ] j += 1 i += 1 temp.sort ( reverse = False ) j = 0 for i in range ( l , r + 1 , 1 ) : arr [ i ] = temp [ j ] j += 1 for i in range ( 0 , N , 1 ) : print ( arr [ i ] , end = """" )"
def productAscii ( str ) : prod = 1 i = 0 while i in list ( range ( len ( str ) ) ) : prod = prod * ord ( str [ i ] ) i += 1 return prod
"def count_greater ( arr , n ) : min = sys.maxsize counter = 0 i = n - 1 while i in list ( range ( - 1 ) ) : if ( arr [ i ] > min ) : counter += 1 if ( arr [ i ] <= min ) : min = arr [ i ] i += - 1 return counter"
"def composite_factors ( n ) : count = 0 a = [ 0 ] * ( n + 1 ) i = 1 while i in list ( range ( n + 1 ) ) : if ( n % i == 0 ) : a [ i ] = i i += 1 for i in range ( 2 , n + 1 ) : j = 2 p = 1 while ( j < a [ i ] ) : if ( a [ i ] % j == 0 ) : p = 0 break j += 1 if ( p == 0 and a [ i ] != 0 ) : count += 1 return count"
def countDigits ( n ) : ans = 0 i = 1 while i in list ( range ( n + 1 ) ) : ans += math.log10 ( i ) i += 1 ans = ans * n return 1 + math.floor ( ans )
"def replaceDigit ( x , d1 , d2 ) : result = 0 multiply = 1 while ( x % 10 > 0 ) : remainder = x % 10 if ( d1 == remainder ) : result = ( result + d2 * multiply ) else : result = ( result + remainder * multiply ) multiply *= 10 x = int ( x / 10 ) return result"
"def minCost ( arr , n ) : cost = 999999 XOR = 0 for i in range ( 0 , n ) : XOR ^= arr [ i ] i = 0 while i in list ( range ( n ) ) : if ( cost > abs ( ( XOR ^ arr [ i ] ) - arr [ i ] ) ) : cost = abs ( ( XOR ^ arr [ i ] ) - arr [ i ] ) element = arr [ i ] i += 1 print ( ""Element="" , element ) print ( ""Operationrequired="" , abs ( cost ) )"
def minAbsDiff ( n ) : mod = n % 4 if ( 0 == mod or mod == 3 ) : return 0 return 1
"def find_difference ( arr , n , m ) : max = 0 min = 0 arr.sort ( ) j = n - 1 i = 0 while i in list ( range ( m ) ) : min += arr [ i ] max += arr [ j ] j = j - 1 i += 1 return ( max - min )"
def isPowerOfFour ( n ) : count = 0 if ( n and ( not ( n & ( n - 1 ) ) ) ) : while ( n > 1 ) : n >>= 1 count = count + 1 if ( count % 2 == 0 ) : return True else : return False
"def fitOrNotFit ( R , r , x , y , rad ) : val = math.sqrt ( math.pow ( x , 2 ) + math.pow ( y , 2 ) ) if ( R >= val + rad and val - rad >= R - r ) : print ( ""Fits\n"" ) else : print ( ""Doesn'tFit"" )"
"def largestNumber ( n ) : s = """" duplicate = n while ( n ) : s = chr ( n % 10 + 48 ) + s n //= 10 index = - 1 for i in range ( len ( s ) ) : if ( ( ( ord ( s [ i ] ) - ord ( '0' ) ) % 2 & 1 ) == 0 ) : index = i break if ( index == - 1 ) : return duplicate num = 0 for i in range ( index ) : num = num * 10 + ( ord ( s [ i ] ) - ord ( '0' ) ) num = num * 10 + ( ord ( s [ index ] ) - ord ( '0' ) - 1 ) i = index + 1 while i in list ( range ( len ( s ) ) ) : num = num * 10 + 9 i += 1 return num"
def countSolutions ( n ) : res = 0 x = 0 while ( n > x * x ) : y = 0 while ( x * x + y * y < n ) : res = res + 1 y = y + 1 x = x + 1 return res
"def countWays ( n , k ) : total = k mod = 1000000007 same , diff = 0 , k i = 2 while i in list ( range ( n + 1 ) ) : same = diff diff = total * ( k - 1 ) diff = diff % mod total = ( same + diff ) % mod i += 1 return total"
"def waysToArrange ( N , K , k ) : C = np.zeros ( ( N + 1 , N + 1 ) ) for i in range ( N + 1 ) : for j in range ( i + 1 ) : if ( j == 0 or j == i ) : C [ i ] [ j ] = 1 else : C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) dp = np.zeros ( ( K + 1 ) ) count = 0 dp [ 0 ] = 1 i = 0 while i in list ( range ( K ) ) : dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] [ k [ i ] - 1 ] ) count += k [ i ] i += 1 return dp [ K ]"
"def alphabetPattern ( N ) : left , middle , right = 0 , N - 1 , N + 1 for row in range ( 0 , 2 * N - 1 ) : if row < N : left += 1 print ( left , end = """" ) else : left -= 1 print ( left , end = """" ) col = 1 while col in list ( range ( N - 1 ) ) : if row != N - 1 : print ( """" , end = """" ) else : print ( """" + str ( middle ) , end = """" ) middle -= 1 col += 1 if row < N : right -= 1 print ( """" + str ( right ) , end = """" ) else : right += 1 print ( """" + str ( right ) , end = """" ) print ( )"
"def modularSum ( arr , n , m ) : if ( n > m ) : return True DP = [ False for i in range ( m ) ] i = 0 while i in list ( range ( n ) ) : if ( DP [ 0 ] ) : i += 1 return True temp = [ False for i in range ( m ) ] for j in range ( m ) : if ( DP [ j ] == True ) : if ( DP [ ( j + arr [ i ] ) % m ] == False ) : temp [ ( j + arr [ i ] ) % m ] = True for j in range ( m ) : if ( temp [ j ] ) : DP [ j ] = True DP [ arr [ i ] % m ] = True i += 1 return DP [ 0 ]"
"def swapOperations ( a , b , c ) : l = len ( a ) i = 0 total_swaps = 0 i = 0 while i in list ( range ( l ) ) : if ( a [ i ] == b [ i ] ) : i += 1 continue if ( a [ i ] == c [ i ] ) : b [ i ] , c [ i ] = c [ i ] , b [ i ] total_swaps += 1 i += 1 continue if ( b [ i ] == c [ i ] ) : a [ i ] , c [ i ] = c [ i ] , a [ i ] total_swaps += 1 i += 1 continue i += 1 break i += 1 i += 1 if ( i == l ) : print ( total_swaps ) else : print ( - 1 )"
"def countRectangles ( radius ) : rectangles = 0 diameter = 2 * radius diameterSquare = diameter * diameter for a in range ( 1 , 2 * radius ) : b = 1 while b in list ( range ( 2 * radius ) ) : diagnalLengthSquare = ( a * a + b * b ) if ( diagnalLengthSquare <= diameterSquare ) : rectangles += 1 b += 1 return rectangles"
"def solve ( arr , n ) : arr.sort ( ) a = 0 b = 0 i = 0 while i in list ( range ( n ) ) : if ( i % 2 != 0 ) : a = a * 10 + arr [ i ] else : b = b * 10 + arr [ i ] i += 1 return a + b"
"def generate ( st , s ) : if len ( s ) == 0 : return if s not in st : st.add ( s ) i = 0 while i in list ( range ( len ( s ) ) ) : t = list ( s ).copy ( ) t.remove ( s [ i ] ) t = ''.join ( t ) generate ( st , t ) i += 1 return"
"def countPairs ( n ) : count = 0 x = 1 while x in list ( range ( n ) ) : for y in range ( x + 1 , n + 1 ) : if ( ( y + x ) % ( y ^ x ) == 0 ) : count += 1 x += 1 return count"
"def countNums ( n , x , y ) : arr = [ False for i in range ( n + 2 ) ] if ( x <= n ) : arr [ x ] = True if ( y <= n ) : arr [ y ] = True result = 0 i = min ( x , y ) while i in list ( range ( n + 1 ) ) : if ( arr [ i ] ) : if ( i + x <= n ) : arr [ i + x ] = True if ( i + y <= n ) : arr [ i + y ] = True result = result + 1 i += 1 return result"
"def printSmall ( arr , n , k ) : i = k while i in list ( range ( n ) ) : max_var = arr [ k - 1 ] pos = k - 1 for j in range ( k - 2 , - 1 , - 1 ) : if ( arr [ j ] > max_var ) : max_var = arr [ j ] pos = j if ( max_var > arr [ i ] ) : j = pos while ( j < k - 1 ) : arr [ j ] = arr [ j + 1 ] j += 1 arr [ k - 1 ] = arr [ i ] i += 1 for i in range ( 0 , k ) : print ( arr [ i ] , end = """" )"
"def getInvCount ( arr ) : n = len ( arr ) invcount = 0 for i in range ( 0 , n - 1 ) : for j in range ( i + 1 , n ) : if arr [ i ] > arr [ j ] : k = j + 1 while k in list ( range ( n ) ) : if arr [ j ] > arr [ k ] : invcount += 1 k += 1 return invcount"
"def getXandYintercept ( P , Q ) : a = P [ 1 ] - Q [ 1 ] b = P [ 0 ] - Q [ 0 ] if 0 == b : print ( P [ 0 ] ) print ( ""infinity"" ) return if a == 0 : print ( ""infinity"" ) print ( P [ 1 ] ) return m = a / b x = P [ 0 ] y = P [ 1 ] c = y - m * x y = 0 x = ( y - c ) / m print ( x ) x = 0 y = m * x + c print ( y )"
"def maxProfit ( profitA , profitB , n ) : preSum = [ 0 ] * n preSum [ 0 ] = profitA [ 0 ] for i in range ( 1 , n ) : preSum [ i ] = preSum [ i - 1 ] + profitA [ i ] suffSum = [ 0 ] * n suffSum [ n - 1 ] = profitB [ n - 1 ] i = n - 2 while i in list ( range ( - 1 ) ) : suffSum [ i ] = suffSum [ i + 1 ] + profitB [ i ] i += - 1 res = preSum [ n - 1 ] for i in range ( 1 , n - 1 ) : res = max ( res , preSum [ i ] + suffSum [ i + 1 ] ) res = max ( res , suffSum [ 0 ] ) return res"
"def fib ( n ) : a = 0 b = 1 if ( n >= 0 ) : print ( a , end = '' ) if ( n >= 1 ) : print ( b , end = '' ) i = 2 while i in list ( range ( n + 1 ) ) : c = a + b print ( c , end = '' ) a = b b = c i += 1"
def isPrime ( n ) : if n <= 1 : return False i = 2 while i in list ( range ( n ) ) : if n % i == 0 : i += 1 return False i += 1 return True
def hexDiagonal ( a ) : if ( 0 > a ) : return - 1 d = 1.73 * a return d
"def count ( arr , N , K ) : count = 0 ans = 0 i = 0 while i in list ( range ( N ) ) : if ( arr [ i ] == K ) : count = count + 1 else : ans += ( count * ( count + 1 ) ) // 2 count = 0 i += 1 ans = ans + ( count * ( count + 1 ) ) // 2 return ans"
"def items ( n , a ) : a.sort ( ) z = a [ n - 1 ] x = 1 s = 0 i = 0 while i in list ( range ( n - 1 ) ) : s += a [ i ] if ( s <= z ) : x += 1 else : i += 1 break i += 1 return x"
def bitwiseAndOdd ( n ) : result = 1 i = 3 while i in list ( range ( n + 1 ) ) : result = ( result & i ) i += 2 return result
"def evenDecimalValue ( str , n ) : result = 0 i = 0 while i in list ( range ( n ) ) : if ( str [ i ] == '0' ) : result += ( n - i ) i += 1 return result"
"def makeAP ( arr , n ) : initial_term , common_difference = 0 , 0 if ( n == 3 ) : common_difference = arr [ 2 ] - arr [ 1 ] initial_term = arr [ 1 ] - common_difference elif ( ( arr [ 1 ] - arr [ 0 ] ) == arr [ 2 ] - arr [ 1 ] ) : initial_term = arr [ 0 ] common_difference = arr [ 1 ] - arr [ 0 ] elif ( ( arr [ 2 ] - arr [ 1 ] ) == ( arr [ 3 ] - arr [ 2 ] ) ) : common_difference = arr [ 2 ] - arr [ 1 ] initial_term = arr [ 1 ] - common_difference else : common_difference = ( arr [ 3 ] - arr [ 0 ] ) / 3 initial_term = arr [ 0 ] i = 0 while i in list ( range ( n ) ) : print ( int ( initial_term + ( i * common_difference ) ) , end = """" ) i += 1 print ( )"
"def findWeights ( X ) : sum = 0 power = 0 while ( sum < X ) : sum = pow ( 3 , power + 1 ) - 1 sum //= 2 power += 1 ans = 1 i = 1 while i in list ( range ( power + 1 ) ) : print ( ans , end = """" ) ans = ans * 3 i += 1"
"def solve ( n , d , arr ) : i = 1 while d > 0 and i < n : if arr [ i ] <= 0 or i > d : i += 1 elif d >= i : d -= i arr [ 0 ] += 1 arr [ i ] -= 1 return arr [ 0 ]"
"def CountTheElements ( arr , n , k ) : counter = 0 i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] % k == 0 ) : counter = counter + 1 i += 1 return counter"
"def printSequence ( arr , input ) : n = len ( input ) output = """" i = 0 while i in list ( range ( n ) ) : if ( input [ i ] == '' ) : output = output + ""0"" else : position = ord ( input [ i ] ) - ord ( 'A' ) output = output + arr [ position ] i += 1 return output"
def countDer ( n ) : if ( n == 1 ) : return 0 if ( n == 0 ) : return 1 if ( 2 == n ) : return 1 return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) )
"def countkDist ( str1 , k ) : n = len ( str1 ) res = 0 cnt = [ 0 ] * 27 for i in range ( 0 , n ) : dist_count = 0 cnt = [ 0 ] * 27 j = i while j in list ( range ( n ) ) : if ( cnt [ ord ( str1 [ j ] ) - 97 ] == 0 ) : dist_count += 1 cnt [ ord ( str1 [ j ] ) - 97 ] += 1 if ( dist_count == k ) : res += 1 if ( dist_count > k ) : j += 1 break j += 1 return res"
"def findMaximum ( arr , low , high ) : if low == high : return arr [ low ] if high == low + 1 and arr [ low ] >= arr [ high ] : return arr [ low ] if low + 1 == high and arr [ low ] < arr [ high ] : return arr [ high ] mid = ( low + high ) // 2 if arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] > arr [ mid - 1 ] : return arr [ mid ] if arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] < arr [ mid - 1 ] : return findMaximum ( arr , low , mid - 1 ) else : return findMaximum ( arr , mid + 1 , high )"
"def printDuplicates ( arr , n ) : fl = 0 i = 0 while i in list ( range ( n ) ) : if ( arr [ arr [ i ] % n ] >= n ) : if ( arr [ arr [ i ] % n ] < 2 * n ) : print ( arr [ i ] % n , end = """" ) fl = 1 arr [ arr [ i ] % n ] += n i += 1 if ( fl == 0 ) : print ( ""-1"" )"
"def printPermutation ( n , k ) : mx = n i = 1 while i in list ( range ( k + 1 ) ) : print ( mx , end = """" ) mx -= 1 i += 1 for i in range ( 1 , mx + 1 ) : print ( i , end = """" )"
"def minMaxProduct ( arr1 , arr2 , n1 , n2 ) : max = arr1 [ 0 ] min = arr2 [ 0 ] i = 1 while ( i < n1 and i < n2 ) : if ( max < arr1 [ i ] ) : max = arr1 [ i ] if ( arr2 [ i ] < min ) : min = arr2 [ i ] i += 1 while ( i < n1 ) : if ( arr1 [ i ] > max ) : max = arr1 [ i ] i += 1 while ( i < n2 ) : if ( arr2 [ i ] < min ) : min = arr2 [ i ] i += 1 return max * min"
"def check ( s , l ) : pos = [ ] i = 0 while i in list ( range ( l ) ) : if ( s [ i ] == '1' ) : pos.append ( i ) i += 1 t = len ( pos ) for i in range ( 1 , t ) : if ( ( pos [ i ] - pos [ i - 1 ] ) != ( pos [ 1 ] - pos [ 0 ] ) ) : return False return True"
"def removeSpecialCharacter ( s ) : t = """" for i in s : if ( 'A' <= i and i <= 'Z' ) or ( i >= 'a' and i <= 'z' ) : t += i print ( t )"
"def count_pairs ( a , b , n , m ) : odd1 = 0 even1 = 0 odd2 = 0 even2 = 0 i = 0 while i in list ( range ( n ) ) : if ( a [ i ] % 2 ) : odd1 += 1 else : even1 += 1 i += 1 for i in range ( m ) : if ( b [ i ] % 2 ) : odd2 += 1 else : even2 += 1 pairs = ( min ( odd1 , even2 ) + min ( odd2 , even1 ) ) return pairs"
"def stirlingFactorial ( n ) : if ( 1 == n ) : return 1 e = 2.71 z = ( math.sqrt ( 2 * 3.14 * n ) * math.pow ( ( n / e ) , n ) ) return math.floor ( z )"
"def LCSubStr ( X , Y , m , n ) : LCSuff = [ [ 0 for k in range ( n + 1 ) ] for l in range ( m + 1 ) ] result = 0 i = 0 while i in list ( range ( m + 1 ) ) : for j in range ( n + 1 ) : if ( i == 0 or j == 0 ) : LCSuff [ i ] [ j ] = 0 elif ( X [ i - 1 ] == Y [ j - 1 ] ) : LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 result = max ( result , LCSuff [ i ] [ j ] ) else : LCSuff [ i ] [ j ] = 0 i += 1 return result"
def countDer ( n ) : der = [ 0 for i in range ( n + 1 ) ] der [ 0 ] = 1 der [ 1 ] = 0 der [ 2 ] = 1 i = 3 while i in list ( range ( n + 1 ) ) : der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) i += 1 return der [ n ]
def isValidISBN ( isbn ) : if len ( isbn ) != 10 : return False _sum = 0 i = 0 while i in list ( range ( 9 ) ) : if 0 <= int ( isbn [ i ] ) <= 9 : _sum += int ( isbn [ i ] ) * ( 10 - i ) else : i += 1 return False i += 1 if ( isbn [ 9 ] != 'X' and 0 <= int ( isbn [ 9 ] ) <= 9 ) : return False _sum += 10 if isbn [ 9 ] == 'X' else int ( isbn [ 9 ] ) return ( _sum % 11 == 0 )
"def numberOfPaths ( m , n ) : count = [ [ 0 for x in range ( m ) ] for y in range ( n ) ] for i in range ( m ) : count [ i ] [ 0 ] = 1 for j in range ( n ) : count [ 0 ] [ j ] = 1 i = 1 while i in list ( range ( m ) ) : for j in range ( n ) : count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] i += 1 return count [ m - 1 ] [ n - 1 ]"
"def findNthTerm ( x , y , n ) : f = [ 0 ] * 6 f [ 0 ] = x f [ 1 ] = y i = 2 while i in list ( range ( 6 ) ) : f [ i ] = f [ i - 1 ] - f [ i - 2 ] i += 1 return f [ n % 6 ]"
"def findAllSequences ( diff , out , start , end ) : if ( abs ( diff ) > ( end - start + 1 ) // 2 ) : return if ( start > end ) : if ( 0 == diff ) : print ( ''.join ( list ( out ) ) , end = """" ) return out [ start ] = '0' out [ end ] = '1' findAllSequences ( diff + 1 , out , start + 1 , end - 1 ) out [ start ] = out [ end ] = '1' findAllSequences ( diff , out , start + 1 , end - 1 ) out [ start ] = out [ end ] = '0' findAllSequences ( diff , out , start + 1 , end - 1 ) out [ start ] = '1' out [ end ] = '0' findAllSequences ( diff - 1 , out , start + 1 , end - 1 )"
"def no_of_ways ( a , n ) : count_0 = 0 count_1 = 0 i = 0 while i in list ( range ( n ) ) : if ( a [ i ] == 0 ) : count_0 += 1 else : count_1 += 1 i += 1 if ( count_1 % 2 == 0 ) : return count_0 else : return count_1"
"def smallestNumber ( n ) : num = 0 s = """" duplicate = n while ( n ) : s = chr ( n % 10 + 48 ) + s n //= 10 index = - 1 for i in range ( len ( s ) ) : digit = ord ( s [ i ] ) - ord ( '0' ) if ( ( digit & 1 ) == 0 ) : index = i break if ( index == - 1 ) : return duplicate for i in range ( index ) : num = num * 10 + ( ord ( s [ i ] ) - ord ( '0' ) ) num = num * 10 + ( ord ( s [ index ] ) - ord ( '0' ) + 1 ) i = index + 1 while i in list ( range ( len ( s ) ) ) : num = num * 10 + 1 i += 1 return num"
def powerNumbers ( n ) : v = set ( ) v.add ( 1 ) i = 2 while i in list ( range ( n + 1 ) ) : if ( i * i <= n ) : j = i * i v.add ( j ) while ( j * i <= n ) : v.add ( j * i ) j = j * i i += 1 return len ( v )
"def findCount ( s , n , a , b ) : res = 0 i = 0 while i in list ( range ( b ) ) : if ( i == a ) : res += ( s [ n - i - 1 ] != '1' ) else : res += ( s [ n - i - 1 ] != '0' ) i += 1 return res"
"def printNumbers ( arr , n ) : arr.sort ( ) A , B = arr [ n - 1 ] , - 1 i = n - 2 while i in list ( range ( - 1 ) ) : if A % arr [ i ] != 0 : B = arr [ i ] i += - 1 break if i - 1 >= 0 and arr [ i ] == arr [ i - 1 ] : B = arr [ i ] i += - 1 break i += - 1 print ( ""A="" , A , "",B="" , B )"
"def trailing_zeros ( N ) : count_of_two = 0 count_of_five = 0 for i in range ( 1 , N + 1 , 1 ) : val = i while ( val % 2 == 0 and val > 0 ) : val /= 2 count_of_two = count_of_two + i while ( val % 5 == 0 and val > 0 ) : val /= 5 count_of_five = count_of_five + i ans = min ( count_of_two , count_of_five ) return ans"
def countX ( n ) : count = 0 i = 0 while i in list ( range ( n + 1 ) ) : if n - i == ( n ^ i ) : count += 1 i += 1 return count
def isPrime ( n ) : if ( 1 >= n ) : return False if ( n <= 3 ) : return True if ( n % 2 == 0 or n % 3 == 0 ) : return False i = 5 while ( i * i <= n ) : if ( n % i == 0 or n % ( i + 2 ) == 0 ) : return False i = i + 6 return True
def totalDigits ( n ) : number_of_digits = 0 i = 1 while i in list ( range ( n ) ) : number_of_digits = ( number_of_digits + ( n - i + 1 ) ) i += 10 return number_of_digits
"def findSmallest ( m , s ) : if ( s == 0 ) : if ( m == 1 ) : print ( ""Smallestnumberis0"" ) else : print ( ""Notpossible"" ) return if ( s > 9 * m ) : print ( ""Notpossible"" ) return res = [ 0 for i in range ( m + 1 ) ] s -= 1 i = m - 1 while i in list ( range ( 0 ) ) : if ( s > 9 ) : res [ i ] = 9 s -= 9 else : res [ i ] = s s = 0 i += - 1 res [ 0 ] = s + 1 print ( ""Smallestnumberis"" , end = """" ) for i in range ( m ) : print ( res [ i ] , end = """" )"
"def prefix ( string ) : k = 1 n = len ( string ) g = [ ] flag = 0 for i in range ( 1 , n ) : if ( string [ i ] == string [ 0 ] ) : g.append ( i ) flag = 1 if ( flag == 0 ) : print ( string ) else : length = len ( g ) while ( k < g [ 0 ] ) : cnt = 0 for j in range ( length ) : if ( string [ g [ j ] + k ] == string [ k ] ) : cnt += 1 if ( cnt == len ) : k += 1 else : break i = 0 while i in list ( range ( k + 1 ) ) : print ( string [ i ] , end = """" ) i += 1 print ( )"
"def print_max ( a , n , k ) : max_upto = [ 0 for i in range ( n ) ] s = [ ] s.append ( 0 ) for i in range ( 1 , n ) : while ( len ( s ) > 0 and a [ s [ - 1 ] ] < a [ i ] ) : max_upto [ s [ - 1 ] ] = i - 1 del s [ - 1 ] s.append ( i ) while ( len ( s ) > 0 ) : max_upto [ s [ - 1 ] ] = n - 1 del s [ - 1 ] j = 0 i = 0 while i in list ( range ( n - k + 1 ) ) : while ( j < i or max_upto [ j ] < i + k - 1 ) : j += 1 print ( a [ j ] , end = """" ) i += 1 print ( )"
"def countKdivPairs ( A , n , K ) : freq = [ 0 ] * K i = 0 while i in list ( range ( n ) ) : freq [ A [ i ] % K ] += 1 i += 1 sum = freq [ 0 ] * ( freq [ 0 ] - 1 ) / 2 i = 1 while ( i <= K // 2 and i != ( K - i ) ) : sum += freq [ i ] * freq [ K - i ] i += 1 if ( K % 2 == 0 ) : sum += ( freq [ K // 2 ] * ( freq [ K // 2 ] - 1 ) / 2 ) return int ( sum )"
"def countSubstr ( s ) : n = len ( s ) auxArr = [ 0 for i in range ( n ) ] if ( s [ 0 ] == '1' ) : auxArr [ 0 ] = 1 for i in range ( 0 , n ) : if ( s [ i ] == '1' ) : auxArr [ i ] = auxArr [ i - 1 ] + 1 else : auxArr [ i ] = auxArr [ i - 1 ] count = 0 i = n - 1 while i in list ( range ( - 1 ) ) : if ( s [ i ] == '1' ) : count += auxArr [ i ] i += - 1 return count"
"def rearrangeArray ( arr , n ) : arr.sort ( ) tempArr = [ 0 ] * ( n + 1 ) ArrIndex = 0 i = 0 j = n - 1 while ( i <= n // 2 or j > n // 2 ) : tempArr [ ArrIndex ] = arr [ i ] ArrIndex = ArrIndex + 1 tempArr [ ArrIndex ] = arr [ j ] ArrIndex = ArrIndex + 1 i = i + 1 j = j - 1 i = 0 while i in list ( range ( n ) ) : arr [ i ] = tempArr [ i ] i += 1"
"def checkIsAP ( arr , n ) : if ( n == 1 ) : return True arr.sort ( ) d = arr [ 1 ] - arr [ 0 ] i = 2 while i in list ( range ( n ) ) : if ( arr [ i ] - arr [ i - 1 ] != d ) : i += 1 return False i += 1 return True"
"def distinctCount ( arr , n ) : s = set ( ) i = 0 while i in list ( range ( n ) ) : s.add ( abs ( arr [ i ] ) ) i += 1 return len ( s )"
"def printPattern ( n ) : for i in range ( n + 1 ) : j = 1 while j in list ( range ( i + 1 ) ) : print ( i , end = """" ) j += 1 print ( """" ) for i in range ( n - 1 , 0 , - 1 ) : for j in range ( i , 0 , - 1 ) : print ( i , end = """" ) print ( """" )"
def isEven ( n ) : if ( n + 1 == n ^ 1 ) : return True else : return False
"def binarySearchCount ( arr , n , key ) : left = 0 right = n - 1 count = 0 while ( left <= right ) : mid = int ( ( right + left ) / 2 ) if ( key >= arr [ mid ] ) : count = mid + 1 left = mid + 1 else : right = mid - 1 return count"
"def alphabetPattern ( N ) : Top , Bottom , Diagonal = 1 , 1 , N - 1 for index in range ( N ) : print ( Top , end = '' ) Top += 1 print ( ) for index in range ( 1 , N - 1 ) : for side_index in range ( 2 * ( N - index - 1 ) ) : print ( '' , end = '' ) print ( Diagonal , end = '' ) Diagonal -= 1 print ( ) index = 0 while index in list ( range ( N ) ) : print ( Bottom , end = '' ) Bottom += 1 index += 1"
"def cntSubSeq ( arr , n ) : pos_count = 0 neg_count = 0 i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] > 0 ) : pos_count += 1 if ( arr [ i ] < 0 ) : neg_count += 1 i += 1 result = int ( math.pow ( 2 , pos_count ) ) if ( neg_count > 0 ) : result *= int ( math.pow ( 2 , neg_count - 1 ) ) else : result = 0 return result"
"def mod ( num , a ) : res = 0 i = 0 while i in list ( range ( len ( num ) ) ) : res = ( res * 10 + int ( num [ i ] ) ) % a i += 1 return res"
"def printBracketNumber ( exp , n ) : left_bnum = 1 right_bnum = list ( ) i = 0 while i in list ( range ( n ) ) : if exp [ i ] == '(' : print ( left_bnum , end = """" ) right_bnum.append ( left_bnum ) left_bnum += 1 elif exp [ i ] == ')' : print ( right_bnum [ - 1 ] , end = """" ) right_bnum.pop ( ) i += 1"
"def modify ( arr , n ) : if n <= 1 : return prev = arr [ 0 ] arr [ 0 ] = arr [ 0 ] * arr [ 1 ] i = 1 while i in list ( range ( n - 1 ) ) : curr = arr [ i ] arr [ i ] = prev * arr [ i + 1 ] prev = curr i += 1 arr [ n - 1 ] = prev * arr [ n - 1 ]"
"def countSubarraysof1and0 ( a , n ) : count1 = 0 count0 = 0 number1 = 0 number0 = 0 for i in range ( 0 , n , 1 ) : if ( a [ i ] == 1 ) : count1 = count1 + 1 else : number1 = number1 + ( ( count1 ) * ( count1 + 1 ) / 2 ) count1 = 0 for i in range ( 0 , n , 1 ) : if ( a [ i ] == 0 ) : count0 = count0 + 1 else : number0 = number0 + ( count0 ) * ( count0 + 1 ) / 2 count0 = 0 if ( count1 ) : number1 = number1 + ( count1 ) * ( count1 + 1 ) / 2 if ( count0 ) : number0 = number0 + ( count0 ) * ( count0 + 1 ) / 2 print ( """" , int ( number0 ) ) print ( """" , int ( number1 ) )"
"def floorSearch ( arr , low , high , x ) : if ( high < low ) : return - 1 if ( x >= arr [ high ] ) : return high mid = int ( ( low + high ) / 2 ) if ( arr [ mid ] == x ) : return mid if ( mid > 0 and arr [ mid - 1 ] <= x and x < arr [ mid ] ) : return mid - 1 if ( x < arr [ mid ] ) : return floorSearch ( arr , low , mid - 1 , x ) return floorSearch ( arr , mid + 1 , high , x )"
"def findstem ( arr ) : n = len ( arr ) s = arr [ 0 ] l = len ( s ) res = """" for i in range ( l ) : for j in range ( i + 1 , l + 1 ) : stem = s [ i : j ] k = 1 k = 1 while k in list ( range ( n ) ) : if stem not in arr [ k ] : k += 1 break k += 1 if ( k + 1 == n and len ( res ) < len ( stem ) ) : res = stem return res"
def distinct ( arr ) : count = 0 if len ( arr ) == 1 : return 1 i = 0 while i in list ( range ( len ( arr ) - 1 ) ) : if ( i == 0 ) : if ( arr [ i ] != arr [ i + 1 ] ) : count += 1 elif ( i > 0 & i < len ( arr ) - 1 ) : if ( arr [ i ] != arr [ i + 1 ] or arr [ i ] != arr [ i - 1 ] ) : count += 1 i += 1 if ( arr [ len ( arr ) - 1 ] != arr [ len ( arr ) - 2 ] ) : count += 1 return count
"def partition ( num_list , start , end ) : split = start - 1 x = num_list [ end ] i = start while i in list ( range ( end ) ) : if num_list [ i ] <= x : split += 1 num_list [ split ] , num_list [ i ] = num_list [ i ] , num_list [ split ] i += 1 num_list [ split + 1 ] , num_list [ end ] = num_list [ end ] , num_list [ split + 1 ] num_list = [ str ( i ) for i in num_list ] num_list [ split + 1 ] = '[{}]'.format ( num_list [ split + 1 ] ) print ( ''.join ( num_list ) )"
"def maxDiff ( arr , n ) : maxDiff = - 1 maxRight = arr [ n - 1 ] i = n - 2 while i in list ( range ( - 1 ) ) : if ( arr [ i ] > maxRight ) : maxRight = arr [ i ] else : diff = maxRight - arr [ i ] if ( diff > maxDiff ) : maxDiff = diff i += - 1 return maxDiff"
"def minOperations ( n , m ) : if ( m % n != 0 ) : return - 1 minOperations = 0 q = int ( m / n ) while ( 0 == q % 2 ) : q = int ( q / 2 ) minOperations += 1 while ( q % 3 == 0 ) : q = int ( q / 3 ) minOperations += 1 if ( q == 1 ) : return minOperations return - 1"
"def rgb_to_hsv ( r , g , b ) : r , g , b = r / 255.0 , g / 255.0 , b / 255.0 cmax = max ( r , g , b ) cmin = min ( r , g , b ) diff = cmax - cmin if cmax == cmin : h = 0 elif r == cmax : h = ( 60 * ( ( g - b ) / diff ) + 360 ) % 360 elif cmax == g : h = ( 60 * ( ( b - r ) / diff ) + 120 ) % 360 elif cmax == b : h = ( 60 * ( ( r - g ) / diff ) + 240 ) % 360 if cmax == 0 : s = 0 else : s = ( diff / cmax ) * 100 v = cmax * 100 return h , s , v"
"def findlargestAfterDel ( arr , m , dell , n ) : mp = dict ( ) i = 0 while i in list ( range ( n ) ) : if dell [ i ] in mp.keys ( ) : mp [ dell [ i ] ] += 1 else : mp [ dell [ i ] ] = 1 i += 1 largestElement = - 10 ** 9 for i in range ( m ) : if ( arr [ i ] in mp.keys ( ) ) : mp [ arr [ i ] ] -= 1 if ( mp [ arr [ i ] ] == 0 ) : mp.pop ( arr [ i ] ) else : largestElement = max ( largestElement , arr [ i ] ) return largestElement"
"def getLargestSum ( N ) : max_sum = 0 i = 1 while i in list ( range ( N + 1 ) ) : for j in range ( i + 1 , N + 1 , 1 ) : if ( i * j % ( i + j ) == 0 ) : max_sum = max ( max_sum , i + j ) i += 1 return max_sum"
"def printPermutation ( n , k ) : i = 1 while i in list ( range ( n + 1 ) ) : x = 2 * i - 1 y = 2 * i if ( i <= k ) : print ( y , x , end = """" ) else : print ( x , y , end = """" ) i += 1"
"def series ( A , X , n ) : term = pow ( A , n ) print ( term , end = """" ) i = 1 while i in list ( range ( n + 1 ) ) : term = int ( term * X * ( n - i + 1 ) / ( i * A ) ) print ( term , end = """" ) i += 1"
def balancedBrackets ( Str ) : dep = 0 minDep = 0 for i in Str : if ( i == '(' ) : dep += 1 else : dep -= 1 if ( minDep > dep ) : minDep = dep if ( minDep < 0 ) : for i in range ( abs ( minDep ) ) : Str = '(' + Str dep = 0 for i in Str : if ( i == '(' ) : dep += 1 else : dep -= 1 if ( dep != 0 ) : i = 0 while i in list ( range ( dep ) ) : Str = Str + ')' i += 1 return Str
"def bonacciseries ( n , m ) : a = [ 0 ] * m a [ n - 1 ] = 1 for i in range ( n , m ) : j = i - n while j in list ( range ( i ) ) : a [ i ] = a [ i ] + a [ j ] j += 1 for i in range ( 0 , m ) : print ( a [ i ] , end = """" )"
def wordReverse ( str ) : i = len ( str ) - 1 start = end = i + 1 result = '' while i >= 0 : if str [ i ] == '' : start = i + 1 while end != start : result += str [ start ] start += 1 result += '' end = i i -= 1 start = 0 while start != end : result += str [ start ] start += 1 return result
"def LiesInsieRectangle ( a , b , x , y ) : if ( x - y - b <= 0 and x - y + b >= 0 and x + y - 2 * a + b <= 0 and 0 <= x + y - b ) : return True return False"
"def printKMax ( a , n , k ) : if ( k == 1 ) : i = 0 while i in list ( range ( n ) ) : print ( a [ i ] , end = """" ) i += 1 return p = 0 q = k - 1 t = p max = a [ k - 1 ] while ( q <= n - 1 ) : if ( a [ p ] > max ) : max = a [ p ] p += 1 if ( q == p and p != n ) : print ( max , end = """" ) q += 1 p = t + 1 if ( q < n ) : max = a [ q ]"
"def calcAngle ( h , m ) : if ( h < 0 or m < 0 or h > 12 or m > 60 ) : print ( 'Wronginput' ) if ( h == 12 ) : h = 0 if ( 60 == m ) : m = 0 hour_angle = 0.5 * ( h * 60 + m ) minute_angle = 6 * m angle = abs ( hour_angle - minute_angle ) angle = min ( 360 - angle , angle ) return angle"
def minLexRotation ( str_ ) : n = len ( str_ ) arr = [ 0 ] * n concat = str_ + str_ i = 0 while i in list ( range ( n ) ) : arr [ i ] = concat [ i : n + i ] i += 1 arr.sort ( ) return arr [ 0 ]
"def maxAverageOfPath ( cost , N ) : dp = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N + 1 ) ] dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] for i in range ( 1 , N ) : dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] j = 1 while j in list ( range ( N ) ) : dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] j += 1 for i in range ( 1 , N ) : for j in range ( 1 , N ) : dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] return dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 )"
def digSum ( n ) : sum = 0 while ( 0 < n or sum > 9 ) : if ( n == 0 ) : n = sum sum = 0 sum += n % 10 n /= 10 return sum
"def findElement ( arr , ranges , rotations , index ) : i = rotations - 1 while i in list ( range ( - 1 ) ) : left = ranges [ i ] [ 0 ] right = ranges [ i ] [ 1 ] if ( left <= index and right >= index ) : if ( index == left ) : index = right else : index = index - 1 i += - 1 return arr [ index ]"
"def right ( aa ) : xa , ya , xb , yb , xc , yc = ( aa [ j ] for j in range ( 6 ) ) a = ( xb - xa ) ** 2 + ( yb - ya ) ** 2 b = ( xc - xa ) ** 2 + ( yc - ya ) ** 2 c = ( xc - xb ) ** 2 + ( yc - yb ) ** 2 ver = 0 if a + b == c or b == a + c or b + c == a : if a * b * c != 0 : ver += 1 return ver"
"def CheckSubarray ( arr , N ) : presum = [ 0 for i in range ( N + 1 ) ] for i in range ( 1 , N + 1 ) : presum [ i ] = presum [ i - 1 ] + arr [ i - 1 ] for i in range ( 1 , N + 1 ) : j = i while j in list ( range ( N + 1 ) ) : if ( ( presum [ j ] - presum [ i - 1 ] ) % N == 0 ) : print ( i - 1 , j - 1 ) j += 1 return j += 1 print ( ""-1"" )"
"def reverse ( str1 , x ) : n = ( len ( str1 ) - x ) // 2 for i in range ( n ) : print ( str1 [ i ] , end = """" ) for i in range ( n + x - 1 , n - 1 , - 1 ) : print ( str1 [ i ] , end = """" ) i = n + x while i in list ( range ( len ( str1 ) ) ) : print ( str1 [ i ] , end = """" ) i += 1"
"def findPlatform ( arr , dep , n ) : arr.sort ( ) dep.sort ( ) plat_needed = 1 result = 1 i = 1 j = 0 while ( i < n and j < n ) : if ( arr [ i ] < dep [ j ] ) : plat_needed += 1 i += 1 if ( result < plat_needed ) : result = plat_needed else : plat_needed -= 1 j += 1 return result"
"def search ( pat , txt ) : M = len ( pat ) N = len ( txt ) i = 0 while i in list ( range ( N - M + 1 ) ) : j = 0 while ( j < M ) : if ( txt [ i + j ] != pat [ j ] ) : i += 1 break j += 1 if ( j == M ) : print ( ""Patternfoundatindex"" , i ) i += 1"
"def Check_is_possible ( l , r , k ) : div_count = ( r // k ) - ( l // k ) if l % k == 0 : div_count += 1 return 1 < div_count"
"def multiply ( x , y ) : if ( y == 0 ) : return 0 if ( 0 < y ) : return ( x + multiply ( x , y - 1 ) ) if ( y < 0 ) : return - multiply ( x , - y )"
"def countManipulations ( s1 , s2 ) : count = 0 char_count = [ 0 ] * 26 for i in range ( 26 ) : char_count [ i ] = 0 i = 0 while i in list ( range ( len ( s1 ) ) ) : char_count [ ord ( s1 [ i ] ) - ord ( 'a' ) ] += 1 i += 1 for i in range ( len ( s2 ) ) : char_count [ ord ( s2 [ i ] ) - ord ( 'a' ) ] -= 1 if ( char_count [ ord ( s2 [ i ] ) - ord ( 'a' ) ] < 0 ) : count += 1 return count"
"def numberOfPaths ( m , n ) : if ( m == 1 or 1 == n ) : return 1 return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 )"
"def findLength ( string , n ) : current_sum = 0 max_sum = 0 i = 0 while i in list ( range ( n ) ) : current_sum += ( 1 if string [ i ] == '0' else - 1 ) if current_sum < 0 : current_sum = 0 max_sum = max ( current_sum , max_sum ) i += 1 return max_sum if max_sum else 0"
"def countPairs ( n ) : num = ( ( n // 2 ) + 1 ) Max = n % num count = 0 for i in range ( 1 , n + 1 ) : j = 1 while j in list ( range ( n + 1 ) ) : val = ( ( n % i ) % j ) % n if ( val == Max ) : count += 1 j += 1 return count"
"def middleProduct ( mat , n ) : row_prod = 1 col_prod = 1 i = 0 while i in list ( range ( n ) ) : row_prod *= mat [ n // 2 ] [ i ] col_prod *= mat [ i ] [ n // 2 ] i += 1 print ( ""Productofmiddlerow="" , row_prod ) print ( ""Productofmiddlecolumn="" , col_prod )"
"def printString ( n , str ) : str2 = """" extraChar = n % 26 if ( extraChar >= 1 ) : i = 26 - ( extraChar + 1 ) while i in list ( range ( 26 ) ) : str2 += str [ i ] i += 1 countOfStr = n // 26 for i in range ( 1 , countOfStr + 1 ) : for j in range ( 26 ) : str2 += str [ j ] return str2"
"def findsolution ( n , x , y ) : if ( ( y - n + 1 ) * ( y - n + 1 ) + n - 1 < x or y < n ) : print ( ""Nosolution"" ) return print ( y - n + 1 ) while ( 1 < n ) : print ( 1 ) n -= 1"
"def findSeries ( num , first , sec ) : print ( ""{}{}"".format ( first , sec ) , end = """" ) counter = 0 while ( num - 2 > counter ) : sum = first + sec print ( ""{}"".format ( sum ) , end = """" ) first = sec sec = sum counter = counter + 1"
def binaryToDecimal ( n ) : num = n dec_value = 0 base = 1 temp = num while ( temp ) : last_digit = temp % 10 temp = int ( temp / 10 ) dec_value = dec_value + last_digit * base base = base * 2 return dec_value
def isBinary ( number ) : set1 = set ( ) while ( number > 0 ) : digit = number % 10 set1.add ( digit ) number = int ( number / 10 ) set1.discard ( 0 ) set1.discard ( 1 ) if ( 0 == len ( set1 ) ) : return True return False
"def countWays ( num ) : dp = [ 0 ] * ( num + 1 ) MOD = 100000000 + 7 dp [ 1 ] = 2 i = 2 while i in list ( range ( num + 1 ) ) : dp [ i ] = 0 for j in range ( 1 , 4 ) : if ( i - j == 0 ) : dp [ i ] += 1 elif ( j == 1 ) : dp [ i ] += dp [ i - j ] * 2 elif ( i - j > 0 ) : dp [ i ] += dp [ i - j ] if ( dp [ i ] >= MOD ) : dp [ i ] %= MOD i += 1 return dp [ num ]"
def minLettersNeeded ( n ) : if 0 == n % 26 : return ( n // 26 ) else : return ( ( n // 26 ) + 1 )
def countPS ( str ) : N = len ( str ) cps = [ [ 0 for i in range ( N + 2 ) ] for j in range ( N + 2 ) ] for i in range ( N ) : cps [ i ] [ i ] = 1 L = 2 while L in list ( range ( N + 1 ) ) : for i in range ( N ) : k = L + i - 1 if ( k < N ) : if ( str [ i ] == str [ k ] ) : cps [ i ] [ k ] = ( cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 ) else : cps [ i ] [ k ] = ( cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] ) L += 1 return cps [ 0 ] [ N - 1 ]
"def findSum ( arr , n , k ) : sum = 0 i = 0 while i in list ( range ( n ) ) : if arr [ i ] % k == 0 : sum += arr [ i ] i += 1 return sum"
def countRotations ( n ) : l = len ( n ) if ( l == 1 ) : oneDigit = ( int ) ( n [ 0 ] ) if ( oneDigit % 4 == 0 ) : return 1 return 0 count = 0 i = 0 while i in list ( range ( l - 1 ) ) : twoDigit = ( int ) ( n [ i ] ) * 10 + ( int ) ( n [ i + 1 ] ) if ( twoDigit % 4 == 0 ) : count = count + 1 i += 1 twoDigit = ( int ) ( n [ l - 1 ] ) * 10 + ( int ) ( n [ 0 ] ) if ( twoDigit % 4 == 0 ) : count = count + 1 return count
"def lcs ( dp , arr1 , n , arr2 , m , k ) : if k < 0 : return - ( 10 ** 7 ) if n < 0 or m < 0 : return 0 ans = dp [ n ] [ m ] [ k ] if ans != - 1 : return ans ans = max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) if arr2 [ m - 1 ] == arr1 [ n - 1 ] : ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) ans = max ( ans , lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) return ans"
"def printAllAPTriplets ( arr , n ) : s = [ ] i = 0 while i in list ( range ( n - 1 ) ) : for j in range ( i + 1 , n ) : diff = arr [ j ] - arr [ i ] if ( ( arr [ i ] - diff ) in arr ) : print ( ""{}{}{}"".format ( ( arr [ i ] - diff ) , arr [ i ] , arr [ j ] ) , end = ""\n"" ) i += 1 s.append ( arr [ i ] )"
"def checkMarkov ( m ) : for i in range ( 0 , len ( m ) ) : sm = 0 j = 0 while j in list ( range ( len ( m [ i ] ) ) ) : sm = sm + m [ i ] [ j ] j += 1 if ( sm != 1 ) : return False return True"
"def checkPairs ( l , r ) : if 0 == ( l - r ) % 2 : return False return True"
"def fibonacciArray ( arr , n ) : s = set ( ) a , b = 1 , 1 s.add ( a ) if n >= 2 : s.add ( b ) for i in range ( 0 , n - 2 ) : c = a + b s.add ( c ) a , b = b , c i = 0 while i in list ( range ( n ) ) : if arr [ i ] in s : s.remove ( arr [ i ] ) i += 1 return len ( s )"
"def printPascal ( n ) : for line in range ( 1 , n + 1 ) : C = 1 i = 1 while i in list ( range ( line + 1 ) ) : print ( C , end = """" ) C = int ( C * ( line - i ) / i ) i += 1 print ( """" )"
"def countStrs ( n ) : dp = [ [ 0 for j in range ( 27 ) ] for i in range ( n + 1 ) ] for i in range ( 0 , 26 ) : dp [ 1 ] [ i ] = 1 i = 2 while i in list ( range ( n + 1 ) ) : for j in range ( 0 , 26 ) : if ( j == 0 ) : dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] else : dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) i += 1 sum = 0 for i in range ( 0 , 26 ) : sum = sum + dp [ n ] [ i ] return sum"
"def maxLength ( s , n ) : invalidOpenBraces = 0 invalidCloseBraces = 0 i = 0 while i in list ( range ( n ) ) : if ( s [ i ] == '(' ) : invalidOpenBraces += 1 else : if ( invalidOpenBraces == 0 ) : invalidCloseBraces += 1 else : invalidOpenBraces -= 1 i += 1 return ( n - ( invalidOpenBraces + invalidCloseBraces ) )"
def calculateSum ( n ) : if ( n <= 0 ) : return 0 fibo = [ 0 ] * ( n + 1 ) fibo [ 1 ] = 1 sm = fibo [ 0 ] + fibo [ 1 ] i = 2 while i in list ( range ( n + 1 ) ) : fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] sm = sm + fibo [ i ] i += 1 return sm
def isTriPerfect ( n ) : sum = 1 + n i = 2 while i * i <= n : if n % i == 0 : if n / i == i : sum = sum + i else : sum = sum + i + n / i i = i + 1 return ( True if sum == 3 * n and n != 1 else False )
def sumOfSeries ( n ) : x = 0 if 0 == n % 2 : x = ( n / 2 ) * ( n + 1 ) else : x = ( ( n + 1 ) / 2 ) * n return ( int ) ( x * x )
"def sumOfDivisblePowers ( L , R , P ) : res = 0 i = L while i in list ( range ( R + 1 ) ) : x = i while ( x % P == 0 ) : res += 1 x /= P i += 1 return res"
"def missingNumber ( arr1 , arr2 , n ) : mnum = 0 for i in range ( n ) : mnum = mnum ^ arr1 [ i ] i = 0 while i in list ( range ( n - 1 ) ) : mnum = mnum ^ arr2 [ i ] i += 1 return mnum"
"def maxPrimefactorNum ( N ) : arr = [ True ] * ( N + 5 ) i = 3 while ( i * i <= N ) : if ( arr [ i ] ) : j = i * i while j in list ( range ( N + 1 ) ) : arr [ j ] = False j += i i += 2 prime = [ ] prime.append ( 2 ) for i in range ( 3 , N + 1 , 2 ) : if ( arr [ i ] ) : prime.append ( i ) i = 0 ans = 1 while ( ans * prime [ i ] <= N and i < len ( prime ) ) : ans *= prime [ i ] i += 1 return ans"
"def longestAlternating ( arr , n ) : count = [ None ] * n count [ n - 1 ] = 1 i = n - 2 while i >= 0 : if ( 0 > arr [ i ] * arr [ i + 1 ] ) : count [ i ] = count [ i + 1 ] + 1 else : count [ i ] = 1 i = i - 1 i = 0 while i < n : print ( count [ i ] , end = """" ) i = i + 1"
"def countSol ( coeff , start , end , rhs ) : if ( rhs == 0 ) : return 1 result = 0 i = start while i in list ( range ( end + 1 ) ) : if ( coeff [ i ] <= rhs ) : result += countSol ( coeff , i , end , rhs - coeff [ i ] ) i += 1 return result"
"def minimumOperations ( a , n ) : mp = dict ( ) i = 0 while i in list ( range ( n ) ) : if a [ i ] in mp.keys ( ) : mp [ a [ i ] ] += 1 else : mp [ a [ i ] ] = 1 i += 1 count = 0 for it in mp : if ( mp [ it ] > 1 ) : count += mp [ it ] - 1 return count"
def findF_N ( n ) : ans = 0 i = 0 while i in list ( range ( n ) ) : ans = ans + ( i + 1 ) * ( n - i - 1 ) i += 1 return ans
"def lcs ( X , Y ) : m = len ( X ) n = len ( Y ) L = [ [ 0 for i in range ( n + 1 ) ] for j in range ( 2 ) ] bi = bool for i in range ( m ) : bi = i & 1 j = 0 while j in list ( range ( n + 1 ) ) : if ( i == 0 or j == 0 ) : L [ bi ] [ j ] = 0 elif ( X [ i ] == Y [ j - 1 ] ) : L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 else : L [ bi ] [ j ] = max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) j += 1 return L [ bi ] [ n ]"
"def checkReverse ( arr , n ) : temp = [ 0 ] * n i = 0 while i in list ( range ( n ) ) : temp [ i ] = arr [ i ] i += 1 temp.sort ( ) for front in range ( n ) : if temp [ front ] != arr [ front ] : break for back in range ( n - 1 , - 1 , - 1 ) : if temp [ back ] != arr [ back ] : break if front >= back : return True while front != back : front += 1 if arr [ front - 1 ] < arr [ front ] : return False return True"
"def minMovesToSort ( arr , n ) : moves = 0 mn = arr [ n - 1 ] i = n - 1 while i in list ( range ( - 1 ) ) : if ( arr [ i ] > mn ) : moves += arr [ i ] - mn mn = arr [ i ] i += - 1 return moves"
"def calculateAlternateSum ( n ) : if ( n <= 0 ) : return 0 fibo = [ 0 ] * ( n + 1 ) fibo [ 0 ] = 0 fibo [ 1 ] = 1 sum = pow ( fibo [ 0 ] , 2 ) + pow ( fibo [ 1 ] , 2 ) i = 2 while i in list ( range ( n + 1 ) ) : fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] if ( i % 2 == 0 ) : sum -= fibo [ i ] else : sum += fibo [ i ] i += 1 return sum"
def isPentagonal ( N ) : i = 1 while True : M = ( 3 * i * i - i ) / 2 i = i + 1 if ( M >= N ) : break return ( M == N )
"def printKPFNums ( A , B , K ) : prime = [ True ] * ( B + 1 ) p_factors = [ 0 ] * ( B + 1 ) for p in range ( 2 , B + 1 ) : if ( p_factors [ p ] == 0 ) : for i in range ( p , B + 1 , p ) : p_factors [ i ] = p_factors [ i ] + 1 i = A while i in list ( range ( B + 1 ) ) : if ( p_factors [ i ] == K ) : print ( i , end = """" ) i += 1"
"def pairwiseProduct ( arr , n ) : prod = 1 i = 0 while i in list ( range ( n - 1 ) ) : prod = arr [ i ] * arr [ i + 1 ] print ( prod , end = """" ) i += 1"
"def countPairs ( arr , n ) : result = 0 for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : product = arr [ i ] * arr [ j ] k = 0 while k in list ( range ( n ) ) : if ( arr [ k ] == product ) : result = result + 1 k += 1 break k += 1 return result"
def spiralDiaSum ( n ) : if 1 == n : return 1 return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) )
"def expressDigit ( arr , n ) : min = 9 index = 0 temp = 0 temp = arr [ 0 ] for i in range ( 1 , 10 ) : if ( arr [ i ] < min ) : min = arr [ i ] index = i if ( temp < min ) : print ( 1 , end = """" ) for i in range ( 1 , temp + 1 ) : print ( 0 , end = """" ) else : i = 0 while i in list ( range ( min ) ) : print ( index , end = """" ) i += 1 print ( index )"
"def NoofTriplets ( N , K ) : cnt = [ 0 ] * K i = 1 while i in list ( range ( N + 1 ) ) : cnt [ i % K ] += 1 i += 1 if ( K & 1 ) : rslt = cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] return rslt else : rslt = ( cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] + cnt [ K // 2 ] * cnt [ K // 2 ] * cnt [ K // 2 ] ) return rslt"
"def sub_segments ( string , n ) : l = len ( string ) x = 0 while x in list ( range ( l ) ) : newlist = string [ x : x + n ] arr = [ ] for y in newlist : if y not in arr : arr.append ( y ) print ( ''.join ( arr ) ) x += n"
"def maxDifference ( arr , N , k ) : S = 0 S1 = 0 max_difference = 0 i = 0 while i in list ( range ( N ) ) : S += arr [ i ] i += 1 arr.sort ( reverse = True ) M = max ( k , N - k ) for i in range ( M ) : S1 += arr [ i ] max_difference = S1 - ( S - S1 ) return max_difference"
"def check_duck ( num ) : l = len ( num ) count_zero = 0 i = 1 while l > i : ch = num [ i ] if ( ch == ""0"" ) : count_zero = count_zero + 1 i = i + 1 return count_zero"
"def isAMultipleOf4 ( n ) : if ( 0 == ( n & 3 ) ) : return ""Yes"" return ""No"""
"def reverse ( arr , n , k ) : i = 0 while ( n > i ) : left = i right = min ( i + k - 1 , n - 1 ) while ( left < right ) : arr [ left ] , arr [ right ] = arr [ right ] , arr [ left ] left += 1 right - + 1 i += k"
"def match_words ( dictionary , sentence , n , m ) : mp = dict ( ) for i in range ( n ) : mp [ dictionary [ i ] ] = mp.get ( dictionary [ i ] , 0 ) + 1 i = 0 while i in list ( range ( m ) ) : if ( mp [ sentence [ i ] ] ) : mp [ sentence [ i ] ] -= 1 else : i += 1 return False i += 1 return True"
"def countSubString ( s , c , k ) : leftCount = 0 rightCount = 0 left = 0 right = 0 freq = 0 result = 0 Len = len ( s ) while ( s [ left ] != c and left < Len ) : left += 1 leftCount += 1 right = left + 1 while ( freq != ( k - 1 ) and ( right - 1 ) < Len ) : if ( c == s [ right ] ) : freq += 1 right += 1 while ( left < Len and ( right - 1 ) < Len ) : while ( s [ left ] != c and left < Len ) : left += 1 leftCount += 1 while ( right < Len and s [ right ] != c ) : if ( s [ right ] == c ) : freq += 1 right += 1 rightCount += 1 result = ( result + ( leftCount + 1 ) * ( rightCount + 1 ) ) freq = k - 1 leftCount = 0 rightCount = 0 left += 1 right += 1 return result"
"def countWays ( n , arr ) : if ( n == 0 ) : return 1 no_ways = 0 for i in arr : if ( 0 <= n - i ) : no_ways = no_ways + countWays ( n - i , arr ) return no_ways"
"def checkCentrosymmetricted ( n , m ) : mid_row = 0 if ( ( n & 1 ) > 0 ) : mid_row = n / 2 + 1 else : mid_row = n / 2 for i in range ( int ( mid_row ) ) : j = 0 while j in list ( range ( n ) ) : if ( m [ i ] [ j ] != m [ n - i - 1 ] [ n - j - 1 ] ) : j += 1 return False j += 1 return True"
def isPowerOf2 ( sttr ) : len_str = len ( sttr ) sttr = list ( sttr ) num = 0 if ( len_str == 1 and sttr [ len_str - 1 ] == '1' ) : return 0 while ( len_str != 1 or sttr [ len_str - 1 ] != '1' ) : if ( ( ord ( sttr [ len_str - 1 ] ) - ord ( '0' ) ) % 2 == 1 ) : return 0 j = 0 i = 0 while i in list ( range ( len_str ) ) : num = num * 10 + ( ord ( sttr [ i ] ) - ord ( '0' ) ) if ( num < 2 ) : if ( i != 0 ) : sttr [ j ] = '0' j += 1 i += 1 continue sttr [ j ] = chr ( ( num // 2 ) + ord ( '0' ) ) j += 1 num = ( num ) - ( num // 2 ) * 2 i += 1 len_str = j return 1
"def NicomachuTheorum_sum ( n ) : sum = 0 k = 1 while k in list ( range ( n + 1 ) ) : sum += k * k * k k += 1 triNo = n * ( n + 1 ) / 2 if ( sum == triNo * triNo ) : print ( ""Yes"" ) else : print ( ""No"" )"
"def farthest_min ( a , n ) : suffix_min = [ 0 for i in range ( n ) ] suffix_min [ n - 1 ] = a [ n - 1 ] i = n - 2 while i in list ( range ( - 1 ) ) : suffix_min [ i ] = min ( suffix_min [ i + 1 ] , a [ i ] ) i += - 1 for i in range ( n ) : low = i + 1 high = n - 1 ans = - 1 while ( low <= high ) : mid = ( low + high ) // 2 if ( suffix_min [ mid ] < a [ i ] ) : ans = mid low = mid + 1 else : high = mid - 1 print ( ans , end = """" )"
"def sumXOR ( arr , n ) : sum = 0 for i in range ( 0 , 32 ) : zc = 0 oc = 0 idsum = 0 j = 0 while j in list ( range ( n ) ) : if ( arr [ j ] % 2 == 0 ) : zc = zc + 1 else : oc = oc + 1 arr [ j ] = int ( arr [ j ] / 2 ) j += 1 idsum = oc * zc * ( 1 << i ) sum = sum + idsum return sum"
"def ReplaceElements ( arr , n ) : prod = 1 for i in range ( n ) : prod *= arr [ i ] i = 0 while i in list ( range ( n ) ) : arr [ i ] = prod // arr [ i ] i += 1"
"def getTotalNumberOfSequences ( m , n ) : if n > m : return 0 if n == 0 : return 1 res = ( getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m // 2 , n - 1 ) ) return res"
def calculate ( a ) : a.sort ( ) count = 1 answer = 0 i = 1 while i in list ( range ( len ( a ) ) ) : if a [ i ] == a [ i - 1 ] : count += 1 else : answer = answer + count * ( count - 1 ) // 2 count = 1 i += 1 answer = answer + count * ( count - 1 ) // 2 return answer
def printSeriesSum ( N ) : sum = 0 a = 1 cnt = 0 flag = True sum = sum + a while ( cnt < N ) : nextElement = None if ( flag ) : nextElement = a * 2 sum = sum + nextElement flag = not flag else : nextElement = a * ( 3 / 2 ) sum = sum + nextElement flag = not flag a = nextElement cnt = cnt + 1 print ( sum )
def count_minimum_operations ( n ) : count = 0 while ( 1 < n ) : if ( n % 3 == 0 ) : n //= 3 elif ( n % 3 == 1 ) : n -= 1 else : if ( n == 2 ) : n -= 1 else : n += 1 count += 1 return count
"def findNumbers ( n , w ) : x = 0 sum = 0 if ( w >= 0 and 8 >= w ) : x = 9 - w elif ( w >= - 9 and w <= - 1 ) : x = 10 + w sum = pow ( 10 , n - 2 ) sum = ( x * sum ) return sum"
"def xorOfArray ( arr , n ) : xor_arr = 0 i = 0 while i in list ( range ( n ) ) : xor_arr = xor_arr ^ arr [ i ] i += 1 return xor_arr"
"def minSum ( a , n ) : a = sorted ( a ) num1 , num2 = 0 , 0 i = 0 while i in list ( range ( n ) ) : if i % 2 == 0 : num1 = num1 * 10 + a [ i ] else : num2 = num2 * 10 + a [ i ] i += 1 return num2 + num1"
"def numbers ( n , arr , m ) : isZero = 0 isFive = 0 result = 0 if ( m < n ) : return - 1 i = 0 while i in list ( range ( m ) ) : if ( arr [ i ] == 0 ) : isZero = 1 if ( arr [ i ] == 5 ) : isFive = 1 i += 1 if ( isZero and isFive ) : result = 2 for i in range ( n - 1 ) : m -= 1 result = result * ( m ) elif ( isZero or isFive ) : result = 1 for i in range ( n - 1 ) : m -= 1 result = result * ( m ) else : result = - 1 return result"
"def isInside ( circle_x , circle_y , rad , x , y ) : if ( rad * rad >= ( x - circle_x ) * ( x - circle_x ) + ( y - circle_y ) * ( y - circle_y ) ) : return True else : return False"
"def printTaxicab2 ( N ) : i , count = 1 , 0 while ( count < N ) : int_count = 0 j = 1 while j in list ( range ( int ( pow ( i , 1.0 / 3 ) ) + 1 ) ) : for k in range ( j + 1 , int ( pow ( i , 1.0 / 3 ) ) + 1 ) : if ( j * j * j + k * k * k == i ) : int_count += 1 j += 1 if ( int_count == 2 ) : count += 1 print ( count , """" , i ) i += 1"
"def kBitDifferencePairs ( arr , n , k ) : MAX = max ( arr ) count = [ 0 for i in range ( MAX + 1 ) ] i = 0 while i in list ( range ( n ) ) : count [ arr [ i ] ] += 1 i += 1 ans = 0 if ( k == 0 ) : for i in range ( MAX + 1 ) : ans += ( count [ i ] * ( count [ i ] - 1 ) ) // 2 return ans for i in range ( MAX + 1 ) : if ( count [ i ] == 0 ) : continue for j in range ( i + 1 , MAX + 1 ) : if ( bin ( i ^ j ).count ( '1' ) == k ) : ans += count [ i ] * count [ j ] return ans"
"def generateGrayarr ( n ) : if ( n <= 0 ) : return arr = list ( ) arr.append ( ""0"" ) arr.append ( ""1"" ) i = 2 j = 0 while ( True ) : if i >= 1 << n : break for j in range ( i - 1 , - 1 , - 1 ) : arr.append ( arr [ j ] ) for j in range ( i ) : arr [ j ] = ""0"" + arr [ j ] j = i while j in list ( range ( 2 * i ) ) : arr [ j ] = ""1"" + arr [ j ] j += 1 i = i << 1 for i in range ( len ( arr ) ) : print ( arr [ i ] )"
"def pattern ( N ) : k , space , rows = 0 , 1 , N for i in range ( rows , 0 , - 1 ) : for j in range ( 1 , i + 1 ) : print ( '*' , end = '' ) if i != rows : for k in range ( 1 , space + 1 ) : print ( '' , end = '' ) space += 2 j = i while j in list ( range ( 0 ) ) : if j != rows : print ( '*' , end = '' ) j += - 1 print ( ) print ( )"
"def difference ( arr , n ) : d1 = 0 d2 = 0 for i in range ( 0 , n ) : j = 0 while j in list ( range ( n ) ) : if ( i == j ) : d1 += arr [ i ] [ j ] if ( i == n - j - 1 ) : d2 += arr [ i ] [ j ] j += 1 return abs ( d1 - d2 )"
"def alternateSort ( arr , n ) : arr.sort ( ) i = 0 j = n - 1 while ( i < j ) : print ( arr [ j ] , end = """" ) j -= 1 print ( arr [ i ] , end = """" ) i += 1 if ( 0 != n % 2 ) : print ( arr [ i ] )"
def getMaximumSumWithLCMN ( N ) : sum = 0 LIM = int ( math.sqrt ( N ) ) i = 1 while i in list ( range ( LIM + 1 ) ) : if ( N % i == 0 ) : if ( i == ( N // i ) ) : sum = sum + i else : sum = sum + ( i + N // i ) i += 1 return sum
"def getElement ( a , n , S ) : a.sort ( ) sum = 0 i = 0 while i in list ( range ( n ) ) : if ( sum + ( a [ i ] * ( n - i ) ) == S ) : i += 1 return a [ i ] sum += a [ i ] i += 1 return - 1"
def isDvisibleBy12 ( num ) : if ( len ( num ) >= 3 ) : d1 = int ( num [ len ( num ) - 1 ] ) if ( d1 % 2 != 0 ) : return False d2 = int ( num [ len ( num ) - 2 ] ) sum = 0 i = 0 while i in list ( range ( len ( num ) ) ) : sum += int ( num [ i ] ) i += 1 return ( sum % 3 == 0 and ( d2 * 10 + d1 ) % 4 == 0 ) else : number = int ( num ) return ( number % 12 == 0 )
def getSum ( n ) : sum = 0 while ( 0 < n ) : sum += int ( n % 10 ) n = int ( n / 10 ) return sum
def countIdenticalRows ( mat ) : count = 0 for i in range ( len ( mat ) ) : first = mat [ i ] [ 0 ] allSame = True j = 1 while j in list ( range ( len ( mat [ i ] ) ) ) : if ( mat [ i ] [ j ] != first ) : allSame = False j += 1 break j += 1 if ( allSame ) : count += 1 return count
"def mul_table ( N , i ) : if ( 10 < i ) : return print ( N , ""*"" , i , ""="" , N * i ) return mul_table ( N , i + 1 )"
"def lenOfLongSubarr ( arr , n ) : um = { i : 0 for i in range ( 10 ) } sum = 0 maxLen = 0 i = 0 while i in list ( range ( n ) ) : if arr [ i ] == 0 : sum += - 1 else : sum += 1 if ( sum == 1 ) : maxLen = i + 1 elif ( sum not in um ) : um [ sum ] = i if ( ( sum - 1 ) in um ) : if ( maxLen < ( i - um [ sum - 1 ] ) ) : maxLen = i - um [ sum - 1 ] i += 1 return maxLen"
"def maxLenSub ( arr , n ) : mls = [ ] max = 0 i = 0 while i in list ( range ( n ) ) : mls.append ( 1 ) i += 1 for i in range ( n ) : for j in range ( i ) : if ( abs ( arr [ i ] - arr [ j ] ) <= 1 and mls [ i ] < mls [ j ] + 1 ) : mls [ i ] = mls [ j ] + 1 for i in range ( n ) : if ( max < mls [ i ] ) : max = mls [ i ] return max"
"def maxPathSum ( tri , m , n ) : i = m - 1 while i in list ( range ( - 1 ) ) : for j in range ( i + 1 ) : if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) : tri [ i ] [ j ] += tri [ i + 1 ] [ j ] else : tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] i += - 1 return tri [ 0 ] [ 0 ]"
"def getIndex ( a , n ) : if ( n == 1 ) : return 0 ptrL = 0 ptrR = n - 1 sumL = a [ 0 ] sumR = a [ n - 1 ] while ( ptrR - ptrL > 1 ) : if ( sumL < sumR ) : ptrL += 1 sumL += a [ ptrL ] elif ( sumR < sumL ) : ptrR -= 1 sumR += a [ ptrR ] else : break return ptrL"
"def bubbleSort ( arr ) : n = len ( arr ) for i in range ( n ) : j = 0 while j in list ( range ( n - i - 1 ) ) : if arr [ j ] > arr [ j + 1 ] : arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ] j += 1"
"def shortestDistance ( S , X ) : prev = float ( '-inf' ) ans = [ ] for i , j in enumerate ( S ) : if j == X : prev = i ans.append ( i - prev ) prev = float ( 'inf' ) i = len ( S ) - 1 while i in list ( range ( - 1 ) ) : if S [ i ] == X : prev = i ans [ i ] = min ( ans [ i ] , prev - i ) i += - 1 return ans"
"def nthDigit ( a , n , b ) : i = 1 while i in list ( range ( n ) ) : a = a // b i += 1 return a % b"
"def printGroups ( n , a ) : ct = [ 0 for i in range ( 7 ) ] grps = n // 3 i = 0 for i in range ( n ) : ct [ a [ i ] ] += 1 if ( ct [ 1 ] != grps or ( ct [ 4 ] + ct [ 6 ] ) != grps or ( ct [ 2 ] + ct [ 3 ] ) != grps or ct [ 2 ] < ct [ 4 ] ) : print ( - 1 ) return for i in range ( ct [ 4 ] ) : print ( ""124"" ) for i in range ( ct [ 2 ] - ct [ 4 ] ) : print ( ""126"" ) for i in range ( ct [ 3 ] ) : print ( ""136"" )"
"def minsteps ( n , m ) : if ( m <= n ) : return ( ( n + 1 ) // 2 + m - 1 ) // m * m else : return - 1"
"def minOperations ( str , n ) : lastUpper = - 1 firstLower = - 1 for i in range ( n - 1 , - 1 , - 1 ) : if ( str [ i ].isupper ( ) ) : lastUpper = i break for i in range ( n ) : if ( str [ i ].islower ( ) ) : firstLower = i break if ( lastUpper == - 1 or firstLower == - 1 ) : return 0 countUpper = 0 for i in range ( firstLower , n ) : if ( str [ i ].isupper ( ) ) : countUpper += 1 countLower = 0 i = 0 while i in list ( range ( lastUpper ) ) : if ( str [ i ].islower ( ) ) : countLower += 1 i += 1 return min ( countLower , countUpper )"
def findCount ( N ) : list = [ ] sum = 0 i = 0 while i in list ( range ( 20 ) ) : sum += 2 ** i list.append ( sum ) i += 1 for value in list : if ( value > N ) : return ( list.index ( value ) + 1 )
"def answerQuery ( a , n , l , r ) : count = 0 l = l - 1 for i in range ( l , r , 1 ) : element = a [ i ] divisors = 0 j = l while j in list ( range ( r ) ) : if ( a [ j ] % a [ i ] == 0 ) : divisors += 1 else : j += 1 break j += 1 if ( divisors == ( r - l ) ) : count += 1 return count"
"def func ( a , k , n ) : i = 0 while i in list ( range ( n ) ) : if ( a [ i ] % k == 0 ) : i += 1 return True i += 1"
def NumberofTimes ( s ) : temporary_sum = 0 count = 0 while ( len ( s ) > 1 ) : temporary_sum = 0 i = 0 while i in list ( range ( len ( s ) ) ) : temporary_sum += ( ord ( s [ i ] ) - ord ( '0' ) ) i += 1 s = str ( temporary_sum ) count += 1 return count
"def findSubarraySum ( arr , n ) : res = 0 m = dict ( ) i = 0 while i in list ( range ( n ) ) : Sum = 0 for j in range ( i , n ) : Sum += arr [ j ] m [ Sum ] = m.get ( Sum , 0 ) + 1 i += 1 for x in m : if m [ x ] == 1 : res += x return res"
"def isFrequencyEqual ( arr , length ) : if ( length % 2 == 1 ) : print ( ""NoSuchElement"" ) return False freq = dict.fromkeys ( arr , 0 ) i = 0 while i in list ( range ( length ) ) : freq [ arr [ i ] ] += 1 i += 1 for i in range ( length ) : if ( freq [ arr [ i ] ] == length / 2 ) : print ( arr [ i ] ) return True print ( ""Nosuchelement"" , end = """" ) return False"
def seriesSum ( n ) : i = 1 res = 0.0 sign = True while ( 0 < n ) : n = n - 1 if ( sign ) : sign = False res = res + ( i + 1 ) / ( i + 2 ) i = i + 2 else : sign = True res = res - ( i + 1 ) / ( i + 2 ) i = i + 2 return res
"def alternateFib ( n ) : if ( n < 0 ) : return - 1 f1 = 0 f2 = 1 print ( f1 , end = """" ) i = 2 while i in list ( range ( n + 1 ) ) : f3 = f2 + f1 if ( i % 2 == 0 ) : print ( f3 , end = """" ) f1 = f2 f2 = f3 i += 1"
"def getLongestSeq ( a , n ) : maxIdx = 0 maxLen = 0 currLen = 0 currIdx = 0 k = 0 while k in list ( range ( n ) ) : if a [ k ] > 0 : currLen += 1 if currLen == 1 : currIdx = k else : if currLen > maxLen : maxLen = currLen maxIdx = currIdx currLen = 0 k += 1 if maxLen > 0 : print ( 'Index:' , maxIdx , ',Length:' , maxLen , ) else : print ( ""Nopositivesequencedetected."" )"
"def pairORSum ( arr , n ) : ans = 0 i = 0 while i in list ( range ( n ) ) : for j in range ( i + 1 , n ) : ans = ans + ( arr [ i ] ^ arr [ j ] ) i += 1 return ans"
"def squarearea ( a , b ) : if ( a < 0 or 0 > b ) : return - 1 area = 4 * ( ( ( pow ( a , 2 ) + pow ( b , 2 ) ) / ( pow ( a , 2 ) * pow ( b , 2 ) ) ) ) return area"
"def printArray ( arr , Len ) : i = 0 while i in list ( range ( Len ) ) : print ( arr [ i ] , end = """" ) i += 1"
"def countPairs ( arr , n ) : cnt = 0 for i in range ( n - 1 ) : j = i + 1 while j in list ( range ( n ) ) : if ( ( arr [ i ] | arr [ j ] ) <= max ( arr [ i ] , arr [ j ] ) ) : cnt += 1 j += 1 return cnt"
"def numberOfPaths ( p , q ) : dp = [ 1 for i in range ( q ) ] i = 0 while i in list ( range ( p - 1 ) ) : for j in range ( 1 , q ) : dp [ j ] += dp [ j - 1 ] i += 1 return dp [ q - 1 ]"
"def innerCirclearea ( radius ) : if ( 0 > radius ) : return - 1 r = radius / 2 Area = ( 3.14 * pow ( r , 2 ) ) return Area"
"def atMostSum ( arr , n , k ) : _sum = 0 cnt = 0 maxcnt = 0 i = 0 while i in list ( range ( n ) ) : if ( ( _sum + arr [ i ] ) <= k ) : _sum += arr [ i ] cnt += 1 elif ( sum != 0 ) : _sum = _sum - arr [ i - cnt ] + arr [ i ] maxcnt = max ( cnt , maxcnt ) i += 1 return maxcnt"
"def divisibilityCheck ( arr , n ) : s = dict ( ) max_ele = - 10 ** 9 for i in range ( n ) : s [ arr [ i ] ] = 1 max_ele = max ( max_ele , arr [ i ] ) res = dict ( ) for i in range ( n ) : if ( arr [ i ] != 0 ) : j = arr [ i ] * 2 while j in list ( range ( max_ele + 1 ) ) : if ( j in s.keys ( ) ) : res [ j ] = 1 j += arr [ i ] for x in res : print ( x , end = """" )"
def validate ( n ) : i = 0 while i in list ( range ( 10 ) ) : temp = n count = 0 while ( temp ) : if ( temp % 10 == i ) : count += 1 if ( count > i ) : i += 1 return - 1 temp //= 10 i += 1 return 1
"def count ( a , b ) : m = len ( a ) n = len ( b ) lookup = [ [ 0 ] * ( n + 1 ) for i in range ( m + 1 ) ] for i in range ( n + 1 ) : lookup [ 0 ] [ i ] = 0 i = 0 while i in list ( range ( m + 1 ) ) : lookup [ i ] [ 0 ] = 1 i += 1 for i in range ( 1 , m + 1 ) : for j in range ( 1 , n + 1 ) : if a [ i - 1 ] == b [ j - 1 ] : lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ] else : lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ] return lookup [ m ] [ n ]"
"def subset ( arr , n ) : mp = { i : 0 for i in range ( 10 ) } i = 0 while i in list ( range ( n ) ) : mp [ arr [ i ] ] += 1 i += 1 res = 0 for key , value in mp.items ( ) : res = max ( res , value ) return res"
"def checkReverse ( arr , n ) : if ( n == 1 ) : return True i = 1 i = 1 while i in list ( range ( n ) ) : if arr [ i - 1 ] < arr [ i ] : if ( i == n ) : i += 1 return True i += 1 j = i while ( arr [ j ] < arr [ j - 1 ] ) : if ( i > 1 and arr [ j ] < arr [ i - 2 ] ) : return False j += 1 if ( j == n ) : return True k = j if ( arr [ k ] < arr [ i - 1 ] ) : return False while ( k > 1 and k < n ) : if ( arr [ k ] < arr [ k - 1 ] ) : return False k += 1 return True"
"def EvenOddProduct ( arr , n ) : even = 1 odd = 1 i = 0 while i in list ( range ( n ) ) : if ( i % 2 == 0 ) : even *= arr [ i ] else : odd *= arr [ i ] i += 1 print ( ""EvenIndexProduct:"" , even ) print ( ""OddIndexProduct:"" , odd )"
"def isRotated ( str1 , str2 ) : if ( len ( str2 ) != len ( str1 ) ) : return False clock_rot = """" anticlock_rot = """" l = len ( str2 ) anticlock_rot = ( anticlock_rot + str2 [ l - 2 : ] + str2 [ 0 : l - 2 ] ) clock_rot = clock_rot + str2 [ 2 : ] + str2 [ 0 : 2 ] return ( str1 == clock_rot or str1 == anticlock_rot )"
"def minflip ( arr1 , arr2 , arr3 , p , q , n ) : flip = 0 i = 0 while i in list ( range ( n ) ) : if ( arr1 [ i ] ^ arr2 [ i ] != arr3 [ i ] ) : flip += 1 i += 1 return flip if ( flip <= p + q ) else - 1"
"def findNumbers ( n ) : i = 1 while ( n >= i ) : print ( ( 3 * i * ( i - 1 ) + 1 ) , end = """" ) i += 1"
"def countTriplets ( arr , n , m ) : count = 0 arr.sort ( ) end = n - 1 while end in list ( range ( 1 ) ) : start = 0 mid = end - 1 while ( start < mid ) : prod = ( arr [ end ] * arr [ start ] * arr [ mid ] ) if ( prod > m ) : mid -= 1 elif ( prod < m ) : start += 1 elif ( prod == m ) : count += 1 mid -= 1 start += 1 end += - 1 return count"
"def printNonSquare ( n ) : curr_count = 2 num = 2 count = 0 while ( count < n ) : i = 0 while ( curr_count > i and count < n ) : print ( num , end = """" ) count = count + 1 num = num + 1 i = i + 1 num = num + 1 curr_count = curr_count + 2"
"def circlearea ( a , b ) : if ( a < 0 or 0 > b ) : return - 1 A = ( ( 3.14 * pow ( a , 2 ) * pow ( b , 2 ) ) / ( 4 * ( pow ( a , 2 ) + pow ( b , 2 ) ) ) ) return A"
"def findMod4 ( s , n ) : if ( 1 == n ) : k = ord ( s [ 0 ] ) - ord ( '0' ) else : k = ( ( ord ( s [ n - 2 ] ) - ord ( '0' ) ) * 10 + ord ( s [ n - 1 ] ) - ord ( '0' ) ) return ( k % 4 )"
def countSetBits ( n ) : count = 0 while ( n ) : count = count + n & 1 n >>= 1 return count
def findTrailingZeros ( n ) : if ( n & 1 ) : return 0 else : ans = 0 n //= 2 while ( n ) : ans = ans + n // 5 n //= 5 return ans
def minSum ( n ) : sum = 0 while ( n > 0 ) : sum = sum + ( n % 10 ) n //= 10 if ( sum == 1 ) : return 10 return sum
"def countdigits ( n , k ) : if n == 0 : return 0 digit = n % 10 if k == digit : return 1 + countdigits ( n / 10 , k ) return countdigits ( n / 10 , k )"
"def countFreq ( arr , n ) : mp = dict ( ) i = 0 while i in list ( range ( n ) ) : if arr [ i ] in mp.keys ( ) : mp [ arr [ i ] ] += 1 else : mp [ arr [ i ] ] = 1 i += 1 for x in mp : print ( x , """" , mp [ x ] )"
def areElementsContiguous ( arr ) : us = set ( ) for i in arr : us.add ( i ) count = 1 curr_ele = arr [ 0 ] - 1 while curr_ele in us : count += 1 curr_ele -= 1 curr_ele = arr [ 0 ] + 1 while curr_ele in us : count += 1 curr_ele += 1 return ( len ( us ) == count )
"def freq ( ar , m , n ) : even = 0 odd = 0 i = 0 while i in list ( range ( m ) ) : for j in range ( n ) : if ( ( ar [ i ] [ j ] % 2 ) == 0 ) : even += 1 else : odd += 1 i += 1 print ( ""Frequencyofoddnumber="" , odd ) print ( ""Frequencyofevennumber="" , even )"
"def twistedTOH ( n , first , middle , last ) : if ( 1 == n ) : print ( ""Movedisk"" , n , ""fromrod"" , first , ""to"" , middle , ""andthento"" , last ) return twistedTOH ( n - 1 , first , middle , last ) print ( ""Movedisk"" , n , ""fromrod"" , first , ""to"" , middle ) twistedTOH ( n - 1 , last , middle , first ) print ( ""Movedisk"" , n , ""fromrod"" , middle , ""to"" , last ) twistedTOH ( n - 1 , first , middle , last )"
def check ( st ) : n = len ( st ) if ( n == 0 ) : return False if ( n == 1 ) : return ( ( st [ 0 ] - '0' ) % 4 == 0 ) last = ( int ) ( st [ n - 1 ] ) second_last = ( int ) ( st [ n - 2 ] ) return ( 0 == ( second_last * 10 + last ) % 4 )
"def findMajority ( arr , size ) : m = { } i = 0 while i in list ( range ( size ) ) : if arr [ i ] in m : m [ arr [ i ] ] += 1 else : m [ arr [ i ] ] = 1 i += 1 count = 0 for key in m : if m [ key ] > size / 2 : count = 1 print ( ""Majorityfound:-"" , key ) break if ( count == 0 ) : print ( ""NoMajorityelement"" )"
def toggleCase ( a ) : i = 0 while i in list ( range ( len ( a ) ) ) : a = a [ : i ] + chr ( ord ( a [ i ] ) ^ 32 ) + a [ i + 1 : ] i += 1 return a
"def find_idx ( ar , n ) : answer = [ ] sum = ar [ 0 ] i = 1 while i in list ( range ( n ) ) : if ( sum == ar [ i ] ) : answer.append ( i + 1 ) sum += ar [ i ] i += 1 return answer"
"def Max_Sum ( a , n ) : b = [ 0 for i in range ( n ) ] S = 0 res = 0 for i in range ( n ) : b [ i ] = res res += a [ i ] S += a [ i ] res = max ( res , - S ) ans = S ans = max ( ans , res ) g = 0 i = n - 1 while i in list ( range ( - 1 ) ) : g -= a [ i ] ans = max ( ans , g + b [ i ] ) i += - 1 return ans"
"def findpair ( l , r ) : c = 0 for i in range ( l , r + 1 ) : j = i + 1 while j in list ( range ( r + 1 ) ) : if ( j % i == 0 and j != i ) : print ( i , "","" , j ) c = 1 j += 1 break j += 1 if ( c == 1 ) : break"
"def recaman ( n ) : arr = [ 0 ] * n arr [ 0 ] = 0 print ( arr [ 0 ] , end = "","" ) i = 1 while i in list ( range ( n ) ) : curr = arr [ i - 1 ] - i for j in range ( 0 , i ) : if ( ( arr [ j ] == curr ) or curr < 0 ) : curr = arr [ i - 1 ] + i i += 1 break arr [ i ] = curr print ( arr [ i ] , end = "","" ) i += 1"
def isToOne ( n ) : return ( 0 < n )
"def isEven ( arr , n , r ) : if ( r % 2 == 0 ) : if ( arr [ n - 1 ] % 2 == 0 ) : return True else : oddCount = 0 i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] % 2 != 0 ) : oddCount += 1 i += 1 if ( oddCount % 2 == 0 ) : return True return False"
"def maxSubseq ( vec , n ) : suffix = 0 i = n - 1 while ( i >= 0 ) : if ( vec [ i ] == 1 ) : suffix += 1 vec [ i ] = suffix i -= 1 res = 0 zero = 0 i = 0 while i in list ( range ( n ) ) : if ( vec [ i ] == 0 ) : zero += 1 if ( vec [ i ] > 0 ) : res = max ( res , zero + vec [ i ] ) i += 1 return max ( res , zero )"
def nextPowerOf2 ( n ) : p = 1 if ( n and not ( n & ( n - 1 ) ) ) : return n while ( n > p ) : p <<= 1 return p
def bit_check ( n ) : if ( 0 == ( n & ( n - 1 ) ) ) : return True return False
"def multiple ( a , b , x ) : if ( b < 0 ) : if ( a == 1 and x == 1 ) : print ( ""1"" ) else : print ( ""0"" ) mul = int ( pow ( a , b ) ) ans = int ( mul / x ) ans1 = x * ans ans2 = x * ( ans + 1 ) if ( ( ans2 - mul ) >= ( mul - ans1 ) ) : print ( ans1 ) else : print ( ans2 )"
"def smallestPermute ( n ) : res = [ """" ] * ( n + 1 ) if ( n % 2 == 0 ) : for i in range ( n ) : if ( i % 2 == 0 ) : res [ i ] = chr ( 48 + i + 2 ) else : res [ i ] = chr ( 48 + i ) else : i = 0 while i in list ( range ( n - 2 ) ) : if ( i % 2 == 0 ) : res [ i ] = chr ( 48 + i + 2 ) else : res [ i ] = chr ( 48 + i ) i += 1 res [ n - 1 ] = chr ( 48 + n - 2 ) res [ n - 2 ] = chr ( 48 + n ) res [ n - 3 ] = chr ( 48 + n - 1 ) res = ''.join ( res ) return res"
"def permutation ( arr , n ) : s = set ( ) maxEle = 0 i = 0 while i in list ( range ( n ) ) : s.add ( arr [ i ] ) maxEle = max ( maxEle , arr [ i ] ) i += 1 if ( maxEle != n ) : return False if ( len ( s ) == n ) : return True return False"
"def findEvenPair ( A , N ) : evenPair = 0 for i in range ( N ) : j = i + 1 while j in list ( range ( N ) ) : if ( A [ i ] | A [ j ] ) % 2 == 0 : evenPair += 1 j += 1 return evenPair"
"def countOperations ( arr , n ) : count = 0 i = 0 while i in list ( range ( n - 1 ) ) : if ( arr [ i ] & 1 ) : arr [ i ] += 1 arr [ i + 1 ] += 1 count += 2 i += 1 for i in range ( n ) : if ( arr [ i ] & 1 ) : return - 1 return count"
"def printDistSum ( arr , n ) : Sum = sum ( arr ) dp = [ [ False for i in range ( Sum + 1 ) ] for i in range ( n + 1 ) ] for i in range ( n + 1 ) : dp [ i ] [ 0 ] = True i = 1 while i in list ( range ( n + 1 ) ) : dp [ i ] [ arr [ i - 1 ] ] = True for j in range ( 1 , Sum + 1 ) : if ( dp [ i - 1 ] [ j ] == True ) : dp [ i ] [ j ] = True dp [ i ] [ j + arr [ i - 1 ] ] = True i += 1 for j in range ( Sum + 1 ) : if ( dp [ n ] [ j ] == True ) : print ( j , end = """" )"
"def findSubsequence ( arr , n ) : sign = [ 0 ] * n i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] > 0 ) : sign [ i ] = 1 else : sign [ i ] = - 1 i += 1 k = 0 result = [ 0 ] * n i = 0 while i < n : cur = arr [ i ] j = i while ( j < n and sign [ i ] == sign [ j ] ) : cur = max ( cur , arr [ j ] ) j += 1 result [ k ] = cur k += 1 i = j - 1 i += 1 for i in range ( k ) : print ( result [ i ] , end = """" )"
"def areAnagram ( str1 , str2 ) : n1 = len ( str1 ) n2 = len ( str2 ) if n1 != n2 : return 0 str1 = sorted ( str1 ) str2 = sorted ( str2 ) i = 0 while i in list ( range ( n1 ) ) : if str1 [ i ] != str2 [ i ] : i += 1 return 0 i += 1 return 1"
"def lps ( s ) : n = len ( s ) a = [ 0 ] * n i = n - 1 while i in list ( range ( - 1 ) ) : back_up = 0 for j in range ( i , n ) : if j == i : a [ j ] = 1 elif s [ i ] == s [ j ] : temp = a [ j ] a [ j ] = back_up + 2 back_up = temp else : back_up = a [ j ] a [ j ] = max ( a [ j - 1 ] , a [ j ] ) i += - 1 return a [ n - 1 ]"
def getPairs ( a ) : count = 0 i = 0 while i in list ( range ( len ( a ) ) ) : for j in range ( len ( a ) ) : if ( a [ i ] < a [ j ] ) : count += 1 i += 1 return count
"def isPossibleToMakeDivisible ( arr , n ) : remainder = 0 i = 0 while i in list ( range ( n ) ) : remainder = ( remainder + arr [ i ] ) % 3 i += 1 return ( remainder == 0 )"
"def maxOperations ( X , Y ) : if ( X > Y ) : return - 1 diff = Y - X if ( diff == 1 ) : return - 1 if ( 0 == diff % 2 ) : return ( diff // 2 ) return ( 1 + ( ( diff - 3 ) // 2 ) )"
"def find_numbers ( N ) : if ( N != 1 ) : print ( N , N + 1 , N * ( N + 1 ) ) else : print ( - 1 , end = """" )"
"def sortString ( str , n ) : new_str = """" for i in range ( ord ( 'a' ) , ord ( 'z' ) + 1 ) : j = 0 while j in list ( range ( n ) ) : if ( str [ j ] == chr ( i ) ) : new_str += str [ j ] j += 1 return new_str"
"def replaceRemove ( s , X , Y , Z ) : s = list ( s ) start = 0 end = len ( s ) - 1 while ( start <= end ) : if ( s [ start ] != Z ) : if ( s [ start ] == X ) : s [ start ] = Y start += 1 else : while ( end >= 0 and s [ end ] == Z ) : end -= 1 if ( end > start ) : s [ start ] , s [ end ] = s [ end ] , s [ start ] if ( s [ start ] == X ) : s [ start ] = Y start += 1 while ( len ( s ) > 0 and s [ len ( s ) - 1 ] == Z ) : s.pop ( ) return """".join ( s )"
"def isPossible ( arr , p , n , m ) : sum = 0 i = 0 while i in list ( range ( p ) ) : sum += arr [ i ] i += 1 if ( sum == ( n * m ) ) : return True return False"
"def countDistinct ( arr , n ) : s = set ( ) res = 0 i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] not in s ) : s.add ( arr [ i ] ) res += 1 i += 1 return res"
"def solve ( low , high , T ) : while low <= high : mid = int ( ( low + high ) / 2 ) if ( mid * ( mid + 1 ) ) == T : return mid if ( 0 < mid and ( mid * ( mid + 1 ) ) > T and ( mid * ( mid - 1 ) ) <= T ) : return mid - 1 if ( mid * ( mid + 1 ) ) > T : high = mid - 1 else : low = mid + 1 return - 1"
def check ( num ) : digitSum = 0 while ( 0 != num ) : digitSum = digitSum + num % 10 num = num // 10 temp = ( int ) ( digitSum ) reverseDigitSum = 0 while ( temp != 0 ) : rem = temp % 10 reverseDigitSum = reverseDigitSum * 10 + rem temp = temp / 10 number = digitSum * reverseDigitSum return number
"def areElementsContiguous ( arr , n ) : arr.sort ( ) i = 1 while i in list ( range ( n ) ) : if ( arr [ i ] - arr [ i - 1 ] > 1 ) : i += 1 return 0 i += 1 return 1"
def sum_of_series ( n ) : result = 0 if ( n % 2 != 0 ) : result = ( n * ( n + 1 ) ) // 2 else : result = - ( n * ( n + 1 ) ) // 2 return result
"def MinimumMoves ( a , n , x ) : ans = 0 i = 1 while i in list ( range ( n ) ) : if a [ i ] <= a [ i - 1 ] : p = ( a [ i - 1 ] - a [ i ] ) // x + 1 ans += p a [ i ] += p * x i += 1 return ans"
"def ellipse ( l , b ) : if 0 > l or b < 0 : return - 1 x = ( 3.14 * l * b ) / 4 return x"
"def solve ( n ) : low = 1 high = 10 ** 4 x , p = n , 0 while ( low <= high ) : mid = ( low + high ) // 2 sum = ( mid * ( mid + 1 ) ) // 2 if ( x - sum >= 1 ) : p = mid low = mid + 1 else : high = mid - 1 start , end , y , q = 1 , 10 ** 4 , 1 , 0 while ( start <= end ) : mid = ( start + end ) // 2 sum = ( mid * ( mid + 1 ) ) // 2 if ( y + sum > n ) : end = mid - 1 else : q = mid start = mid + 1 x = x - ( p * ( p + 1 ) ) // 2 y = y + ( q * ( q + 1 ) ) // 2 r = x c = q + 1 - n + y return r , c"
"def isIdentity ( mat , N ) : for row in range ( N ) : col = 0 while col in list ( range ( N ) ) : if ( row == col and mat [ row ] [ col ] != 1 ) : col += 1 return False elif ( row != col and mat [ row ] [ col ] != 0 ) : col += 1 return False col += 1 return True"
"def uniqueRows ( s , m , n ) : i , j , count = 0 , 0 , 0 for i in range ( n ) : j = 0 while j in list ( range ( i ) ) : if ( s [ i ] == s [ j ] ) : count += 1 j += 1 break j += 1 if ( count >= 1 ) : print ( ""No"" ) else : print ( ""Yes"" )"
"def find_value ( a , n , k ) : sum = 0 i = 0 while i in list ( range ( n ) ) : sum += a [ i ] i += 1 return sum % k"
"def maxProduct ( arr , n ) : minVal = arr [ 0 ] maxVal = arr [ 0 ] maxProduct = arr [ 0 ] i = 1 while i in list ( range ( n ) ) : if ( arr [ i ] < 0 ) : temp = maxVal maxVal = minVal minVal = temp maxVal = max ( arr [ i ] , maxVal * arr [ i ] ) minVal = min ( arr [ i ] , minVal * arr [ i ] ) maxProduct = max ( maxProduct , maxVal ) i += 1 return maxProduct"
"def constructTree ( n , d , h ) : if d == 1 : if n == 2 and h == 1 : print ( ""12"" ) return 0 print ( ""-1"" ) return 0 if d > 2 * h : print ( ""-1"" ) return 0 i = 1 while i in list ( range ( h + 1 ) ) : print ( i , """" , i + 1 ) i += 1 if d > h : print ( 1 , """" , h + 2 ) for i in range ( h + 2 , d + 1 ) : print ( i , """" , i + 1 ) for i in range ( d + 1 , n ) : k = 1 if d == h : k = 2 print ( k , """" , i + 1 )"
"def polygonArea ( X , Y , n ) : area = 0.0 j = n - 1 i = 0 while i in list ( range ( n ) ) : area = area + ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) j = i i += 1 return abs ( area // 2.0 )"
"def SplitAndAdd ( A , length , rotation ) : tmp = [ 0 for i in range ( length * 2 ) ] for i in range ( length ) : tmp [ i ] = A [ i ] tmp [ i + length ] = A [ i ] i = rotation while i in list ( range ( rotation + length ) ) : A [ i - rotation ] = tmp [ i ] i += 1"
def solution ( A ) : m = max ( A ) if m < 1 : return 1 if len ( A ) == 1 : return 2 if A [ 0 ] == 1 else 1 l = [ 0 ] * m for i in range ( len ( A ) ) : if A [ i ] > 0 : if l [ A [ i ] - 1 ] != 1 : l [ A [ i ] - 1 ] = 1 i = 0 while i in list ( range ( len ( l ) ) ) : if l [ i ] == 0 : i += 1 return i + 1 i += 1 return i + 2
"def perfectSquare ( s ) : n = len ( s ) ans = - 1 num = """" for i in range ( 1 , ( 1 << n ) ) : str = """" j = 0 while j in list ( range ( n ) ) : if ( ( i >> j ) & 1 ) : str = str + s [ j ] j += 1 if ( str [ 0 ] != '0' ) : temp = 0 for j in range ( 0 , len ( str ) ) : temp = ( temp * 10 + ( ord ( str [ j ] ) - ord ( '0' ) ) ) k = int ( math.sqrt ( temp ) ) if ( k * k == temp ) : if ( ans < len ( str ) ) : ans = len ( str ) num = str if ( ans == - 1 ) : return ans else : print ( ""{}"".format ( num ) , end = """" ) return n - ans"
"def subArrayExists ( arr , n ) : s = set ( ) sum = 0 i = 0 while i in list ( range ( n ) ) : sum += arr [ i ] if sum == 0 or sum in s : i += 1 return True s.add ( sum ) i += 1 return False"
"def getnumbers ( n ) : divisor = [ ] for i in range ( 2 , n + 1 ) : while ( n % i == 0 ) : divisor.append ( i ) n //= i if ( n != 1 ) : divisor.append ( n ) a , b , c , size = 0 , 0 , 0 , 0 a = b = c = 1 size = len ( divisor ) i = 0 while i in list ( range ( size ) ) : if ( a == 1 ) : a = a * divisor [ i ] elif ( b == 1 or b == a ) : b = b * divisor [ i ] else : c = c * divisor [ i ] i += 1 if ( a == 1 or b == 1 or c == 1 or a == b or b == c or a == c ) : print ( ""-1"" ) else : print ( a , b , c )"
"def Move ( a , x , b ) : if ( ( ( 0 == ( b - a ) % x ) or ( ( b - a - 1 ) % x == 0 ) and a + 1 != b ) and b >= a ) : return True return False"
"def isRectangle ( a , b , c , d ) : if a == b == c == d : return True elif a == b and d == c : return True elif a == d and c == b : return True elif a == c and d == b : return True return False"
"def bin ( n ) : if 1 < n : bin ( n // 2 ) print ( n % 2 , end = """" )"
"def pythagorean_quadruple ( a , b , c , d ) : sum = a * a + b * b + c * c if ( sum == d * d ) : return True else : return False"
"def check ( arr , n ) : k = - 10 ** 9 r = 10 ** 9 for i in range ( n ) : k = max ( k , arr [ i ] ) r = min ( r , arr [ i ] ) k += 1 for i in range ( n ) : arr [ i ] = k - arr [ i ] for i in range ( n ) : if ( abs ( arr [ i ] ) - 1 < n and arr [ abs ( arr [ i ] ) - 1 ] > 0 ) : arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] flag = 0 i = 0 while i in list ( range ( k - r ) ) : if ( arr [ i ] > 0 ) : flag = 1 i += 1 break i += 1 return flag == 0"
"def solve ( M , N , s ) : if ( 0 == N % s ) : N = N // s else : N = ( N // s ) + 1 if ( M % s == 0 ) : M = M // s else : M = ( M // s ) + 1 return M * N"
def removeConsecutiveSame ( v ) : st = [ ] i = 0 while i in list ( range ( len ( v ) ) ) : if ( len ( st ) == 0 ) : st.append ( v [ i ] ) else : Str = st [ - 1 ] if ( Str == v [ i ] ) : st.pop ( ) else : st.append ( v [ i ] ) i += 1 return len ( st )
"def totalOperations ( st , length ) : d = { } i = 0 while i in list ( range ( length ) ) : if st [ i ] in d : d [ st [ i ] ] += 1 else : d [ st [ i ] ] = 1 i += 1 valueSet = set ( ) for key in d.keys ( ) : valueSet.add ( d [ key ] ) return len ( valueSet )"
def rectanglearea ( r ) : if 0 > r : return - 1 a = r * r return a
"def findSum ( arr , n ) : s = set ( ) sum = 0 i = 0 while i in list ( range ( n ) ) : if arr [ i ] not in s : s.add ( arr [ i ] ) i += 1 for i in s : sum = sum + i return sum"
"def findNumberOfEvenCells ( n , q , size ) : row = [ 0 ] * n col = [ 0 ] * n i = 0 while i in list ( range ( size ) ) : x = q [ i ] [ 0 ] y = q [ i ] [ 1 ] row [ x - 1 ] += 1 col [ y - 1 ] += 1 i += 1 r1 = 0 r2 = 0 c1 = 0 c2 = 0 for i in range ( n ) : if ( row [ i ] % 2 == 0 ) : r1 += 1 if ( row [ i ] % 2 == 1 ) : r2 += 1 if ( col [ i ] % 2 == 0 ) : c1 += 1 if ( col [ i ] % 2 == 1 ) : c2 += 1 count = r1 * c1 + r2 * c2 return count"
def divSum ( num ) : result = 0 i = 2 while i <= ( math.sqrt ( num ) ) : if ( 0 == num % i ) : if ( i == ( num / i ) ) : result = result + i else : result = result + ( i + num / i ) i = i + 1 return ( result + 1 )
"def nCrModp ( n , r , p ) : C = [ 0 for i in range ( r + 1 ) ] C [ 0 ] = 1 i = 1 while i in list ( range ( n + 1 ) ) : for j in range ( min ( i , r ) , 0 , - 1 ) : C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p i += 1 return C [ r ]"
"def seiresSum ( n , a ) : res = 0 i = 0 while i in list ( range ( 2 * n ) ) : if ( i % 2 == 0 ) : res += a [ i ] * a [ i ] else : res -= a [ i ] * a [ i ] i += 1 return res"
def patternCount ( str ) : last = str [ 0 ] i = 1 counter = 0 while ( i < len ( str ) ) : if ( str [ i ] == '0' and last == '1' ) : while ( str [ i ] == '0' ) : i += 1 if ( '1' == str [ i ] ) : counter += 1 last = str [ i ] i += 1 return counter
def findNthTerm ( N ) : ans = 0 if ( N % 2 != 0 ) : ans = ( N // 2 + 1 ) * 6 + ( N // 2 ) * 2 else : ans = ( N // 2 ) * 6 + ( N // 2 ) * 2 print ( ans )
"def printPattern ( s , n ) : print ( ''.join ( s ) ) i , j = 0 , n - 1 while j > i : s [ i ] , s [ j ] = s [ j ] , s [ i ] i += 1 j -= 1 i , j = 0 , n - 1 while j - i > 1 : s [ i ] , s [ j ] = '*' , '*' print ( ''.join ( s ) ) i += 1 j -= 1"
"def findPosition ( k , n ) : f1 = 0 f2 = 1 i = 2 while i != 0 : f3 = f1 + f2 f1 = f2 f2 = f3 if 0 == f2 % k : return n * i i += 1 return"
"def bin ( n ) : if ( 1 < n ) : bin ( n >> 1 ) print ( n & 1 , end = """" )"
def sum ( n ) : i = 1 s = 0.0 i = 1 while i in list ( range ( n + 1 ) ) : s = s + 1 / i i += 1 return s
def factorial ( n ) : i = n fact = 1 while ( n != n / i ) : fact = fact * i i -= 1 return fact
"def smallestSubWithSum ( arr , n , x ) : curr_sum = 0 min_len = n + 1 start = 0 end = 0 while ( end < n ) : while ( curr_sum <= x and end < n ) : curr_sum += arr [ end ] end += 1 while ( x < curr_sum and start < n ) : if ( end - start < min_len ) : min_len = end - start curr_sum -= arr [ start ] start += 1 return min_len"
"def substrDeletion ( string , length ) : count0 = 0 count1 = 0 i = 0 while i in list ( range ( length ) ) : if ( string [ i ] == '0' ) : count0 += 1 else : count1 += 1 i += 1 return min ( count0 , count1 )"
def solve ( nums ) : while 1 < len ( nums ) : nums = [ nums [ i ] + nums [ i + 1 ] for i in range ( len ( nums ) - 1 ) ] return nums [ 0 ] % 10
"def check ( n , x , y ) : fact = 1 i = 2 while i in list ( range ( n + 1 ) ) : fact *= i i += 1 divisor = x ** y if ( fact % divisor == 0 ) : print ( ""YES"" ) else : print ( ""NO"" )"
"def findIndices ( arr , n ) : leftMin , rightMin = 0 , 0 leftMax , rightMax = 0 , 0 min_element = arr [ 0 ] max_element = arr [ 0 ] i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] < min_element ) : leftMin = rightMin = i min_element = arr [ i ] elif ( arr [ i ] == min_element ) : rightMin = i if ( arr [ i ] > max_element ) : leftMax = rightMax = i max_element = arr [ i ] elif ( arr [ i ] == max_element ) : rightMax = i i += 1 print ( ""Minimumleft:"" , leftMin ) print ( ""Minimumright:"" , rightMin ) print ( ""Maximumleft:"" , leftMax ) print ( ""Maximumright:"" , rightMax )"
"def sortMultiples ( arr , n , x ) : v = [ ] i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] % x == 0 ) : v.append ( arr [ i ] ) i += 1 v.sort ( reverse = False ) j = 0 for i in range ( 0 , n , 1 ) : if ( arr [ i ] % x == 0 ) : arr [ i ] = v [ j ] j += 1"
"def getNumber ( n , k ) : if ( n % 2 != 0 ) : pos = ( n // 2 ) + 1 else : pos = n // 2 if ( k <= pos ) : return ( k * 2 - 1 ) else : return ( ( k - pos ) * 2 )"
"def countUnique ( mat , n , m ) : rowsum = [ 0 ] * n colsum = [ 0 ] * m for i in range ( n ) : for j in range ( m ) : if ( mat [ i ] [ j ] != 0 ) : rowsum [ i ] += 1 colsum [ j ] += 1 uniquecount = 0 for i in range ( n ) : j = 0 while j in list ( range ( m ) ) : if ( mat [ i ] [ j ] != 0 and rowsum [ i ] == 1 and colsum [ j ] == 1 ) : uniquecount += 1 j += 1 return uniquecount"
"def productDiagonals ( arr , n ) : product = 1 i = 0 while i in list ( range ( n ) ) : product = product * arr [ i ] [ i ] product = product * arr [ i ] [ n - i - 1 ] i += 1 if ( n % 2 == 1 ) : product = product // arr [ n // 2 ] [ n // 2 ] return product"
def maxProd ( n ) : if ( n == 2 or 3 == n ) : return ( n - 1 ) res = 1 while ( n > 4 ) : n -= 3 res *= 3 return ( n * res )
def findNthTerm ( n ) : if n % 2 != 0 : n = ( n // 2 ) + 1 print ( 2 ** ( n - 1 ) ) else : n //= 2 print ( 3 ** ( n - 1 ) )
"def minOperations ( arr , n ) : result = 0 freq = [ 0 ] * 1000001 for i in range ( 0 , n ) : freq [ arr [ i ] ] += 1 maxi = max ( arr ) for i in range ( 1 , maxi + 1 ) : if freq [ i ] != 0 : j = i * 2 while j in list ( range ( maxi + 1 ) ) : freq [ j ] = 0 j += i result += 1 return result"
"def middlesum ( mat , n ) : row_sum = 0 col_sum = 0 i = 0 while i in list ( range ( n ) ) : row_sum += mat [ n // 2 ] [ i ] i += 1 print ( ""Sumofmiddlerow="" , row_sum ) for i in range ( n ) : col_sum += mat [ i ] [ n // 2 ] print ( ""Sumofmiddlecolumn="" , col_sum )"
"def properDivisorSum ( n ) : sum = 0 i = 0 while i in list ( range ( n + 1 ) ) : for j in range ( 1 , i + 1 ) : if j * j > i : i += 1 break if ( i % j == 0 ) : if ( i // j == j ) : sum += j else : sum += j + i // j sum = sum - i i += 1 return sum"
"def sumOfElements ( arr , n ) : m = dict.fromkeys ( arr , 0 ) i = 0 while i in list ( range ( n ) ) : m [ arr [ i ] ] += 1 i += 1 sum = 0 for key , value in m.items ( ) : if value >= key : sum += key return sum"
"def countElements ( p , n ) : ans = 0 i = 1 while i in list ( range ( n - 1 ) ) : if ( p [ i - 1 ] > p [ i ] and p [ i ] > p [ i + 1 ] ) : ans += 1 elif ( p [ i - 1 ] < p [ i ] and p [ i ] < p [ i + 1 ] ) : ans += 1 i += 1 return ans"
"def sortWithSetbits ( arr , n , k ) : v1 = [ ] v2 = [ ] for i in range ( 0 , n , 1 ) : if ( bin ( arr [ i ] ).count ( '1' ) == k ) : v1.append ( i ) v2.append ( arr [ i ] ) v2.sort ( reverse = False ) for i in range ( 0 , len ( v1 ) , 1 ) : arr [ v1 [ i ] ] = v2 [ i ] i = 0 while i in list ( range ( n ) ) : print ( arr [ i ] , end = """" ) i += 1"
"def findMax ( arr , n ) : divisible = [ False ] * n res = 0 for i in range ( n - 1 , - 1 , - 1 ) : if ( divisible [ i ] ) : continue cnt = 0 j = 0 while j in list ( range ( i ) ) : if ( ( arr [ j ] % arr [ i ] ) == 0 ) : divisible [ j ] = True cnt += 1 j += 1 res = max ( res , cnt ) return res"
"def countSubStr ( st , n ) : res = 0 for i in range ( 0 , n ) : if ( st [ i ] == '1' ) : j = i + 1 while j in list ( range ( n ) ) : if ( st [ j ] == '1' ) : res = res + 1 j += 1 return res"
"def CountCharacters ( str , k ) : cnt = 0 l = len ( str ) i = 0 while i in list ( range ( l ) ) : if ( ord ( str [ i ] ) < k ) : cnt += 1 i += 1 return cnt"
"def printArray ( A , n , K ) : minEle = 10 ** 9 maxEle = - 10 ** 9 for i in range ( n ) : minEle = min ( minEle , A [ i ] ) maxEle = max ( maxEle , A [ i ] ) if ( K != 0 ) : if ( K % 2 == 1 ) : i = 0 while i in list ( range ( n ) ) : A [ i ] = maxEle - A [ i ] i += 1 else : for i in range ( n ) : A [ i ] = A [ i ] - minEle for i in A : print ( i , end = """" )"
def FirstRepeated ( string ) : checker = 0 pos = 0 for i in string : val = ord ( i ) - ord ( 'a' ) if ( 0 < ( checker & ( 1 << val ) ) ) : return pos checker |= ( 1 << val ) pos += 1 return - 1
"def countNegative ( M , n , m ) : count = 0 i = 0 while i in list ( range ( n ) ) : for j in range ( m ) : if M [ i ] [ j ] < 0 : count += 1 else : i += 1 break i += 1 return count"
"def getClosest ( a , b , x ) : num = pow ( a , b ) floor = num // x numOnLeft = x * floor numOnRight = x * ( floor + 1 ) if ( ( numOnRight - num ) > ( num - numOnLeft ) ) : return numOnLeft else : return numOnRight"
"def middleOfThree ( a , b , c ) : if a <= b : if ( a > c ) : return a elif ( b > c ) : return c else : return b else : if ( b > c ) : return b elif ( a > c ) : return c else : return a"
def checkSentence ( string ) : length = len ( string ) if string [ 0 ] < 'A' or string [ 0 ] > 'Z' : return False if string [ length - 1 ] != '.' : return False prev_state = 0 curr_state = 0 index = 1 while ( string [ index ] ) : if string [ index ] >= 'A' and string [ index ] <= 'Z' : curr_state = 0 elif string [ index ] == '' : curr_state = 1 elif string [ index ] >= 'a' and string [ index ] <= 'z' : curr_state = 2 elif string [ index ] == '.' : curr_state = 3 if prev_state == curr_state and curr_state != 2 : return False if prev_state == 2 and curr_state == 0 : return False if 3 == curr_state and prev_state != 1 : return True index += 1 prev_state = curr_state return False
"def printFibonacciNumbers ( n ) : f1 = 0 f2 = 1 if ( n < 1 ) : return x = 0 while x in list ( range ( n ) ) : print ( f2 , end = """" ) next = f1 + f2 f1 = f2 f2 = next x += 1"
"def countIndices ( arr , n ) : cnt = 0 max = 0 i = 0 while i in list ( range ( n ) ) : if ( max < arr [ i ] ) : max = arr [ i ] cnt += 1 i += 1 return cnt"
def nextPowerOf2 ( n ) : count = 0 if ( n and not ( n & ( n - 1 ) ) ) : return n while ( n != 0 ) : n >>= 1 count = count + 1 return 1 << count
def squareSide ( a ) : if ( 0 > a ) : return - 1 x = 0.423 * a return x
"def maxNumOfChocolates ( arr , n , k ) : um , curr_rem , maxSum = { } , 0 , 0 sm = [ 0 ] * n sm [ 0 ] = arr [ 0 ] for i in range ( 1 , n ) : sm [ i ] = sm [ i - 1 ] + arr [ i ] i = 0 while i in list ( range ( n ) ) : curr_rem = sm [ i ] % k if ( not curr_rem and maxSum < sm [ i ] ) : maxSum = sm [ i ] elif ( not curr_rem in um ) : um [ curr_rem ] = i elif ( maxSum < ( sm [ i ] - sm [ um [ curr_rem ] ] ) ) : maxSum = sm [ i ] - sm [ um [ curr_rem ] ] i += 1 return maxSum // k"
"def getOddOccurrence ( arr , size ) : Hash = dict ( ) i = 0 while i in list ( range ( size ) ) : Hash [ arr [ i ] ] = Hash.get ( arr [ i ] , 0 ) + 1 i += 1 for i in Hash : if ( Hash [ i ] % 2 != 0 ) : return i return - 1"
"def printTwoElements ( arr , size ) : i = 0 while i in list ( range ( size ) ) : if arr [ abs ( arr [ i ] ) - 1 ] > 0 : arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] else : print ( ""Therepeatingelementis"" , abs ( arr [ i ] ) ) i += 1 for i in range ( size ) : if arr [ i ] > 0 : print ( ""andthemissingelementis"" , i + 1 )"
def isDivisibleBy25 ( st ) : n = len ( st ) if ( n == 1 ) : return False return ( ( int ) ( st [ n - 1 ] ) == 0 and ( 0 == ( int ) ( st [ n - 2 ] ) ) or ( ( int ) ( st [ n - 2 ] ) * 10 + ( int ) ( st [ n - 1 ] ) % 25 == 0 ) )
"def isInorder ( arr , n ) : if ( n == 0 or n == 1 ) : return True i = 1 while i in list ( range ( n ) ) : if ( arr [ i - 1 ] > arr [ i ] ) : i += 1 return False i += 1 return True"
"def MaximumHeight ( a , n ) : result = 1 i = 1 while i in list ( range ( n ) ) : y = ( i * ( i + 1 ) ) / 2 if ( y < n ) : result = i else : i += 1 break i += 1 return result"
"def maxRectangles ( L , B , l , b ) : horizontal , vertical = 0 , 0 if l <= L and b <= B : columns = B // b rows = L // l horizontal = rows * columns if B >= l and b <= L : columns = L // b rows = B // l vertical = rows * columns return max ( horizontal , vertical )"
"def printFactorialNums ( n ) : fact = 1 x = 2 while n >= fact : print ( fact , end = """" ) fact = fact * x x += 1"
def sum ( n ) : root = ( int ) ( math.sqrt ( n ) ) ans = 0 i = 1 while i in list ( range ( root + 1 ) ) : ans = ans + n // i i += 1 ans = 2 * ans - ( root * root ) return ans
"def findMaxSegment ( s , k ) : seg_len = len ( s ) - k res = 0 for i in range ( seg_len ) : res = res * 10 + ( ord ( s [ i ] ) - ord ( '0' ) ) seg_len_pow = pow ( 10 , seg_len - 1 ) curr_val = res i = 1 while i in list ( range ( len ( s ) - seg_len ) ) : curr_val = curr_val - ( ord ( s [ i - 1 ] ) - ord ( '0' ) ) * seg_len_pow curr_val = ( curr_val * 10 + ( ord ( s [ i + seg_len - 1 ] ) - ord ( '0' ) ) ) res = max ( res , curr_val ) i += 1 return res"
def isDivisible ( n ) : while n // 100 : d = n % 10 n //= 10 n = n + d * 7 return ( 0 == n % 23 )
"def findPair ( arr , n ) : found = False for i in range ( 0 , n ) : for j in range ( i + 1 , n ) : k = 0 while k in list ( range ( n ) ) : if ( arr [ i ] + arr [ j ] == arr [ k ] ) : print ( arr [ i ] , arr [ j ] ) found = True k += 1 if ( found == False ) : print ( ""Notexist"" )"
"def findMinEqualSums ( a , N ) : sum = 0 i = 0 while i in list ( range ( N ) ) : sum = sum + a [ i ] i += 1 sum1 = 0 sum2 = 0 min = sys.maxsize for i in range ( 0 , N - 1 ) : sum1 += a [ i ] sum2 = sum - sum1 if ( abs ( sum1 - sum2 ) < min ) : min = abs ( sum1 - sum2 ) if ( min == 0 ) : break return min"
"def maximumSegments ( n , a , b , c ) : dp = [ - 1 ] * ( n + 10 ) dp [ 0 ] = 0 i = 0 while i in list ( range ( n ) ) : if ( dp [ i ] != - 1 ) : if ( i + a <= n ) : dp [ i + a ] = max ( dp [ i ] + 1 , dp [ i + a ] ) if ( i + b <= n ) : dp [ i + b ] = max ( dp [ i ] + 1 , dp [ i + b ] ) if ( i + c <= n ) : dp [ i + c ] = max ( dp [ i ] + 1 , dp [ i + c ] ) i += 1 return dp [ n ]"
"def findX ( n , k ) : r = n m = int ( math.sqrt ( k ) ) + 1 i = 2 while i <= m and k > 1 : if ( i == m ) : i = k u = 0 v = 0 while k % i == 0 : k //= i v = v + 1 if ( v > 0 ) : t = n while ( t > 0 ) : t //= i u = u + t r = min ( r , u // v ) i = i + 1 return r"
"def longestAlternatingSubarray ( a , n ) : longest = 1 cnt = 1 i = 1 while n > i : if ( a [ i ] * a [ i - 1 ] < 0 ) : cnt = cnt + 1 longest = max ( longest , cnt ) else : cnt = 1 i = i + 1 return longest"
def remainder ( st ) : ln = len ( st ) rem = 0 i = 0 while i in list ( range ( ln ) ) : num = rem * 10 + ( int ) ( st [ i ] ) rem = num % 11 i += 1 return rem
"def productArray ( arr , n ) : if n == 1 : print ( 0 ) return i , temp = 1 , 1 prod = [ 1 for i in range ( n ) ] i = 0 while i in list ( range ( n ) ) : prod [ i ] = temp temp *= arr [ i ] i += 1 temp = 1 for i in range ( n - 1 , - 1 , - 1 ) : prod [ i ] *= temp temp *= arr [ i ] for i in range ( n ) : print ( prod [ i ] , end = """" ) return"
"def FirstDigit ( arr , n ) : S = 0 i = 0 while i in list ( range ( n ) ) : S = S + math.log10 ( arr [ i ] * 1.0 ) i += 1 fract_S = S - math.floor ( S ) ans = math.pow ( 10 , fract_S ) return ans"
"def reduceString ( s , l ) : count = 1 steps = 0 i = 1 while i in list ( range ( l ) ) : if ( s [ i ] is s [ i - 1 ] ) : count += 1 else : steps += ( int ) ( count / 2 ) count = 1 steps += ( int ) ( count / 2 ) i += 1 return steps"
"def count ( str1 , str2 ) : c = 0 ; j = 0 i = 0 while i in list ( range ( len ( str1 ) ) ) : if str1 [ i ] in str2 : c += 1 j += 1 i += 1 print ( ""No.ofmatchingcharactersare:"" , c )"
"def ReplaceElements ( arr , n ) : if ( n <= 1 ) : return prev = arr [ 0 ] arr [ 0 ] = arr [ 0 ] + arr [ 1 ] i = 1 while i in list ( range ( n - 1 ) ) : curr = arr [ i ] arr [ i ] = prev + arr [ i + 1 ] prev = curr i += 1 arr [ n - 1 ] = prev + arr [ n - 1 ]"
"def isRatioPossible ( lowCost , upCost , lowQuant , upQuant , r ) : i = lowQuant while i in list ( range ( upQuant + 1 ) ) : ans = i * r if ( lowCost <= ans and ans <= upCost ) : i += 1 return True i += 1 return False"
"def findSum ( N , K ) : ans = 0 i = 1 while i in list ( range ( N + 1 ) ) : ans += ( i % K ) i += 1 return ans"
"def findNumberOfTimes ( str1 , str2 ) : freq = [ 0 ] * 26 l1 = len ( str1 ) for i in range ( l1 ) : freq [ ord ( str1 [ i ] ) - ord ( ""a"" ) ] += 1 l2 = len ( str2 ) count = sys.maxsize i = 0 while i in list ( range ( l2 ) ) : count = min ( count , freq [ ord ( str2 [ i ] ) - ord ( 'a' ) ] ) i += 1 return count"
def countSubstringWithEqualEnds ( s ) : result = 0 n = len ( s ) for i in range ( n ) : j = i while j in list ( range ( n ) ) : if ( s [ i ] == s [ j ] ) : result = result + 1 j += 1 return result
def findTwoscomplement ( str ) : n = len ( str ) i = n - 1 while ( i >= 0 ) : if ( '1' == str [ i ] ) : break i -= 1 if ( i == - 1 ) : return '1' + str k = i - 1 while ( k >= 0 ) : if ( str [ k ] == '1' ) : str = list ( str ) str [ k ] = '0' str = ''.join ( str ) else : str = list ( str ) str [ k ] = '1' str = ''.join ( str ) k -= 1 return str
"def harmonicMean ( arr , freq , n ) : sm = 0 frequency_sum = 0 i = 0 while i in list ( range ( n ) ) : sm = sm + freq [ i ] / arr [ i ] frequency_sum = frequency_sum + freq [ i ] i += 1 return ( round ( frequency_sum / sm , 4 ) )"
"def getInvCount ( arr , n ) : invcount = 0 for i in range ( 1 , n - 1 ) : small = 0 for j in range ( i + 1 , n ) : if ( arr [ i ] > arr [ j ] ) : small += 1 great = 0 j = i - 1 while j in list ( range ( - 1 ) ) : if ( arr [ i ] < arr [ j ] ) : great += 1 j += - 1 invcount += great * small return invcount"
def phi ( n ) : result = n p = 2 while ( p * p <= n ) : if ( n % p == 0 ) : while ( 0 == n % p ) : n = n // p result = result * ( 1.0 - ( 1.0 / ( float ) ( p ) ) ) p = p + 1 if ( n > 1 ) : result = result * ( 1.0 - ( 1.0 / ( float ) ( n ) ) ) return ( int ) ( result )
def divSum ( n ) : result = 0 i = 2 while i in list ( range ( ( int ) ( math.sqrt ( n ) ) + 1 ) ) : if ( n % i == 0 ) : if ( i == ( n / i ) ) : result = result + i else : result = result + ( i + n // i ) i += 1 return ( result + n + 1 )
"def find_sum ( n , k ) : total_sum = ( n * ( n + 1 ) ) // 2 power = k while n >= power : total_sum -= power power *= k return total_sum"
def nswp ( n ) : if 0 == n or n == 1 : return 1 return 2 * nswp ( n - 1 ) + nswp ( n - 2 )
def squareRoot ( n ) : x = n y = 1 e = 0.000001 while ( e < x - y ) : x = ( x + y ) / 2 y = n / x return x
"def minInt ( str1 ) : i = 0 while i in list ( range ( len ( str1 ) ) ) : if ( str1 [ i ] >= 5 ) : str1 [ i ] = ( 9 - str1 [ i ] ) i += 1 if ( str1 [ 0 ] == 0 ) : str1 [ 0 ] = 9 temp = """" for i in str1 : temp += str ( i ) return temp"
"def ksmallest ( arr , n , k ) : arr.sort ( ) if ( k < arr [ 0 ] ) : return k if ( k == arr [ 0 ] ) : return arr [ 0 ] + 1 if ( k > arr [ n - 1 ] ) : return k + n if ( arr [ 0 ] == 1 ) : k -= 1 else : k -= ( arr [ 0 ] - 1 ) i = 1 while i in list ( range ( n ) ) : c = arr [ i ] - arr [ i - 1 ] - 1 if ( k <= c ) : i += 1 return arr [ i - 1 ] + k else : k -= c i += 1 return arr [ n - 1 ] + k"
def isFactorial ( n ) : i = 1 while ( True ) : if ( n % i != 0 ) : break else : n //= i i += 1 if ( n == 1 ) : return True else : return False
def aliquotSum ( n ) : sm = 0 i = 1 while i in list ( range ( n ) ) : if ( n % i == 0 ) : sm = sm + i i += 1 return sm
"def minimumRemoval ( n , a ) : c = dict.fromkeys ( a , 0 ) for i in range ( n ) : c [ a [ i ] ] += 1 ans = 0 for i in range ( n ) : ok = False j = 0 while j in list ( range ( 31 ) ) : x = ( 1 << j ) - a [ i ] if ( x in c and ( c [ x ] > 1 or ( c [ x ] == 1 and x != a [ i ] ) ) ) : ok = True j += 1 break j += 1 if ( not ok ) : ans += 1 return ans"
def to_upper ( string ) : i = 0 while i in list ( range ( len ( string ) ) ) : if ( 'a' <= string [ i ] <= 'z' ) : string = ( string [ 0 : i ] + chr ( ord ( string [ i ] ) - ord ( 'a' ) + ord ( 'A' ) ) + string [ i + 1 : ] ) i += 1 return string
def findMinSum ( num ) : sum = 0 i = 2 while ( i * i <= num ) : while ( num % i == 0 ) : sum = sum + i num /= i i = i + 1 sum = sum + num return sum
"def deleteElement ( A , L , R , N ) : j = 0 i = 0 while i in list ( range ( N ) ) : if i <= L or i >= R : A [ j ] = A [ i ] j += 1 i += 1 return j"
"def printCubes ( a , b ) : for i in range ( a , b + 1 ) : j = 1 j = j ** 3 while j in list ( range ( i + 1 ) ) : if ( j ** 3 == i ) : print ( j ** 3 , end = """" ) j += 1 break j += 1"
"def minCost ( graph , n ) : cost1 , cost2 = 0 , 0 start = [ False ] * ( n + 1 ) end = [ False ] * ( n + 1 ) i = 0 while i in list ( range ( n ) ) : a = graph [ i ] [ 0 ] b = graph [ i ] [ 1 ] c = graph [ i ] [ 2 ] if ( start [ a ] or end [ b ] ) : cost2 += c start [ b ] = True end [ a ] = True else : cost1 += c start [ a ] = True end [ b ] = True i += 1 return min ( cost1 , cost2 )"
"def reverse ( string ) : if 0 == len ( string ) : return temp = string [ 0 ] reverse ( string [ 1 : ] ) print ( temp , end = '' )"
"def isPowerOfK ( n , k ) : oneSeen = False while ( 0 < n ) : digit = n % k if ( digit > 1 ) : return False if ( digit == 1 ) : if ( oneSeen ) : return False oneSeen = True n //= k return True"
"def solve ( dp , a , low , high , turn ) : if ( high == low ) : return a [ low ] * turn if ( dp [ low ] [ high ] != 0 ) : return dp [ low ] [ high ] dp [ low ] [ high ] = max ( a [ low ] * turn + solve ( dp , a , low + 1 , high , turn + 1 ) , a [ high ] * turn + solve ( dp , a , low , high - 1 , turn + 1 ) ) return dp [ low ] [ high ]"
"def maxOverlap ( start , end ) : n = len ( start ) maxa = max ( start ) maxb = max ( end ) maxc = max ( maxa , maxb ) x = ( maxc + 2 ) * [ 0 ] cur = 0 idx = 0 for i in range ( 0 , n ) : x [ start [ i ] ] += 1 x [ end [ i ] + 1 ] -= 1 maxy = - 1 for i in range ( 0 , maxc + 1 ) : cur = cur + x [ i ] if maxy < cur : maxy = cur idx = i print ( """".format ( maxy ) , """".format ( idx ) )"
"def minTime ( arr , n ) : if ( n <= 0 ) : return 0 incl = arr [ 0 ] excl = 0 i = 1 while i in list ( range ( n ) ) : incl_new = arr [ i ] + min ( excl , incl ) excl_new = incl incl = incl_new excl = excl_new i += 1 return min ( incl , excl )"
"def findFirstMissing ( array , start , end ) : if ( start > end ) : return end + 1 if ( start != array [ start ] ) : return start mid = int ( ( start + end ) / 2 ) if ( mid == array [ mid ] ) : return findFirstMissing ( array , mid + 1 , end ) return findFirstMissing ( array , start , mid )"
"def findLCM ( a , b ) : lar = max ( a , b ) small = min ( a , b ) i = lar while ( 1 ) : if ( 0 == i % small ) : return i i += lar"
"def countgroup ( a , n ) : xs = 0 i = 0 while i in list ( range ( n ) ) : xs = xs ^ a [ i ] i += 1 if xs == 0 : return ( 1 << ( n - 1 ) ) - 1 return 0"
"def findMaxDiff ( arr , n ) : if ( n < 2 ) : print ( ""Invalid"" ) return 0 res = - 2147483648 for i in range ( n ) : j = 0 while j in list ( range ( n ) ) : if ( res < ( arr [ i ] - arr [ j ] - i + j ) ) : res = ( arr [ i ] - arr [ j ] - i + j ) j += 1 return res"
"def knowPair ( a , b , n , s , m ) : i = 0 rem = 0 count_b = 0 flag = 0 while ( i <= a ) : rem = s - ( n * i ) count_b = rem // m if ( rem % m == 0 and count_b <= b ) : flag = 1 i += 1 if ( flag != 1 ) : print ( ""NO"" ) else : print ( ""YES"" )"
"def eggDrop ( n , k ) : if ( k == 1 or k == 0 ) : return k if ( n == 1 ) : return k min = sys.maxsize x = 1 while x in list ( range ( k + 1 ) ) : res = max ( eggDrop ( n - 1 , x - 1 ) , eggDrop ( n , k - x ) ) if ( res < min ) : min = res x += 1 return min + 1"
"def findMaximumNum ( st , n , k ) : i = 0 while i in list ( range ( n ) ) : if ( k < 1 ) : i += 1 break if ( st [ i ] != '9' ) : st = st [ 0 : i ] + '9' + st [ i + 1 : ] k -= 1 i += 1 return st"
"def minTime ( arr , n , m ) : t = 0 while ( 1 ) : items = 0 i = 0 while i in list ( range ( n ) ) : items += ( t // arr [ i ] ) i += 1 if ( items >= m ) : return t t += 1"
"def HalfDiagonalSums ( mat , n ) : diag1_left = 0 diag1_right = 0 diag2_left = 0 diag2_right = 0 i = 0 j = n - 1 while n > i : if ( i < n // 2 ) : diag1_left += mat [ i ] [ i ] diag2_left += mat [ j ] [ i ] elif ( i > n // 2 ) : diag1_right += mat [ i ] [ i ] diag2_right += mat [ j ] [ i ] i += 1 j -= 1 return ( diag1_left == diag2_right and diag2_right == diag2_left and diag1_right == diag2_left and diag2_right == mat [ n // 2 ] [ n // 2 ] )"
"def maxSumPairWithDifferenceLessThanK ( arr , N , K ) : arr.sort ( ) dp = [ 0 ] * N dp [ 0 ] = 0 i = 1 while i in list ( range ( N ) ) : dp [ i ] = dp [ i - 1 ] if ( arr [ i ] - arr [ i - 1 ] < K ) : if ( i >= 2 ) : dp [ i ] = max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) else : dp [ i ] = max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) i += 1 return dp [ N - 1 ]"
"def printNumbers ( N ) : flag = 1 x = N if ( N > 0 ) : while ( x > 0 and flag == 1 ) : digit = x % 10 if ( digit != 1 and digit != 3 ) : flag = 0 x = x // 10 if ( 1 == flag ) : print ( N , end = """" ) printNumbers ( N - 1 )"
"def countOccurrences ( s , K ) : n = len ( s ) c1 = 0 c2 = 0 C = 0 for i in range ( n ) : if s [ i ] == '' : c1 = c1 + 1 if s [ i ] == '' : c2 = c2 + 1 C = C + c1 return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2"
"def countSubarrays ( a , n , x ) : count = 0 number = 0 i = 0 while i in list ( range ( n ) ) : if ( a [ i ] > x ) : count += 1 else : number += ( count ) * ( count + 1 ) / 2 count = 0 i += 1 if ( count ) : number += ( count ) * ( count + 1 ) / 2 return int ( number )"
"def sort012 ( a , arr_size ) : lo = 0 hi = arr_size - 1 mid = 0 while mid <= hi : if a [ mid ] == 0 : a [ lo ] , a [ mid ] = a [ mid ] , a [ lo ] lo = lo + 1 mid = mid + 1 elif 1 == a [ mid ] : mid = mid + 1 else : a [ mid ] , a [ hi ] = a [ hi ] , a [ mid ] hi = hi - 1"
def catalan ( n ) : if n <= 1 : return 1 res = 0 i = 0 while i in list ( range ( n ) ) : res += catalan ( i ) * catalan ( n - i - 1 ) i += 1 return res
"def longest ( a , n , k ) : freq = [ 0 ] * n start = 0 end = 0 now = 0 l = 0 for i in range ( n ) : freq [ a [ i ] ] += 1 if ( freq [ a [ i ] ] == 1 ) : now += 1 while ( now > k ) : freq [ a [ l ] ] -= 1 if ( freq [ a [ l ] ] == 0 ) : now -= 1 l += 1 if ( i - l + 1 >= end - start + 1 ) : end = i start = l i = start while i in list ( range ( end + 1 ) ) : print ( a [ i ] , end = """" ) i += 1"
"def K_multiple ( a , n , k ) : a.sort ( ) s = set ( ) i = 0 while i in list ( range ( n ) ) : if ( ( a [ i ] % k == 0 and a [ i ] // k not in s ) or a [ i ] % k != 0 ) : s.add ( a [ i ] ) i += 1 for i in s : print ( i , end = """" )"
def countConsecutive ( n ) : s = str ( n ) count = 0 i = 0 while i in list ( range ( len ( s ) - 1 ) ) : if ( s [ i ] == s [ i + 1 ] ) : count += 1 i += 1 return count
"def printInitials ( string : str ) : length = len ( string ) string.strip ( ) t = """" i = 0 while i in list ( range ( length ) ) : ch = string [ i ] if ch != '' : t += ch else : print ( t [ 0 ].upper ( ) + ""."" , end = """" ) t = """" i += 1 temp = """" for j in range ( len ( t ) ) : if j == 0 : temp += t [ 0 ].upper ( ) else : temp += t [ j ].lower ( ) print ( temp )"
"def xorPairCount ( arr , n , x ) : result = 0 m = dict ( ) i = 0 while i in list ( range ( n ) ) : curr_xor = x ^ arr [ i ] if ( curr_xor in m.keys ( ) ) : result += m [ curr_xor ] if arr [ i ] in m.keys ( ) : m [ arr [ i ] ] += 1 else : m [ arr [ i ] ] = 1 i += 1 return result"
"def findMaxFrequency ( s ) : arr = [ 0 ] * 26 for i in range ( len ( s ) ) : arr [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1 hash = { } i = 0 while i in list ( range ( 26 ) ) : if ( arr [ i ] != 0 ) : if arr [ i ] not in hash : hash [ arr [ i ] ] = 0 hash [ arr [ i ] ] += 1 i += 1 max_count = 0 res = - 1 for i in hash : if ( max_count < hash [ i ] ) : res = i max_count = hash [ i ] print ( ""Frequency"" , res , ""isrepeated"" , max_count , ""times"" )"
"def minToggle ( arr , n ) : zero = [ 0 for i in range ( n + 1 + 1 ) ] zero [ 0 ] = 0 i = 1 while i in list ( range ( n + 1 ) ) : if ( arr [ i - 1 ] == 0 ) : zero [ i ] = zero [ i - 1 ] + 1 else : zero [ i ] = zero [ i - 1 ] i += 1 ans = n for i in range ( 1 , n + 1 ) : ans = min ( ans , i - zero [ i ] + zero [ n ] - zero [ i ] ) return ans"
def reachTarget ( target ) : target = abs ( target ) sum = 0 step = 0 while ( sum < target or 0 != ( sum - target ) % 2 ) : step = step + 1 sum = sum + step return step
"def maxDiff ( arr , n ) : result = 0 arr.sort ( ) i = 0 while i in list ( range ( n - 1 ) ) : if ( abs ( arr [ i ] ) != abs ( arr [ i + 1 ] ) ) : result += abs ( arr [ i ] ) else : pass i += 1 if ( arr [ n - 2 ] != arr [ n - 1 ] ) : result += abs ( arr [ n - 1 ] ) return result"
"def splitString ( str ) : alpha = """" num = """" special = """" i = 0 while i in list ( range ( len ( str ) ) ) : if ( str [ i ].isdigit ( ) ) : num = num + str [ i ] elif ( ( str [ i ] >= 'A' and str [ i ] <= 'Z' ) or ( str [ i ] >= 'a' and str [ i ] <= 'z' ) ) : alpha += str [ i ] else : special += str [ i ] i += 1 print ( alpha ) print ( num ) print ( special )"
"def powerfulIntegers ( x , y , bound ) : s = set ( ) powersOfY = [ ] powersOfY.append ( 1 ) i = y while i < bound : powersOfY.append ( i ) i *= y i = 0 while ( True ) : xPowI = pow ( x , i ) if ( xPowI >= bound ) : break for j in powersOfY : num = xPowI + j if ( bound >= num ) : s.add ( num ) else : break i += 1 for itr in s : print ( itr , end = """" )"
"def subsetSums ( arr , l , r , sum = 0 ) : if r < l : print ( sum , end = """" ) return subsetSums ( arr , l + 1 , r , sum + arr [ l ] ) subsetSums ( arr , l + 1 , r , sum )"
"def randomize ( arr , n ) : i = n - 1 while i in list ( range ( 0 ) ) : j = random.randint ( 0 , i + 1 ) arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] i += - 1 return arr"
"def maxProdSum ( arr , n ) : leftArraySum = 0 maxProduct = 0 i = 0 while i in list ( range ( n ) ) : leftArraySum += arr [ i ] rightArraySum = 0 for j in range ( i + 1 , n ) : rightArraySum += arr [ j ] k = leftArraySum * rightArraySum if ( k > maxProduct ) : maxProduct = k i += 1 return maxProduct"
"def sum ( a , n ) : cnt = dict ( ) ans = 0 pre_sum = 0 i = 0 while i in list ( range ( n ) ) : ans += ( i * a [ i ] ) - pre_sum pre_sum += a [ i ] if ( a [ i ] - 1 ) in cnt : ans -= cnt [ a [ i ] - 1 ] if ( a [ i ] + 1 ) in cnt : ans += cnt [ a [ i ] + 1 ] if a [ i ] not in cnt : cnt [ a [ i ] ] = 0 cnt [ a [ i ] ] += 1 i += 1 return ans"
"def getMinSquares ( n ) : if n <= 3 : return n res = n x = 1 while x in list ( range ( n + 1 ) ) : temp = x * x if temp > n : x += 1 break else : res = min ( res , 1 + getMinSquares ( n - temp ) ) x += 1 return res"
"def frequencyOfSmallest ( n , arr ) : mn = arr [ 0 ] freq = 1 i = 1 while i in list ( range ( n ) ) : if ( arr [ i ] < mn ) : mn = arr [ i ] freq = 1 elif ( arr [ i ] == mn ) : freq += 1 i += 1 return freq"
"def printExpansion ( str ) : for i in range ( len ( str ) - 1 , - 1 , - 1 ) : j = i while j in list ( range ( len ( str ) ) ) : print ( str [ j ] , end = """" ) j += 1"
"def find ( n , m ) : if ( n <= 2 * m ) : print ( ""Minimum"" , 0 ) else : print ( ""Minimum"" , n - 2 * m ) i = 1 while i in list ( range ( n + 1 ) ) : if ( i * ( i - 1 ) // 2 >= m ) : i += 1 break i += 1 print ( ""Maximum"" , n - i )"
"def palindrome ( arr , begin , end ) : if ( begin >= end ) : return 1 if ( arr [ end ] == arr [ begin ] ) : return palindrome ( arr , begin + 1 , end - 1 ) else : return 0"
"def printGroups ( n ) : x = 1 y = n * n for i in range ( 1 , n + 1 ) : j = 1 while j in list ( range ( n // 2 + 1 ) ) : print ( ""{"" , x , "","" , y , ""}"" , end = """" ) x += 1 y -= 1 j += 1 print ( )"
"def minimumX ( n , k ) : ans = 10 ** 18 i = k - 1 while i in list ( range ( 0 ) ) : if n % i == 0 : ans = min ( ans , i + ( n / i ) * k ) i += - 1 return ans"
"def pairs_count ( arr , n , sum ) : ans = 0 arr = sorted ( arr ) i , j = 0 , n - 1 while ( i < j ) : if ( arr [ i ] + arr [ j ] < sum ) : i += 1 elif ( sum < arr [ i ] + arr [ j ] ) : j -= 1 else : x = arr [ i ] xx = i while ( i < j and arr [ i ] == x ) : i += 1 y = arr [ j ] yy = j while ( j >= i and arr [ j ] == y ) : j -= 1 if ( x == y ) : temp = i - xx + yy - j - 1 ans += ( temp * ( temp + 1 ) ) // 2 else : ans += ( i - xx ) * ( yy - j ) return ans"
"def containsElement ( arr , n ) : xorArr = 0 for i in range ( n ) : xorArr ^= arr [ i ] i = 0 while i in list ( range ( n ) ) : x = xorArr ^ arr [ i ] if ( arr [ i ] == x ) : i += 1 return True i += 1 return False"
"def max_length_substring ( st , n , k ) : max_len = 0 len = 0 i = 0 while i in list ( range ( n ) ) : if ( st [ i ] == '0' ) : len = len + 1 else : len = 0 max_len = max ( max_len , len ) i += 1 if ( max_len == n ) : return n * k pref = 0 suff = 0 i = 0 while ( st [ i ] == '0' ) : i = i + 1 pref = pref + 1 i = n - 1 while ( st [ i ] == '0' ) : i = i - 1 suff = suff + 1 if ( k > 1 ) : max_len = max ( max_len , pref + suff ) return max_len"
"def printFirstRepeating ( arr , n ) : Min = - 1 myset = dict ( ) i = n - 1 while i in list ( range ( - 1 ) ) : if arr [ i ] in myset.keys ( ) : Min = i else : myset [ arr [ i ] ] = 1 i += - 1 if ( Min != - 1 ) : print ( ""Thefirstrepeatingelementis"" , arr [ Min ] ) else : print ( ""Therearenorepeatingelements"" )"
"def checkDuplicatesWithinK ( arr , n , k ) : myset = [ ] i = 0 while i in list ( range ( n ) ) : if arr [ i ] in myset : i += 1 return True myset.append ( arr [ i ] ) if ( i >= k ) : myset.remove ( arr [ i - k ] ) i += 1 return False"
"def lengthOfSmallestSubsequence ( K , v ) : pq = [ ] for i in v : pq.append ( i ) pq.sort ( ) sum = 0 count = 0 while ( len ( pq ) > 0 and sum < K ) : sum = sum + pq [ - 1 ] del pq [ - 1 ] count = count + 1 if ( sum < K ) : return - 1 return count"
def check ( num ) : digitSum = 0 while 0 < num : rem = num % 10 digitSum = digitSum + rem num = num // 10 return ( digitSum % 3 == 0 )
"def printArray ( arr , n ) : arr.sort ( ) l = 0 r = n - 1 flag = 0 k = 2 while ( l <= r ) : if ( flag != 0 ) : i = r while i > r - k and i >= l : print ( arr [ i ] , end = """" ) i -= 1 flag = 0 r = i else : i = l while i < l + k and i <= r : print ( arr [ i ] , end = """" ) i += 1 flag = 1 l = i k += 1"
"def pairsInSortedRotated ( arr , n , x ) : i = 0 while i in list ( range ( n ) ) : if arr [ i ] > arr [ i + 1 ] : i += 1 break i += 1 l = ( i + 1 ) % n r = i cnt = 0 while ( l != r ) : if arr [ l ] + arr [ r ] == x : cnt += 1 if l == ( r - 1 + n ) % n : return cnt l = ( l + 1 ) % n r = ( r - 1 + n ) % n elif arr [ l ] + arr [ r ] < x : l = ( l + 1 ) % n else : r = ( n + r - 1 ) % n return cnt"
"def countSubarrays ( a , n , m ) : count = 0 prefix = [ 0 ] * n odd = 0 i = 0 while i in list ( range ( n ) ) : prefix [ odd ] += 1 if ( a [ i ] & 1 ) : odd += 1 if ( odd >= m ) : count += prefix [ odd - m ] i += 1 return count"
"def makePalindrome ( str1 ) : i = 0 j = len ( str1 ) - 1 str1 = list ( str1 ) while ( i <= j ) : if ( str1 [ i ] == '*' and '*' == str1 [ j ] ) : str1 [ i ] = 'a' str1 [ j ] = 'a' elif ( str1 [ j ] == '*' ) : str1 [ j ] = str1 [ i ] elif ( str1 [ i ] == '*' ) : str1 [ i ] = str1 [ j ] elif ( str1 [ i ] != str1 [ j ] ) : str1 = ''.join ( str1 ) return ""-1"" i += 1 j -= 1 str1 = ''.join ( str1 ) return str1"
"def PowerOFPINnfactorial ( n , p ) : ans = 0 temp = p while ( temp <= n ) : ans = ans + n / temp temp = temp * p return int ( ans )"
"def firstkdigits ( n , k ) : product = 1 i = 0 while i in list ( range ( n ) ) : product *= n i += 1 while ( ( product // pow ( 10 , k ) ) != 0 ) : product = product // 10 return product"
"def steps ( N , M ) : if ( 1 == N ) : return 0 elif ( N == 2 ) : return M return 2 * M + ( N - 3 )"
"def countX ( a , b ) : if ( a < b ) : return 0 elif ( a == b ) : return - 1 else : x = a - b ans = 0 i = 1 while i * i <= x : if ( x % i == 0 ) : d1 = i d2 = b - 1 if ( i * i != x ) : d2 = x // i if ( d1 > b ) : ans += 1 if ( d2 > b ) : ans += 1 i += 1 return ans"
"def noAdjacentDup ( s ) : n = len ( s ) i = 1 while i in list ( range ( n ) ) : if ( s [ i ] == s [ i - 1 ] ) : s [ i ] = ""a"" while ( s [ i ] == s [ i - 1 ] or ( i + 1 < n and s [ i ] == s [ i + 1 ] ) ) : s [ i ] += 1 i += 1 i += 1 return s"
"def diagonalsquare ( mat , row , column ) : print ( ""Diagonalone:"" , end = """" ) for i in range ( 0 , row ) : j = 0 while j in list ( range ( column ) ) : if ( i == j ) : print ( ""{}"".format ( mat [ i ] [ j ] * mat [ i ] [ j ] ) , end = """" ) j += 1 print ( ""\n\nDiagonaltwo:"" , end = """" ) for i in range ( 0 , row ) : for j in range ( 0 , column ) : if ( i + j == column - 1 ) : print ( ""{}"".format ( mat [ i ] [ j ] * mat [ i ] [ j ] ) , end = """" )"
"def printPattern ( n ) : arr = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] p = 1 for k in range ( n ) : j = k i = 0 while ( j >= 0 ) : arr [ i ] [ j ] = p p += 1 i = i + 1 j = j - 1 for k in range ( 1 , n , 1 ) : i = k j = n - 1 f = k while ( j >= f ) : arr [ i ] [ j ] = p p += 1 i = i + 1 j = j - 1 for i in range ( 0 , n , 1 ) : j = 0 while j in list ( range ( n ) ) : print ( arr [ i ] [ j ] , end = """" ) j += 1 print ( ""\n"" , end = """" )"
"def countWays ( n , m ) : count = [ ] for i in range ( n + 2 ) : count.append ( 0 ) count [ 0 ] = 0 i = 1 while i in list ( range ( n + 1 ) ) : if ( i > m ) : count [ i ] = count [ i - 1 ] + count [ i - m ] elif ( i < m ) : count [ i ] = 1 else : count [ i ] = 2 i += 1 return count [ n ]"
"def maxSum ( p0 , p1 , a , pos , n ) : if ( pos == n ) : if ( p1 == p0 ) : return p0 else : return 0 ans = maxSum ( p0 , p1 , a , pos + 1 , n ) ans = max ( ans , maxSum ( p0 + a [ pos ] , p1 , a , pos + 1 , n ) ) ans = max ( ans , maxSum ( p0 , p1 + a [ pos ] , a , pos + 1 , n ) ) return ans"
"def odd_even ( n ) : odd_indexes = [ ] even_indexes = [ ] i = 0 while i in list ( range ( len ( n ) ) ) : if i % 2 == 0 : odd_indexes.append ( n [ i ] ) else : even_indexes.append ( n [ i ] ) i += 1 for i in sorted ( odd_indexes ) : print ( i , end = """" ) for i in sorted ( even_indexes ) : print ( i , end = """" )"
"def printRotatedString ( str ) : lenn = len ( str ) temp = [ 0 ] * ( lenn ) i = 0 while i in list ( range ( lenn ) ) : j = i k = 0 while ( j < len ( str ) ) : temp [ k ] = str [ j ] k += 1 j += 1 j = 0 while ( j < i ) : temp [ k ] = str [ j ] j += 1 k += 1 print ( * temp , sep = """" ) i += 1"
"def printPath ( str ) : i = 0 curX = 0 curY = 0 while ( len ( str ) > i ) : nextX = int ( ( ord ( str [ i ] ) - ord ( 'A' ) ) / 5 ) nextY = ( ord ( str [ i ] ) - ord ( 'B' ) + 1 ) % 5 while ( curX > nextX ) : print ( ""MoveUp"" ) curX -= 1 while ( curY > nextY ) : print ( ""MoveLeft"" ) curY -= 1 while ( curX < nextX ) : print ( ""MoveDown"" ) curX += 1 while ( curY < nextY ) : print ( ""MoveRight"" ) curY += 1 print ( ""PressOK"" ) i += 1"
"def isSubset ( arr1 , arr2 , m , n ) : i = 0 j = 0 i = 0 while i in list ( range ( n ) ) : for j in range ( m ) : if ( arr2 [ i ] == arr1 [ j ] ) : i += 1 break if ( j == m ) : i += 1 return 0 i += 1 return 1"
"def countNum ( N , arr ) : Sum , count = 0 , 0 i = 0 while i in list ( range ( N ) ) : Sum += arr [ i ] i += 1 for i in range ( N ) : if ( ( Sum - arr [ i ] ) % arr [ i ] == 0 ) : count += 1 return count"
"def permutation ( arr , N ) : hash = [ 0 ] * ( N + 1 ) for i in range ( N ) : hash [ arr [ i ] ] += 1 i = 1 while i in list ( range ( N + 1 ) ) : if ( hash [ i ] != 1 ) : i += 1 return ""No"" i += 1 return ""Yes"""
"def cntPairs ( a , n ) : odd = 0 ; even = 0 i = 0 while i in list ( range ( n ) ) : if ( a [ i ] % 2 == 1 ) : odd += 1 elif ( ( a [ i ] / 2 ) % 2 == 1 ) : even += 1 i += 1 ans = odd * even + ( odd * ( odd - 1 ) ) // 2 return ans"
"def findFibSubset ( arr , n ) : m = max ( arr ) a = 0 b = 1 hash = [ ] hash.append ( a ) hash.append ( b ) while ( b < m ) : c = a + b a = b b = c hash.append ( b ) i = 0 while i in list ( range ( n ) ) : if arr [ i ] in hash : print ( arr [ i ] , end = """" ) i += 1"
"def getElements ( a , arr , n ) : elements = [ 1 for i in range ( n + 1 ) ] elements [ 0 ] = a for i in range ( n ) : elements [ i + 1 ] = arr [ i ] ^ elements [ i ] i = 0 while i in list ( range ( n + 1 ) ) : print ( elements [ i ] , end = """" ) i += 1"
"def answer_query ( a , n , l , r ) : count = 0 i = l while i in list ( range ( r ) ) : if ( a [ i ] == a [ i + 1 ] ) : count += 1 i += 1 return count"
"def printLines ( n , k ) : i = 0 while i in list ( range ( n ) ) : print ( k * ( 6 * i + 1 ) , k * ( 6 * i + 2 ) , k * ( 6 * i + 3 ) , k * ( 6 * i + 5 ) ) i += 1"
def is_possible ( s ) : l = len ( s ) one = 0 zero = 0 i = 0 while i in list ( range ( l ) ) : if ( s [ i ] == '0' ) : zero += 1 else : one += 1 i += 1 if ( l % 2 == 0 ) : return ( one == zero ) else : return ( abs ( one - zero ) == 1 )
"def eulerian ( n , m ) : dp = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] for i in range ( 1 , n + 1 ) : j = 0 while j in list ( range ( m + 1 ) ) : if ( i > j ) : if ( j == 0 ) : dp [ i ] [ j ] = 1 else : dp [ i ] [ j ] = ( ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ) j += 1 return dp [ n ] [ m ]"
"def trianglearea ( l , b ) : if ( l < 0 or 0 > b ) : return - 1 area = ( l * b ) / 2 return area"
"def printEqualModNumbers ( arr , n ) : arr.sort ( ) d = arr [ n - 1 ] - arr [ 0 ] v = [ ] i = 1 while ( i * i <= d ) : if ( d % i == 0 ) : v.append ( i ) if ( i != d / i ) : v.append ( d / i ) i += 1 i = 0 while i in list ( range ( len ( v ) ) ) : temp = arr [ 0 ] % v [ i ] j = 1 while ( j < n ) : if ( arr [ j ] % v [ i ] != temp ) : i += 1 break j += 1 if ( j == n ) : print ( v [ i ] , end = """" ) i += 1"
"def search ( arr , n , x ) : i = 0 i = i while i in list ( range ( n ) ) : if ( arr [ i ] == x ) : i += 1 return i i += 1 return - 1"
def highestPowerof2 ( n ) : res = 0 i = n while i in list ( range ( 0 ) ) : if ( ( i & ( i - 1 ) ) == 0 ) : res = i i += - 1 break i += - 1 return res
"def ways ( s , n ) : dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] for i in range ( n ) : dp [ 0 ] [ i ] = 1 i = 1 while i in list ( range ( n ) ) : temp = """" for j in range ( i , n ) : temp += s [ j ] test = """" for k in range ( i - 1 , - 1 , - 1 ) : test += s [ k ] if ( test < temp ) : dp [ i ] [ j ] += dp [ k ] [ i - 1 ] i += 1 ans = 0 for i in range ( n ) : ans += dp [ i ] [ n - 1 ] return ans"
"def largestGCDSubsequence ( arr , n ) : ans = 0 maxele = max ( arr ) for i in range ( 2 , maxele + 1 ) : count = 0 j = 0 while j in list ( range ( n ) ) : if ( arr [ j ] % i == 0 ) : count += 1 j += 1 ans = max ( ans , count ) return ans"
def possibleways ( n ) : if ( 1 == n % 2 ) : return 0 elif ( n % 4 == 0 ) : return n // 4 - 1 else : return n // 4
"def Valid ( a , b , c ) : if ( ( a + b + c == 180 ) and a != 0 and b != 0 and 0 != c ) : return True else : return False"
"def isValidSeq ( a , n ) : nodes = n + 2 i = 0 while i in list ( range ( n ) ) : if ( a [ i ] < 1 or a [ i ] > nodes ) : i += 1 return False i += 1 return True"
"def printUnique ( l , r ) : i = l while i in list ( range ( r + 1 ) ) : num = i visited = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] while ( num ) : if visited [ num % 10 ] == 1 : i += 1 break visited [ num % 10 ] = 1 num = ( int ) ( num / 10 ) if num == 0 : print ( i , end = """" ) i += 1"
"def updateArray ( arr , n ) : i = n - 1 while ( i > 0 ) : arr [ i ] = arr [ i - 1 ] i -= 1 arr [ 0 ] = - 1 i = 0 while i in list ( range ( n ) ) : print ( arr [ i ] , end = """" ) i += 1"
"def findMinDifference ( arr , n ) : if ( arr [ 0 ] < arr [ 1 ] ) : min__ = secondMax = arr [ 0 ] else : min__ = secondMax = arr [ 1 ] if ( arr [ 0 ] < arr [ 1 ] ) : max__ = secondMin = arr [ 1 ] else : max__ = secondMin = arr [ 0 ] i = 2 while i in list ( range ( n ) ) : if ( arr [ i ] > max__ ) : secondMax = max__ max__ = arr [ i ] elif ( arr [ i ] > secondMax ) : secondMax = arr [ i ] elif ( arr [ i ] < min__ ) : secondMin = min__ min__ = arr [ i ] elif ( arr [ i ] < secondMin ) : secondMin = arr [ i ] i += 1 diff = min ( max__ - secondMin , secondMax - min__ ) return diff"
"def product ( mat , n ) : d1 = 0 d2 = 0 i = 0 while i in list ( range ( n ) ) : d1 += mat [ i ] [ i ] d2 += mat [ i ] [ n - i - 1 ] i += 1 return d1 * d2"
"def min_sum ( n , k , a ) : a.sort ( reverse = False ) if ( a [ 0 ] < 0 ) : return - 1 if ( k == 0 ) : if ( a [ 0 ] == a [ n - 1 ] ) : return ( n * a [ 0 ] ) else : return - 1 else : f = 0 i = 1 while i in list ( range ( n ) ) : p = a [ i ] - a [ 0 ] if ( p % k == 0 ) : i += 1 continue else : f = 1 i += 1 break i += 1 if ( f ) : return - 1 else : if ( k == 1 ) : return n else : return ( n * ( a [ 0 ] % k ) )"
"def minOperations ( n , a , b , c ) : ans = 0 i = 0 while i in list ( range ( n ) ) : x = a [ i ] y = b [ i ] z = c [ i ] if ( x == y and y == z ) : i += 1 continue elif ( x == y or y == z or x == z ) : ans += 1 else : ans += 2 i += 1 return ans"
"def fibonacci ( n ) : i = 0 while i in list ( range ( n ) ) : fib = ( ( pow ( ( 1 + math.sqrt ( 5 ) ) , i ) - pow ( ( 1 - math.sqrt ( 5 ) ) , i ) ) / ( pow ( 2 , i ) * math.sqrt ( 5 ) ) ) print ( int ( fib ) , end = """" ) i += 1"
"def findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) : s = set ( ) for i in range ( n1 ) : s.add ( a1 [ i ] ) for i in range ( n2 ) : j = 0 while j in list ( range ( n3 ) ) : if sum - a2 [ i ] - a3 [ j ] in s : j += 1 return True j += 1 return False"
"def maxLen ( arr ) : hash_map = { } max_len = 0 curr_sum = 0 i = 0 while i in list ( range ( len ( arr ) ) ) : curr_sum += arr [ i ] if arr [ i ] is 0 and max_len is 0 : max_len = 1 if curr_sum is 0 : max_len = i + 1 if curr_sum in hash_map : max_len = max ( max_len , i - hash_map [ curr_sum ] ) else : hash_map [ curr_sum ] = i i += 1 return max_len"
"def printRepeatingEven ( arr , n ) : axor = 0 i = 0 while i in list ( range ( n ) ) : pos = 1 << arr [ i ] axor ^= pos i += 1 for i in range ( 0 , n - 1 ) : pos = 1 << arr [ i ] if ( not ( pos & axor ) ) : print ( arr [ i ] , end = """" ) axor ^= pos"
"def zigzag ( n , k ) : dp = [ [ 0 for x in range ( k + 1 ) ] for y in range ( n + 1 ) ] dp [ 0 ] [ 0 ] = 1 i = 1 while i in list ( range ( n + 1 ) ) : dp [ i ] [ 0 ] = 0 i += 1 for i in range ( 1 , n + 1 ) : for j in range ( 1 , k + 1 ) : dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] ) return dp [ n ] [ k ]"
"def minimum_cost ( a , n ) : mn = sys.maxsize sum = 0 i = 0 while i in list ( range ( n ) ) : mn = min ( a [ i ] , mn ) sum += a [ i ] i += 1 return mn * ( sum - mn )"
"def maxLength ( a , n ) : maximum = 1 left = [ 0 ] * n right = [ 0 ] * n for i in range ( n ) : left [ i ] = 1 right [ i ] = 1 for i in range ( n - 2 , - 1 , - 1 ) : if ( a [ i ] > a [ i + 1 ] ) : right [ i ] = right [ i + 1 ] + 1 maximum = max ( maximum , right [ i ] ) for i in range ( 1 , n ) : if ( a [ i ] < a [ i - 1 ] ) : left [ i ] = left [ i - 1 ] + 1 if ( n > 2 ) : i = 1 while i in list ( range ( n - 1 ) ) : if ( a [ i - 1 ] > a [ i + 1 ] ) : maximum = max ( maximum , left [ i - 1 ] + right [ i + 1 ] ) i += 1 return maximum"
"def isPower ( x , y ) : if ( 1 == x ) : return ( y == 1 ) pow = 1 while ( pow < y ) : pow = pow * x return ( pow == y )"
"def CntDivbyX ( arr , n , x ) : number = 0 count = 0 i = 0 while i in list ( range ( n ) ) : number = ( number * 2 + arr [ i ] ) % x if number == 0 : count += 1 i += 1 return count"
"def pre_compute ( a , n , index , k ) : dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] i = 0 while i in list ( range ( n ) ) : if a [ i ] > a [ 0 ] : dp [ 0 ] [ i ] = a [ i ] + a [ 0 ] else : dp [ 0 ] [ i ] = a [ i ] i += 1 for i in range ( 1 , n ) : for j in range ( n ) : if a [ j ] > a [ i ] and j > i : if dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j ] : dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ] else : dp [ i ] [ j ] = dp [ i - 1 ] [ j ] else : dp [ i ] [ j ] = dp [ i - 1 ] [ j ] return dp [ index ] [ k ]"
"def leftRotate ( arr , n , k ) : i = k while i in list ( range ( k + n ) ) : print ( str ( arr [ i % n ] ) , end = """" ) i += 1"
def abFree ( s ) : b_count = 0 res = 0 i = 0 while i in list ( range ( len ( s ) ) ) : if s [ ~ i ] == 'a' : res = ( res + b_count ) b_count = ( b_count * 2 ) else : b_count += 1 i += 1 return res
"def maxOnesIndex ( arr , n ) : i = 0 leftCnt = 0 rightCnt = 0 maxIndex = - 1 lastInd = - 1 maxCnt = 0 while i < n : if arr [ i ] == 1 : rightCnt += 1 else : if lastInd != - 1 : if rightCnt + leftCnt + 1 > maxCnt : maxCnt = leftCnt + rightCnt + 1 maxIndex = lastInd lastInd = i leftCnt = rightCnt rightCnt = 0 i += 1 if lastInd != - 1 : if maxCnt < leftCnt + rightCnt + 1 : maxCnt = leftCnt + rightCnt + 1 maxIndex = lastInd return maxIndex"
"def NFG ( a , n ) : if ( n <= 0 ) : print ( ""Listempty"" ) return [ ] stack = [ 0 ] * n freq = { } for i in a : freq [ a [ i ] ] = 0 for i in a : freq [ a [ i ] ] += 1 res = [ 0 ] * n top = - 1 top += 1 stack [ top ] = 0 i = 1 while i in list ( range ( n ) ) : if ( freq [ a [ stack [ top ] ] ] > freq [ a [ i ] ] ) : top += 1 stack [ top ] = i else : while ( top > - 1 and freq [ a [ stack [ top ] ] ] < freq [ a [ i ] ] ) : res [ stack [ top ] ] = a [ i ] top -= 1 top += 1 stack [ top ] = i i += 1 while ( top > - 1 ) : res [ stack [ top ] ] = - 1 top -= 1 return res"
"def EvenOddLength ( arr , n ) : even = 0 i = 0 while i in list ( range ( n ) ) : x = str ( arr [ i ] ) if ( len ( x ) % 2 == 0 ) : even += 1 i += 1 print ( ""Numberofevenlengthelements="" , even ) print ( ""Numberofoddlengthelements="" , n - even )"
def getHermiteNumber ( n ) : if n == 0 : return 1 if 1 == n : return 0 else : return ( - 2 * ( n - 1 ) * getHermiteNumber ( n - 2 ) )
"def findFrequency ( arr , n , left , right , element ) : count = 0 i = left - 1 while i in list ( range ( right ) ) : if ( arr [ i ] == element ) : count += 1 i += 1 return count"
"def extraElement ( A , B , n ) : ans = 0 for i in range ( n ) : ans ^= A [ i ] i = 0 while i in list ( range ( n + 1 ) ) : ans ^= B [ i ] i += 1 return ans"
def calculate ( N ) : length = len ( N ) l = int ( ( length ) / 2 ) count = 0 i = 0 while i in list ( range ( l + 1 ) ) : s = N [ 0 : 0 + i ] l1 = len ( s ) t = N [ i : l1 + i ] try : if s [ 0 ] == '0' or t [ 0 ] == '0' : i += 1 continue except : i += 1 continue if s == t : count += 1 i += 1 return count
"def AlternateRearrange ( arr , n ) : arr.sort ( ) v1 = list ( ) v2 = list ( ) for i in range ( n ) : if ( arr [ i ] % 2 == 0 ) : v1.append ( arr [ i ] ) else : v2.append ( arr [ i ] ) index = 0 i = 0 j = 0 flag = False if ( arr [ 0 ] % 2 == 0 ) : flag = True while ( index < n ) : if ( flag == True ) : arr [ index ] = v1 [ i ] index = index + 1 i = i + 1 flag = ~ flag else : arr [ index ] = v2 [ j ] index = index + 1 j = j + 1 flag = ~ flag for i in range ( n ) : print ( arr [ i ] , end = """" )"
"def precisionCompute ( x , y , n ) : if y == 0 : print ( ""Infinite"" ) return if x == 0 : print ( 0 ) return if n <= 0 : print ( x / y ) return if ( ( ( x > 0 ) and ( y < 0 ) ) or ( ( x < 0 ) and ( y > 0 ) ) ) : print ( ""-"" , end = """" ) if x < 0 : x = - x if y < 0 : y = - y d = x / y i = 0 while i in list ( range ( n + 1 ) ) : print ( d ) x = x - ( y * d ) if x == 0 : i += 1 break x = x * 10 d = x / y if ( i == 0 ) : print ( ""."" , end = """" ) i += 1"
"def printSubsequences ( str ) : n = len ( str ) opsize = int ( pow ( 2 , n - 1 ) ) counter = 0 while counter in list ( range ( opsize ) ) : for j in range ( n ) : print ( str [ j ] , end = """" ) if ( counter & ( 1 << j ) ) : print ( """" , end = """" ) print ( ""\n"" , end = """" ) counter += 1"
"def getMissingNo ( a , n ) : x1 = a [ 0 ] x2 = 1 i = 1 while i in list ( range ( n ) ) : x1 = x1 ^ a [ i ] i += 1 for i in range ( 2 , n + 2 ) : x2 = x2 ^ i return x1 ^ x2"
"def printQueries ( n , a , q , qry ) : occ = dict ( ) suffixCount = [ 0 for i in range ( n + 1 ) ] for i in range ( n - 1 , - 1 , - 1 ) : occ [ a [ i ] ] = 1 suffixCount [ i + 1 ] = len ( occ ) i = 0 while i in list ( range ( q ) ) : print ( suffixCount [ qry [ i ] ] ) i += 1"
"def superSeq ( X , Y , m , n ) : if ( not m ) : return n if ( not n ) : return m if ( Y [ n - 1 ] == X [ m - 1 ] ) : return 1 + superSeq ( X , Y , m - 1 , n - 1 ) return 1 + min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) )"
"def search ( arr , n , x , k ) : i = 0 while ( i < n ) : if ( x == arr [ i ] ) : return i i = i + max ( 1 , int ( abs ( arr [ i ] - x ) / k ) ) print ( ""numberisnotpresent!"" ) return - 1"
"def solve ( S ) : n = len ( S ) mat = np.zeros ( [ n + 1 , n + 1 ] , int ) for l in range ( 2 , n + 1 , 2 ) : s = 0 while s in list ( range ( n + 1 - l ) ) : t = s + l mat [ s , t ] = max ( [ mat [ s + 1 , j ] + mat [ j + 1 , t ] + ( 10 if S [ s ] == S [ j ] else 5 ) for j in range ( s + 1 , t + 1 , 2 ) ] ) s += 1 return mat [ 0 , n ]"
"def nobleInteger ( arr , size ) : for i in range ( 0 , size ) : count = 0 j = 0 while j in list ( range ( size ) ) : if ( arr [ i ] < arr [ j ] ) : count += 1 j += 1 if ( count == arr [ i ] ) : return arr [ i ] return - 1"
"def average ( arr , n , k ) : total = 0 if ( 2 * k >= n ) : return 0 arr.sort ( ) start , end = k , n - k - 1 i = start while i in list ( range ( end + 1 ) ) : total += arr [ i ] i += 1 return ( total / ( n - 2 * k ) )"
"def maxOnesIndex ( arr , n ) : start = 0 end = 0 maxIndex = - 1 lastInd = - 1 maxCnt = 0 while ( end < n ) : while ( n > end and arr [ end ] ) : end += 1 if ( maxCnt < end - start and lastInd != - 1 ) : maxCnt = end - start maxIndex = lastInd start = lastInd + 1 lastInd = end end += 1 if ( maxCnt < end - start and lastInd != - 1 ) : maxCnt = end - start maxIndex = lastInd return maxIndex"
"def check_last ( arr , n , p ) : _sum = 0 i = 0 while i in list ( range ( n ) ) : _sum = _sum + arr [ i ] i += 1 if p == 1 : if _sum % 2 == 0 : return ""ODD"" else : return ""EVEN"" return ""EVEN"""
"def find_n ( a ) : j , k = 0 , 0 x = max ( a ) for i in range ( len ( a ) ) : if ( a [ i ] == x ) : s = i break for i in a : if ( i != x and i <= min ( a ) and i != '\0' ) : a [ j ] += 1 a [ s ] -= 1 x -= 1 k += 1 j += 1 elif ( i != '\0' ) : j += 1 for i in range ( len ( a ) ) : if ( x != a [ i ] ) : k = - 1 break return k"
def check ( n ) : sum = 0 while n != 0 : sum = sum + n % 10 n = n // 10 if sum % 7 == 0 : return 1 else : return 0
"def squarearea ( r ) : if ( 0 > r ) : return - 1 a = 4 * ( pow ( r , 2 ) / 5 ) return a"
def getChar ( strr ) : summ = 0 i = 0 while i in list ( range ( len ( strr ) ) ) : summ += ( ord ( strr [ i ] ) - ord ( 'a' ) + 1 ) i += 1 if ( summ % 26 == 0 ) : return ord ( 'z' ) else : summ = summ % 26 return chr ( ord ( 'a' ) + summ - 1 )
"def count ( s , c ) : res = 0 i = 0 while i in list ( range ( len ( s ) ) ) : if ( s [ i ] == c ) : res = res + 1 i += 1 return res"
"def lis ( arr , n ) : mpis = [ 0 ] * ( n ) for i in range ( n ) : mpis [ i ] = arr [ i ] i = 1 while i in list ( range ( n ) ) : for j in range ( i ) : if ( arr [ i ] > arr [ j ] and mpis [ i ] < ( mpis [ j ] * arr [ i ] ) ) : mpis [ i ] = mpis [ j ] * arr [ i ] i += 1 return max ( mpis )"
"def isPossible ( n , k , arr ) : sum = arr [ 0 ] maxVal = arr [ 0 ] i = 1 while i in list ( range ( n ) ) : sum += arr [ i ] maxVal = max ( maxVal , arr [ i ] ) i += 1 if ( int ( maxVal ) > int ( ( sum + k ) / n ) ) : return False return True"
"def isDivisible ( n ) : temp = n while ( n ) : k = n % 10 if ( 0 == temp % k ) : return ""YES"" n /= 10 return ""NO"""
"def isConvertible ( str1 , str2 , k ) : if ( ( len ( str1 ) + len ( str2 ) ) < k ) : return True commonLength = 0 i = 0 while i in list ( range ( min ( len ( str1 ) , len ( str2 ) ) ) ) : if ( str1 [ i ] == str2 [ i ] ) : commonLength += 1 else : i += 1 break i += 1 if ( ( k - len ( str1 ) - len ( str2 ) + 2 * commonLength ) % 2 == 0 ) : return True return False"
def power ( n ) : if 1 == n : return 2 return 2 * power ( n - 1 )
"def countSubStr ( st , n ) : m = 0 i = 0 while i in list ( range ( n ) ) : if ( st [ i ] == '1' ) : m = m + 1 i += 1 return m * ( m - 1 ) // 2"
"def countEvenOdd ( n ) : even_count = 0 odd_count = 0 while ( n > 0 ) : rem = n % 10 if ( rem % 2 == 0 ) : even_count += 1 else : odd_count += 1 n = int ( n / 10 ) print ( ""Evencount:"" , even_count ) print ( ""\nOddcount:"" , odd_count ) if ( 0 == even_count % 2 and odd_count % 2 != 0 ) : return 1 else : return 0"
"def maxSumPairWithDifferenceLessThanK ( arr , N , k ) : maxSum = 0 arr.sort ( ) i = N - 1 while ( 0 <= i ) : if ( arr [ i ] - arr [ i - 1 ] < k ) : maxSum += arr [ i ] maxSum += arr [ i - 1 ] i -= 1 i -= 1 return maxSum"
def repUnitValue ( n ) : if ( 0 == n % 2 or n % 5 == 0 ) : return 0 rem = 1 power = 1 k = 1 while ( rem % n != 0 ) : k += 1 power = power * 10 % n rem = ( rem + power ) % n return k
"def binarySearch ( arr , low , high , key ) : if ( low > high ) : return - 1 mid = ( low + high ) / 2 if ( key == arr [ int ( mid ) ] ) : return mid if ( key > arr [ int ( mid ) ] ) : return binarySearch ( arr , ( mid + 1 ) , high , key ) return ( binarySearch ( arr , low , ( mid - 1 ) , key ) )"
"def isDivisible ( n ) : temp = n sum = 0 while ( n ) : k = n % 10 sum = sum + k n /= 10 if ( temp % sum == 0 ) : return """" return """""
"def check ( n , k , a , b ) : a.sort ( ) b.sort ( ) fl = False ind = - 1 i = 0 while i in list ( range ( n ) ) : if ( a [ i ] != b [ i ] ) : if ( fl == True ) : i += 1 return False fl = True ind = i i += 1 if ( ind == - 1 or abs ( a [ ind ] - b [ ind ] ) <= k ) : return True return False"
"def maxSum ( a , n ) : maxAnd = max ( a ) maxOR = 0 i = 0 while i in list ( range ( n ) ) : maxOR |= a [ i ] i += 1 print ( maxAnd + maxOR )"
"def printPattern ( n , m , flag ) : print ( m ) if flag == False and n == m : return if flag : if 0 < m - 5 : printPattern ( n , m - 5 , True ) else : printPattern ( n , m - 5 , False ) else : printPattern ( n , m + 5 , False )"
"def zzis ( arr , n ) : Z = [ [ 1 for i in range ( 2 ) ] for i in range ( n ) ] res = 1 i = 1 while i in list ( range ( n ) ) : for j in range ( i ) : if ( arr [ j ] < arr [ i ] and Z [ i ] [ 0 ] < Z [ j ] [ 1 ] + 1 ) : Z [ i ] [ 0 ] = Z [ j ] [ 1 ] + 1 if ( arr [ j ] > arr [ i ] and Z [ i ] [ 1 ] < Z [ j ] [ 0 ] + 1 ) : Z [ i ] [ 1 ] = Z [ j ] [ 0 ] + 1 if ( res < max ( Z [ i ] [ 0 ] , Z [ i ] [ 1 ] ) ) : res = max ( Z [ i ] [ 0 ] , Z [ i ] [ 1 ] ) i += 1 return res"
"def countSubarrWithEqualZeroAndOne ( arr , n ) : mp = dict ( ) Sum = 0 count = 0 i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] == 0 ) : arr [ i ] = - 1 Sum += arr [ i ] if ( Sum == 0 ) : count += 1 if ( Sum in mp.keys ( ) ) : count += mp [ Sum ] mp [ Sum ] = mp.get ( Sum , 0 ) + 1 i += 1 return count"
"def findPair ( arr , n ) : if ( n < 2 ) : print ( ""-1"" ) return i = 0 first = - 1 second = - 1 i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] > first ) : second = first first = arr [ i ] elif ( arr [ i ] > second ) : second = arr [ i ] i += 1 print ( ""n="" , first , ""andr="" , second )"
"def sizeSubSet ( a , k , n ) : a.sort ( ) s = set ( ) i = 0 while i in list ( range ( n ) ) : if ( a [ i ] % k != 0 or a [ i ] // k not in s ) : s.add ( a [ i ] ) i += 1 return len ( s )"
"def numofsubset ( arr , n ) : x = sorted ( arr ) count = 1 i = 0 while i in list ( range ( n - 1 ) ) : if ( x [ i ] + 1 != x [ i + 1 ] ) : count = count + 1 i += 1 return count"
"def getNumber ( n , k ) : arr = [ 0 ] * n i = 0 odd = 1 while ( odd <= n ) : arr [ i ] = odd i = i + 1 odd = odd + 2 even = 2 while ( even <= n ) : arr [ i ] = even i = i + 1 even = even + 2 return arr [ k - 1 ]"
def maxPrimefactorNum ( N ) : if ( N < 2 ) : return 0 arr = [ True ] * ( N + 1 ) prod = 1 res = 0 p = 2 while ( p * p <= N ) : if ( arr [ p ] == True ) : i = p * 2 while i in list ( range ( N + 1 ) ) : arr [ i ] = False i += p prod *= p if ( prod > N ) : return res res += 1 p += 1 return res
"def findOptimalSolution ( a , N ) : a.sort ( ) points = 0 i = 0 while i in list ( range ( N ) ) : points += a [ i ] * i i += 1 return points"
"def nth_term ( a , b , n ) : z = 0 if ( n % 6 == 1 ) : z = a elif ( n % 6 == 2 ) : z = b elif ( n % 6 == 3 ) : z = b - a elif ( n % 6 == 4 ) : z = - a elif ( n % 6 == 5 ) : z = - b if ( 0 == n % 6 ) : z = - ( b - a ) return z"
"def MaxNumbers ( a , n ) : fre = [ 0 for i in range ( 3 ) ] i = 0 while i in list ( range ( n ) ) : a [ i ] %= 3 fre [ a [ i ] ] += 1 i += 1 ans = fre [ 0 ] k = min ( fre [ 1 ] , fre [ 2 ] ) ans += k fre [ 1 ] -= k fre [ 2 ] -= k ans += fre [ 1 ] // 3 + fre [ 2 ] // 3 return ans"
"def PrintNumber ( N , Original , K , flag ) : print ( N , end = """" ) if ( N <= 0 ) : if ( flag == 0 ) : flag = 1 else : flag = 0 if ( N == Original and ( not ( flag ) ) ) : return if ( True == flag ) : PrintNumber ( N - K , Original , K , flag ) return if ( not ( flag ) ) : PrintNumber ( N + K , Original , K , flag ) return"
"def findSubSeq ( arr , n ) : arr.sort ( ) count = [ 1 ] * n prev = [ - 1 ] * n max = 0 maxprev = - 1 for i in range ( n ) : j = i - 1 while j in list ( range ( - 1 ) ) : if ( arr [ i ] % arr [ j ] == 0 and count [ j ] + 1 > count [ i ] ) : count [ i ] = count [ j ] + 1 prev [ i ] = j j += - 1 if ( max < count [ i ] ) : max = count [ i ] maxprev = i i = maxprev while ( i >= 0 ) : if ( arr [ i ] != - 1 ) : print ( arr [ i ] , end = """" ) i = prev [ i ]"
def check ( s ) : freq = [ 0 ] * 10 while ( s != 0 ) : r = s % 10 s = s // 10 freq [ r ] += 1 xor = 0 i = 0 while i in list ( range ( 10 ) ) : xor = xor ^ freq [ i ] i += 1 if ( xor == 0 ) : return True else : return False
"def seriesSum ( calculated , current , N ) : i = calculated cur = 1 if ( N + 1 == current ) : return 0 while ( i < calculated + current ) : cur *= i i += 1 return cur + seriesSum ( i , current + 1 , N )"
"def solve ( ang , n ) : if ( ( 180 * ( n - 2 ) ) < ( ang * n ) ) : return 0 elif ( ( ang * n ) % 180 != 0 ) : return 0 ans = 1 freq = ( ang * n ) // 180 ans = ans * ( n - 1 - freq ) ans = ans * n return ans"
"def decToBinary ( n ) : i = 31 while i in list ( range ( - 1 ) ) : k = n >> i if ( k & 1 ) : print ( ""1"" , end = """" ) else : print ( ""0"" , end = """" ) i += - 1"
"def countSubstrs ( s1 , s2 ) : ans = 0 i = 0 while i in list ( range ( len ( s1 ) ) ) : s3 = """" for j in range ( i , len ( s1 ) ) : s3 += s1 [ j ] if s2.find ( s3 ) != - 1 : ans += 1 i += 1 return ans"
"def returnWinner ( s , l ) : freq = [ 0 for i in range ( 26 ) ] for i in range ( 0 , l , 1 ) : freq [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1 cnt = 0 i = 0 while i in list ( range ( 26 ) ) : if ( freq [ i ] % 2 != 0 ) : cnt += 1 i += 1 if ( cnt == 0 or cnt & 1 == 1 ) : return 1 else : return 2"
"def winner ( a , n , k ) : if k >= n - 1 : return n best = 0 times = 0 i = 0 while i in list ( range ( n ) ) : if a [ i ] > best : best = a [ i ] if i == True : times = 1 else : times += 1 if times >= k : i += 1 return best i += 1 return best"
"def search ( arr , n , x ) : i = 0 while ( n - 1 >= i ) : if ( arr [ i ] == x ) : return i i += abs ( arr [ i ] - x ) return - 1"
"def minXOR ( arr , n ) : arr.sort ( ) minXor = int ( sys.float_info.max ) val = 0 i = 0 while i in list ( range ( n - 1 ) ) : val = arr [ i ] ^ arr [ i + 1 ] minXor = min ( minXor , val ) i += 1 return minXor"
"def evenDecimalValue ( str , n ) : result = 0 for i in range ( 0 , n ) : j = i while j in list ( range ( n ) ) : decimalValue = 0 powerOf2 = 1 for k in range ( i , j + 1 ) : decimalValue += ( ( int ( str [ k ] ) - 0 ) * powerOf2 ) powerOf2 *= 2 if ( decimalValue % 2 == 0 ) : result += 1 j += 1 return result"
"def CountWays ( n , flag ) : if 0 == n : return 1 sum = 0 if flag == False and n > 1 : sum = sum + CountWays ( n - 1 , False ) + CountWays ( n - 2 , True ) else : sum = sum + CountWays ( n - 1 , False ) return sum"
"def sumPairs ( arr , n ) : sum = 0 i = 0 while i in list ( range ( n ) ) : sum = sum + ( arr [ i ] * ( 2 * n ) ) i += 1 return sum"
"def countStaircases ( N ) : memo = [ [ 0 for x in range ( N + 5 ) ] for y in range ( N + 5 ) ] i = 0 while i in list ( range ( N + 1 ) ) : for j in range ( N + 1 ) : memo [ i ] [ j ] = 0 i += 1 memo [ 3 ] [ 2 ] = memo [ 4 ] [ 2 ] = 1 for i in range ( 5 , N + 1 ) : for j in range ( 2 , i + 1 ) : if ( j == 2 ) : memo [ i ] [ j ] = memo [ i - j ] [ j ] + 1 else : memo [ i ] [ j ] = ( memo [ i - j ] [ j ] + memo [ i - j ] [ j - 1 ] ) answer = 0 for i in range ( 1 , N + 1 ) : answer = answer + memo [ N ] [ i ] return answer"
"def find_number ( N , K ) : r = """" if ( N % 100 == 0 ) : N += 1 r = str ( N ) else : r = str ( N ) i = 1 while i in list ( range ( K + 1 ) ) : r += ""00"" i += 1 return r"
"def search ( arr , n , x ) : i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] == x ) : i += 1 return i i += 1 return - 1"
"def converthenumber ( n ) : s = str ( n ) res = """" for i in range ( len ( s ) ) : if ( s [ i ] == '' or s [ i ] == '' or s [ i ] == '' or s [ i ] == '' or s [ i ] == '' ) : res = res + s [ i ] if ( len ( res ) == 2 ) : break if ( len ( res ) == 2 ) : print ( res ) else : print ( """" )"
"def match ( first , second ) : if len ( first ) == 0 and len ( second ) == 0 : return True if len ( first ) > 1 and first [ 0 ] == '*' and len ( second ) == 0 : return False if ( len ( first ) > 1 and first [ 0 ] == '?' ) or ( len ( first ) != 0 and len ( second ) != 0 and first [ 0 ] == second [ 0 ] ) : return match ( first [ 1 : ] , second [ 1 : ] ) if len ( first ) != 0 and '*' == first [ 0 ] : return match ( first [ 1 : ] , second ) or match ( first , second [ 1 : ] ) return False"
"def countSum ( arr , n ) : result = 0 count_odd = 0 count_even = 0 i = 0 while i in list ( range ( n ) ) : if arr [ i - 1 ] % 2 == 0 : count_even = count_even + count_even + 1 count_odd = count_odd + count_odd else : temp = count_even count_even = count_even + count_odd count_odd = count_odd + temp + 1 i += 1 return [ count_even , count_odd ]"
"def findCost ( str , arr , n ) : costofC , costofO = 0 , 0 costofD , costofE = 0 , 0 i = 0 while i in list ( range ( n ) ) : if ( str [ i ] == 'c' ) : costofC += arr [ i ] elif ( str [ i ] == 'o' ) : costofO = min ( costofC , costofO + arr [ i ] ) elif ( str [ i ] == 'd' ) : costofD = min ( costofO , costofD + arr [ i ] ) elif ( str [ i ] == 'e' ) : costofE = min ( costofD , costofE + arr [ i ] ) i += 1 return costofE"
"def printPowerSet ( set , set_size ) : pow_set_size = ( int ) ( math.pow ( 2 , set_size ) ) counter = 0 j = 0 for counter in range ( 0 , pow_set_size ) : j = 0 while j in list ( range ( set_size ) ) : if ( ( counter & ( 1 << j ) ) > 0 ) : print ( set [ j ] , end = """" ) j += 1 print ( """" )"
def count ( n ) : if n < 3 : return n elif n >= 3 and n < 10 : return n - 1 po = 1 while 9 < n / po : po = po * 10 msd = n / po if msd != 3 : return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) else : return count ( msd * po - 1 )
def countToMake0lternate ( s ) : result = 0 i = 0 while i in list ( range ( len ( s ) - 1 ) ) : if ( s [ i ] == s [ i + 1 ] ) : result += 1 i += 1 return result
def ispowerof2 ( num ) : if ( 0 == ( num & ( num - 1 ) ) ) : return 1 return 0
"def pairORSum ( arr , n ) : ans = 0 for i in range ( 0 , n ) : j = ( i + 1 ) while j in list ( range ( n ) ) : ans = ans + arr [ i ] | arr [ j ] j += 1 return ans"
def isPalindrome ( n ) : divisor = 1 while ( n / divisor >= 10 ) : divisor *= 10 while ( 0 != n ) : leading = n // divisor trailing = n % 10 if ( leading != trailing ) : return False n = ( n % divisor ) // 10 divisor = divisor / 100 return True
"def returnMaxSum ( A , B , n ) : mp = set ( ) result = 0 curr_sum = curr_begin = 0 i = 0 while i in list ( range ( n ) ) : while A [ i ] in mp : mp.remove ( A [ curr_begin ] ) curr_sum -= B [ curr_begin ] curr_begin += 1 mp.add ( A [ i ] ) curr_sum += B [ i ] result = max ( result , curr_sum ) i += 1 return result"
"def getMinimumSum ( arr , n ) : ans = sys.maxsize i = 0 while i in list ( range ( n - 2 ) ) : for j in range ( i + 1 , n - 1 ) : for k in range ( j + 1 , n ) : ans = min ( ans , arr [ i ] + arr [ j ] + arr [ k ] ) i += 1 return ans"
"def maxSubarrayLength ( A , N ) : maxLen = 0 curr_sum = 0 hash = { } i = 0 while i in list ( range ( N ) ) : if ( A [ i ] % 2 == 0 ) : curr_sum -= 1 else : curr_sum += 1 if ( curr_sum == 0 ) : maxLen = max ( maxLen , i + 1 ) if curr_sum in hash : maxLen = max ( maxLen , i - hash [ curr_sum ] ) else : hash [ curr_sum ] = i i += 1 return maxLen"
"def countPairs ( arr , n ) : count_2 , count_others = 0 , 0 i = 0 while i in list ( range ( n ) ) : if arr [ i ] == 2 : count_2 += 1 elif arr [ i ] > 2 : count_others += 1 i += 1 ans = ( count_2 * count_others + ( count_others * ( count_others - 1 ) ) // 2 ) return ans"
"def Minimum_Operations ( a , n ) : np = [ 0 for i in range ( n + 1 ) ] i = n - 1 while i in list ( range ( - 1 ) ) : np [ i ] = np [ i + 1 ] if ( a [ i ] <= 0 ) : np [ i ] += 1 i += - 1 pos = 0 ans = n for i in range ( n - 1 ) : if ( a [ i ] >= 0 ) : pos += 1 ans = min ( ans , pos + np [ i + 1 ] ) return ans"
"def solve ( X , Y , l , r , k , dp ) : if k == 0 : return 0 if 0 > l or r < 0 : return 1000000000 if dp [ l ] [ r ] [ k ] != - 1 : return dp [ l ] [ r ] [ k ] cost = ( ( ord ( X [ l ] ) - ord ( 'a' ) ) ^ ( ord ( Y [ r ] ) - ord ( 'a' ) ) ) dp [ l ] [ r ] [ k ] = min ( [ cost + solve ( X , Y , l - 1 , r - 1 , k - 1 , dp ) , solve ( X , Y , l - 1 , r , k , dp ) , solve ( X , Y , l , r - 1 , k , dp ) ] ) return dp [ l ] [ r ] [ k ]"
"def asPowerSum ( w , m ) : while ( 0 < m ) : if ( ( m - 1 ) % w == 0 ) : m = ( m - 1 ) / w elif ( ( m + 1 ) % w == 0 ) : m = ( m + 1 ) / w elif ( m % w == 0 ) : m = m / w else : break return ( m == 0 )"
"def countNumber ( N , S ) : countElements = 0 currentSum = 0 currSum = 0 while ( currSum <= S ) : currSum = currSum + N N = N - 1 countElements = countElements + 1 return countElements"
def isAnBn ( str ) : n = len ( str ) for i in range ( n ) : if ( str [ i ] != 'a' ) : break if ( i * 2 != n ) : return False j = i while j in list ( range ( n ) ) : if ( str [ j ] != 'b' ) : j += 1 return False j += 1 return True
"def triangular_series ( n ) : j = 1 k = 1 i = 1 while i in list ( range ( n + 1 ) ) : print ( k , end = '' ) j = j + 1 k = k + j i += 1"
"def numOfIncSubseqOfSizeK ( arr , n , k ) : dp = [ [ 0 for i in range ( n ) ] for i in range ( k ) ] for i in range ( n ) : dp [ 0 ] [ i ] = 1 for l in range ( 1 , k ) : for i in range ( l , n ) : dp [ l ] [ i ] = 0 for j in range ( l - 1 , i ) : if ( arr [ j ] < arr [ i ] ) : dp [ l ] [ i ] += dp [ l - 1 ] [ j ] Sum = 0 i = k - 1 while i in list ( range ( n ) ) : Sum += dp [ k - 1 ] [ i ] i += 1 return Sum"
"def findMaxAverage ( arr , n , k ) : if k > n : return - 1 csum = [ 0 ] * n csum [ 0 ] = arr [ 0 ] for i in range ( 1 , n ) : csum [ i ] = csum [ i - 1 ] + arr [ i ] max_sum = csum [ k - 1 ] max_end = k - 1 i = k while i in list ( range ( n ) ) : curr_sum = csum [ i ] - csum [ i - k ] if curr_sum > max_sum : max_sum = curr_sum max_end = i i += 1 return max_end - k + 1"
def findNthTerm ( n ) : if ( n % 2 != 0 ) : n = ( n // 2 ) + 1 n = 2 * ( n - 1 ) print ( n ) else : n = n // 2 n = 2 * ( n - 1 ) print ( n // 2 )
"def maximumPoints ( arr , n , k , i ) : start = 0 if ( k > i ) : start = 0 else : start = i - k res = 0 j = start while ( j <= start + k and j < n ) : res = res + arr [ j ] j = j + 1 curr_sum = res j = start + k + 1 while ( j < n and j <= i + k ) : curr_sum = curr_sum + arr [ j ] - arr [ j - k - 1 ] res = max ( res , curr_sum ) j = j + 1 return res"
"def checksum ( n ) : n = int ( n ) if 0 == n % 3 : print ( int ( n / 3 - 1 ) , """" , int ( n / 3 ) , """" , int ( n / 3 + 1 ) ) else : print ( ""-1"" )"
"def normalSieve ( n ) : prime = [ 0 ] * int ( n / 2 ) i = 3 while ( n > i * i ) : if ( prime [ int ( i / 2 ) ] == 0 ) : j = i * i while ( j < n ) : prime [ int ( j / 2 ) ] = 1 j += i * 2 i += 2 print ( 2 , end = """" ) i = 3 while ( i < n ) : if ( prime [ int ( i / 2 ) ] == 0 ) : print ( i , end = """" ) i += 2"
def isDivisible ( n ) : while n // 100 : d = n % 10 n //= 10 n = abs ( n - ( d * 14 ) ) return ( 0 == n % 47 )
"def maxInt ( string ) : string2 = """" i = 0 while i in list ( range ( len ( string ) ) ) : if ( string [ i ] < '5' ) : string2 += str ( ( ord ( '9' ) - ord ( string [ i ] ) ) ) else : string2 += str ( string [ i ] ) i += 1 if ( string2 [ 0 ] == '0' ) : string2 [ 0 ] = '9' return string2"
"def half ( arr , n ) : flag = 0 i = 0 while i in list ( range ( n ) ) : if arr [ i ] % 2 == 0 : print ( arr [ i ] // 2 , end = """" ) else : if flag == 0 : print ( arr [ i ] // 2 , end = """" ) flag = 1 else : q = arr [ i ] // 2 q += 1 print ( q , end = """" ) flag = 0 i += 1"
def countSetBits ( n ) : n = n + 1 powerOf2 = 2 cnt = n // 2 while ( powerOf2 <= n ) : totalPairs = n // powerOf2 cnt = cnt + ( totalPairs // 2 ) * powerOf2 if ( totalPairs & 1 ) : cnt = cnt + ( n % powerOf2 ) else : cnt = cnt + 0 powerOf2 <<= 1 return cnt
"def findEncryptedArray ( arr , n ) : sum = 0 i = 0 while i in list ( range ( n ) ) : sum += arr [ i ] i += 1 for i in range ( n ) : print ( sum - arr [ i ] , end = """" )"
"def getMinimumSum ( arr , n ) : fMin = sys.maxsize sMin = sys.maxsize tMin = sys.maxsize i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] < fMin ) : tMin = sMin sMin = fMin fMin = arr [ i ] elif ( arr [ i ] < sMin ) : tMin = sMin sMin = arr [ i ] elif ( arr [ i ] < tMin ) : tMin = arr [ i ] i += 1 return ( fMin + sMin + tMin )"
"def countWays ( n ) : DP = [ 0 for i in range ( 0 , n + 1 ) ] DP [ 0 ] = DP [ 1 ] = DP [ 2 ] = 1 DP [ 3 ] = 2 i = 4 while i in list ( range ( n + 1 ) ) : DP [ i ] = DP [ i - 1 ] + DP [ i - 3 ] + DP [ i - 4 ] i += 1 return DP [ n ]"
"def maxDistance ( arr , n ) : mp = { } maxDict = 0 i = 0 while i in list ( range ( n ) ) : if arr [ i ] not in mp.keys ( ) : mp [ arr [ i ] ] = i else : maxDict = max ( maxDict , i - mp [ arr [ i ] ] ) i += 1 return maxDict"
"def findX ( A , B ) : j = 0 x = 0 while ( A or B ) : if ( ( A & 1 ) and ( B & 1 ) ) : x = x + ( 1 << j ) A >>= 1 B >>= 1 j = j + 1 return x"
"def noOfMoves ( arr , n ) : cnt = 0 maxCnt = 0 i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] == 1 ) : cnt += 1 else : if ( cnt != 0 ) : maxCnt = max ( maxCnt , cnt ) cnt = 0 i += 1 print ( maxCnt )"
"def closestNumber ( n , m ) : q = int ( n / m ) n1 = m * q if ( ( n * m ) > 0 ) : n2 = ( m * ( q + 1 ) ) else : n2 = ( m * ( q - 1 ) ) if ( abs ( n - n2 ) > abs ( n - n1 ) ) : return n1 return n2"
def sequence ( n ) : if 1 == n or n == 2 : return 1 else : return sequence ( sequence ( n - 1 ) ) + sequence ( n - sequence ( n - 1 ) )
"def pairInSortedRotated ( arr , n , x ) : i = 0 while i in list ( range ( n - 1 ) ) : if ( arr [ i ] > arr [ i + 1 ] ) : i += 1 break i += 1 l = ( i + 1 ) % n r = i while ( l != r ) : if ( arr [ l ] + arr [ r ] == x ) : return True if ( arr [ l ] + arr [ r ] < x ) : l = ( l + 1 ) % n else : r = ( n + r - 1 ) % n return False"
"def cocktailSort ( a ) : n = len ( a ) swapped = True start = 0 end = n - 1 while ( swapped == True ) : swapped = False for i in range ( start , end ) : if ( a [ i ] > a [ i + 1 ] ) : a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] swapped = True if ( swapped == False ) : break swapped = False end = end - 1 i = end - 1 while i in list ( range ( start - 1 ) ) : if ( a [ i ] > a [ i + 1 ] ) : a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] swapped = True i += - 1 start = start + 1"
"def printPairs ( arr , n , k ) : isPairFound = True for i in range ( 0 , n ) : j = 0 while j in list ( range ( n ) ) : if ( i != j and arr [ i ] % arr [ j ] == k ) : print ( ""("" , arr [ i ] , "","" , arr [ j ] , "")"" , sep = """" , end = """" ) isPairFound = True j += 1 return isPairFound"
"def findMaximumDiff ( a , n ) : ind1 = 0 for i in range ( n - 1 , - 1 , - 1 ) : if ( a [ 0 ] != a [ i ] ) : ind1 = i break ind2 = 0 i = 0 while i in list ( range ( n - 1 ) ) : if ( a [ n - 1 ] != a [ i ] ) : ind2 = ( n - 1 - i ) i += 1 break i += 1 return max ( ind1 , ind2 )"
def findSDSFunc ( n ) : DP = [ 0 ] * ( n + 1 ) DP [ 0 ] = 0 DP [ 1 ] = 1 i = 2 while i in list ( range ( n + 1 ) ) : if ( int ( i % 2 ) == 0 ) : DP [ i ] = DP [ int ( i / 2 ) ] else : DP [ i ] = ( DP [ int ( ( i - 1 ) / 2 ) ] + DP [ int ( ( i + 1 ) / 2 ) ] ) i += 1 return DP [ n ]
"def ifPossible ( arr , n ) : cp = [ 0 ] * n cp = arr cp.sort ( ) i = 0 while i in list ( range ( n ) ) : if ( not ( arr [ i ] == cp [ i ] ) and not ( arr [ n - 1 - i ] == cp [ i ] ) ) : i += 1 return False i += 1 return True"
def countIdenticalRows ( mat ) : count = 0 for i in range ( len ( mat ) ) : hs = dict ( ) j = 0 while j in list ( range ( len ( mat [ i ] ) ) ) : hs [ mat [ i ] [ j ] ] = 1 j += 1 if ( len ( hs ) == 1 ) : count += 1 return count
"def isExists ( a , n ) : freq = { i : 0 for i in a } Sum = 0 i = 0 while i in list ( range ( n ) ) : freq [ a [ i ] ] += 1 Sum += a [ i ] i += 1 if Sum % 2 == 0 : if freq [ Sum // 2 ] : return True return False"
"def maxSubArraySumRepeated ( a , n , k ) : max_so_far = - 2147483648 max_ending_here = 0 i = 0 while i in list ( range ( n * k ) ) : max_ending_here = max_ending_here + a [ i % n ] if ( max_so_far < max_ending_here ) : max_so_far = max_ending_here if ( max_ending_here < 0 ) : max_ending_here = 0 i += 1 return max_so_far"
"def relativeComplement ( arr1 , arr2 , n , m ) : i = 0 j = 0 while ( i < n and m > j ) : if ( arr1 [ i ] < arr2 [ j ] ) : print ( arr1 [ i ] , """" , end = """" ) i += 1 elif ( arr1 [ i ] > arr2 [ j ] ) : j += 1 elif ( arr1 [ i ] == arr2 [ j ] ) : i += 1 j += 1 while ( i < n ) : print ( arr1 [ i ] , """" , end = """" )"
"def splitStrings ( st , dl ) : word = """" num = 0 st += dl l = len ( st ) substr_list = [ ] i = 0 while i in list ( range ( l ) ) : if ( st [ i ] != dl ) : word += st [ i ] else : if ( len ( word ) != 0 ) : substr_list.append ( word ) word = """" i += 1 return substr_list"
"def minimizeDiff ( arr , n , k ) : max_element = max ( arr ) min_element = min ( arr ) if ( ( max_element - min_element ) <= k ) : return ( max_element - min_element ) avg = ( max_element + min_element ) // 2 i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] > avg ) : arr [ i ] -= k else : arr [ i ] += k i += 1 max_element = max ( arr ) min_element = min ( arr ) return ( max_element - min_element )"
"def breakSum ( n ) : if ( n == 0 or 1 == n ) : return n return max ( ( breakSum ( n // 2 ) + breakSum ( n // 3 ) + breakSum ( n // 4 ) ) , n )"
"def maximize ( A1 , A2 , n , x , y ) : c = [ 0 for i in range ( n ) ] Sum = 0 i = 0 while i in list ( range ( n ) ) : c [ i ] = A2 [ i ] - A1 [ i ] Sum += A1 [ i ] i += 1 c.sort ( ) c = c [ : : - 1 ] maxi = - 1 for i in range ( n ) : Sum += c [ i ] if ( i + 1 >= ( n - x ) ) : maxi = max ( Sum , maxi ) return maxi"
"def findMinimumOperation ( n , d , arrays ) : cnt = 0 first = - 10 ** 9 end = 10 ** 9 while ( n ) : arr = [ arrays [ cnt ] [ 0 ] , arrays [ cnt ] [ 1 ] ] arr = sorted ( arr ) first = max ( first , arr [ 0 ] ) end = min ( end , arr [ 1 ] ) cnt += 1 n -= 1 if ( end < first ) : print ( ""-1"" , end = """" ) else : if ( d >= first and d <= end ) : print ( ""0"" , end = """" ) else : print ( min ( abs ( first - d ) , abs ( d - end ) ) , end = """" )"
"def printExpansion ( str ) : suff = """" i = len ( str ) - 1 while i in list ( range ( - 1 ) ) : suff = suff + str [ i ] print ( suff , end = """" ) i += - 1"
"def countStr ( n , bCount , cCount ) : if ( bCount < 0 or cCount < 0 ) : return 0 if ( n == 0 ) : return 1 if ( bCount == 0 and cCount == 0 ) : return 1 res = countStr ( n - 1 , bCount , cCount ) res = res + countStr ( n - 1 , bCount - 1 , cCount ) res = res + countStr ( n - 1 , bCount , cCount - 1 ) return res"
"def checkForSorting ( arr , n ) : i = 0 while i in list ( range ( n - 1 ) ) : if ( arr [ i ] > arr [ i + 1 ] ) : if ( arr [ i ] - arr [ i + 1 ] == 1 ) : arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] else : i += 1 return False i += 1 return True"
"def countEvenSum ( arr , n ) : result = 0 i = 0 while i in list ( range ( n ) ) : sum = 0 for j in range ( i , n , 1 ) : sum = sum + arr [ j ] if ( sum % 2 == 0 ) : result = result + 1 i += 1 return ( result )"
"def countPiles ( n , a ) : occ = dict ( ) for i in a : if i in occ.keys ( ) : occ [ i ] += 1 else : occ [ i ] = 1 pile = 0 while ( len ( occ ) > 0 ) : pile = pile + 1 size = 0 toRemove = dict ( ) for tm in occ : mx = tm ct = occ [ tm ] use = min ( ct , mx - size + 1 ) occ [ mx ] -= use size = size + use if ( occ [ mx ] == 0 ) : toRemove [ mx ] = 1 for tm in toRemove : del occ [ tm ] return pile"
"def findSymPairs ( arr , row ) : hM = dict ( ) i = 0 while i in list ( range ( row ) ) : first = arr [ i ] [ 0 ] sec = arr [ i ] [ 1 ] if ( sec in hM.keys ( ) and hM [ sec ] == first ) : print ( ""("" , sec , "","" , first , "")"" ) else : hM [ first ] = sec i += 1"
"def complement ( num ) : i = 0 len = 0 comp = 0 temp = num while ( 1 ) : len += 1 num = int ( num / 10 ) if ( 0 == abs ( num ) ) : break num = temp comp = math.pow ( 10 , len ) - num return int ( comp )"
"def replace ( A , B ) : n , m = len ( A ) , len ( B ) count , i = 0 , 0 while i < n : j = 0 while j < m : if i + j >= n or A [ i + j ] != B [ j ] : break j = j + 1 if j == m : count = count + 1 i = i + m - 1 i = i + 1 return count"
"def countTriplets ( arr , n , a , b ) : ans = 0 for i in range ( 0 , n - 2 ) : for j in range ( i + 1 , n - 1 ) : k = j + 1 while k in list ( range ( n ) ) : if ( ( arr [ i ] + arr [ j ] + arr [ k ] >= a ) and ( arr [ i ] + arr [ j ] + arr [ k ] <= b ) ) : ans += 1 k += 1 return ans"
"def checkplusperfect ( x ) : temp = x n = 0 while ( x != 0 ) : x = x // 10 n = n + 1 x = temp sm = 0 while ( 0 != x ) : sm = sm + ( int ) ( math.pow ( x % 10 , n ) ) x = x // 10 return ( sm == temp )"
"def rightmostNonZero ( a , n ) : c5 = 0 for i in range ( n ) : while ( a [ i ] > 0 and a [ i ] % 5 == 0 ) : a [ i ] //= 5 c5 += 1 for i in range ( n ) : while ( c5 and a [ i ] > 0 and ( a [ i ] & 1 ) == 0 ) : a [ i ] >>= 1 c5 -= 1 ans = 1 i = 0 while i in list ( range ( n ) ) : ans = ( ans * a [ i ] % 10 ) % 10 i += 1 if ( c5 ) : ans = ( ans * 5 ) % 10 if ( ans ) : return ans return - 1"
def divisible ( num ) : n = len ( num ) sum = 0 i = 0 while i in list ( range ( n ) ) : sum += int ( num [ i ] ) i += 1 if ( sum % 3 == 0 ) : return 0 if ( n == 1 ) : return - 1 for i in range ( n ) : if ( sum % 3 == int ( num [ i ] ) % 3 ) : return 1 if ( n == 2 ) : return - 1 return 2
def firstDigit ( x ) : while ( 10 <= x ) : x = x // 10 return x
"def playGame ( arr , n ) : s = set ( ) for i in range ( n ) : s.add ( arr [ i ] ) return 1 if 0 == len ( s ) % 2 else 2"
"def FindAllElements ( n , k ) : sum = k A = [ 1 for i in range ( k ) ] i = k - 1 while ( i >= 0 ) : while ( sum + A [ i ] <= n ) : sum += A [ i ] A [ i ] *= 2 i -= 1 if ( sum != n ) : print ( ""Impossible"" ) else : i = 0 while i in list ( range ( k ) ) : print ( A [ i ] , end = '' ) i += 1"
"def LeibnizHarmonicTriangle ( n ) : C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] for i in range ( 0 , n + 1 ) : for j in range ( 0 , min ( i , n ) + 1 ) : if ( j == 0 or j == i ) : C [ i ] [ j ] = 1 else : C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) i = 1 while i in list ( range ( n + 1 ) ) : for j in range ( 1 , i + 1 ) : print ( ""1/"" , end = """" ) print ( i * C [ i - 1 ] [ j - 1 ] , end = """" ) print ( ) i += 1"
"def findTriplets ( arr , n ) : found = False arr.sort ( ) i = 0 while i in list ( range ( n - 1 ) ) : l = i + 1 r = n - 1 x = arr [ i ] while ( l < r ) : if ( x + arr [ l ] + arr [ r ] == 0 ) : print ( x , arr [ l ] , arr [ r ] ) l += 1 r -= 1 found = True elif ( x + arr [ l ] + arr [ r ] < 0 ) : l += 1 else : r -= 1 i += 1 if ( found == False ) : print ( ""NoTripletFound"" )"
"def longestSubarray ( input , length ) : prev = - 1 prevCount = 0 currentCount = 1 longest = 1 current = input [ 0 ] i = 1 while i in list ( range ( length ) ) : next = input [ i ] if next == current : currentCount += 1 elif next == prev : prevCount += currentCount prev = current current = next currentCount = 1 else : longest = max ( longest , currentCount + prevCount ) prev = current prevCount = currentCount current = next currentCount = 1 i += 1 return max ( longest , currentCount + prevCount )"
"def findK ( n , k ) : a = list ( ) i = 1 while i < n : a.append ( i ) i = i + 2 i = 2 while n > i : a.append ( i ) i = i + 2 return ( a [ k - 1 ] )"
"def reverseFibonacci ( n ) : a = [ 0 ] * n a [ 0 ] = 0 a [ 1 ] = 1 for i in range ( 2 , n ) : a [ i ] = a [ i - 2 ] + a [ i - 1 ] i = n - 1 while i in list ( range ( - 1 ) ) : print ( a [ i ] , end = """" ) i += - 1"
"def largestPalinSub ( s ) : res = """" mx = s [ 0 ] for i in range ( 1 , len ( s ) ) : mx = max ( mx , s [ i ] ) i = 0 while i in list ( range ( len ( s ) ) ) : if s [ i ] == mx : res += s [ i ] i += 1 return res"
"def findLen ( arr , n , m ) : filter = [ ] i = 0 while i in list ( range ( n ) ) : if ( ( arr [ i ] & m ) == m ) : filter.append ( arr [ i ] ) i += 1 if ( len ( filter ) == 0 ) : return 0 c_and = filter [ 0 ] for i in range ( 1 , len ( filter ) ) : c_and &= filter [ i ] if ( c_and == m ) : return len ( filter )"
"def gcd ( a , b ) : while 0 != b : r = a % b a , b = b , r return a"
"def sqrtSearch ( low , high , N ) : if ( low <= high ) : mid = ( low + high ) // 2 if ( ( mid * mid <= N ) and ( N < ( mid + 1 ) * ( mid + 1 ) ) ) : return mid elif ( mid * mid < N ) : return sqrtSearch ( mid + 1 , high , N ) else : return sqrtSearch ( low , mid - 1 , N ) return low"
"def isSubSeqDivisible ( st ) : l = len ( st ) arr = [ 0 ] * l for i in range ( 0 , l ) : for j in range ( i , l ) : k = j while k in list ( range ( l ) ) : if ( arr [ i ] % 8 == 0 ) : k += 1 return True elif ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 and i != j ) : k += 1 return True elif ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 and i != j and j != k and i != k ) : k += 1 return True k += 1 return False"
"def findElement ( arr , size ) : right_sum , left_sum = 0 , 0 i = 1 while i in list ( range ( size ) ) : right_sum += arr [ i ] i += 1 i , j = 0 , 1 while j < size : right_sum -= arr [ j ] left_sum += arr [ i ] if left_sum == right_sum : return arr [ i + 1 ] j += 1 i += 1 return - 1"
"def count_of_ways ( n ) : count = 0 for i in range ( 0 , n + 1 ) : for j in range ( 0 , n + 1 ) : k = 0 while k in list ( range ( n + 1 ) ) : if ( i + j + k == n ) : count = count + 1 k += 1 return count"
"def largestSumOfAverages ( A , K ) : n = len ( A ) pre_sum = [ 0 ] * ( n + 1 ) pre_sum [ 0 ] = 0 for i in range ( n ) : pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] dp = [ 0 ] * n sum = 0 for i in range ( n ) : dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i ) k = 0 while k in list ( range ( K - 1 ) ) : for i in range ( n ) : for j in range ( i + 1 , n ) : dp [ i ] = max ( dp [ i ] , ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] ) k += 1 return int ( dp [ 0 ] )"
"def countFreq ( a , n ) : hm = { } i = 0 while i in list ( range ( n ) ) : hm [ a [ i ] ] = hm.get ( a [ i ] , 0 ) + 1 i += 1 st = set ( ) for x in hm : st.add ( ( x , hm [ x ] ) ) cumul = 0 for x in sorted ( st ) : cumul += x [ 1 ] print ( x [ 0 ] , cumul )"
"def countPairs ( arr , n ) : ans = 0 for i in range ( 0 , n ) : j = i + 1 while j in list ( range ( n ) ) : if ( arr [ i ] == arr [ j ] ) : ans += 1 j += 1 return ans"
"def findNumber ( s , d ) : num = """" val = s // d rem = s % d for i in range ( 1 , d - rem + 1 ) : num = num + str ( val ) if ( rem ) : val += 1 i = d - rem + 1 while i in list ( range ( d + 1 ) ) : num = num + str ( val ) i += 1 return num"
"def getSingle ( arr , n ) : ones = 0 twos = 0 i = 0 while i in list ( range ( n ) ) : twos = twos | ( ones & arr [ i ] ) ones = ones ^ arr [ i ] common_bit_mask = ~ ( ones & twos ) ones &= common_bit_mask twos &= common_bit_mask i += 1 return ones"
def per ( n ) : if ( 0 == n ) : return 3 if ( n == 1 ) : return 0 if ( n == 2 ) : return 2 return per ( n - 2 ) + per ( n - 3 )
"def computeTotient ( n ) : phi = [ ] for i in range ( n + 2 ) : phi.append ( 0 ) i = 1 while i in list ( range ( n + 1 ) ) : phi [ i ] = i i += 1 for p in range ( 2 , n + 1 ) : if ( phi [ p ] == p ) : phi [ p ] = p - 1 for i in range ( 2 * p , n + 1 , p ) : phi [ i ] = ( phi [ i ] // p ) * ( p - 1 ) for i in range ( 1 , n + 1 ) : print ( ""Totientof"" , i , ""is"" , phi [ i ] )"
"def computeLPSArray ( pat , M , lps ) : len = 0 lps [ 0 ] i = 1 while i < M : if pat [ i ] != pat [ len ] : if len != 0 : len = lps [ len - 1 ] else : lps [ i ] = 0 i += 1 else : len += 1 lps [ i ] = len i += 1"
"def display ( n ) : for i in range ( 1 , n + 1 ) : k = i j = 1 while j in list ( range ( i + 1 ) ) : if k % 2 == 0 : print ( j , end = '' ) else : print ( '*' , end = '' ) k -= 1 j += 1 print ( )"
"def rearrange ( arr , n ) : temp = n * [ None ] small , large = 0 , n - 1 flag = True i = 0 while i in list ( range ( n ) ) : if flag is True : temp [ i ] = arr [ large ] large -= 1 else : temp [ i ] = arr [ small ] small += 1 flag = bool ( 1 - flag ) i += 1 for i in range ( n ) : arr [ i ] = temp [ i ] return arr"
"def TotalWays ( n , s , k ) : dp = [ 0 ] * n dp [ s - 1 ] = 1 i = s while i in list ( range ( n ) ) : idx = max ( s - 1 , i - k ) for j in range ( idx , i ) : dp [ i ] += dp [ j ] i += 1 return dp [ n - 1 ]"
"def maxSumSubarrayRemovingOneEle ( arr , n ) : fw = [ 0 for k in range ( n ) ] bw = [ 0 for k in range ( n ) ] cur_max , max_so_far = arr [ 0 ] , arr [ 0 ] for i in range ( n ) : cur_max = max ( arr [ i ] , cur_max + arr [ i ] ) max_so_far = max ( max_so_far , cur_max ) fw [ i ] = cur_max cur_max = max_so_far = bw [ n - 1 ] = arr [ n - 1 ] i = n - 2 while i >= 0 : cur_max = max ( arr [ i ] , cur_max + arr [ i ] ) max_so_far = max ( max_so_far , cur_max ) bw [ i ] = cur_max i -= 1 fans = max_so_far i = 1 while i in list ( range ( n - 1 ) ) : fans = max ( fans , fw [ i - 1 ] + bw [ i + 1 ] ) i += 1 return fans"
"def validateStackSequence ( pushed , popped ) : j = 0 stack = [ ] for x in pushed : stack.append ( x ) while stack and len ( popped ) > j and stack [ - 1 ] == popped [ j ] : stack.pop ( ) j = j + 1 return j == len ( popped )"
"def circlearea ( a ) : if 0 > a : return - 1 A = ( 3.14 * 3 * pow ( a , 2 ) ) / 4 return A"
def countWays ( n ) : dp = [ [ 0 ] * ( n + 1 ) for i in range ( 2 ) ] dp [ 0 ] [ 1 ] = 1 dp [ 1 ] [ 1 ] = 2 i = 2 while i in list ( range ( n + 1 ) ) : dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] dp [ 1 ] [ i ] = ( dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ) i += 1 return dp [ 0 ] [ n ] + dp [ 1 ] [ n ]
"def pairwiseDifference ( arr , n ) : i = 0 while i in list ( range ( n - 1 ) ) : diff = abs ( arr [ i ] - arr [ i + 1 ] ) print ( diff , end = """" ) i += 1"
"def MaximumNumbers ( string ) : n = len ( string ) remIndex = [ - 1 for i in range ( 3 ) ] remIndex [ 0 ] = 0 res = [ - 1 for i in range ( n + 1 ) ] r = 0 i = 0 while i in list ( range ( n + 1 ) ) : r = ( r + ord ( string [ i - 1 ] ) - ord ( '0' ) ) % 3 res [ i ] = res [ i - 1 ] if ( remIndex [ r ] != - 1 ) : res [ i ] = max ( res [ i ] , res [ remIndex [ r ] ] + 1 ) remIndex [ r ] = i + 1 i += 1 return res [ n ]"
"def minPower ( n , x ) : if ( x == 1 ) : return n ans = 0 while ( n > 0 ) : ans = ans + ( n % x ) n //= x return ans"
"def valueofX ( ar , n ) : summ = sum ( ar ) if ( 0 == summ % n ) : return summ // n else : A = summ // n B = summ // n + 1 ValueA = 0 ValueB = 0 i = 0 while i in list ( range ( n ) ) : ValueA += ( ar [ i ] - A ) * ( ar [ i ] - A ) ValueB += ( ar [ i ] - B ) * ( ar [ i ] - B ) if ( ValueA < ValueB ) : return A else : return B i += 1"
"def getWinner ( string , length ) : total = 0 i = 0 while i in list ( range ( length ) ) : if ( string [ i ] == 'S' ) : total += 1 i += 1 if ( ( total % 2 ) == 1 ) : return ""First"" return ""Second"""
def fix ( A ) : s = set ( ) i = 0 while i in list ( range ( len ( A ) ) ) : s.add ( A [ i ] ) i += 1 for i in range ( len ( A ) ) : if i in s : A [ i ] = i else : A [ i ] = - 1 return A
"def minOperations ( str , n ) : count = 0 i = 0 while i in list ( range ( n - 1 ) ) : if ( str [ i ] != str [ i + 1 ] ) : count += 1 i += 1 return ( count + 1 ) // 2"
"def minproduct ( a , b , n , k ) : diff = 0 res = 0 i = 0 while i in list ( range ( n ) ) : pro = a [ i ] * b [ i ] res = res + pro if ( pro < 0 and b [ i ] < 0 ) : temp = ( a [ i ] + 2 * k ) * b [ i ] elif ( pro < 0 and a [ i ] < 0 ) : temp = ( a [ i ] - 2 * k ) * b [ i ] elif ( pro > 0 and a [ i ] < 0 ) : temp = ( a [ i ] + 2 * k ) * b [ i ] elif ( pro > 0 and a [ i ] > 0 ) : temp = ( a [ i ] - 2 * k ) * b [ i ] d = abs ( pro - temp ) if ( d > diff ) : diff = d i += 1 return res - diff"
"def countPoints ( n , m , a , b , x , y ) : a.sort ( ) b.sort ( ) j , count = 0 , 0 i = 0 while i in list ( range ( n ) ) : while j < m : if a [ i ] + y < b [ j ] : i += 1 break if ( b [ j ] >= a [ i ] - x and b [ j ] <= a [ i ] + y ) : count += 1 j += 1 i += 1 break else : j += 1 i += 1 return count"
"def getPosition ( a , n , m ) : for i in range ( n ) : a [ i ] = ( a [ i ] // m + ( a [ i ] % m != 0 ) ) ans , maxx = - 1 , - 1 i = n - 1 while i in list ( range ( - 1 ) ) : if ( maxx < a [ i ] ) : maxx = a [ i ] ans = i i += - 1 return ans + 1"
def phi ( n ) : result = n p = 2 while ( p * p <= n ) : if ( n % p == 0 ) : while ( n % p == 0 ) : n = int ( n / p ) result -= int ( result / p ) p += 1 if ( 1 < n ) : result -= int ( result / n ) return result
"def countways ( a , n ) : cnt = [ 0 for i in range ( n ) ] s = 0 s = sum ( a ) if ( s % 3 != 0 ) : return 0 s //= 3 ss = 0 for i in range ( n - 1 , - 1 , - 1 ) : ss += a [ i ] if ( ss == s ) : cnt [ i ] = 1 for i in range ( n - 2 , - 1 , - 1 ) : cnt [ i ] += cnt [ i + 1 ] ans = 0 ss = 0 i = 0 while i in list ( range ( n - 2 ) ) : ss += a [ i ] if ( ss == s ) : ans += cnt [ i + 2 ] i += 1 return ans"
"def result ( n , k , t ) : if ( t <= k ) : print ( t ) elif ( n >= t ) : print ( k ) else : temp = t - n temp = k - temp print ( temp )"
"def calculate ( a , b , n , m ) : mul = 1 for i in range ( m ) : if ( b [ i ] != 0 ) : mul = mul * b [ i ] i = 0 while i in list ( range ( n ) ) : x = math.floor ( a [ i ] / mul ) print ( x , end = """" ) i += 1"
"def subsetDifference ( n ) : s = int ( n * ( n + 1 ) / 2 ) if n % 4 == 0 : print ( ""Firstsubsetsum="" , int ( s / 2 ) ) print ( ""Secondsubsetsum="" , int ( s / 2 ) ) print ( ""Difference="" , 0 ) else : if n % 4 == 1 or 2 == n % 4 : print ( ""Firstsubsetsum="" , int ( s / 2 ) ) print ( ""Secondsubsetsum="" , int ( s / 2 ) + 1 ) print ( ""Difference="" , 1 ) else : print ( ""Firstsubsetsum="" , int ( s / 2 ) ) print ( ""Secondsubsetsum="" , int ( s / 2 ) ) print ( ""Difference="" , 0 )"
"def countOddPair ( A , N ) : count = 0 i = 0 while i in list ( range ( N ) ) : if ( A [ i ] % 2 != 1 ) : count += 1 i += 1 evenPairCount = count * ( count - 1 ) / 2 totPairs = N * ( N - 1 ) / 2 return ( int ) ( totPairs - evenPairCount )"
"def countHexadecimal ( L , R ) : count = 0 i = L while i in list ( range ( R + 1 ) ) : if ( i >= 10 and i <= 15 ) : count += 1 elif ( i > 15 ) : k = i while ( k != 0 ) : if ( k % 16 >= 10 ) : count += 1 k = k // 16 i += 1 return count"
"def countSolutions ( n , val ) : total = 0 if n == 1 and val >= 0 : return 1 i = 0 while i in list ( range ( val + 1 ) ) : total += countSolutions ( n - 1 , val - i ) i += 1 return total"
"def LongestFibSubseq ( A , n ) : S = set ( A ) maxLen = 0 i = 0 while i in list ( range ( n ) ) : for j in range ( i + 1 , n ) : x = A [ j ] y = A [ i ] + A [ j ] length = 2 while y in S : z = x + y x = y y = z length += 1 maxLen = max ( maxLen , length ) i += 1 return maxLen if maxLen >= 3 else 0"
"def countWays ( index , cnt , dp , n , m , k ) : if ( index == n ) : if ( cnt == k ) : return 1 else : return 0 if ( dp [ index ] [ cnt ] != - 1 ) : return dp [ index ] [ cnt ] ans = 0 ans = ans + countWays ( index + 1 , cnt , dp , n , m , k ) ans = ans + ( m - 1 ) * countWays ( index + 1 , cnt + 1 , dp , n , m , k ) dp [ index ] [ cnt ] = ans return dp [ index ] [ cnt ]"
def evenlength ( n ) : res = n j = len ( n ) - 1 while j in list ( range ( - 1 ) ) : res += n [ j ] j += - 1 return res
"def maxSubStrings ( s , k ) : maxSubStr = 0 n = len ( s ) c = 0 while c in list ( range ( 27 ) ) : ch = chr ( ord ( 'a' ) + c ) curr = 0 for i in range ( n - k ) : if ( s [ i ] != ch ) : c += 1 continue cnt = 0 while ( i < n and s [ i ] == ch and cnt != k ) : i += 1 cnt += 1 i -= 1 if ( cnt == k ) : curr += 1 maxSubStr = max ( maxSubStr , curr ) c += 1 return maxSubStr"
"def findDiff ( arr , n ) : arr.sort ( ) count = 0 max_count = 0 min_count = n i = 0 while i in list ( range ( ( n - 1 ) ) ) : if arr [ i ] == arr [ i + 1 ] : count += 1 i += 1 continue else : max_count = max ( max_count , count ) min_count = min ( min_count , count ) count = 0 i += 1 return max_count - min_count"
"def SumDivisible ( n , k ) : sum = 0 position = 1 while ( n > 0 ) : if ( position % 2 == 1 ) : sum = sum + n % 10 n = n // 10 position = position + 1 if ( sum % k == 0 ) : return True return False"
"def encodedChar ( string , k ) : n = len ( string ) i = 0 while i < n : j = i length = 0 freq = 0 while j < n and string [ j ].isalpha ( ) : j += 1 length += 1 while j < n and string [ j ].isdigit ( ) : freq = freq * 10 + int ( string [ j ] ) j += 1 num = freq * length if k <= num : k -= 1 k %= length return string [ i + k ] else : k -= num i = j return string [ k - 1 ]"
"def search ( arr , x ) : n = len ( arr ) j = 0 while j in list ( range ( n ) ) : if ( x == arr [ j ] ) : j += 1 return j j += 1 return - 1"
"def minCost ( cost , n ) : totalCost = 0 boardingBus = 0 i = 1 while i in list ( range ( n ) ) : if ( cost [ boardingBus ] > cost [ i ] ) : totalCost += ( ( i - boardingBus ) * cost [ boardingBus ] ) boardingBus = i i += 1 totalCost += ( ( n - boardingBus ) * cost [ boardingBus ] ) return totalCost"
"def pattern ( rows_no ) : for i in range ( 1 , rows_no + 1 ) : k = 1 while k in list ( range ( i ) ) : print ( """" , end = """" ) k += 1 for j in range ( i , rows_no + 1 ) : print ( j , end = """" ) print ( ) for i in range ( rows_no - 1 , 0 , - 1 ) : for k in range ( 1 , i ) : print ( """" , end = """" ) for j in range ( i , rows_no + 1 ) : print ( j , end = """" ) print ( )"
"def findSubSeq ( arr , n , sum ) : i = n - 1 while i in list ( range ( - 1 ) ) : if ( sum < arr [ i ] ) : arr [ i ] = - 1 else : sum -= arr [ i ] i += - 1 for i in range ( n ) : if ( arr [ i ] != - 1 ) : print ( arr [ i ] , end = """" )"
"def findNumbers ( N ) : i = 1 while ( N >= i ) : print ( ( i * i * i ) , end = """" ) i += 1"
"def findTheNumber ( n ) : if ( n == 1 ) : print ( ""Impossible"" ) return i = 0 while i in list ( range ( n - 1 ) ) : print ( ""5"" , end = """" ) i += 1 print ( ""4"" )"
def productPrimeFactors ( n ) : product = 1 if ( n % 2 == 0 ) : product *= 2 while ( n % 2 == 0 ) : n = n / 2 i = 3 while i in list ( range ( int ( math.sqrt ( n ) ) ) ) : if ( n % i == 0 ) : product = product * i while ( n % i == 0 ) : n = n / i i += 2 if ( n > 2 ) : product = product * n return product
"def maxLen ( arr ) : max_len = 0 for i in range ( len ( arr ) ) : curr_sum = 0 j = i while j in list ( range ( len ( arr ) ) ) : curr_sum += arr [ j ] if curr_sum == 0 : max_len = max ( max_len , j - i + 1 ) j += 1 return max_len"
"def sumoflength ( arr , n ) : s = [ ] j = 0 ans = 0 i = 0 while i in list ( range ( n ) ) : while ( j < n and ( arr [ j ] not in s ) ) : s.append ( arr [ j ] ) j += 1 ans += ( ( j - i ) * ( j - i + 1 ) ) // 2 s.remove ( arr [ i ] ) i += 1 return ans"
"def min_noOf_operation ( arr , n , k ) : res = 0 i = 1 while i in list ( range ( n ) ) : noOfSubtraction = 0 if ( arr [ i ] > arr [ i - 1 ] ) : noOfSubtraction = ( arr [ i ] - arr [ i - 1 ] ) / k if ( ( arr [ i ] - arr [ i - 1 ] ) % k != 0 ) : noOfSubtraction += 1 arr [ i ] = arr [ i ] - k * noOfSubtraction res = res + noOfSubtraction i += 1 return int ( res )"
"def countP ( n , k ) : dp = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] for i in range ( n + 1 ) : dp [ i ] [ 0 ] = 0 i = 0 while i in list ( range ( k + 1 ) ) : dp [ 0 ] [ k ] = 0 i += 1 for i in range ( 1 , n + 1 ) : for j in range ( 1 , k + 1 ) : if ( j == 1 or i == j ) : dp [ i ] [ j ] = 1 else : dp [ i ] [ j ] = ( j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ) return dp [ n ] [ k ]"
"def centeredHexagonalSeries ( n ) : i = 1 while i in list ( range ( n + 1 ) ) : print ( 3 * i * ( i - 1 ) + 1 , end = """" ) i += 1"
"def averageOdd ( n ) : if ( 0 == n % 2 ) : print ( ""InvalidInput"" ) return - 1 sm = 0 count = 0 while ( n >= 1 ) : count = count + 1 sm = sm + n n = n - 2 return sm // count"
def sumOfSubstrings ( num ) : n = len ( num ) sumofdigit = [ ] sumofdigit.append ( int ( num [ 0 ] ) ) res = sumofdigit [ 0 ] i = 1 while i in list ( range ( n ) ) : numi = int ( num [ i ] ) sumofdigit.append ( ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] ) res += sumofdigit [ i ] i += 1 return res
"def findNumbers ( arr , n ) : num = [ 0 for i in range ( n ) ] b_minus_a = arr [ n - 1 ] - arr [ 1 ] num [ 1 ] = ( arr [ 0 ] + b_minus_a ) // 2 num [ 0 ] = arr [ 0 ] - num [ 1 ] for i in range ( 1 , ( n - 2 ) + 1 ) : num [ i + 1 ] = arr [ i ] - num [ 0 ] print ( ""Numbersare:"" , end = """" ) i = 0 while i in list ( range ( n ) ) : print ( num [ i ] , end = "","" ) i += 1"
"def checkType ( arr , n ) : if ( arr [ 0 ] <= arr [ 1 ] and arr [ n - 2 ] <= arr [ n - 1 ] ) : print ( ""Increasing"" ) elif ( arr [ 1 ] <= arr [ 0 ] and arr [ n - 2 ] >= arr [ n - 1 ] ) : print ( ""Decreasing"" ) elif ( arr [ 0 ] <= arr [ 1 ] and arr [ n - 2 ] >= arr [ n - 1 ] ) : print ( ""Increasingthendecreasing"" ) else : print ( ""Decreasingthenincreasing"" )"
"def countPairs ( arr1 , arr2 , m , n , x ) : count = 0 us = set ( ) i = 0 while i in list ( range ( m ) ) : us.add ( arr1 [ i ] ) i += 1 for j in range ( n ) : if x - arr2 [ j ] in us : count += 1 return count"
"def count ( arr , n , x ) : if ( x == 1 ) : ans = pow ( 2 , n ) - 1 return ans count = 0 i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] % x == 0 ) : count += 1 i += 1 ans = pow ( 2 , count ) - 1 return ans"
def isEqualBlock ( n ) : first_bit = n % 2 first_count = 1 n = n // 2 while n % 2 == first_bit and n > 0 : n = n // 2 first_count += 1 if n == 0 : return False while 0 < n : first_bit = n % 2 curr_count = 1 n = n // 2 while n % 2 == first_bit : n = n // 2 curr_count += 1 if curr_count != first_count : return False return True
"def find_Solution ( x , n ) : Sum = x e = 2 o = 1 p = 1 i = 2 while i in list ( range ( n + 1 ) ) : p += 2 Sum += ( o / e ) * ( pow ( x , p ) / p ) o = o * ( o + 2 ) e = e * ( e + 2 ) i += 1 print ( round ( Sum , 10 ) )"
"def countEvenSum ( arr , n ) : temp = [ 1 , 0 ] result = 0 sum = 0 i = 0 while i in list ( range ( n ) ) : sum = ( ( sum + arr [ i ] ) % 2 + 2 ) % 2 temp [ sum ] += 1 i += 1 result = result + ( temp [ 0 ] * ( temp [ 0 ] - 1 ) // 2 ) result = result + ( temp [ 1 ] * ( temp [ 1 ] - 1 ) // 2 ) return ( result )"
"def groupElements ( arr , n ) : visited = [ False ] * n for i in range ( 0 , n ) : visited [ i ] = False i = 0 while i in list ( range ( n ) ) : if ( visited [ i ] == False ) : print ( arr [ i ] , end = """" ) for j in range ( i + 1 , n ) : if ( arr [ i ] == arr [ j ] ) : print ( arr [ i ] , end = """" ) visited [ j ] = True i += 1"
"def min_elimination ( n , arr ) : countOdd = 0 i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] % 2 ) : countOdd += 1 i += 1 return min ( countOdd , n - countOdd )"
"def countPairs ( str1 ) : result = 0 n = len ( str1 ) for i in range ( 0 , n ) : j = i + 1 while j in list ( range ( n ) ) : if ( abs ( ord ( str1 [ i ] ) - ord ( str1 [ j ] ) ) == abs ( i - j ) ) : result += 1 j += 1 return result"
"def smallestSubWithSum ( arr , n , x ) : curr_sum = 0 min_len = n + 1 start = 0 end = 0 while ( n > end ) : while ( curr_sum <= x and end < n ) : if ( curr_sum <= 0 and x > 0 ) : start = end curr_sum = 0 curr_sum += arr [ end ] end += 1 while ( curr_sum > x and start < n ) : if ( end - start < min_len ) : min_len = end - start curr_sum -= arr [ start ] start += 1 return min_len"
"def maxEvenLenSum ( arr , n ) : if ( n < 2 ) : return 0 dp = [ 0 for i in range ( n ) ] dp [ n - 1 ] = 0 dp [ n - 2 ] = arr [ n - 2 ] + arr [ n - 1 ] i = n - 3 while i in list ( range ( - 1 ) ) : dp [ i ] = arr [ i ] + arr [ i + 1 ] if ( dp [ i + 2 ] > 0 ) : dp [ i ] += dp [ i + 2 ] i += - 1 maxSum = max ( dp ) return maxSum"
"def find_k ( a , b ) : if ( 0 == ( a + b ) % 2 ) : return ( ( a + b ) // 2 ) return - 1"
"def findMaxRec ( A , n ) : if ( 1 == n ) : return A [ 0 ] return max ( A [ n - 1 ] , findMaxRec ( A , n - 1 ) )"
"def maxEvenSubarray ( array , N ) : ans = 0 count = 0 i = 0 while i in list ( range ( N ) ) : if array [ i ] % 2 == 0 : count += 1 ans = max ( ans , count ) else : count = 0 i += 1 ans = max ( ans , count ) return ans"
"def isPossible ( Sx , Sy , Dx , Dy , x , y ) : if ( 0 == abs ( Sx - Dx ) % x and abs ( Sy - Dy ) % y == 0 and ( abs ( Sx - Dx ) / x ) % 2 == ( abs ( Sy - Dy ) / y ) % 2 ) : return True return False"
"def digit_product_Sum ( N ) : a = [ 0 ] * ( N + 1 ) product = 1 a [ 0 ] = 1 for i in range ( 1 , N + 1 ) : product = int ( a [ i - 1 ] / 10 ) if ( product == 0 ) : product = 1 else : product = a [ i - 1 ] % 10 val = int ( a [ i - 1 ] / 10 ) if ( val == 0 ) : val = a [ i - 1 ] a [ i ] = a [ i - 1 ] + ( val * product ) i = 0 while i in list ( range ( N ) ) : print ( a [ i ] , end = """" ) i += 1"
"def solve ( n ) : ans = n - 1 i = 2 while i in list ( range ( n // 2 + 1 ) ) : j = n k = 0 while i > 1 and j > 1 : k += 1 if j >= i : j -= i else : i -= j if i < 1 or j < 1 : i += 1 continue elif i == 1 : ans = min ( ans , k + j - 1 ) elif j == 1 : ans = min ( ans , k + i - 1 ) i += 1 return ans"
"def countX ( n ) : binary = ""{0:b}"".format ( n ) count = 0 i = 0 while i in list ( range ( len ( binary ) ) ) : if ( binary [ i ] == '1' ) : count += 1 i += 1 answer = int ( pow ( 2 , count ) ) return answer"
"def minDist ( arr , n , x , y ) : min_dist = 99999999 i = 0 while i in list ( range ( n ) ) : for j in range ( i + 1 , n ) : if ( x == arr [ i ] and y == arr [ j ] or y == arr [ i ] and x == arr [ j ] ) and min_dist > abs ( i - j ) : min_dist = abs ( i - j ) i += 1 return min_dist i += 1"
"def heptdiagonal ( a ) : if ( 0 > a ) : return - 1 d = 1.802 * a return round ( d , 3 )"
"def maxDiff ( arr , n ) : diff = arr [ 1 ] - arr [ 0 ] curr_sum = diff max_sum = curr_sum i = 1 while i in list ( range ( n - 1 ) ) : diff = arr [ i + 1 ] - arr [ i ] if ( curr_sum > 0 ) : curr_sum += diff else : curr_sum = diff if ( curr_sum > max_sum ) : max_sum = curr_sum i += 1 return max_sum"
"def concatenate ( a , b , c , n1 , n2 ) : i = - 1 for i in range ( n1 ) : c [ i ] = a [ i ] j = 0 while j in list ( range ( n2 ) ) : c [ i ] = b [ j ] i += 1 j += 1"
"def countSubArrays ( arr , x , n ) : count = 0 start = - 1 ; end = - 1 i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] < x ) : if ( start == - 1 ) : start = i end = i else : end = i else : if ( start != - 1 and end != - 1 ) : length = end - start + 1 count = count + ( ( length * ( length + 1 ) ) / 2 ) start = - 1 end = - 1 i += 1 if ( start != - 1 and end != - 1 ) : length = end - start + 1 count = count + ( ( length * ( length + 1 ) ) / 2 ) return count"
"def pairs ( arr , n , k ) : smallest = 999999999999 count = 0 i = 0 while i in list ( range ( n ) ) : for j in range ( i + 1 , n ) : if abs ( arr [ i ] + arr [ j ] - k ) < smallest : smallest = abs ( arr [ i ] + arr [ j ] - k ) count = 1 elif abs ( arr [ i ] + arr [ j ] - k ) == smallest : count += 1 i += 1 print ( ""MinimalValue="" , smallest ) print ( ""TotalPairs="" , count )"
"def solve ( A , n ) : cnt = 0 parent = [ None ] * ( n + 1 ) vis = [ None ] * ( n + 1 ) for i in range ( 0 , n + 1 ) : parent [ i ] = - 1 vis [ i ] = 0 i = 0 while i in list ( range ( n ) ) : j = i if ( parent [ j ] == - 1 ) : while ( parent [ j ] == - 1 ) : parent [ j ] = i j = ( j + A [ j ] + 1 ) % n if ( parent [ j ] == i ) : while ( vis [ j ] == 0 ) : vis [ j ] = 1 cnt = cnt + 1 j = ( j + A [ j ] + 1 ) % n i += 1 return cnt"
def evenFib ( n ) : if ( 1 > n ) : return n if ( n == 1 ) : return 2 return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) )
"def solve ( li , n , s , total , cnt ) : for i in li : value = i * n + total if s < value : break if n - 1 : subli = li [ : ] subli.remove ( i ) r = range ( n - 1 , 0 , - 1 ) minimum = value + sum ( i * j for i , j in zip ( r , subli ) ) maximum = value + sum ( i * j for i , j in zip ( r , subli [ : : - 1 ] ) ) if minimum <= s <= maximum : solve ( subli , n - 1 , s , value , cnt ) elif value == s : cnt [ 0 ] += 1 break"
"def smallestIndex ( a , n ) : right1 = 0 right0 = 0 i = 0 while i in list ( range ( n ) ) : if ( a [ i ] == 1 ) : right1 = i else : right0 = i i += 1 return min ( right1 , right0 )"
"def findMinRooms ( slots , n , m ) : counts = [ 0 ] * m i = 0 while i in list ( range ( n ) ) : for j in range ( m ) : if ( slots [ i ] [ j ] == '1' ) : counts [ j ] += 1 i += 1 return max ( counts )"
def summation ( n ) : abs_sum = n * ( n + 1 ) // 2 sign = 1 if ( 0 == ( n + 1 ) % 2 ) else - 1 result_sum = sign * abs_sum return result_sum
"def maxProduct ( arr , n ) : if n < 3 : return - 1 max_product = - ( sys.maxsize - 1 ) for i in range ( 0 , n - 2 ) : j = i + 1 while j in list ( range ( n - 1 ) ) : for k in range ( j + 1 , n ) : max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) j += 1 return max_product"
def divisorSum ( n ) : sum = 0 i = 1 while i in list ( range ( n + 1 ) ) : sum += int ( n / i ) * i i += 1 return int ( sum )
"def MinOfCubed ( k ) : if ( k < 8 ) : return k res = k i = 1 while i in list ( range ( k + 1 ) ) : if ( ( i * i * i ) > k ) : i += 1 return res res = min ( res , MinOfCubed ( k - ( i * i * i ) ) + 1 ) i += 1 return res"
"def maxAbsDiff ( arr , n ) : minEle = arr [ 0 ] maxEle = arr [ 0 ] i = 1 while i in list ( range ( n ) ) : minEle = min ( minEle , arr [ i ] ) maxEle = max ( maxEle , arr [ i ] ) i += 1 return ( maxEle - minEle )"
"def isPossible ( n , index , modulo , M , arr , dp ) : modulo = ( ( modulo % M ) + M ) % M if ( index == n ) : if ( 0 == modulo ) : return 1 return 0 if ( dp [ index ] [ modulo ] != - 1 ) : return dp [ index ] [ modulo ] placeAdd = isPossible ( n , index + 1 , modulo + arr [ index ] , M , arr , dp ) placeMinus = isPossible ( n , index + 1 , modulo - arr [ index ] , M , arr , dp ) res = bool ( placeAdd or placeMinus ) dp [ index ] [ modulo ] = res return res"
"def findExtraCharacter ( s1 , s2 ) : smallStr = """" largeStr = """" if ( len ( s1 ) > len ( s2 ) ) : smallStr = s2 largeStr = s1 else : smallStr = s1 largeStr = s2 smallStrCodeTotal = 0 largeStrCodeTotal = 0 i = 0 while ( i < len ( smallStr ) ) : smallStrCodeTotal = smallStrCodeTotal + ord ( smallStr [ i ] ) largeStrCodeTotal = largeStrCodeTotal + ord ( largeStr [ i ] ) i = i + 1 largeStrCodeTotal = largeStrCodeTotal + ord ( largeStr [ i ] ) intChar = largeStrCodeTotal - smallStrCodeTotal return chr ( intChar )"
def findSum ( n ) : arr = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] for i in range ( n ) : for j in range ( n ) : arr [ i ] [ j ] = abs ( i - j ) sum = 0 i = 0 while i in list ( range ( n ) ) : for j in range ( n ) : sum += arr [ i ] [ j ] i += 1 return sum
"def findCount ( n ) : a , b , c = 1 , 0 , 0 x = ( int ) ( n / 60 ) a = int ( math.pow ( 32 , x ) ) x = 60 * x i = x + 1 while i in list ( range ( n + 1 ) ) : if ( i % 2 == 0 ) : b += a a = 0 if ( i % 5 == 0 ) : c += b b = 0 if ( i % 12 == 0 ) : a += ( 2 * c ) c = 0 i += 1 print ( ""a="" , a , end = "","" ) print ( ""b="" , b , end = "","" ) print ( ""c="" , c )"
"def getMaxValue ( arr , arr_size ) : if ( arr_size < 2 ) : return 0 first = - sys.maxsize - 1 second = - sys.maxsize - 1 i = 0 while i in list ( range ( arr_size ) ) : if ( arr [ i ] > first ) : second = first first = arr [ i ] elif ( arr [ i ] > second and arr [ i ] != first ) : second = arr [ i ] i += 1 if ( second == - sys.maxsize - 1 ) : return 0 else : return second"
def squareDigitSum ( num ) : summ = 0 num = int ( num ) squareNum = num * num while 0 < squareNum : summ = summ + ( squareNum % 10 ) squareNum = squareNum // 10 return summ
"def segments ( n , p , m ) : c = dict ( ) c [ 0 ] = 1 has = False Sum = 0 ans = 0 r = 0 while r in list ( range ( n ) ) : if ( p [ r ] < m ) : Sum -= 1 elif ( p [ r ] > m ) : Sum += 1 if ( p [ r ] == m ) : has = True if ( has ) : if ( Sum in c.keys ( ) ) : ans += c [ Sum ] if Sum - 1 in c.keys ( ) : ans += c [ Sum - 1 ] else : c [ Sum ] = c.get ( Sum , 0 ) + 1 r += 1 return ans"
"def printMatrix ( n , m ) : if ( n < 5 or m < 5 ) : print ( - 1 , end = """" ) return s = ""aeiou"" s = list ( s ) i = 0 while i in list ( range ( n ) ) : for j in range ( m ) : print ( s [ j % 5 ] , end = """" ) print ( ) c = s [ 0 ] for i in range ( 4 ) : s [ i ] = s [ i + 1 ] s [ 4 ] = c i += 1"
"def minBroadcastRange ( houses , towers , n , m ) : leftTower = - sys.maxsize - 1 rightTower = towers [ 0 ] j , k = 0 , 0 min_range = 0 while ( j < n ) : if ( houses [ j ] < rightTower ) : left = houses [ j ] - leftTower right = rightTower - houses [ j ] if left < right : local_max = left else : local_max = right if ( local_max > min_range ) : min_range = local_max j += 1 else : leftTower = towers [ k ] if ( k >= m - 1 ) : rightTower = sys.maxsize else : k += 1 rightTower = towers [ k ] return min_range"
"def findPhoneNumber ( n ) : temp = n sum = 0 while ( temp != 0 ) : sum = sum + temp % 10 temp = temp // 10 if ( sum < 10 ) : print ( n , """" , sum ) else : n = str ( n ) sum = str ( sum ) n = n + sum print ( n )"
"def printChar ( str_ , n ) : freq = [ 0 ] * 26 for i in range ( n ) : freq [ ord ( str_ [ i ] ) - ord ( 'a' ) ] += 1 i = 0 while i in list ( range ( n ) ) : if ( freq [ ord ( str_ [ i ] ) - ord ( 'a' ) ] ) % 2 == 1 : print ( ""{}"".format ( str_ [ i ] ) , end = """" ) i += 1"
"def solve ( arr , n ) : k = len ( arr ) mp = [ False for i in range ( n + 2 ) ] for i in range ( k ) : mp [ arr [ i ] ] = True leftSegment = arr [ 0 ] - 1 i = 1 while i in list ( range ( k ) ) : leftSegment = max ( leftSegment , arr [ i ] - arr [ i - 1 ] - 1 ) i += 1 rightSegment = n - arr [ k - 1 ] maxSegment = max ( leftSegment , rightSegment ) tim = 0 if ( maxSegment & 1 ) : tim = ( maxSegment // 2 ) + 1 else : tim = maxSegment // 2 return tim"
def cntSquares ( n ) : squares = 0 i = 1 while i in list ( range ( n + 1 ) ) : squares += i ** 2 i += 1 return squares
"def findLastIndex ( str , x ) : i = len ( str ) - 1 while i in list ( range ( - 1 ) ) : if ( str [ i ] == x ) : i += - 1 return i i += - 1 return - 1"
"def LongestSubarray ( arr , n , k ) : arr2 = [ 0 ] * n for i in range ( n ) : arr2 [ i ] = arr [ i ] % k max_length = 0 i = 0 while i < n : current_length = 1 j = i + 1 while j in list ( range ( n ) ) : if ( arr2 [ j ] == arr2 [ i ] ) : current_length += 1 else : j += 1 break j += 1 max_length = max ( max_length , current_length ) i = j i += 1 return max_length"
"def findKthChar ( s , k ) : len1 = len ( s ) i = 0 total_len = 0 while ( i < len1 ) : if ( s [ i ].isalpha ( ) ) : total_len += 1 if ( total_len == k ) : return s [ i ] i += 1 else : n = 0 while ( len1 > i and s [ i ].isalpha ( ) == False ) : n = n * 10 + ( ord ( s [ i ] ) - ord ( '0' ) ) i += 1 next_total_len = total_len * n if ( k <= next_total_len ) : pos = k % total_len if ( pos == 0 ) : pos = total_len return findKthChar ( s , pos ) else : total_len = next_total_len return - 1"
"def search ( mat , m , n , x ) : i , j = m - 1 , 0 while ( i >= 0 and n > j ) : if ( mat [ i ] [ j ] == x ) : return True if ( mat [ i ] [ j ] > x ) : i -= 1 else : j += 1 return False"
"def findMissing ( a , b , n , m ) : s = dict ( ) i = 0 while i in list ( range ( m ) ) : s [ b [ i ] ] = 1 i += 1 for i in range ( n ) : if a [ i ] not in s.keys ( ) : print ( a [ i ] , end = """" )"
"def checkEqualMatrix ( arr , n , m , k ) : c = 0 ; cnt1 = 0 ; cnt2 = 0 for i in range ( n ) : j = 0 while j in list ( range ( m ) ) : if ( c % 2 == 0 ) : if ( arr [ i ] [ j ] == k ) : cnt1 += 1 else : if ( arr [ i ] [ j ] == k ) : cnt2 += 1 c = c + 1 j += 1 if ( cnt1 >= 1 and cnt2 >= 1 ) : print ( ""Yes"" ) else : print ( ""No"" )"
"def printSum ( m , s , n ) : total = 0 i = 0 while i in list ( range ( n ) ) : total += s [ i ] total += ( m [ i ] * 60 ) i += 1 print ( int ( total / 3600 ) , end = "":"" ) total %= 3600 print ( int ( total / 60 ) , end = "":"" ) total %= 60 print ( int ( total ) )"
"def maxModValue ( arr , n ) : ans = 0 arr = sorted ( arr ) j = n - 2 while j in list ( range ( - 1 ) ) : if ( ans >= arr [ j ] ) : j += - 1 break if ( arr [ j ] == arr [ j + 1 ] ) : j += - 1 continue i = 2 * arr [ j ] while ( i <= arr [ n - 1 ] + arr [ j ] ) : ind = 0 for k in arr : if k >= i : ind = arr.index ( k ) ans = max ( ans , arr [ ind - 1 ] % arr [ j ] ) i += arr [ j ] j += - 1 return ans"
"def printSeries ( n ) : i = 1 while i in list ( range ( n + 1 ) ) : num = i * ( i + 1 ) * ( i + 2 ) // 6 print ( num , end = '' ) i += 1"
"def FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) : x5 = max ( x1 , x3 ) y5 = max ( y1 , y3 ) x6 = min ( x2 , x4 ) y6 = min ( y2 , y4 ) if ( x6 < x5 or y5 > y6 ) : print ( ""Nointersection"" ) return print ( ""("" , x5 , "","" , y5 , "")"" , end = """" ) print ( ""("" , x6 , "","" , y6 , "")"" , end = """" ) x7 = x5 y7 = y6 print ( ""("" , x7 , "","" , y7 , "")"" , end = """" ) x8 = x6 y8 = y5 print ( ""("" , x8 , "","" , y8 , "")"" )"
"def getPassingCars ( A , n ) : result = 0 for i in range ( 0 , n - 1 , 1 ) : if ( A [ i ] == 0 ) : j = i + 1 while j in list ( range ( n ) ) : if ( A [ j ] ) : result += 1 j += 1 return result"
"def findMinCost ( arr , n , choc_cost ) : choc_buy = arr [ 0 ] curr_choc = 0 i = 0 while i in list ( range ( n - 1 ) ) : choc = arr [ i ] - arr [ i + 1 ] curr_choc += choc if ( curr_choc < 0 ) : choc_buy += abs ( curr_choc ) curr_choc = 0 i += 1 return choc_buy * choc_cost"
"def record_sum ( record , l , r , n , adder ) : i = l while i in list ( range ( r + 1 ) ) : record [ i ] += adder i += 1"
"def MatrixChainOrder ( p , n ) : m = [ [ 0 for x in range ( n ) ] for x in range ( n ) ] for i in range ( 1 , n ) : m [ i ] [ i ] = 0 for L in range ( 2 , n ) : i = 1 while i in list ( range ( n - L + 1 ) ) : j = i + L - 1 m [ i ] [ j ] = sys.maxint for k in range ( i , j ) : q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] if q < m [ i ] [ j ] : m [ i ] [ j ] = q i += 1 return m [ 1 ] [ n - 1 ]"
"def findAndSum ( arr , n ) : Sum = 0 mul = 1 i = 0 while i in list ( range ( 30 ) ) : count_on = 0 l = 0 for j in range ( n ) : if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) : if ( count_on ) : l += 1 else : count_on = 1 l += 1 elif ( count_on ) : Sum += ( ( mul * l * ( l + 1 ) ) // 2 ) count_on = 0 l = 0 if ( count_on ) : Sum += ( ( mul * l * ( l + 1 ) ) // 2 ) count_on = 0 l = 0 mul *= 2 i += 1 return Sum"
"def nthTermOfTheSeries ( n ) : if ( 0 == n % 2 ) : nthTerm = pow ( n - 1 , 2 ) + n else : nthTerm = pow ( n + 1 , 2 ) + n return nthTerm"
"def pythagoreanTriplets ( limits ) : c , m = 0 , 2 while c < limits : n = 1 while n in list ( range ( m ) ) : a = m * m - n * n b = 2 * m * n c = m * m + n * n if c > limits : n += 1 break print ( a , b , c ) n += 1 m = m + 1"
"def MinimumCost ( a , n , x ) : i = 1 while i in list ( range ( n ) ) : a [ i ] = min ( a [ i ] , 2 * a [ i - 1 ] ) i += 1 ind = 0 sum = 0 while ( x ) : if ( x & 1 ) : sum += a [ ind ] ind += 1 x = x >> 1 return sum"
def divisorSum ( n ) : sum = 0 i = 1 while i in list ( range ( n + 1 ) ) : j = 1 while j * j <= i : if i % j == 0 : if i / j == j : sum += j else : sum += j + i / j j = j + 1 i += 1 return int ( sum )
"def strBitwiseAND ( arr , n ) : res = """" smallest_size = sys.maxsize largest_size = - ( sys.maxsize - 1 ) for i in range ( n ) : arr [ i ] = arr [ i ] [ : : - 1 ] smallest_size = min ( smallest_size , len ( arr [ i ] ) ) largest_size = max ( largest_size , len ( arr [ i ] ) ) for i in range ( smallest_size ) : all_ones = True j = 0 while j in list ( range ( n ) ) : if ( arr [ j ] [ i ] == '0' ) : all_ones = False j += 1 break j += 1 if all_ones : res += '1' else : res += '0' for i in range ( largest_size - smallest_size ) : res += '0' res = res [ : : - 1 ] return res"
def count9s ( number ) : n = len ( number ) d = [ 0 for i in range ( 9 ) ] d [ 0 ] = 1 result = 0 mod_sum = 0 continuous_zero = 0 i = 0 while i in list ( range ( n ) ) : if ( ord ( number [ i ] ) - ord ( '0' ) == 0 ) : continuous_zero += 1 else : continuous_zero = 0 mod_sum += ord ( number [ i ] ) - ord ( '0' ) mod_sum %= 9 result += d [ mod_sum ] d [ mod_sum ] += 1 result -= continuous_zero i += 1 return result
def isDivisible ( n ) : while ( int ( n / 100 ) ) : last_digit = int ( n % 10 ) n = int ( n / 10 ) n = n + last_digit * 3 return ( n % 29 == 0 )
"def search ( arr , low , high ) : if low > high : return None if low == high : return arr [ low ] mid = ( low + high ) / 2 if mid % 2 != 0 : if arr [ mid ] == arr [ mid - 1 ] : return search ( arr , mid + 1 , high ) else : return search ( arr , low , mid - 1 ) else : if arr [ mid ] == arr [ mid + 1 ] : return search ( arr , mid + 2 , high ) else : return search ( arr , low , mid )"
"def findSum ( arr , N ) : mp = dict ( ) for i in arr : if i in mp.keys ( ) : mp [ i ] += 1 else : mp [ i ] = 1 minFreq = 10 ** 9 for itr in mp : if minFreq > mp [ itr ] : minFreq = mp [ itr ] Sum = 0 for itr in mp : if mp [ itr ] == minFreq : Sum += itr * mp [ itr ] return Sum"
"def compute ( graph , N ) : count = 0 i = 1 while i in list ( range ( N + 1 ) ) : if ( len ( graph [ i ] ) == 0 ) : count += 1 i += 1 return count"
"def printHutStar ( n ) : for i in range ( n ) : j = i + 1 while j in list ( range ( n ) ) : print ( '' , end = '' ) j += 1 for j in range ( 0 , 2 * i + 1 ) : print ( '*' , end = '' ) print ( ) for i in range ( 3 ) : for j in range ( 3 ) : print ( '*' , end = '' ) for j in range ( 2 * n - 7 ) : print ( '' , end = '' ) for j in range ( 3 ) : print ( '*' , end = '' ) print ( )"
"def findArea ( a , b , c ) : if ( a < 0 or b < 0 or c < 0 or ( a + b <= c ) or ( a + c <= b ) or ( a >= b + c ) ) : print ( 'Notavalidtrianglen' ) return s = ( a + b + c ) / 2 area = ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ** 0.5 print ( 'Areaofatraingleis%f' % area )"
"def isSellingPossible ( n , a ) : c25 = 0 c50 = 0 i = 0 while ( i < n ) : if ( a [ i ] == 25 ) : c25 += 1 elif ( a [ i ] == 50 ) : c50 += 1 if ( c25 == 0 ) : break c25 -= 1 else : if ( c50 > 0 and c25 > 0 ) : c50 -= 1 c25 -= 1 elif ( 3 <= c25 ) : c25 -= 3 else : break i += 1 if ( i == n ) : return True else : return False"
"def lenoflongestnonpalindrome ( s ) : max1 , length = 1 , 0 i = 0 while i in list ( range ( len ( s ) - 1 ) ) : if s [ i ] == s [ i + 1 ] : length = 0 elif s [ i + 1 ] == s [ i - 1 ] and i > 0 : length = 1 else : length += 1 max1 = max ( max1 , length + 1 ) i += 1 if max1 == 1 : return 0 else : return max1"
"def findFirstAndLast ( arr , n , x ) : first = - 1 last = - 1 i = 0 while i in list ( range ( n ) ) : if ( x != arr [ i ] ) : i += 1 continue if ( first == - 1 ) : first = i last = i i += 1 if ( first != - 1 ) : print ( ""FirstOccurrence="" , first , ""\nLastOccurrence="" , last ) else : print ( ""NotFound"" )"
"def repeat ( s , n ) : s1 = s i = 1 while i in list ( range ( n ) ) : s += s1 i += 1 return s"
"def areAllBitsSet ( n ) : if ( n == 0 ) : return ""No"" while ( 0 < n ) : if ( ( n & 1 ) == 0 ) : return ""No"" n = n >> 1 return ""Yes"""
"def isSymmetric ( mat , N ) : i = 0 while i in list ( range ( N ) ) : for j in range ( N ) : if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) : i += 1 return False i += 1 return True"
"def minNumber ( a , n , x ) : a.sort ( reverse = False ) k = 0 while ( x != a [ int ( ( n - 1 ) / 2 ) ] ) : a [ n - 1 ] = x n += 1 a.sort ( reverse = False ) k += 1 return k"
"def counLastDigitK ( low , high , k ) : count = 0 i = low while i in list ( range ( high + 1 ) ) : if ( i % 10 == k ) : count += 1 i += 1 return count"
"def cntSubsets ( arr , n ) : max = pow ( 2 , n ) result = 0 i = 0 while i in list ( range ( max ) ) : counter = i if ( counter & ( counter >> 1 ) ) : i += 1 continue result += 1 i += 1 return result"
"def frequency ( a , x ) : count = 0 for i in a : if x == i : count += 1 return count"
"def profitLoss ( N , M ) : if ( N == M ) : print ( ""NoProfitnorLoss"" ) else : result = 0.0 result = float ( abs ( N - M ) ) / M if ( 0 > N - M ) : print ( ""Loss=-"" , '{0:.6}'.format ( result * 100 ) , ""%"" ) else : print ( ""Profit="" , '{0:.6}'.format ( result * 100 ) , ""%"" )"
def pronic_check ( n ) : x = ( int ) ( math.sqrt ( n ) ) if ( n == x * ( x + 1 ) ) : return True else : return False
def isPalindrome ( num ) : s = str ( num ) low = 0 high = len ( s ) - 1 while ( high > low ) : if ( s [ low ] != s [ high ] ) : return False low += 1 high -= 1 return True
"def countPairs ( A , B ) : cnt = 0 i = 0 while i in list ( range ( A + 1 ) ) : for j in range ( i , A + 1 ) : AND = i & j OR = i | j if ( OR == A and AND == B ) : cnt += 1 i += 1 return cnt"
"def LeadingZeros ( x , y ) : if ( ( x ^ y ) <= ( x & y ) ) : print ( ""Equal"" ) elif ( y < ( x & ( ~ y ) ) ) : print ( y ) else : print ( x )"
"def countSegments ( a , n , x ) : flag = False count = 0 i = 0 while i in list ( range ( n ) ) : if ( a [ i ] > x ) : flag = True else : if ( flag ) : count += 1 flag = False i += 1 if ( flag ) : count += 1 return count"
"def countCurrency ( amount ) : notes = [ 2000 , 500 , 200 , 100 , 50 , 20 , 10 , 5 , 1 ] noteCounter = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] print ( ""CurrencyCount->"" ) for i , j in zip ( notes , noteCounter ) : if i <= amount : j = amount // i amount = amount - j * i print ( i , "":"" , j )"
"def insertSorted ( arr , n , key , capacity ) : if ( capacity <= n ) : return n i = n - 1 while i >= 0 and arr [ i ] > key : arr [ i + 1 ] = arr [ i ] i -= 1 arr [ i + 1 ] = key return ( n + 1 )"
def minIncrementForUnique ( A ) : count = collections.Counter ( A ) taken = [ ] ans = 0 x = 0 while x in list ( range ( 100000 ) ) : if count [ x ] >= 2 : taken.extend ( [ x ] * ( count [ x ] - 1 ) ) elif taken and count [ x ] == 0 : ans += x - taken.pop ( ) x += 1 return ans
"def printSpiral ( n ) : for i in range ( 0 , n ) : j = 0 while j in list ( range ( n ) ) : x = min ( min ( i , j ) , min ( n - 1 - i , n - 1 - j ) ) if ( i <= j ) : print ( ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ) , end = ""\t"" ) else : print ( ( ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) ) , end = ""\t"" ) j += 1 print ( )"
"def evaluateBoolExpr ( s ) : n = len ( s ) i = 0 while i in list ( range ( n - 2 ) ) : if ( s [ i + 1 ] == ""A"" ) : if ( s [ i + 2 ] == ""0"" or s [ i ] == ""0"" ) : s [ i + 2 ] = ""0"" else : s [ i + 2 ] = ""1"" elif ( s [ i + 1 ] == ""B"" ) : if ( s [ i + 2 ] == ""1"" or s [ i ] == ""1"" ) : s [ i + 2 ] = ""1"" else : s [ i + 2 ] = ""0"" else : if ( s [ i + 2 ] == s [ i ] ) : s [ i + 2 ] = ""0"" else : s [ i + 2 ] = ""1"" i += 2 return ord ( s [ n - 1 ] ) - ord ( ""0"" )"
"def minimumProduct ( arr , n ) : arr = sorted ( arr ) product = 1 i = 0 while i in list ( range ( n ) ) : product *= ( arr [ i ] + arr [ i + 1 ] ) i += 2 return product"
"def calculateEnergy ( mat , n ) : tot_energy = 0 i = 0 while i in list ( range ( n ) ) : for j in range ( n ) : q = mat [ i ] [ j ] // n i_des = q j_des = mat [ i ] [ j ] - ( n * q ) tot_energy += ( abs ( i_des - i ) + abs ( j_des - j ) ) i += 1 return tot_energy"
"def getSum ( n , d ) : sum = 0 while ( d <= n ) : sum = sum + d d = d + 10 return sum"
"def printRepeating ( arr , size ) : print ( ""Therepeatingelementsare"" , end = """" ) i = 0 while i in list ( range ( size ) ) : if ( arr [ abs ( arr [ i ] ) ] > 0 ) : arr [ abs ( arr [ i ] ) ] = ( - 1 ) * arr [ abs ( arr [ i ] ) ] else : print ( abs ( arr [ i ] ) , end = """" ) i += 1"
"def solveWordWrap ( arr , n , k ) : dp = [ 0 ] * n ans = [ 0 ] * n dp [ n - 1 ] = 0 ans [ n - 1 ] = n - 1 for i in range ( n - 2 , - 1 , - 1 ) : currlen = - 1 dp [ i ] = sys.maxsize j = i while j in list ( range ( n ) ) : currlen += ( arr [ j ] + 1 ) if ( currlen > k ) : j += 1 break if ( j == n - 1 ) : cost = 0 else : cost = ( ( k - currlen ) * ( k - currlen ) + dp [ j + 1 ] ) if ( cost < dp [ i ] ) : dp [ i ] = cost ans [ i ] = j j += 1 i = 0 while ( i < n ) : print ( i + 1 , ans [ i ] + 1 , end = """" ) i = ans [ i ] + 1"
"def shufleArray ( a , f , l ) : if ( l > f ) : return if ( l - f == 1 ) : return mid = int ( ( f + l ) / 2 ) temp = mid + 1 mmid = int ( ( f + mid ) / 2 ) i = mmid + 1 while i in list ( range ( mid + 1 ) ) : ( a [ i ] , a [ temp ] ) = ( a [ temp ] , a [ i ] ) temp += 1 i += 1 shufleArray ( a , f , mid ) shufleArray ( a , mid + 1 , l )"
"def getTotalXorOfSubarrayXors ( arr , N ) : if ( N % 2 == 0 ) : return 0 res = 0 i = 0 while i in list ( range ( N ) ) : res ^= arr [ i ] i += 2 return res"
"def spiralFill ( m , n , a ) : val = 1 k , l = 0 , 0 while ( k < m and l < n ) : for i in range ( l , n ) : a [ k ] [ i ] = val val += 1 k += 1 for i in range ( k , m ) : a [ i ] [ n - 1 ] = val val += 1 n -= 1 if ( k < m ) : for i in range ( n - 1 , l - 1 , - 1 ) : a [ m - 1 ] [ i ] = val val += 1 m -= 1 if ( l < n ) : i = m - 1 while i in list ( range ( k - 1 ) ) : a [ i ] [ l ] = val val += 1 i += - 1 l += 1"
"def isFascinating ( num ) : freq = [ 0 ] * 10 val = ( str ( num ) + str ( num * 2 ) + str ( num * 3 ) ) i = 0 while i in list ( range ( len ( val ) ) ) : digit = int ( val [ i ] ) if freq [ digit ] > 0 : i += 1 return False else : freq [ digit ] += 1 i += 1 for i in range ( 1 , 10 ) : if freq [ i ] == 0 : return False return True"
"def divCount ( n ) : hh = [ 1 ] * ( n + 1 ) p = 2 while ( ( p * p ) < n ) : if ( hh [ p ] == 1 ) : for i in range ( ( p * 2 ) , n , p ) : hh [ i ] = 0 p += 1 total = 1 p = 2 while p in list ( range ( n + 1 ) ) : if ( hh [ p ] == 1 ) : count = 0 if ( n % p == 0 ) : while ( n % p == 0 ) : n = int ( n / p ) count += 1 total *= ( count + 1 ) p += 1 return total"
"def printNumber ( n ) : count = [ 0 ] * 10 while ( n ) : count [ n % 10 ] += 1 n //= 10 i = 1 while i in list ( range ( 10 ) ) : for j in range ( count [ i ] * i ) : print ( i , end = """" ) i += 1"
"def countOdd ( L , R ) : N = ( R - L ) // 2 if ( R % 2 != 0 or 0 != L % 2 ) : N += 1 return N"
"def pattern ( min_stars , p_height ) : p_space = p_height - 1 x = 1 for i in range ( 0 , p_height ) : j = p_space while j in list ( range ( i ) ) : print ( """" , end = """" ) j += - 1 for k in range ( 0 , min_stars ) : print ( ""*"" , end = """" ) for n in range ( ( p_height + p_height - 2 ) , x - 1 , - 1 ) : print ( """" , end = """" ) for k in range ( 0 , min_stars ) : print ( ""*"" , end = """" ) min_stars = min_stars + 2 x = x + 2 print ( """" )"
"def isSubArray ( A , B , n , m ) : i = 0 ; j = 0 while ( n > i and j < m ) : if ( A [ i ] == B [ j ] ) : i += 1 j += 1 if ( j == m ) : return True else : i = i - j + 1 j = 0 return False"
"def search ( mat , n , x ) : i = 0 j = n - 1 while ( i < n and j >= 0 ) : if ( x == mat [ i ] [ j ] ) : print ( ""nFoundat"" , i , "","" , j ) return 1 if ( mat [ i ] [ j ] > x ) : j -= 1 else : i += 1 print ( ""Elementnotfound"" ) return 0"
"def maxProduct ( arr , n ) : if 3 > n : return - 1 arr.sort ( ) return max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] )"
"def getNthUglyNo ( n ) : ugly = [ 0 ] * n ugly [ 0 ] = 1 i2 = i3 = i5 = 0 next_multiple_of_2 = 2 next_multiple_of_3 = 3 next_multiple_of_5 = 5 l = 1 while l in list ( range ( n ) ) : ugly [ l ] = min ( next_multiple_of_2 , next_multiple_of_3 , next_multiple_of_5 ) if ugly [ l ] == next_multiple_of_2 : i2 += 1 next_multiple_of_2 = ugly [ i2 ] * 2 if ugly [ l ] == next_multiple_of_3 : i3 += 1 next_multiple_of_3 = ugly [ i3 ] * 3 if ugly [ l ] == next_multiple_of_5 : i5 += 1 next_multiple_of_5 = ugly [ i5 ] * 5 l += 1 return ugly [ - 1 ]"
"def kLargest ( arr , k ) : arr.sort ( reverse = True ) i = 0 while i in list ( range ( k ) ) : print ( arr [ i ] , end = """" ) i += 1"
"def compute ( S , X ) : A = ( S - X ) // 2 a = 0 b = 0 i = 0 while i in list ( range ( 64 ) ) : i += 1"
"def findevenPair ( A , N ) : evenPair = 0 i = 0 while i in list ( range ( N ) ) : for j in range ( i + 1 , N ) : if ( ( A [ i ] & A [ j ] ) % 2 == 0 ) : evenPair += 1 i += 1 return evenPair"
def firstFactorialDivisibleNumber ( x ) : i = 1 fact = 1 i = 1 while i in list ( range ( x ) ) : fact = fact * i if ( fact % x == 0 ) : i += 1 break i += 1 return i
"def findMajority ( arr , n ) : Len = 32 number = 0 for i in range ( Len ) : count = 0 for j in range ( n ) : if ( arr [ j ] & ( 1 << i ) ) : count += 1 if ( count > ( n // 2 ) ) : number += ( 1 << i ) count = 0 i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] == number ) : count += 1 i += 1 if ( count > ( n // 2 ) ) : print ( number ) else : print ( ""MajorityElementNotPresent"" )"
"def findLongestRepeatingSubSeq ( str ) : n = len ( str ) dp = [ [ 0 ] * ( n + 1 ) ] * ( n + 1 ) i = 1 while i in list ( range ( n + 1 ) ) : for j in range ( 1 , n + 1 ) : if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) : dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) i += 1 return dp [ n ] [ n ]"
"def find_Square_369 ( num ) : if ( num [ 0 ] == '' ) : a = '' b = '' c = '' d = '' elif ( num [ 0 ] == '' ) : a = '' b = '' c = '' d = '' else : a = '' b = '' c = '' d = '' result = """" size = len ( num ) for i in range ( 1 , size ) : result = result + a result = result + b for i in range ( 1 , size ) : result = result + c result = result + d return result"
def isNumber ( s ) : i = 0 while i in list ( range ( len ( s ) ) ) : if s [ i ].isdigit ( ) != True : i += 1 return False i += 1 return True
"def lexNext ( s , n ) : i = n - 1 while i in list ( range ( - 1 ) ) : if s [ i ] != 'z' : k = ord ( s [ i ] ) s [ i ] = chr ( k + 1 ) i += - 1 return ''.join ( s ) s [ i ] = 'a' i += - 1"
"def minimumChar ( S1 , S2 ) : n , m = len ( S1 ) , len ( S2 ) ans = sys.maxsize for i in range ( m - n + 1 ) : minRemovedChar = 0 j = 0 while j in list ( range ( n ) ) : if ( S1 [ j ] != S2 [ i + j ] ) : minRemovedChar += 1 j += 1 ans = min ( minRemovedChar , ans ) return ans"
"def calc_Expectation ( a , n ) : prb = 1 / n sum = 0 i = 0 while i in list ( range ( n ) ) : sum += ( a [ i ] * prb ) i += 1 return float ( sum )"
"def subarrayXor ( arr , n , m ) : ans = 0 xorArr = [ 0 for _ in range ( n ) ] mp = dict ( ) xorArr [ 0 ] = arr [ 0 ] i = 1 while i in list ( range ( n ) ) : xorArr [ i ] = xorArr [ i - 1 ] ^ arr [ i ] i += 1 for i in range ( n ) : tmp = m ^ xorArr [ i ] if tmp in mp.keys ( ) : ans = ans + ( mp [ tmp ] ) if ( xorArr [ i ] == m ) : ans += 1 mp [ xorArr [ i ] ] = mp.get ( xorArr [ i ] , 0 ) + 1 return ans"
"def isEvenOrOdd ( L , R ) : oddCount = ( R - L ) / 2 if ( R % 2 == 1 or 1 == L % 2 ) : oddCount = oddCount + 1 if ( oddCount % 2 == 0 ) : return ""Even"" else : return ""Odd"""
def maxConsecutiveOnes ( x ) : count = 0 while ( 0 != x ) : x = ( x & ( x << 1 ) ) count = count + 1 return count
"def get ( x , y , z ) : if ( z < x ) : return - 1 val = z - x div = ( z - x ) // y ans = div * y + x return ans"
"def count ( x , y ) : ans = 0 m = dict ( ) while 0 != x % y : x %= y ans += 1 if x in m : return - 1 m [ x ] = 1 x *= 10 return ans"
def checkJumbled ( num ) : if ( 0 == num // 10 ) : return True while ( num != 0 ) : if ( num // 10 == 0 ) : return True digit1 = num % 10 digit2 = ( num // 10 ) % 10 if ( abs ( digit2 - digit1 ) > 1 ) : return False num = num // 10 return True
"def findLarger ( arr , n ) : x = sorted ( arr ) i = n / 2 while i in list ( range ( n ) ) : print ( x [ i ] ) , i += 1"
"def middleOfThree ( a , b , c ) : if ( ( a < b and b < c ) or ( c < b and b < a ) ) : return b if ( ( b < a and a < c ) or ( a > c and a < b ) ) : return a else : return c"
def partitions ( n ) : p = [ 0 ] * ( n + 1 ) p [ 0 ] = 1 i = 1 while i in list ( range ( n + 1 ) ) : k = 1 while ( ( k * ( 3 * k - 1 ) ) / 2 <= i ) : p [ i ] += ( ( 1 if k % 2 else - 1 ) * p [ i - ( k * ( 3 * k - 1 ) ) // 2 ] ) if ( k > 0 ) : k *= - 1 else : k = 1 - k i += 1 return p [ n ]
"def countFibs ( low , high ) : f1 , f2 , f3 = 0 , 1 , 1 result = 0 while ( high >= f1 ) : if ( f1 >= low ) : result += 1 f1 = f2 f2 = f3 f3 = f1 + f2 return result"
"def ReplaceElements ( arr , n ) : mp = dict ( ) for i in range ( n ) : mp [ arr [ i ] ] = mp.get ( arr [ i ] , 0 ) + 1 i = 0 while i in list ( range ( n ) ) : arr [ i ] = n - mp [ arr [ i ] ] i += 1"
"def countNum ( arr , n ) : count = 0 arr.sort ( ) i = 0 while i in list ( range ( n - 1 ) ) : if ( arr [ i ] != arr [ i + 1 ] and arr [ i ] != arr [ i + 1 ] - 1 ) : count += arr [ i + 1 ] - arr [ i ] - 1 i += 1 return count"
"def findSum ( n ) : sm = 0 i = 1 while i in list ( range ( n + 1 ) ) : for j in range ( i , n + 1 ) : sm = sm + i * j i += 1 return sm"
"def findSum ( n ) : ans = 0 temp = 0 for i in range ( 1 , n + 1 ) : if temp < n : temp = i - 1 num = 1 while temp < n : if temp + i <= n : ans = ans + i * num else : ans = ans + ( n - temp ) * num temp = temp + i num = num + 1 return ans"
"def findMinRec ( A , n ) : if ( 1 == n ) : return A [ 0 ] return min ( A [ n - 1 ] , findMinRec ( A , n - 1 ) )"
def findTrailingZeros ( n ) : count = 0 i = 5 while ( n / i >= 1 ) : count = count + int ( n / i ) i *= 5 return int ( count )
"def minimumDeletions ( a , n ) : if ( n <= 2 ) : return 0 count = 0 i = 0 while i in list ( range ( n - 2 ) ) : if ( ( a [ i ] < a [ i + 1 ] and a [ i + 1 ] < a [ i + 2 ] ) or ( a [ i ] > a [ i + 1 ] and a [ i + 1 ] > a [ i + 2 ] ) ) : count += 1 i += 1 return count"
"def amendSentence ( string ) : string = list ( string ) i = 0 while i in list ( range ( len ( string ) ) ) : if string [ i ] >= 'A' and string [ i ] <= 'Z' : string [ i ] = chr ( ord ( string [ i ] ) + 32 ) if i != 0 : print ( """" , end = """" ) print ( string [ i ] , end = """" ) else : print ( string [ i ] , end = """" ) i += 1"
"def findTriplets ( arr , n ) : found = True for i in range ( 0 , n - 2 ) : j = i + 1 while j in list ( range ( n - 1 ) ) : for k in range ( j + 1 , n ) : if ( arr [ i ] + arr [ j ] + arr [ k ] == 0 ) : print ( arr [ i ] , arr [ j ] , arr [ k ] ) found = True j += 1 if ( found == False ) : print ( ""notexist"" )"
"def ReplaceElements ( arr , n ) : if n <= 1 : return prev = arr [ 0 ] arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] i = 1 while i in list ( range ( n - 1 ) ) : curr = arr [ i ] arr [ i ] = prev ^ arr [ i + 1 ] prev = curr i += 1 arr [ n - 1 ] = prev ^ arr [ n - 1 ]"
"def printPrevSmaller ( arr , n ) : print ( ""_,"" , end = """" ) for i in range ( 1 , n ) : j = i - 1 while j in list ( range ( - 2 ) ) : if ( arr [ j ] < arr [ i ] ) : print ( arr [ j ] , "","" , end = """" ) j += - 1 break j += - 1 if ( j == - 1 ) : print ( ""_,"" , end = """" )"
"def printAsMaximalPrimeSum ( n ) : if ( 1 == n % 2 ) : print ( ""3"" , end = """" ) n -= 3 while ( n > 0 ) : print ( ""2"" , end = """" ) n -= 2"
"def convert12 ( str ) : h1 = ord ( str [ 0 ] ) - ord ( '0' ) h2 = ord ( str [ 1 ] ) - ord ( '0' ) hh = h1 * 10 + h2 Meridien = """" if ( hh < 12 ) : Meridien = ""AM"" else : Meridien = ""PM"" hh %= 12 if ( hh == 0 ) : print ( ""12"" , end = """" ) i = 2 while i in list ( range ( 8 ) ) : print ( str [ i ] , end = """" ) i += 1 else : print ( hh , end = """" ) for i in range ( 2 , 8 ) : print ( str [ i ] , end = """" ) print ( """" + Meridien )"
def sumOfSeries ( n ) : sum = 0 i = 1 while i in list ( range ( n + 1 ) ) : sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) i += 1 return sum
"def findWater ( i , j , X ) : if ( j > i ) : print ( ""IncorrectInput"" ) return glass = [ 0 ] * int ( i * ( i + 1 ) / 2 ) index = 0 glass [ index ] = X for row in range ( 1 , i ) : col = 1 while col in list ( range ( row + 1 ) ) : X = glass [ index ] glass [ index ] = 1.0 if ( X >= 1.0 ) else X X = ( X - 1 ) if ( X >= 1.0 ) else 0.0 glass [ index + row ] += ( X / 2 ) glass [ index + row + 1 ] += ( X / 2 ) index += 1 col += 1 return glass [ int ( i * ( i - 1 ) / 2 + j - 1 ) ]"
"def reduceArray ( arr , n , K ) : vec = [ ] size = 0 curr_ele = arr [ 0 ] ; curr_freq = 1 for i in range ( n ) : if ( curr_ele == arr [ i ] and curr_freq <= K ) : vec.append ( arr [ i ] ) size += 1 elif ( curr_ele != arr [ i ] ) : curr_ele = arr [ i ] vec.append ( arr [ i ] ) size += 1 curr_freq = 1 curr_freq += 1 print ( ""{"" , end = """" ) i = 0 while i in list ( range ( size ) ) : print ( vec [ i ] , end = "","" ) i += 1 print ( ""}"" , end = """" )"
"def printNos ( n ) : if 0 < n : printNos ( n - 1 ) print ( n , end = '' )"
def check ( s ) : i = 0 while i in list ( range ( len ( s ) ) ) : if ( s [ i ] == s [ i + 1 ] ) : i += 1 return True i += 1 return False
"def complement ( number ) : i = 0 while i in list ( range ( len ( number ) ) ) : if ( number [ i ] != '.' ) : a = 9 - int ( number [ i ] ) number = ( number [ : i ] + str ( a ) + number [ i + 1 : ] ) i += 1 print ( ""9'scomplementis:"" , number )"
"def minJumps ( arr , l , h ) : if ( h == l ) : return 0 if ( arr [ l ] == 0 ) : return float ( 'inf' ) min = float ( 'inf' ) i = l + 1 while i in list ( range ( h + 1 ) ) : if ( i < l + arr [ l ] + 1 ) : jumps = minJumps ( arr , i , h ) if ( jumps != float ( 'inf' ) and jumps + 1 < min ) : min = jumps + 1 i += 1 return min"
"def findMinDel ( arr , n ) : min_num = sys.maxsize for i in range ( n ) : min_num = min ( arr [ i ] , min_num ) cnt = 0 i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] == min_num ) : cnt += 1 i += 1 return n - cnt"
"def LISusingLCS ( seq ) : n = len ( seq ) L = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ] sortedseq = sorted ( seq ) for i in range ( n + 1 ) : j = 0 while j in list ( range ( n + 1 ) ) : if ( i == 0 or j == 0 ) : L [ i ] [ j ] = 0 elif ( seq [ i - 1 ] == sortedseq [ j - 1 ] ) : L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 else : L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) j += 1 return L [ n ] [ n ]"
"def KthMinValAfterMconcatenate ( A , N , M , K ) : V = [ ] for i in range ( 0 , M ) : j = 0 while j in list ( range ( N ) ) : V.append ( A [ j ] ) j += 1 V.sort ( ) return V [ K - 1 ]"
def findThirdDigit ( n ) : if 3 > n : return 0 return 1 if n and 1 else 6
"def countDivisibles ( A , B , M ) : counter = 0 i = A while i in list ( range ( B ) ) : if ( i % M == 0 ) : counter = counter + 1 i += 1 return counter"
"def isPossible ( a , n ) : cur = a [ 0 ] cur -= 1 i = 1 while i in list ( range ( n ) ) : nxt = a [ i ] if ( nxt > cur ) : nxt -= 1 elif ( nxt < cur ) : i += 1 return False cur = nxt i += 1 return True"
"def maxval ( a , n ) : if ( n < 2 ) : return - 99999 max = 0 i = 0 while i in list ( range ( n ) ) : for j in range ( i + 1 , n ) : x = ( a [ i ] + i ) * ( a [ j ] + j ) if max < x : max = x i += 1 return max"
"def count_pairs ( a , b , n , m ) : odd1 = 0 even1 = 0 odd2 = 0 even2 = 0 i = 0 while i in list ( range ( n ) ) : if ( a [ i ] % 2 == 1 ) : odd1 += 1 else : even1 += 1 i += 1 for i in range ( m ) : if ( b [ i ] % 2 == 1 ) : odd2 += 1 else : even2 += 1 pairs = min ( odd1 , odd2 ) + min ( even1 , even2 ) return pairs"
"def towerOfHanoi ( n , from_rod , to_rod , aux_rod1 , aux_rod2 ) : if ( 0 == n ) : return if ( n == 1 ) : print ( ""Movedisk"" , n , ""fromrod"" , from_rod , ""ctorod"" , to_rod ) return towerOfHanoi ( n - 2 , from_rod , aux_rod1 , aux_rod2 , to_rod ) print ( ""Movedisk"" , n - 1 , ""fromrod"" , from_rod , ""ctorod"" , aux_rod2 ) print ( ""Movedisk"" , n , ""fromrod"" , from_rod , ""ctorod"" , to_rod ) print ( ""Movedisk"" , n - 1 , ""fromrod"" , aux_rod2 , ""ctorod"" , to_rod ) towerOfHanoi ( n - 2 , aux_rod1 , to_rod , from_rod , aux_rod2 )"
"def SubArraySum ( arr , n ) : result = 0 i = 0 while i in list ( range ( n ) ) : result += ( arr [ i ] * ( i + 1 ) * ( n - i ) ) i += 1 return result"
"def revAlternateK ( s , k , Len ) : i = 0 while ( i < len ( s ) ) : if ( Len < i + k ) : break ss = s [ i : i + k ] s = s [ : i ] + ss [ : : - 1 ] + s [ i + k : ] i += 2 * k return s"
"def countOps ( A , B , m , n ) : for i in range ( n ) : for j in range ( m ) : A [ i ] [ j ] -= B [ i ] [ j ] i = 1 while i in list ( range ( n ) ) : for j in range ( 1 , n ) : if ( A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j ] + A [ 0 ] [ 0 ] != 0 ) : i += 1 return - 1 i += 1 result = 0 for i in range ( n ) : result += abs ( A [ i ] [ 0 ] ) for j in range ( m ) : result += abs ( A [ 0 ] [ j ] - A [ 0 ] [ 0 ] ) return ( result )"
"def leyland ( n ) : ans = [ ] x = 2 y = 2 while x <= n : y = 2 while y <= x : temp = pow ( x , y ) + pow ( y , x ) ans.append ( temp ) y = y + 1 x = x + 1 ans.sort ( ) i = 0 while n > i : print ( ans [ i ] , end = """" ) i = i + 1"
"def bitonicGenerator ( arr , n ) : evenArr = [ ] oddArr = [ ] i = 0 while i in list ( range ( n ) ) : if ( ( i % 2 ) == 0 ) : evenArr.append ( arr [ i ] ) else : oddArr.append ( arr [ i ] ) i += 1 evenArr = sorted ( evenArr ) oddArr = sorted ( oddArr ) oddArr = oddArr [ : : - 1 ] i = 0 for j in range ( len ( evenArr ) ) : arr [ i ] = evenArr [ j ] i += 1 for j in range ( len ( oddArr ) ) : arr [ i ] = oddArr [ j ] i += 1"
"def halfsquare ( n , x , y ) : half = n // 2 if ( ( half == x or x - 1 == half ) and ( half == y or half == y - 1 ) ) : print ( ""NO"" ) else : print ( ""YES"" )"
"def indexedSequentialSearch ( arr , n , k ) : elements = [ 0 ] * 20 indices = [ 0 ] * 20 j , ind = 0 , 0 i = 0 while i in list ( range ( n ) ) : elements [ ind ] = arr [ i ] indices [ ind ] = i ind += 1 i += 3 if k < elements [ 0 ] : print ( ""Notfound"" ) exit ( 0 ) else : for i in range ( 1 , ind + 1 ) : if k < elements [ i ] : start = indices [ i - 1 ] end = indices [ i ] break for i in range ( start , end + 1 ) : if k == arr [ i ] : j = 1 break if j == 1 : print ( ""Foundatindex"" , i ) else : print ( ""Notfound"" )"
"def breakSum ( n ) : dp = [ 0 ] * ( n + 1 ) dp [ 0 ] = 0 dp [ 1 ] = 1 i = 2 while i in list ( range ( n + 1 ) ) : dp [ i ] = max ( dp [ int ( i / 2 ) ] + dp [ int ( i / 3 ) ] + dp [ int ( i / 4 ) ] , i ) i += 1 return dp [ n ]"
"def findLength ( st , n ) : total = [ 0 ] * ( n + 1 ) for i in range ( 1 , n + 1 ) : total [ i ] = ( total [ i - 1 ] + int ( st [ i - 1 ] ) - int ( '0' ) ) ans = 0 l = 2 while ( l <= n ) : i = 0 while i in list ( range ( n - l + 1 ) ) : j = i + l - 1 if ( total [ i + int ( l / 2 ) ] - total [ i ] == total [ i + l ] - total [ i + int ( l / 2 ) ] ) : ans = max ( ans , l ) i += 1 l = l + 2 return ans"
"def countSubseq ( arr , n ) : count = 0 mp = { } for x in arr : if x in mp.keys ( ) : mp [ x ] += 1 else : mp [ x ] = 1 for i in mp.keys ( ) : if ( i == 0 ) : count = count + pow ( 2 , mp [ i ] ) - 1 else : count = count + pow ( 2 , mp [ i ] - 1 ) return count"
"def linearSearch ( arr , n ) : i = 0 while i in list ( range ( n ) ) : if arr [ i ] is i : i += 1 return i i += 1 return - 1"
"def printPairs ( arr , n ) : v = [ ] i = 0 while i in list ( range ( n ) ) : for j in range ( i + 1 , n ) : if ( abs ( arr [ i ] ) == abs ( arr [ j ] ) ) : v.append ( abs ( arr [ i ] ) ) i += 1 if ( len ( v ) == 0 ) : return v.sort ( ) for i in range ( len ( v ) ) : print ( - v [ i ] , """" , v [ i ] , end = """" )"
def countSetBits ( n ) : if ( 0 == n ) : return 0 else : return ( n & 1 ) + countSetBits ( n >> 1 )
"def minCost ( arr , n ) : count_even = 0 count_odd = 0 i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] % 2 == 0 ) : count_even += 1 else : count_odd += 1 i += 1 return min ( count_even , count_odd )"
"def pendulumArrangement ( arr , n ) : arr.sort ( reverse = False ) pos = n - 1 if ( n % 2 == 0 ) : odd = n - 1 else : odd = n - 2 while ( odd > 0 ) : temp = arr [ odd ] in1 = odd while ( in1 != pos ) : arr [ in1 ] = arr [ in1 + 1 ] in1 += 1 arr [ in1 ] = temp odd = odd - 2 pos = pos - 1 start = 0 end = int ( ( n - 1 ) / 2 ) while ( start < end ) : temp = arr [ start ] arr [ start ] = arr [ end ] arr [ end ] = temp start += 1 end -= 1 i = 0 while i in list ( range ( n ) ) : print ( arr [ i ] , end = """" ) i += 1"
"def gouldSequence ( n ) : for row_num in range ( 1 , n ) : count = 1 c = 1 i = 1 while i in list ( range ( row_num ) ) : c = c * ( row_num - i ) / i if ( c % 2 == 1 ) : count += 1 i += 1 print ( count , end = """" )"
"def countDivisbleby4 ( s ) : n = len ( s ) count = 0 i = 0 while i in list ( range ( n ) ) : if ( s [ i ] == '4' or s [ i ] == '8' or s [ i ] == '0' ) : count += 1 i += 1 for i in range ( 0 , n - 1 , 1 ) : h = ( ord ( s [ i ] ) - ord ( '0' ) ) * 10 + ( ord ( s [ i + 1 ] ) - ord ( '0' ) ) if ( h % 4 == 0 ) : count = count + i + 1 return count"
"def generate ( ones , zeroes , str , len1 ) : if ( len ( str ) == len1 ) : print ( str , end = """" ) return generate ( ones + 1 , zeroes , str + ""1"" , len1 ) if ( ones > zeroes ) : generate ( ones , zeroes + 1 , str + ""0"" , len1 )"
"def perfectSquares ( l , r ) : i = l while i in list ( range ( r + 1 ) ) : if ( i ** (.5 ) == int ( i ** (.5 ) ) ) : print ( i , end = """" ) i += 1"
"def MinOperation ( a , n , k ) : result = 0 i = 0 while i in list ( range ( n ) ) : if ( a [ i ] != 1 and a [ i ] > k ) : result = ( result + min ( a [ i ] % k , k - a [ i ] % k ) ) else : result = result + k - a [ i ] i += 1 return result"
"def arePermutations ( a , b , n , m ) : sum1 , sum2 , mul1 , mul2 = 0 , 0 , 1 , 1 i = 0 while i in list ( range ( n ) ) : sum1 += a [ i ] mul1 *= a [ i ] i += 1 for i in range ( m ) : sum2 += b [ i ] mul2 *= b [ i ] return ( ( sum1 == sum2 ) and ( mul1 == mul2 ) )"
"def shuffle ( card , n ) : i = 0 while i in list ( range ( n ) ) : r = i + ( random.randint ( 0 , 55 ) % ( 52 - i ) ) tmp = card [ i ] card [ i ] = card [ r ] card [ r ] = tmp i += 1"
"def find3Numbers ( arr , n ) : small = + 2147483647 large = + 2147483647 for i in range ( n ) : if ( arr [ i ] <= small ) : small = arr [ i ] elif ( arr [ i ] <= large ) : large = arr [ i ] else : break if ( i == n ) : print ( ""Nosuchtripletfound"" ) return j = 0 while j in list ( range ( i + 1 ) ) : if ( arr [ j ] < large ) : small = arr [ j ] j += 1 break j += 1 print ( small , """" , large , """" , arr [ i ] ) return"
"def createSemiPrimeSieve ( n ) : v = [ 0 for i in range ( n + 1 ) ] for i in range ( 1 , n + 1 ) : v [ i ] = i countDivision = [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) : countDivision [ i ] = 2 for i in range ( 2 , n + 1 , 1 ) : if ( v [ i ] == i and countDivision [ i ] == 2 ) : for j in range ( 2 * i , n + 1 , i ) : if ( countDivision [ j ] > 0 ) : v [ j ] = int ( v [ j ] / i ) countDivision [ j ] -= 1 res = [ ] i = 2 while i in list ( range ( n + 1 ) ) : if ( v [ i ] == 1 and countDivision [ i ] == 0 ) : res.append ( i ) i += 1 return res"
"def findLength ( str ) : n = len ( str ) maxlen = 0 for i in range ( 0 , n ) : for j in range ( i + 1 , n , 2 ) : length = j - i + 1 leftsum = 0 rightsum = 0 k = 0 while k in list ( range ( int ( length / 2 ) ) ) : leftsum += ( int ( str [ i + k ] ) - int ( '0' ) ) rightsum += ( int ( str [ i + k + int ( length / 2 ) ] ) - int ( '0' ) ) k += 1 if ( leftsum == rightsum and maxlen < length ) : maxlen = length return maxlen"
"def removeElements ( arr , n , l , r ) : mp = { i : 0 for i in range ( len ( arr ) ) } for i in range ( n ) : mp [ arr [ i ] ] += 1 i = 0 while i in list ( range ( n ) ) : if ( mp [ arr [ i ] ] < l or mp [ arr [ i ] > r ] ) : print ( arr [ i ] , end = """" ) i += 1"
"def findMaxProduct ( arr , n ) : ans = - float ( 'inf' ) maxval = 1 minval = 1 i = 0 while i in list ( range ( n ) ) : if arr [ i ] > 0 : maxval = maxval * arr [ i ] minval = min ( 1 , minval * arr [ i ] ) elif arr [ i ] == 0 : minval = 1 maxval = 0 elif arr [ i ] < 0 : prevMax = maxval maxval = minval * arr [ i ] minval = prevMax * arr [ i ] ans = max ( ans , maxval ) if maxval <= 0 : maxval = 1 i += 1 return ans"
"def CountWords ( str , k ) : sum = 0 NumberOfWords = 0 counter = 0 l = len ( str ) for i in range ( l ) : if ( str [ i ] == '' ) : if ( sum < k ) : counter = counter + 1 sum = 0 NumberOfWords = NumberOfWords + 1 else : sum = sum + ord ( str [ i ] ) NumberOfWords = NumberOfWords + 1 if ( sum < k ) : counter = counter + 1 print ( """" , """" , counter ) print ( """" , """" , NumberOfWords - counter )"
def numberOfDistinct ( n ) : ans = 0 i = 1 while i in list ( range ( int ( math.sqrt ( n ) ) + 1 ) ) : if ( n % i == 0 ) : ans += 1 if ( ( n // i ) != i ) : ans += 1 i += 1 return ans
"def count ( s , k ) : n = len ( s ) d , count = 0 , 0 for i in range ( k ) : d += ord ( s [ i ] ) if ( d % k == 0 ) : count += 1 i = k while i in list ( range ( n ) ) : prev = ord ( s [ i - k ] ) d -= prev d += ord ( s [ i ] ) if ( d % k == 0 ) : count += 1 i += 1 return count i += 1"
"def ReplaceElements ( arr , n ) : max_ele = arr [ 0 ] arr [ 0 ] = - 1 i = 1 while i in list ( range ( n ) ) : if ( max_ele > arr [ i ] ) : arr [ i ] = max_ele elif ( max_ele <= arr [ i ] ) : temp = arr [ i ] arr [ i ] = max_ele max_ele = temp i += 1"
"def makeAndCheckString ( words , str ) : n = len ( words ) first = second = False i = 0 while i in list ( range ( n ) ) : if words [ i ] == str : i += 1 return True if str [ 0 ] == words [ i ] [ 1 ] : first = True if str [ 1 ] == words [ i ] [ 0 ] : second = True if first and second : i += 1 return True i += 1 return False"
"def printPattern ( N ) : i = 1 while i in list ( range ( N + 1 ) ) : print ( i - 1 if i % 2 == 0 else i + 1 , end = """" ) i += 1"
"def isDivisible ( str , k ) : n = len ( str ) c = 0 i = 0 while i in list ( range ( k ) ) : if ( str [ n - i - 1 ] == '0' ) : c += 1 i += 1 return ( c == k )"
"def maximumSumSubarray ( arr , n ) : min_prefix_sum = 0 res = - math.inf prefix_sum = [ ] prefix_sum.append ( arr [ 0 ] ) for i in range ( 1 , n ) : prefix_sum.append ( prefix_sum [ i - 1 ] + arr [ i ] ) i = 0 while i in list ( range ( n ) ) : res = max ( res , prefix_sum [ i ] - min_prefix_sum ) min_prefix_sum = min ( min_prefix_sum , prefix_sum [ i ] ) i += 1 return res"
"def printPartition ( n , m ) : k = int ( n / m ) ct = n % m for i in range ( 1 , ct + 1 , 1 ) : print ( k + 1 , end = """" ) count = i i = count while i in list ( range ( m ) ) : print ( k , end = """" ) i += 1"
"def processQueries ( Q , m , n ) : a = [ 0 ] * ( m + 1 ) ; pos = [ 0 ] * ( m + 1 ) for i in range ( 1 , m + 1 ) : a [ i - 1 ] = i pos [ i ] = i - 1 ans = [ ] for i in range ( n ) : q = Q [ i ] p = pos [ q ] ans.append ( p ) i = p while i in list ( range ( 0 ) ) : a [ i ] , a [ i - 1 ] = a [ i - 1 ] , a [ i ] pos [ a [ i ] ] = i i += - 1 pos [ a [ 0 ] ] = 0 return ans"
"def findInteger ( arr , n ) : neg = 0 pos = 0 sum = 0 i = 0 while i in list ( range ( n ) ) : sum += arr [ i ] if ( arr [ i ] < 0 ) : neg += 1 else : pos += 1 i += 1 return ( sum / abs ( neg - pos ) )"
"def countSink ( n , m , edgeFrom , edgeTo ) : mark = [ 0 ] * ( n + 1 ) for i in range ( m ) : mark [ edgeFrom [ i ] ] = 1 count = 0 i = 1 while i in list ( range ( n + 1 ) ) : if ( not mark [ i ] ) : count += 1 i += 1 return count"
"def areSumSame ( a , n , m ) : sum1 = 0 sum2 = 0 i = 0 while i in list ( range ( n ) ) : sum1 = 0 sum2 = 0 for j in range ( 0 , m ) : sum1 += a [ i ] [ j ] sum2 += a [ j ] [ i ] if ( sum1 == sum2 ) : i += 1 return 1 i += 1 return 0"
"def printPFsInPairs ( n ) : i = 1 while i in list ( range ( int ( pow ( n , 1 / 2 ) ) + 1 ) ) : if n % i == 0 : print ( str ( i ) + ""*"" + str ( int ( n / i ) ) ) i += 1"
"def printDistinct ( arr , n ) : arr.sort ( ) i = 0 while i in list ( range ( n ) ) : if ( i < n - 1 and arr [ i ] == arr [ i + 1 ] ) : while ( i < n - 1 and ( arr [ i ] == arr [ i + 1 ] ) ) : i += 1 else : print ( arr [ i ] , end = """" ) i += 1"
"def sortArrays ( arr , length ) : j = 0 while ( length - 1 > j ) : d1 = arr [ j ] d2 = arr [ j + 1 ] if ( d1 > d2 ) : temp = arr [ j ] arr [ j ] = arr [ j + 1 ] arr [ j + 1 ] = temp j = - 1 j += 1 return arr"
"def thirdLargest ( arr , arr_size ) : if ( arr_size < 3 ) : print ( ""InvalidInput"" ) return first = arr [ 0 ] second = - sys.maxsize third = - sys.maxsize i = 1 while i in list ( range ( arr_size ) ) : if ( arr [ i ] > first ) : third = second second = first first = arr [ i ] elif ( arr [ i ] > second ) : third = second second = arr [ i ] elif ( arr [ i ] > third ) : third = arr [ i ] i += 1 print ( ""ThethirdLargest"" , ""elementis"" , third )"
def countunsetbits ( n ) : count = 0 x = 1 while ( n + 1 > x ) : if ( ( x & n ) == 0 ) : count += 1 x = x << 1 return count
"def findCnt ( arr , n , k ) : ret = 0 i = 0 while ( i < n ) : j = i + 1 while ( j < n and arr [ j ] >= arr [ j - 1 ] ) : j = j + 1 x = max ( 0 , j - i - k ) ret = ret + ( x * ( x + 1 ) ) / 2 i = j return ret"
"def pythagoreanTriplet ( n ) : i = 1 while i in list ( range ( int ( n / 3 ) + 1 ) ) : for j in range ( i + 1 , int ( n / 2 ) + 1 ) : k = n - i - j if ( i * i + j * j == k * k ) : print ( i , "","" , j , "","" , k , sep = """" ) i += 1 return i += 1 print ( ""NoTriplet"" )"
"def countWays ( arr , n ) : max_val = 0 for i in range ( n ) : max_val = max ( max_val , arr [ i ] ) freq = [ 0 for i in range ( max_val + 1 ) ] for i in range ( n ) : freq [ arr [ i ] ] += 1 ans = 0 ans = ans + ( freq [ 0 ] * ( freq [ 0 ] - 1 ) * ( freq [ 0 ] - 2 ) // 6 ) for i in range ( 1 , max_val + 1 ) : ans = ans + ( freq [ 0 ] * freq [ i ] * ( freq [ i ] - 1 ) // 2 ) for i in range ( 1 , ( max_val + 1 ) // 2 ) : ans = ans + ( freq [ i ] * ( freq [ i ] - 1 ) // 2 * freq [ 2 * i ] ) for i in range ( 1 , max_val + 1 ) : for j in range ( i + 1 , max_val - i + 1 ) : ans = ans + freq [ i ] * freq [ j ] * freq [ i + j ] return ans"
"def countWays ( N ) : E = ( N * ( N - 1 ) ) / 2 if ( 1 == N ) : return 0 return int ( pow ( 2 , E - 1 ) )"
def findNthNum ( N ) : bit_L = 1 last_num = 0 while ( N > bit_L * ( bit_L + 1 ) / 2 ) : last_num = last_num + bit_L bit_L += 1 bit_R = N - last_num - 1 print ( ( 1 << bit_L ) + ( 1 << bit_R ) )
"def countarray ( n , k , x ) : dp = list ( ) dp.append ( 0 ) dp.append ( 1 ) i = 2 while i < n : dp.append ( ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] ) i = i + 1 return ( ( k - 1 ) * dp [ n - 2 ] if 1 == x else dp [ n - 1 ] )"
def nthTerm ( N ) : nth = 0 if ( 1 == N % 2 ) : nth = ( N * N ) + 1 else : nth = ( N * N ) - 1 return nth
def isDivisible ( n ) : while n // 100 : d = n % 10 n //= 10 n -= d * 4 return 0 == n % 41
"def eulerian ( n , m ) : if ( m >= n or n == 0 ) : return 0 if ( 0 == m ) : return 1 return ( ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) )"
"def maxSum ( stack1 , stack2 , stack3 , n1 , n2 , n3 ) : sum1 , sum2 , sum3 = 0 , 0 , 0 for i in range ( n1 ) : sum1 += stack1 [ i ] for i in range ( n2 ) : sum2 += stack2 [ i ] i = 0 while i in list ( range ( n3 ) ) : sum3 += stack3 [ i ] i += 1 top1 , top2 , top3 = 0 , 0 , 0 ans = 0 while ( 1 ) : if ( top1 == n1 or top2 == n2 or top3 == n3 ) : return 0 if ( sum1 == sum2 and sum2 == sum3 ) : return sum1 if ( sum1 >= sum2 and sum1 >= sum3 ) : sum1 -= stack1 [ top1 ] top1 = top1 + 1 elif ( sum2 >= sum3 and sum2 >= sum3 ) : sum2 -= stack2 [ top2 ] top2 = top2 + 1 elif ( sum3 >= sum2 and sum3 >= sum1 ) : sum3 -= stack3 [ top3 ] top3 = top3 + 1"
"def alter ( x , y ) : while ( True ) : if ( x == 0 or y == 0 ) : break if ( 2 * y <= x ) : x = x % ( 2 * y ) elif ( y >= 2 * x ) : y = y % ( 2 * x ) else : break print ( ""X="" , x , "","" , ""Y="" , y )"
"def printDiagonalSums ( mat , n ) : principal = 0 secondary = 0 for i in range ( 0 , n ) : j = 0 while j in list ( range ( n ) ) : if ( i == j ) : principal += mat [ i ] [ j ] if ( ( i + j ) == ( n - 1 ) ) : secondary += mat [ i ] [ j ] j += 1 print ( ""PrincipalDiagonal:"" , principal ) print ( ""SecondaryDiagonal:"" , secondary )"
"def isOverflow ( a , b ) : if ( a == 0 or 0 == b ) : return False result = a * b if ( result >= 9223372036854775807 or result <= - 9223372036854775808 ) : result = 0 if ( a == ( result // b ) ) : print ( result // b ) return False else : return True"
def minParentheses ( p ) : bal = 0 ans = 0 i = 0 while i in list ( range ( len ( p ) ) ) : if ( p [ i ] == '(' ) : bal += 1 else : bal += - 1 if ( bal == - 1 ) : ans += 1 bal += 1 i += 1 return bal + ans
"def oddEquivalent ( s , n ) : count = 0 i = 0 while i in list ( range ( n ) ) : if ( s [ i ] == '1' ) : count = count + 1 i += 1 return count"
"def printNonConsecutive ( n ) : p = ( 1 << n ) i = 1 while i in list ( range ( p ) ) : if ( ( i & ( i << 1 ) ) == 0 ) : print ( i , end = """" ) i += 1"
"def rev ( n , temp ) : if ( 0 == n ) : return temp temp = ( temp * 10 ) + ( n % 10 ) return rev ( n / 10 , temp )"
"def closetAND ( arr , n , k ) : ans = 10 ** 9 i = 0 while i in list ( range ( n ) ) : X = arr [ i ] for j in range ( i , n ) : X &= arr [ j ] ans = min ( ans , abs ( k - X ) ) i += 1 return ans"
"def russianPeasant ( a , b ) : res = 0 while ( 0 < b ) : if ( b & 1 ) : res = res + a a = a << 1 b = b >> 1 return res"
"def answer ( X , K ) : MIN = pow ( 10 , K - 1 ) if ( 0 == MIN % X ) : return ( MIN ) else : return ( ( MIN + X ) - ( ( MIN + X ) % X ) )"
"def maxSum ( arr , n ) : arr.sort ( ) sum = 0 i = 0 while i in list ( range ( n ) ) : sum += arr [ i ] * i i += 1 return sum"
"def longestSubsequence ( a , n ) : mp = { i : 0 for i in range ( 13 ) } dp = [ 0 for i in range ( n ) ] maximum = - sys.maxsize - 1 index = - 1 for i in range ( n ) : if ( ( a [ i ] - 1 ) in mp ) : lastIndex = mp [ a [ i ] - 1 ] - 1 dp [ i ] = 1 + dp [ lastIndex ] else : dp [ i ] = 1 mp [ a [ i ] ] = i + 1 if ( maximum < dp [ i ] ) : maximum = dp [ i ] index = i curr = a [ index ] - maximum + 1 while curr in list ( range ( a [ index ] + 1 ) ) : print ( curr , end = """" ) curr += 1"
def countWays ( n ) : count = 0 i = 1 while ( n > ( i * i ) ) : if ( n % i == 0 ) : count += 1 i += 1 return count
"def generateNumbers ( factor , n , k ) : next = [ 0 ] * k output = 0 i = 0 while ( i < n ) : toincrement = 0 j = 0 while j in list ( range ( k ) ) : if ( next [ j ] < next [ toincrement ] ) : toincrement = j j += 1 if ( output != next [ toincrement ] ) : output = next [ toincrement ] print ( next [ toincrement ] , end = """" ) i += 1 next [ toincrement ] += factor [ toincrement ]"
"def countSteps ( x , y ) : if ( 0 == x % y ) : return math.floor ( x / y ) return math.floor ( ( x / y ) + countSteps ( y , x % y ) )"
"def superSeq ( X , Y , m , n ) : dp = [ [ 0 ] * ( n + 2 ) for i in range ( m + 2 ) ] for i in range ( m + 1 ) : j = 0 while j in list ( range ( n + 1 ) ) : if ( not i ) : dp [ i ] [ j ] = j elif ( not j ) : dp [ i ] [ j ] = i elif ( X [ i - 1 ] == Y [ j - 1 ] ) : dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] else : dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) j += 1 return dp [ m ] [ n ]"
"def sackRace ( p1 , s1 , p2 , s2 ) : return ( ( s1 > s2 and 0 == ( p2 - p1 ) % ( s1 - s2 ) ) or ( s2 > s1 and ( p1 - p2 ) % ( s2 - s1 ) == 0 ) )"
"def find ( a , b , k , n1 , n2 ) : s = set ( ) for i in range ( n2 ) : s.add ( b [ i ] ) missing = 0 i = 0 while i in list ( range ( n1 ) ) : if a [ i ] not in s : missing += 1 if missing == k : i += 1 return a [ i ] i += 1 return - 1"
"def arrayEvenAndOdd ( arr , n ) : i = - 1 j = 0 while ( j != n ) : if ( 0 == arr [ j ] % 2 ) : i = i + 1 arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] j = j + 1 for i in arr : print ( str ( i ) + """" , end = '' )"
"def findMinX ( num , rem , k ) : x = 1 while ( True ) : j = 0 while ( k > j ) : if ( x % num [ j ] != rem [ j ] ) : break j += 1 if ( j == k ) : return x x += 1"
"def longestRepeatedSubstring ( str ) : n = len ( str ) LCSRe = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] res = """" res_length = 0 index = 0 for i in range ( 1 , n + 1 ) : for j in range ( i + 1 , n + 1 ) : if ( str [ i - 1 ] == str [ j - 1 ] and LCSRe [ i - 1 ] [ j - 1 ] < ( j - i ) ) : LCSRe [ i ] [ j ] = LCSRe [ i - 1 ] [ j - 1 ] + 1 if ( LCSRe [ i ] [ j ] > res_length ) : res_length = LCSRe [ i ] [ j ] index = max ( i , index ) else : LCSRe [ i ] [ j ] = 0 if ( res_length > 0 ) : i = index - res_length + 1 while i in list ( range ( index + 1 ) ) : res = res + str [ i - 1 ] i += 1 return res"
"def printArray ( X , d , first_ele ) : while ( X > 0 ) : count_ele , pow_of_two = 0 , 2 while ( X - pow_of_two + 1 >= 0 ) : count_ele += 1 pow_of_two *= 2 X = X - ( pow_of_two / 2 ) + 1 j = 0 while j in list ( range ( count_ele ) ) : print ( first_ele , end = """" ) j += 1 first_ele += d"
"def print_sequence ( n , k ) : b = int ( n / ( k * ( k + 1 ) / 2 ) ) if b != 0 : r = 1 x = 1 while x ** 2 <= n : if n % x != 0 : continue elif x <= b and x > r : r = x elif n / x <= b and n / x > r : r = n / x x = x + 1 i = 1 while i < k : print ( r * i , end = """" ) i = i + 1 last_term = n - ( r * ( k * ( k - 1 ) / 2 ) ) print ( last_term ) else : print ( ""-1"" )"
"def Count ( s , pos ) : c = s [ pos - 1 ] counter = 0 i = 0 while i in list ( range ( pos - 1 ) ) : if s [ i ] == c : counter = counter + 1 i += 1 return counter"
"def Permutation ( n , k ) : p = [ 0 for i in range ( n + 1 ) ] for i in range ( 1 , n + 1 ) : p [ i ] = i for i in range ( 1 , n - k ) : p [ i + 1 ] = i p [ 1 ] = n - k i = 1 while i in list ( range ( n + 1 ) ) : print ( p [ i ] , end = """" ) i += 1"
"def horner ( poly , n , x ) : result = poly [ 0 ] i = 1 while i in list ( range ( n ) ) : result = result * x + poly [ i ] i += 1 return result"
"def binarySearch ( arr , left , right ) : if ( right >= left ) : mid = ( left + right ) // 2 if ( arr [ mid - 1 ] < arr [ mid ] and arr [ mid ] > arr [ mid + 1 ] ) : return mid if ( arr [ mid ] < arr [ mid + 1 ] ) : return binarySearch ( arr , mid + 1 , right ) else : return binarySearch ( arr , left , mid - 1 ) return - 1"
"def isFrequencyEqual ( string , length ) : if length % 2 == 1 : return False freq = [ 0 ] * 26 for i in range ( 0 , length ) : freq [ ord ( string [ i ] ) - ord ( 'a' ) ] += 1 i = 0 while i in list ( range ( 26 ) ) : if freq [ i ] == length // 2 : i += 1 return True i += 1 return False"
"def findInteger ( arr , n ) : hash = dict ( ) maximum = 0 for i in arr : if ( i < 0 ) : if abs ( i ) not in hash.keys ( ) : hash [ abs ( i ) ] = - 1 else : hash [ abs ( i ) ] -= 1 else : hash [ i ] = hash.get ( i , 0 ) + 1 for i in arr : if i in hash.keys ( ) and 0 < hash [ i ] : return i return - 1"
"def minSum ( arr , n ) : evenArr = [ ] oddArr = [ ] arr.sort ( ) i = 0 while i in list ( range ( n ) ) : if ( i < n // 2 ) : oddArr.append ( arr [ i ] ) else : evenArr.append ( arr [ i ] ) i += 1 evenArr.sort ( reverse = True ) i = 0 sum = 0 for j in range ( len ( evenArr ) ) : arr [ i ] = evenArr [ j ] i += 1 arr [ i ] = oddArr [ j ] i += 1 sum += evenArr [ j ] * oddArr [ j ] return sum"
"def firstFit ( blockSize , m , processSize , n ) : allocation = [ - 1 ] * n for i in range ( n ) : for j in range ( m ) : if blockSize [ j ] >= processSize [ i ] : allocation [ i ] = j blockSize [ j ] -= processSize [ i ] break print ( ""ProcessNo.ProcessSizeBlockno."" ) i = 0 while i in list ( range ( n ) ) : print ( """" , i + 1 , """" , processSize [ i ] , """" , end = """" ) if allocation [ i ] != - 1 : print ( allocation [ i ] + 1 ) else : print ( ""NotAllocated"" ) i += 1"
"def replaceOriginal ( s , n ) : r = [ '' ] * n i = 0 while i in list ( range ( n ) ) : r [ i ] = s [ n - 1 - i ] if ( s [ i ] != 'a' and s [ i ] != 'e' and s [ i ] != 'i' and s [ i ] != 'o' and s [ i ] != 'u' ) : print ( r [ i ] , end = """" ) i += 1 print ( )"
def findLargestDivisor ( n ) : i = 2 while i in list ( range ( int ( math.sqrt ( n ) ) + 1 ) ) : while ( n % ( i * i ) == 0 ) : n = n // i i += 1 return n
"def isHeap ( arr , i , n ) : if int ( ( n - 2 ) / 2 ) < i : return True if ( arr [ i ] >= arr [ 2 * i + 1 ] and arr [ i ] >= arr [ 2 * i + 2 ] and isHeap ( arr , 2 * i + 1 , n ) and isHeap ( arr , 2 * i + 2 , n ) ) : return True return False"
"def generate_derangement ( N ) : S = [ 0 ] * ( N + 1 ) i = 1 while i in list ( range ( N + 1 ) ) : S [ i ] = i i += 1 D = [ 0 ] * ( N + 1 ) for i in range ( 1 , N + 1 , 2 ) : if i == N : D [ N ] = S [ N - 1 ] D [ N - 1 ] = S [ N ] else : D [ i ] = i + 1 D [ i + 1 ] = i for i in range ( 1 , N + 1 ) : print ( D [ i ] , end = """" ) print ( )"
"def countPairsWithDiffK ( arr , n , k ) : count = 0 arr.sort ( ) l = 0 r = 0 while r < n : if k == arr [ r ] - arr [ l ] : count += 1 l += 1 r += 1 elif arr [ r ] - arr [ l ] > k : l += 1 else : r += 1 return count"
def findMinNumber ( n ) : count = 0 ans = 1 while n % 2 == 0 : count += 1 n //= 2 if count % 2 is not 0 : ans *= 2 i = 3 while i in list ( range ( ( int ) ( math.sqrt ( n ) ) + 1 ) ) : count = 0 while n % i == 0 : count += 1 n //= i if count % 2 is not 0 : ans *= i i += 2 if n > 2 : ans *= n return ans
"def longOddEvenIncSeq ( arr , n ) : lioes = list ( ) maxLen = 0 for i in range ( n ) : lioes.append ( 1 ) i = 1 for i in range ( n ) : for j in range ( i ) : if ( arr [ i ] > arr [ j ] and ( arr [ i ] + arr [ j ] ) % 2 != 0 and lioes [ i ] < lioes [ j ] + 1 ) : lioes [ i ] = lioes [ j ] + 1 i = 0 while i in list ( range ( n ) ) : if maxLen < lioes [ i ] : maxLen = lioes [ i ] i += 1 return maxLen"
"def countFreq ( pat , txt ) : M = len ( pat ) N = len ( txt ) res = 0 i = 0 while i in list ( range ( N - M + 1 ) ) : j = 0 for j in range ( M ) : if ( txt [ i + j ] != pat [ j ] ) : i += 1 break if ( j == M - 1 ) : res += 1 j = 0 i += 1 return res"
"def countNumbers ( n ) : k = 0 count = 0 while ( n > 0 ) : if ( ( n & 1 ) == 0 ) : count = count + pow ( 2 , k ) k = k + 1 n >>= 1 return count"
def firstDigit ( n ) : fact = 1 i = 2 while i in list ( range ( n + 1 ) ) : fact = fact * i while ( fact % 10 == 0 ) : fact = int ( fact / 10 ) i += 1 while ( fact >= 10 ) : fact = int ( fact / 10 ) return math.floor ( fact )
"def count_numbers ( k , n , flag ) : if ( 1 == n ) : if ( flag ) : return ( k - 1 ) else : return 1 if ( flag ) : return ( k - 1 ) * ( count_numbers ( k , n - 1 , 0 ) + count_numbers ( k , n - 1 , 1 ) ) else : return count_numbers ( k , n - 1 , 1 )"
"def constructPalin ( string , l ) : string = list ( string ) i = - 1 j = l while i < j : i += 1 j -= 1 if ( string [ i ] == string [ j ] and string [ i ] != '*' ) : continue elif ( string [ i ] == string [ j ] and string [ i ] == '*' ) : string [ i ] = 'a' string [ j ] = 'a' continue elif string [ i ] == '*' : string [ i ] = string [ j ] continue elif '*' == string [ j ] : string [ j ] = string [ i ] continue print ( ""NotPossible"" ) return """" return ''.join ( string )"
"def countDivisibles ( arr , n ) : res = 0 i = 0 while i in list ( range ( n ) ) : for j in range ( i + 1 , n ) : if ( arr [ i ] % arr [ j ] == 0 or arr [ j ] % arr [ i ] == 0 ) : res += 1 i += 1 return res"
"def minimumChanges ( arr , n , d ) : maxFreq = - 2147483648 freq = { } i = 0 while i in list ( range ( n ) ) : a0 = arr [ i ] - i * d if a0 in freq : freq [ a0 ] += 1 else : freq [ a0 ] = 1 if freq [ a0 ] > maxFreq : maxFreq = freq [ a0 ] i += 1 return ( n - maxFreq )"
"def printPattern ( i , j , n ) : if ( j >= n ) : return 0 if ( i >= n ) : return 1 if ( i == j or j == n - 1 - i ) : if ( i == n - 1 - j ) : print ( ""/"" , end = """" ) else : print ( ""\\"" , end = """" ) else : print ( ""*"" , end = """" ) if ( printPattern ( i , j + 1 , n ) == 1 ) : return 1 print ( ) return printPattern ( i + 1 , 0 , n )"
def Circular ( n ) : Result = 1 while 0 < n : Result = Result * n n -= 1 return Result
"def findMinDiff ( arr , n ) : arr = sorted ( arr ) diff = 10 ** 20 i = 0 while i in list ( range ( n - 1 ) ) : if arr [ i + 1 ] - arr [ i ] < diff : diff = arr [ i + 1 ] - arr [ i ] i += 1 return diff"
"def ceilSearch ( arr , low , high , x ) : if x <= arr [ low ] : return low i = low i = 0 while i in list ( range ( high ) ) : if arr [ i ] == x : i += 1 return i if arr [ i ] < x and arr [ i + 1 ] >= x : i += 1 return i + 1 i += 1 return - 1"
"def printModulus ( X , Y ) : n = max ( X , Y ) i = 1 while i in list ( range ( n + 1 ) ) : if ( X % i == Y % i ) : print ( i , end = """" ) i += 1"
"def steps ( string , n ) : flag = False x = 0 i = 0 while i in list ( range ( len ( string ) ) ) : if ( x == 0 ) : flag = True if ( x == n - 1 ) : flag = False for j in range ( x ) : print ( ""*"" , end = """" ) print ( string [ i ] ) if ( flag == True ) : x += 1 else : x -= 1 i += 1"
"def countSeq ( n , diff ) : if ( abs ( diff ) > n ) : return 0 if ( 1 == n and diff == 0 ) : return 2 if ( n == 1 and abs ( diff ) == 1 ) : return 1 res = ( countSeq ( n - 1 , diff + 1 ) + 2 * countSeq ( n - 1 , diff ) + countSeq ( n - 1 , diff - 1 ) ) return res"
"def findTime ( T , K ) : minutes = ( ( ( ord ( T [ 0 ] ) - ord ( '' ) ) * 10 + ord ( T [ 1 ] ) - ord ( '' ) ) * 60 + ( ( ord ( T [ 3 ] ) - ord ( '' ) ) * 10 + ord ( T [ 4 ] ) - ord ( '' ) ) ) minutes = minutes + K hour = ( int ( minutes / 60 ) ) % 24 min = minutes % 60 if ( hour < 10 ) : print ( 0 , hour , """" , end = """" ) else : print ( hour , """" , end = """" ) if ( min < 10 ) : print ( 0 , min , end = """" ) else : print ( min , end = """" )"
def countLattice ( r ) : if ( r <= 0 ) : return 0 result = 4 x = 1 while x in list ( range ( r ) ) : ySquare = r * r - x * x y = int ( math.sqrt ( ySquare ) ) if ( y * y == ySquare ) : result += 4 x += 1 return result
"def cntSubSeq ( arr , n ) : pos_count = 0 neg_count = 0 i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] > 0 ) : pos_count += 1 if ( arr [ i ] < 0 ) : neg_count += 1 i += 1 result = int ( math.pow ( 2 , pos_count ) ) if ( neg_count > 0 ) : result *= int ( math.pow ( 2 , neg_count - 1 ) ) result -= 1 return result"
"def findAnswer ( str1 , str2 , n ) : l , r = 0 , 0 ans = 2 for i in range ( n ) : if ( str1 [ i ] != str2 [ i ] ) : l = i break for i in range ( n - 1 , - 1 , - 1 ) : if ( str1 [ i ] != str2 [ i ] ) : r = i break if ( r < l ) : return 26 * ( n + 1 ) elif ( l == r ) : return ans else : for i in range ( l + 1 , r + 1 ) : if ( str1 [ i ] != str2 [ i - 1 ] ) : ans -= 1 break i = l + 1 while i in list ( range ( r + 1 ) ) : if ( str1 [ i - 1 ] != str2 [ i ] ) : ans -= 1 i += 1 break i += 1 return ans"
"def findSum ( arr , N ) : mp = dict ( ) i = 0 while i in list ( range ( N ) ) : mp [ arr [ i ] ] = mp.get ( arr [ i ] , 0 ) + 1 i += 1 maxFreq = 0 for itr in mp : if ( mp [ itr ] > maxFreq ) : maxFreq = mp [ itr ] Sum = 0 for itr in mp : if ( mp [ itr ] == maxFreq ) : Sum += itr * mp [ itr ] return Sum"
"def areConsecutives ( arr , n ) : first_term = sys.maxsize i = 0 while i in list ( range ( n ) ) : if arr [ i ] < first_term : first_term = arr [ i ] i += 1 ap_sum = ( ( n * ( 2 * first_term + ( n - 1 ) * 1 ) ) // 2 ) arr_sum = 0 for i in range ( n ) : arr_sum += arr [ i ] return ap_sum == arr_sum"
"def SieveOfEratosthenes ( n , isPrime ) : isPrime [ 0 ] = isPrime [ 1 ] = False for i in range ( 2 , n + 1 ) : isPrime [ i ] = True for p in range ( 2 , n + 1 ) : if ( p * p <= n and isPrime [ p ] == True ) : i = p * 2 while i in list ( range ( n + 1 ) ) : isPrime [ i ] = False p += 1 i += p"
"def smallestMultiple ( n ) : if ( 1 == n ) : return 5 return pow ( 10 , n - 1 )"
"def minSum ( arr , n , x ) : Sum = 0 largestDivisible , minimum = - 1 , arr [ 0 ] i = 0 while i in list ( range ( n ) ) : Sum += arr [ i ] if ( arr [ i ] % x == 0 and largestDivisible < arr [ i ] ) : largestDivisible = arr [ i ] if arr [ i ] < minimum : minimum = arr [ i ] i += 1 if largestDivisible == - 1 : return Sum sumAfterOperation = ( Sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible // x ) ) return min ( Sum , sumAfterOperation )"
"def countSubarray ( arr , n , k ) : s = 0 i = 0 while ( i < n ) : if ( arr [ i ] > k ) : i = i + 1 continue count = 0 while ( i < n and k >= arr [ i ] ) : i = i + 1 count = count + 1 s = s + ( ( count * ( count + 1 ) ) // 2 ) return ( n * ( n + 1 ) // 2 - s )"
"def sortedCount ( mat , r , c ) : result = 0 i = 0 while i in list ( range ( r ) ) : j = 0 for j in range ( c - 1 ) : if mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] : i += 1 break if j == c - 2 : result += 1 i += 1 for i in range ( 0 , r ) : j = 0 for j in range ( c - 1 , 0 , - 1 ) : if mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] : break if c > 1 and j == 1 : result += 1 return result"
"def countPairs ( arr , n ) : mp = dict ( ) i = 0 while i in list ( range ( n ) ) : if arr [ i ] in mp.keys ( ) : mp [ arr [ i ] ] += 1 else : mp [ arr [ i ] ] = 1 i += 1 ans = 0 for it in mp : count = mp [ it ] ans += ( count * ( count - 1 ) ) // 2 return ans"
"def solve ( n , t , p ) : s = list ( p ) i = 0 while i in list ( range ( t ) ) : for j in range ( 0 , n - 1 ) : if ( s [ j ] == 'B' and s [ j + 1 ] == 'G' ) : temp = s [ j ] s [ j ] = s [ j + 1 ] s [ j + 1 ] = temp j = j + 1 i += 1 print ( ''.join ( s ) )"
"def totalSumDivisibleByNum ( n , number ) : firstnum = pow ( 10 , n - 1 ) lastnum = pow ( 10 , n ) sum = 0 i = firstnum while i in list ( range ( lastnum ) ) : if ( i % number == 0 ) : sum += i i += 1 return sum"
"def minRadius ( k , x , y , n ) : dis = [ 0 ] * n i = 0 while i in list ( range ( n ) ) : dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] i += 1 dis.sort ( ) return dis [ k - 1 ]"
"def incrementVector ( a ) : n = len ( a ) a [ n - 1 ] += 1 carry = a [ n - 1 ] / 10 a [ n - 1 ] = a [ n - 1 ] % 10 i = n - 2 while i in list ( range ( - 1 ) ) : if ( carry == 1 ) : a [ i ] += 1 carry = a [ i ] / 10 a [ i ] = a [ i ] % 10 i += - 1 if ( carry == 1 ) : a.insert ( 0 , 1 )"
"def numberOfLines ( S , widths ) : if ( S == """" ) : return 0 , 0 lines , width = 1 , 0 for c in S : w = widths [ ord ( c ) - ord ( '' ) ] width = width + w if width > 10 : lines = lines + 1 width = w return lines , width"
"def xorLessK ( arr , n , k ) : count = 0 i = 0 while i in list ( range ( n ) ) : tempXor = 0 for j in range ( i , n ) : tempXor ^= arr [ j ] if ( tempXor < k ) : count += 1 i += 1 return count"
"def strScore ( str , s , n ) : score = 0 index = 0 for i in range ( n ) : if ( str [ i ] == s ) : j = 0 while j in list ( range ( len ( s ) ) ) : score += ( ord ( s [ j ] ) - ord ( 'a' ) + 1 ) j += 1 index = i + 1 break score = score * index return score"
"def minOperations ( ar , k ) : ar = sorted ( ar ) opsNeeded = 0 i = 0 while i in list ( range ( k ) ) : opsNeeded += ar [ k - 1 ] - ar [ i ] i += 1 ans = opsNeeded for i in range ( k , len ( ar ) ) : opsNeeded = opsNeeded - ( ar [ i - 1 ] - ar [ i - k ] ) opsNeeded += ( k - 1 ) * ( ar [ i ] - ar [ i - 1 ] ) ans = min ( ans , opsNeeded ) return ans"
"def printSquares ( n ) : square = 0 ; prev_x = 0 x = 0 while x in list ( range ( n ) ) : square = ( square + x + prev_x ) print ( square , end = """" ) prev_x = x x += 1"
"def divisibleBy36 ( num ) : l = len ( num ) if ( l == 0 ) : return ( ""No"" ) if ( l == 1 and num [ 0 ] != '0' ) : return ( ""No"" ) two_digit_num = ( ( ( int ) ( num [ l - 2 ] ) ) * 10 + ( int ) ( num [ l - 1 ] ) ) if ( two_digit_num % 4 != 0 ) : return ""No"" sm = 0 i = 0 while i in list ( range ( l ) ) : sm = sm + ( int ) ( num [ i ] ) i += 1 if ( sm % 9 != 0 ) : return ( ""No"" ) return ( ""Yes"" )"
"def originalArray ( greater , n ) : temp = [ ] i = 0 while i in list ( range ( n + 1 ) ) : temp.append ( i ) i += 1 arr = [ 0 for i in range ( n ) ] for i in range ( n ) : k = n - greater [ i ] - i arr [ i ] = temp [ k ] del temp [ k ] for i in range ( n ) : print ( arr [ i ] , end = """" )"
def check ( st ) : n = len ( st ) oddDigSum = 0 evenDigSum = 0 i = 0 while i in list ( range ( n ) ) : if ( i % 2 == 0 ) : oddDigSum = oddDigSum + ( ( int ) ( st [ i ] ) ) else : evenDigSum = evenDigSum + ( ( int ) ( st [ i ] ) ) i += 1 return ( ( oddDigSum - evenDigSum ) % 11 == 0 )
"def countNumbers ( x , n ) : if n < x : return 0 return ( 1 + countNumbers ( x * 10 , n ) + countNumbers ( x * 10 + 1 , n ) )"
"def vietaFormula ( roots , n ) : coeff = [ 0 ] * ( n + 1 ) coeff [ n ] = 1 i = 1 while i in list ( range ( n + 1 ) ) : for j in range ( n - i - 1 , n ) : coeff [ j ] += ( ( - 1 ) * roots [ i - 1 ] * coeff [ j + 1 ] ) i += 1 coeff = coeff [ : : - 1 ] print ( ""PolynomialCoefficients:"" , end = """" ) for i in coeff : print ( i , end = """" ) print ( )"
"def isChangeable ( notes , n ) : fiveCount = 0 tenCount = 0 i = 0 while i in list ( range ( n ) ) : if ( notes [ i ] == 5 ) : fiveCount += 1 elif ( notes [ i ] == 10 ) : if ( fiveCount > 0 ) : fiveCount -= 1 tenCount += 1 else : i += 1 return 0 else : if ( fiveCount > 0 and tenCount > 0 ) : fiveCount -= 1 tenCount -= 1 elif ( fiveCount >= 3 ) : fiveCount -= 3 else : i += 1 return 0 i += 1 return 1"
"def rearrange ( arr , n ) : max_idx = n - 1 min_idx = 0 max_elem = arr [ n - 1 ] + 1 i = 0 while i in list ( range ( n ) ) : if i % 2 == 0 : arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem max_idx -= 1 else : arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem min_idx += 1 i += 1 for i in range ( 0 , n ) : arr [ i ] = arr [ i ] / max_elem"
def findSum ( n ) : sum = 0 i = 0 while i in list ( range ( n ) ) : sum += i * ( n - i ) i += 1 return 2 * sum
"def findTransitionPoint ( arr , n ) : lb = 0 ub = n - 1 while ( lb <= ub ) : mid = ( int ) ( ( lb + ub ) / 2 ) if ( arr [ mid ] == 0 ) : lb = mid + 1 elif ( 1 == arr [ mid ] ) : if ( arr [ mid - 1 ] == 0 ) : return mid ub = mid - 1 return - 1"
"def findMod ( a , b ) : if ( a < 0 ) : a = - a if ( b < 0 ) : b = - b mod = a while ( b <= mod ) : mod = mod - b if ( a < 0 ) : return - mod return mod"
"def alternateSubarray ( arr , n ) : count = 1 prev = arr [ 0 ] i = 1 while i in list ( range ( n ) ) : if ( ( arr [ i ] ^ prev ) == 0 ) : while ( count ) : print ( count , end = """" ) count -= 1 count += 1 prev = arr [ i ] i += 1 while ( count ) : print ( count , end = """" ) count -= 1"
"def MinSteps ( SourceX , SourceY , DestX , DestY ) : print ( max ( abs ( SourceX - DestX ) , abs ( SourceY - DestY ) ) ) while ( ( SourceX != DestX ) or ( DestY != SourceY ) ) : if ( SourceX < DestX ) : print ( 'U' , end = """" ) SourceX += 1 if ( SourceX > DestX ) : print ( 'D' , end = """" ) SourceX -= 1 if ( SourceY > DestY ) : print ( 'L' ) SourceY -= 1 if ( SourceY < DestY ) : print ( 'R' , end = """" ) SourceY += 1"
"def minJumps ( a , b , d ) : temp = a a = min ( a , b ) b = max ( temp , b ) if ( b <= d ) : return ( d + b - 1 ) / b if ( d == 0 ) : return 0 if ( d == a ) : return 1 return 2"
"def lis ( arr ) : n = len ( arr ) lis = [ 1 ] * n for i in range ( 1 , n ) : j = 0 while j in list ( range ( i ) ) : if arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 : lis [ i ] = lis [ j ] + 1 j += 1 maximum = 0 for i in range ( n ) : maximum = max ( maximum , lis [ i ] ) return maximum"
"def firstNonRepeating ( arr , n ) : i = 0 while i in list ( range ( n ) ) : j = 0 while ( j < n ) : if ( i != j and arr [ i ] == arr [ j ] ) : i += 1 break j += 1 if ( j == n ) : i += 1 return arr [ i ] i += 1 return - 1"
def removeDuplicates ( S ) : n = len ( S ) if ( n < 2 ) : return j = 0 i = 0 while i in list ( range ( n ) ) : if ( S [ j ] != S [ i ] ) : j += 1 S [ j ] = S [ i ] i += 1 j += 1 S = S [ : j ] return S
"def findNumber ( arr , n ) : arr = sorted ( arr ) Max = arr [ n - 1 ] table = [ 10 ** 9 for i in range ( ( 2 * Max ) + 1 ) ] table [ 0 ] = 0 ans = - 1 for i in range ( 1 , 2 * Max + 1 ) : j = 0 while j in list ( range ( n ) ) : if ( arr [ j ] <= i ) : res = table [ i - arr [ j ] ] if ( res != 10 ** 9 and res + 1 < table [ i ] ) : table [ i ] = res + 1 j += 1 if ( i > arr [ n - 1 ] and table [ i ] == 10 ** 9 ) : ans = i break return ans"
"def findValues ( a , b ) : if ( 1 == ( a - b ) % 2 ) : print ( ""-1"" ) return print ( ( a - b ) // 2 , ( a + b ) // 2 )"
"def countEleLessThanOrEqual ( arr1 , arr2 , m , n ) : for i in range ( m ) : count = 0 j = 0 while j in list ( range ( n ) ) : if ( arr2 [ j ] <= arr1 [ i ] ) : count += 1 j += 1 print ( count , end = """" )"
"def SternSequenceFunc ( BrocotSequence , n ) : for i in range ( 1 , n ) : considered_element = BrocotSequence [ i ] precedent = BrocotSequence [ i - 1 ] BrocotSequence.append ( considered_element + precedent ) BrocotSequence.append ( considered_element ) i = 0 while i in list ( range ( 15 ) ) : print ( BrocotSequence [ i ] , end = """" ) i += 1"
"def printPossible ( a , b , c ) : if ( 0 != ( a + b + c ) % 2 or a + b < c ) : print ( ""NO"" ) else : print ( ""YES"" )"
"def findMinInsertions ( str , l , h ) : if ( l > h ) : return sys.maxsize if ( l == h ) : return 0 if ( l == h - 1 ) : return 0 if ( str [ l ] == str [ h ] ) else 1 if ( str [ h ] == str [ l ] ) : return findMinInsertions ( str , l + 1 , h - 1 ) else : return ( min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 )"
def MinOfCubedDP ( k ) : DP = [ 0 ] * ( k + 1 ) j = 1 t = 1 DP [ 0 ] = 0 i = 1 while i in list ( range ( k + 1 ) ) : DP [ i ] = sys.maxsize while ( j <= i ) : if ( j == i ) : DP [ i ] = 1 elif ( DP [ i ] > DP [ i - j ] ) : DP [ i ] = DP [ i - j ] + 1 t += 1 j = t * t * t t = j = 1 i += 1 return DP [ k ]
def isPowerOfFour ( n ) : return ( 0 != n and ( ( n & ( n - 1 ) ) == 0 ) and not ( n & 0xAAAAAAAA ) )
"def countDistinct ( arr , n ) : arr.sort ( ) res = 0 i = 0 while ( n > i ) : while ( i < n - 1 and arr [ i ] == arr [ i + 1 ] ) : i += 1 res += 1 i += 1 return res"
"def pre_process ( substrings , s ) : n = len ( s ) for i in range ( n ) : dup = """" j = i while j in list ( range ( n ) ) : dup += s [ j ] substrings.append ( dup ) j += 1 substrings.sort ( ) return substrings"
"def countMaxContiguous ( arr , n ) : current_max = 0 max_so_far = 0 i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] % 2 != 0 ) : current_max = 0 else : current_max += 1 max_so_far = max ( current_max , max_so_far ) i += 1 return max_so_far"
"def nthTerm ( N ) : nth = 0 i = N while i in list ( range ( 0 ) ) : nth += pow ( i , i ) i += - 1 return nth"
"def countSubsequence ( s , n ) : cntG = 0 cntF = 0 result = 0 C = 0 i = 0 while i in list ( range ( n ) ) : if ( s [ i ] == 'G' ) : cntG += 1 result += C i += 1 continue if ( s [ i ] == 'F' ) : cntF += 1 C += cntG i += 1 continue else : i += 1 continue i += 1 print ( result )"
"def minReplacement ( string ) : if len ( string ) > 26 : print ( ""IMPOSSIBLE"" ) else : Hash = [ 0 ] * 26 i = 0 while i in list ( range ( len ( string ) ) ) : Hash [ ord ( string [ i ] ) - ord ( 'a' ) ] += 1 i += 1 count = 0 for i in range ( 0 , len ( string ) ) : if Hash [ ord ( string [ i ] ) - ord ( 'a' ) ] > 1 : for j in range ( 0 , 26 ) : if Hash [ j ] == 0 : Hash [ ord ( string [ i ] ) - ord ( 'a' ) ] -= 1 string [ i ] = chr ( j + ord ( 'a' ) ) Hash [ j ] += 1 break print ( ''.join ( string ) )"
def numberOfWays ( x ) : if 0 == x or x == 1 : return 1 else : return ( numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) )
def nthTerm ( n ) : nth = 0 if ( 0 == n % 2 ) : nth = 2 * ( ( n * n ) - n ) else : nth = ( 2 * n * n ) - n return nth
"def missingNumber ( a , n ) : mp = dict ( ) i = 0 while i in list ( range ( n ) ) : if ( a [ i ] > 0 ) : if a [ i ] not in mp.keys ( ) : mp [ a [ i ] ] = 0 mp [ a [ i ] ] += 1 i += 1 index = 1 while ( 1 ) : if ( index not in mp.keys ( ) ) : return index index += 1"
"def countSubarrays ( a , n ) : count = 0 pre = [ 0 for i in range ( n + 1 ) ] for i in range ( 1 , n + 1 ) : pre [ i ] = pre [ i - 1 ] + a [ i - 1 ] i = 1 while i in list ( range ( n + 1 ) ) : for j in range ( i , n + 1 ) : sum1 = pre [ j ] - pre [ i - 1 ] count1 = j - i + 1 sum2 = pre [ n ] - sum1 if n - count1 == 0 : count2 = 1 else : count2 = n - count1 includ = sum1 // count1 exclud = sum2 // count2 if ( includ > exclud ) : count += 1 i += 1 return count"
"def find3Numbers ( A , arr_size , sum ) : for i in range ( 0 , arr_size - 2 ) : j = i + 1 while j in list ( range ( arr_size - 1 ) ) : for k in range ( j + 1 , arr_size ) : if A [ i ] + A [ j ] + A [ k ] == sum : print ( ""Tripletis"" , A [ i ] , "","" , A [ j ] , "","" , A [ k ] ) j += 1 return True j += 1 return False"
"def maxPartitions ( arr , n ) : ans = 0 ; max_so_far = 0 i = 0 while i in list ( range ( n ) ) : max_so_far = max ( max_so_far , arr [ i ] ) if ( max_so_far == i ) : ans += 1 i += 1 return ans"
"def minJumps ( arr , n ) : jumps = [ 0 for i in range ( n ) ] for i in range ( n - 2 , - 1 , - 1 ) : if ( arr [ i ] == 0 ) : jumps [ i ] = float ( 'inf' ) elif ( arr [ i ] >= n - i - 1 ) : jumps [ i ] = 1 else : min = float ( 'inf' ) j = i + 1 while j in list ( range ( n ) ) : if ( j <= arr [ i ] + i ) : if ( min > jumps [ j ] ) : min = jumps [ j ] j += 1 if ( min != float ( 'inf' ) ) : jumps [ i ] = min + 1 else : jumps [ i ] = min return jumps [ 0 ]"
"def countSol ( coeff , n , rhs ) : dp = [ 0 for i in range ( rhs + 1 ) ] dp [ 0 ] = 1 i = 0 while i in list ( range ( n ) ) : for j in range ( coeff [ i ] , rhs + 1 ) : dp [ j ] += dp [ j - coeff [ i ] ] i += 1 return dp [ rhs ]"
"def distribution ( arr , n ) : resources = set ( ) i = 0 while i in list ( range ( n ) ) : resources.add ( arr [ i ] ) i += 1 return min ( len ( resources ) , n // 2 )"
"def checksum ( n ) : if n == 0 : print ( ""-2-1012"" ) return 0 inc = 0 if n > 0 : inc = 1 else : inc = - 1 i = 0 while i in list ( range ( n - 3 ) ) : if i + i + 1 + i + 2 + i + 3 + i + 4 == n : print ( i , """" , i + 1 , """" , i + 2 , """" , i + 3 , """" , i + 4 ) i += inc return 0 i += inc print ( ""-1"" )"
"def minimumSets ( arr , n , key ) : arr.sort ( reverse = False ) j = n - 1 i = 0 while i in list ( range ( j + 1 ) ) : if ( arr [ i ] + arr [ j ] <= key ) : j -= 1 i += 1 return i + 1"
"def findMinDiff ( arr , n ) : diff = 10 ** 20 i = 0 while i in list ( range ( n - 1 ) ) : for j in range ( i + 1 , n ) : if abs ( arr [ i ] - arr [ j ] ) < diff : diff = abs ( arr [ i ] - arr [ j ] ) i += 1 return diff"
"def printSubArrays ( arr , start , end ) : if end == len ( arr ) : return elif end < start : return printSubArrays ( arr , 0 , end + 1 ) else : print ( arr [ start : end + 1 ] ) return printSubArrays ( arr , start + 1 , end )"
"def findCountOfPairs ( a , b , n ) : ans = 0 i = 1 while i in list ( range ( a + 1 ) ) : ans += b // n ans += 1 if ( i % n + b % n ) >= n else 0 i += 1 return ans"
"def maxnumber ( n , k ) : i = 0 while i in list ( range ( k ) ) : ans = 0 i = 1 while n // i > 0 : temp = ( n // ( i * 10 ) ) * i + ( n % i ) i *= 10 if temp > ans : ans = temp n = ans i += 1 return ans"
"def hasCrest ( arr , n , L , R ) : present = [ 0 ] * n i = 1 while i in list ( range ( n - 2 + 1 ) ) : if ( ( arr [ i ] <= arr [ i + 1 ] ) and ( arr [ i ] <= arr [ i - 1 ] ) ) : present [ i ] = 1 i += 1 for i in range ( 1 , n ) : present [ i ] += present [ i - 1 ] if ( present [ L ] == present [ R - 1 ] ) : return True return False"
"def findMajority ( arr , n ) : maxCount = 0 index = - 1 i = 0 while i in list ( range ( n ) ) : count = 0 for j in range ( n ) : if ( arr [ i ] == arr [ j ] ) : count += 1 if ( count > maxCount ) : maxCount = count index = i i += 1 if ( maxCount > n // 2 ) : print ( arr [ index ] ) else : print ( ""NoMajorityElement"" )"
"def printTrib ( n ) : if ( n < 1 ) : return first = 0 second = 0 third = 1 print ( first , """" , end = """" ) if ( n > 1 ) : print ( second , """" , end = """" ) if ( n > 2 ) : print ( second , """" , end = """" ) i = 3 while i in list ( range ( n ) ) : curr = first + second + third first = second second = third third = curr print ( curr , """" , end = """" ) i += 1"
"def maxCircularSum ( arr , n , k ) : if ( n < k ) : print ( """" ) return sum = 0 ; start = 0 ; end = k - 1 for i in range ( k ) : sum = sum + arr [ i ] ans = sum for i in range ( k , n + k ) : sum = sum + arr [ i % n ] - arr [ ( i - k ) % n ] if ( sum > ans ) : ans = sum start = ( i - k + 1 ) % n end = i % n print ( """" , ans ) print ( """" , start , ""\n"" , end )"
def evenNumSubstring ( str ) : length = len ( str ) count = 0 i = 0 while i in list ( range ( length ) ) : temp = ord ( str [ i ] ) - ord ( '0' ) if ( temp % 2 == 0 ) : count += ( i + 1 ) i += 1 return count
"def minimumSubarrays ( ar , n ) : se = [ ] cnt = 1 i = 0 while i in list ( range ( n ) ) : if se.count ( ar [ i ] ) == 0 : se.append ( ar [ i ] ) else : cnt += 1 se.clear ( ) se.append ( ar [ i ] ) i += 1 return cnt"
"def countPairs ( arr , n ) : map = dict ( ) i = 0 while i in list ( range ( n ) ) : map [ arr [ i ] - i ] = map.get ( arr [ i ] - i , 0 ) + 1 i += 1 res = 0 for x in map : cnt = map [ x ] res += ( ( cnt * ( cnt - 1 ) ) // 2 ) return res"
"def lastPosition ( n , m , k ) : if ( n - k + 1 >= m ) : return m + k - 1 m = m - ( n - k + 1 ) if ( m % n == 0 ) : return n else : return m % n"
"def count ( S , m , n ) : if ( n == 0 ) : return 1 if ( 0 > n ) : return 0 if ( m <= 0 and n >= 1 ) : return 0 return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] )"
"def decodeMedianString ( s ) : l = len ( s ) s1 = """" if ( l % 2 == 0 ) : isEven = True else : isEven = False i = 0 while i in list ( range ( l ) ) : if ( isEven ) : s1 = s [ i ] + s1 s1 += s [ i + 1 ] else : if ( l - i > 1 ) : s1 += s [ i ] s1 = s [ i + 1 ] + s1 else : s1 += s [ i ] i += 2 return s1"
"def checkSolution ( a , b , c ) : if 0 < ( ( b * b ) - ( 4 * a * c ) ) : print ( ""2solutions"" ) elif ( ( b * b ) - ( 4 * a * c ) ) == 0 : print ( ""1solution"" ) else : print ( ""Nosolutions"" )"
"def find3Numbers ( A , arr_size , sum ) : for i in range ( 0 , arr_size - 1 ) : s = set ( ) curr_sum = sum - A [ i ] j = i + 1 while j in list ( range ( arr_size ) ) : if ( curr_sum - A [ j ] ) in s : print ( ""Tripletis"" , A [ i ] , "","" , A [ j ] , "","" , curr_sum - A [ j ] ) j += 1 return True s.add ( A [ j ] ) j += 1 return False"
"def max_profit ( a , b , n , fee ) : i , j , profit = 1 , n - 1 , 0 l , r , diff_day = 0 , 0 , 1 b [ 0 ] = 0 b [ 1 ] = diff_day for i in range ( 1 , n ) : l = 0 r = diff_day Sum = 0 j = n - 1 while j in list ( range ( i - 1 ) ) : profit = ( a [ r ] - a [ l ] ) - fee if ( profit > 0 ) : Sum = Sum + profit l += 1 r += 1 j += - 1 if ( b [ 0 ] < Sum ) : b [ 0 ] = Sum b [ 1 ] = diff_day diff_day += 1 return 0"
"def findMaxSum ( arr , n ) : res = - sys.maxsize - 1 for i in range ( n ) : prefix_sum = arr [ i ] j = 0 while j in list ( range ( i ) ) : prefix_sum += arr [ j ] j += 1 suffix_sum = arr [ i ] j = n - 1 while ( j > i ) : suffix_sum += arr [ j ] j -= 1 if ( prefix_sum == suffix_sum ) : res = max ( res , prefix_sum ) return res"
def isReversible ( str ) : i = 0 j = len ( str ) - 1 while ( j > i ) : if ( str [ i ] != str [ j ] ) : return False i += 1 j -= 1 return True
"def maxRepeating ( str ) : l = len ( str ) count = 0 res = str [ 0 ] i = 0 while i in list ( range ( l ) ) : cur_count = 1 for j in range ( i + 1 , l ) : if ( str [ i ] != str [ j ] ) : i += 1 break cur_count += 1 if cur_count > count : count = cur_count res = str [ i ] i += 1 return res"
"def longestSubarray ( a , n , x ) : count = 0 length = 0 i = 0 while i in list ( range ( n ) ) : if ( a [ i ] > x ) : count += 1 else : length = max ( length , count ) count = 0 i += 1 if ( count > 0 ) : length = max ( length , count ) return length"
"def checkPangram ( s ) : List = [ ] i = 0 while i in list ( range ( 26 ) ) : List.append ( False ) i += 1 for c in s.lower ( ) : if not c == """" : List [ ord ( c ) - ord ( 'a' ) ] = True for ch in List : if ch == False : return False return True"
"def interchangeFirstLast ( mat , n , m ) : rows = n i = 0 while i in list ( range ( n ) ) : t = mat [ 0 ] [ i ] mat [ 0 ] [ i ] = mat [ rows - 1 ] [ i ] mat [ rows - 1 ] [ i ] = t i += 1"
"def getPairsCount ( arr , n , sum ) : count = 0 for i in range ( 0 , n ) : j = i + 1 while j in list ( range ( n ) ) : if arr [ i ] + arr [ j ] == sum : count += 1 j += 1 return count"
"def FindPoint ( x1 , y1 , x2 , y2 , x , y ) : if ( x > x1 and x < x2 and y1 < y and y < y2 ) : return True else : return False"
"def solve ( A , B , n ) : cnt = 0 for i in range ( n ) : j = i while j in list ( range ( n ) ) : if ( bin ( A [ i ] | A [ j ] ).count ( '1' ) == B [ j ] ) : cnt += 1 j += 1 return cnt"
def makeOdd ( n ) : if n % 2 != 0 : return 1 i = 2 while i in list ( range ( n ) ) : if ( n % i == 0 and ( int ) ( n / i ) % 2 == 1 ) : i += 1 return i i += 1
"def checkBitonic ( arr , n ) : for i in range ( 1 , n ) : if arr [ i ] > arr [ i - 1 ] : continue else : break if i == n - 1 : return 1 j = i + 1 while j in list ( range ( n ) ) : if arr [ j ] < arr [ j - 1 ] : j += 1 continue else : j += 1 break j += 1 i = j if i != n - 1 : return 0 return 1"
"def minMoves ( n , a , k ) : ct1 = [ 0 for i in range ( k ) ] ct0 = [ 0 for i in range ( k ) ] moves = 0 for i in range ( n ) : if ( a [ i ] == 1 ) : ct1 [ i % k ] += 1 else : ct0 [ i % k ] += 1 i = 0 while i in list ( range ( k ) ) : moves += min ( ct1 [ i ] , ct0 [ i ] ) i += 1 return moves"
"def minOperations ( s , t , n ) : ct0 = 0 ct1 = 0 i = 0 while i in list ( range ( n ) ) : if ( s [ i ] == t [ i ] ) : i += 1 continue if ( s [ i ] == '0' ) : ct0 += 1 else : ct1 += 1 i += 1 return max ( ct0 , ct1 )"
"def findSum ( N , k ) : sum = 0 i = 1 while i in list ( range ( N + 1 ) ) : sum += pow ( i , k ) i += 1 return sum"
"def calculate ( a , n ) : a.sort ( ) s = [ ] i = 0 j = n - 1 while ( j > i ) : s.append ( ( a [ i ] + a [ j ] ) ) i += 1 j -= 1 mini = min ( s ) maxi = max ( s ) return abs ( maxi - mini )"
"def largestSquareFactor ( num ) : answer = 1 i = 2 while i in list ( range ( int ( math.sqrt ( num ) ) ) ) : cnt = 0 j = i while ( num % j == 0 ) : cnt += 1 j *= i if ( cnt & 1 ) : cnt -= 1 answer *= pow ( i , cnt ) else : answer *= pow ( i , cnt ) i += 1 return answer"
"def usingBinarySearch ( start , end , N , S ) : if ( start >= end ) : return start mid = start + ( end - start ) // 2 totalSum = ( N * ( N + 1 ) ) // 2 midSum = ( mid * ( mid + 1 ) ) // 2 if ( S >= ( totalSum - midSum ) ) : return usingBinarySearch ( start , mid , N , S ) return usingBinarySearch ( mid + 1 , end , N , S )"
"def getMinDiff ( arr , n , k ) : if ( n == 1 ) : return 0 arr.sort ( ) ans = arr [ n - 1 ] - arr [ 0 ] small = arr [ 0 ] + k big = arr [ n - 1 ] - k if ( small > big ) : small , big = big , small i = 1 while i in list ( range ( n - 1 ) ) : subtract = arr [ i ] - k add = arr [ i ] + k if ( subtract >= small or add <= big ) : i += 1 continue if ( big - subtract <= add - small ) : small = subtract else : big = add i += 1 return min ( ans , big - small )"
"def maximumXOR ( n , l , r ) : x = 0 i = int ( math.log2 ( r ) ) while i in list ( range ( - 1 ) ) : if ( n & ( 1 << i ) ) : if ( x > r ) or ( x + ( 1 << i ) - 1 < l ) : x ^= ( 1 << i ) else : if ( x ^ ( 1 << i ) ) <= r : x ^= ( 1 << i ) i += - 1 return n ^ x"
"def findMinSum ( arr , n ) : occ = n - 1 Sum = 0 i = 0 while i in list ( range ( n ) ) : Sum += arr [ i ] * pow ( 2 , occ ) occ -= 1 i += 1 return Sum"
"def countPairs ( a , n ) : mn = + 2147483647 mx = - 2147483648 for i in range ( n ) : mn = min ( mn , a [ i ] ) mx = max ( mx , a [ i ] ) c1 = 0 c2 = 0 i = 0 while i in list ( range ( n ) ) : if ( a [ i ] == mn ) : c1 += 1 if ( a [ i ] == mx ) : c2 += 1 i += 1 if ( mn == mx ) : return n * ( n - 1 ) // 2 else : return c1 * c2"
"def split ( x , n ) : if ( x < n ) : print ( - 1 ) elif ( x % n == 0 ) : i = 0 while i in list ( range ( n ) ) : print ( x // n , end = """" ) i += 1 else : zp = n - ( x % n ) pp = x // n for i in range ( n ) : if ( i >= zp ) : print ( pp + 1 , end = """" ) else : print ( pp , end = """" )"
"def printSquares ( n ) : square = 0 odd = 1 x = 0 while x in list ( range ( n ) ) : print ( square , end = """" ) square = square + odd odd = odd + 2 x += 1"
"def printCombination ( n ) : print ( ""1"" , end = """" ) if ( 0 == ( n - 2 ) % 3 ) : print ( ""2"" , n - 3 , end = """" ) else : print ( ""1"" , ( n - 2 ) , end = """" )"
"def SquareCube ( N ) : cnt , i = 0 , 1 while ( N >= i ** 6 ) : cnt += 1 i += 1 return cnt"
"def findWays ( m , n , x ) : table = [ [ 0 ] * ( x + 1 ) for i in range ( n + 1 ) ] for j in range ( 1 , min ( m + 1 , x + 1 ) ) : table [ 1 ] [ j ] = 1 for i in range ( 2 , n + 1 ) : for j in range ( 1 , x + 1 ) : k = 1 while k in list ( range ( min ( m + 1 , j ) ) ) : table [ i ] [ j ] += table [ i - 1 ] [ j - k ] k += 1 return table [ - 1 ] [ - 1 ]"
"def kthLargestSum ( arr , n , k ) : sum = [ ] sum.append ( 0 ) sum.append ( arr [ 0 ] ) for i in range ( 2 , n + 1 ) : sum.append ( sum [ i - 1 ] + arr [ i - 1 ] ) Q = [ ] heapq.heapify ( Q ) i = 1 while i in list ( range ( n + 1 ) ) : for j in range ( i , n + 1 ) : x = sum [ j ] - sum [ i - 1 ] if len ( Q ) < k : heapq.heappush ( Q , x ) else : if Q [ 0 ] < x : heapq.heappop ( Q ) heapq.heappush ( Q , x ) i += 1 return Q [ 0 ]"
"def checkArray ( a , b , n ) : operations = 0 i = 0 while ( i < n ) : if ( a [ i ] - b [ i ] == 0 ) : i += 1 continue diff = a [ i ] - b [ i ] i += 1 while ( i < n and diff == a [ i ] - b [ i ] ) : i += 1 operations += 1 print ( operations )"
"def printSmallest ( a , n ) : sum0 , sum1 = 0 , 0 a = sorted ( a ) for i in range ( n ) : if ( a [ i ] % 3 == 0 ) : return a [ i ] for i in range ( n ) : j = 0 while j in list ( range ( n ) ) : num = ( a [ i ] * 10 ) + a [ j ] if ( num % 3 == 0 ) : j += 1 return num j += 1 return a [ 0 ] * 100 + a [ 0 ] * 10 + a [ 0 ]"
"def minimizeWithKSwaps ( arr , n , k ) : for i in range ( n - 1 ) : pos = i for j in range ( i + 1 , n ) : if ( j - i > k ) : break if ( arr [ j ] < arr [ pos ] ) : pos = j j = pos while j in list ( range ( i ) ) : arr [ j ] , arr [ j - 1 ] = arr [ j - 1 ] , arr [ j ] j += - 1 k -= pos - i"
"def findMin ( arr , n ) : sum = 0 for i in range ( 0 , n ) : sum = sum + arr [ i ] arr.sort ( ) min = arr [ 0 ] max = 0 i = n - 1 while i in list ( range ( 0 ) ) : num = arr [ i ] total = num + min for j in range ( 2 , num + 1 ) : if ( num % j == 0 ) : d = j now = ( num // d ) + ( min * d ) reduce = total - now if ( reduce > max ) : max = reduce i += - 1 print ( sum - max )"
"def newString ( s , k ) : X = """" while ( len ( s ) > 0 ) : temp = s [ 0 ] i = 1 while ( i < k and i < len ( s ) ) : if ( s [ i ] < temp ) : temp = s [ i ] i += 1 X = X + temp i = 0 while i in list ( range ( k ) ) : if ( s [ i ] == temp ) : s = s [ 0 : i ] + s [ i + 1 : ] i += 1 break i += 1 return X"
"def solve ( s ) : z = s l = len ( s ) i = 0 if ( s.find ( '+' ) == - 1 ) : i = s.find ( '-' ) s = s.replace ( '-' , '+' , 1 ) else : i = s.find ( '+' ) s = s.replace ( '+' , '-' ) print ( ""Conjugateof"" , z , ""="" , s )"
"def vowelOrConsonant ( x ) : if ( x == 'a' or x == 'e' or x == 'i' or x == 'o' or 'u' == x ) : print ( ""Vowel"" ) else : print ( ""Consonant"" )"
"def findSum ( str1 , str2 ) : if len ( str1 ) > len ( str2 ) : temp = str1 str1 = str2 str2 = temp str3 = """" n1 = len ( str1 ) n2 = len ( str2 ) diff = n2 - n1 carry = 0 i = n1 - 1 while i in list ( range ( - 1 ) ) : sum = ( ( ord ( str1 [ i ] ) - ord ( '0' ) ) + int ( ( ord ( str2 [ i + diff ] ) - ord ( '0' ) ) ) + carry ) str3 = str3 + str ( sum % 10 ) carry = sum // 10 i += - 1 for i in range ( n2 - n1 - 1 , - 1 , - 1 ) : sum = ( ( ord ( str2 [ i ] ) - ord ( '0' ) ) + carry ) str3 = str3 + str ( sum % 10 ) carry = sum // 10 if ( carry ) : str3 + str ( carry + '0' ) str3 = str3 [ : : - 1 ] return str3"
"def binarySearchCount ( arr , n , key ) : left = 0 right = n mid = 0 while ( right > left ) : mid = ( right + left ) // 2 if ( arr [ mid ] == key ) : while ( mid + 1 < n and arr [ mid + 1 ] == key ) : mid += 1 break elif ( arr [ mid ] > key ) : right = mid else : left = mid + 1 while ( mid > - 1 and arr [ mid ] > key ) : mid -= 1 return mid + 1"
"def isMinHeap ( level , n ) : i = int ( n / 2 ) - 1 while i in list ( range ( - 1 ) ) : if level [ i ] > level [ 2 * i + 1 ] : i += - 1 return False if 2 * i + 2 < n : if level [ i ] > level [ 2 * i + 2 ] : i += - 1 return False i += - 1 return True"
"def printMaxSum ( arr , n ) : dp = [ 0 for i in range ( n ) ] i = 0 while i in list ( range ( n ) ) : dp [ i ] = arr [ i ] maxi = 0 for j in range ( 1 , int ( ( i + 1 ) ** 0.5 ) + 1 ) : if ( ( i + 1 ) % j == 0 and ( i + 1 ) != j ) : if ( dp [ j - 1 ] > maxi ) : maxi = dp [ j - 1 ] if ( dp [ ( i + 1 ) // j - 1 ] > maxi and j != 1 ) : maxi = dp [ ( i + 1 ) // j - 1 ] dp [ i ] += maxi i += 1 for i in range ( n ) : print ( dp [ i ] , end = '' )"
"def findRepeatingElement ( arr , low , high ) : if low > high : return - 1 mid = ( low + high ) / 2 if ( arr [ mid ] != mid + 1 ) : if ( mid > 0 and arr [ mid - 1 ] == arr [ mid ] ) : return mid return findRepeatingElement ( arr , low , mid - 1 ) return findRepeatingElement ( arr , mid + 1 , high )"
"def LCIS ( arr1 , n , arr2 , m ) : table = [ 0 ] * m j = 0 while j in list ( range ( m ) ) : table [ j ] = 0 j += 1 for i in range ( n ) : current = 0 for j in range ( m ) : if ( arr1 [ i ] == arr2 [ j ] ) : if ( current + 1 > table [ j ] ) : table [ j ] = current + 1 if ( arr1 [ i ] > arr2 [ j ] ) : if ( table [ j ] > current ) : current = table [ j ] result = 0 for i in range ( m ) : if ( table [ i ] > result ) : result = table [ i ] return result"
"def sortArray ( a , n ) : ans = [ ] i = 0 while i in list ( range ( n ) ) : if ( a [ i ] >= 0 ) : ans.append ( a [ i ] ) i += 1 ans = sorted ( ans ) j = 0 for i in range ( n ) : if ( a [ i ] >= 0 ) : a [ i ] = ans [ j ] j += 1 for i in range ( n ) : print ( a [ i ] , end = """" )"
def isDivisible ( n ) : while n // 100 : d = n % 10 n //= 10 n = abs ( n - ( d * 7 ) ) return ( 0 == n % 71 )
"def pyramid ( n ) : for i in range ( n , 0 , - 1 ) : for gap in range ( n - 1 , i - 1 , - 1 ) : print ( """" , end = '' ) print ( """" , end = '' ) num = ord ( 'A' ) for j in range ( 1 , i + 1 ) : print ( chr ( num ) , end = '' ) num += 1 j = i - 1 while j in list ( range ( - 1 ) ) : num -= 1 print ( chr ( num ) , end = '' ) j += - 1 print ( ""\n"" , end = '' )"
def checkTriangularSumRepresentation ( n ) : tri = list ( ) i = 1 while ( 1 ) : x = i * ( i + 1 ) // 2 if ( n <= x ) : break tri.append ( x ) i += 1 for tm in tri : if n - tm in tri : return True return False
def calculateLeaps ( n ) : if n == 0 or n == 1 : return 1 else : leaps = 0 i = 0 while i in list ( range ( n ) ) : leaps = leaps + calculateLeaps ( i ) i += 1 return leaps
"def rotateRec ( n , L , B ) : m = sys.maxsize i = 0 while i in list ( range ( n ) ) : if ( max ( L [ i ] , B [ i ] ) <= m ) : m = max ( L [ i ] , B [ i ] ) elif ( min ( L [ i ] , B [ i ] ) <= m ) : m = min ( L [ i ] , B [ i ] ) else : i += 1 return 0 i += 1 return 1"
"def check ( s , m ) : l = len ( s ) c1 = 0 c2 = 0 i = 0 while i in list ( range ( l - 1 ) ) : if ( s [ i ] == '0' ) : c2 = 0 c1 = c1 + 1 else : c1 = 0 c2 = c2 + 1 if ( c1 == m or c2 == m ) : i += 1 return True i += 1 return False"
"def printTwoSetBitNums ( n ) : x = 1 while ( 0 < n ) : y = 0 while ( y < x ) : print ( ( 1 << x ) + ( 1 << y ) , end = """" ) n -= 1 if ( n == 0 ) : return y += 1 x += 1"
"def EqualNumbers ( a , n ) : sum = 0 i = 0 while i in list ( range ( n ) ) : sum += a [ i ] i += 1 if ( sum % n ) : return n - 1 return n"
"def LongestSubarray ( arr , n , k ) : count = 1 max_lenght = 1 prev_mod = arr [ 0 ] % k i = 1 while i in list ( range ( n ) ) : curr_mod = arr [ i ] % k if curr_mod == prev_mod : count += 1 else : max_lenght = max ( max_lenght , count ) count = 1 prev_mod = curr_mod i += 1 return max_lenght"
"def rangeGCD ( n , m ) : return n if ( m == n ) else 1"
def nondecdigits ( n ) : x = 0 x = n while x in list ( range ( 0 ) ) : no = x prev_dig = 11 flag = True while ( no != 0 ) : if ( prev_dig < no % 10 ) : flag = False x += - 1 break prev_dig = no % 10 no //= 10 if ( flag == True ) : x += - 1 break x += - 1 return x
"def reversingString ( str , start , end ) : while ( end > start ) : str = ( str [ : start ] + chr ( ord ( str [ start ] ) ^ ord ( str [ end ] ) ) + str [ start + 1 : ] ) str = ( str [ : end ] + chr ( ord ( str [ start ] ) ^ ord ( str [ end ] ) ) + str [ end + 1 : ] ) str = ( str [ : start ] + chr ( ord ( str [ start ] ) ^ ord ( str [ end ] ) ) + str [ start + 1 : ] ) start += 1 end -= 1 return str"
"def minimumflip ( mat , n ) : transpose = [ [ 0 ] * n ] * n for i in range ( n ) : for j in range ( n ) : transpose [ i ] [ j ] = mat [ j ] [ i ] flip = 0 i = 0 while i in list ( range ( n ) ) : for j in range ( n ) : if transpose [ i ] [ j ] != mat [ i ] [ j ] : flip += 1 i += 1 return int ( flip / 2 )"
"def getMaxNum ( a , b , c ) : if ( 0 == b % c ) : return b x = ( ( b // c ) * c ) if ( x >= a and x <= b ) : return x else : return - 1"
def recursiveReverse ( str ) : stack = [ ] i = 0 while i in list ( range ( len ( str ) ) ) : stack.append ( str [ i ] ) i += 1 for i in range ( len ( str ) ) : str [ i ] = stack.pop ( )
def isTidy ( num ) : prev = 10 while ( num ) : rem = num % 10 num /= 10 if prev < rem : return False prev = rem return True
"def findLastIndex ( str , x ) : index = - 1 i = 0 while i in list ( range ( len ( str ) ) ) : if str [ i ] == x : index = i i += 1 return index"
"def printNonDivisible ( A , B , n , m ) : for i in range ( m ) : j = 0 j = 0 while j in list ( range ( n ) ) : if ( B [ i ] % A [ j ] == 0 ) : j += 1 break j += 1 if ( j == n - 1 ) : print ( B [ i ] )"
"def findSmallestNonZeroY ( A_num ) : A_binary = bin ( A_num ) B = 1 length = len ( A_binary ) no_ones = ( A_binary ).count ( '1' ) if length == no_ones : return A_num + 1 i = 0 while i in list ( range ( length ) ) : ch = A_binary [ length - i - 1 ] if ( ch == '0' ) : B = pow ( 2.0 , i ) i += 1 break i += 1 return B"
"def getPermutation ( a , n ) : ans = [ 0 ] * n ans [ 0 ] = a [ 0 ] for i in range ( 1 , n ) : ans [ i ] = a [ i ] - a [ i - 1 ] present = [ 0 ] * ( n + 1 ) for i in range ( n ) : if ( present [ ans [ i ] ] ) : print ( ""-1"" , end = """" ) return else : present [ ans [ i ] ] = True i = 0 while i in list ( range ( n ) ) : print ( ans [ i ] , end = """" ) i += 1"
"def isPossibleTriangle ( arr , N ) : if N < 3 : return False arr.sort ( ) i = 0 while i in list ( range ( N - 2 ) ) : if arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] : i += 1 return True i += 1"
"def maxProfit ( price , n ) : profit = [ 0 ] * n max_price = price [ n - 1 ] for i in range ( n - 2 , 0 , - 1 ) : if price [ i ] > max_price : max_price = price [ i ] profit [ i ] = max ( profit [ i + 1 ] , max_price - price [ i ] ) min_price = price [ 0 ] i = 1 while i in list ( range ( n ) ) : if price [ i ] < min_price : min_price = price [ i ] profit [ i ] = max ( profit [ i - 1 ] , profit [ i ] + ( price [ i ] - min_price ) ) i += 1 result = profit [ n - 1 ] return result"
"def maxValue ( arr , n , moves ) : i = n - 2 while i in list ( range ( - 1 ) ) : if ( arr [ i ] > 0 ) : distance = n - 1 - i if ( moves < distance ) : i += - 1 break can_take = moves // distance take = min ( arr [ i ] , can_take ) arr [ n - 1 ] += take moves -= take * distance i += - 1 return arr [ n - 1 ]"
"def rearrange ( arr , n ) : max_ele = arr [ n - 1 ] min_ele = arr [ 0 ] i = 0 while i in list ( range ( n ) ) : if i % 2 == 0 : arr [ i ] = max_ele max_ele -= 1 else : arr [ i ] = min_ele min_ele += 1 i += 1"
def getSum ( n ) : sum = 0 while ( 0 != n ) : sum = sum + int ( n % 10 ) n = int ( n / 10 ) return sum
def doublefactorial ( n ) : if ( n == 0 or 1 == n ) : return 1 return n * doublefactorial ( n - 2 )
"def Maximum_xor_Triplet ( n , a ) : s = set ( ) i = 0 while i in list ( range ( n ) ) : for j in range ( i , n ) : s.add ( a [ i ] ^ a [ j ] ) i += 1 ans = 0 for i in s : for j in range ( 0 , n ) : ans = max ( ans , i ^ a [ j ] ) print ( ans )"
def isPower ( n ) : if ( n <= 1 ) : return True x = 2 while x in list ( range ( ( int ) ( math.sqrt ( n ) ) + 1 ) ) : p = x while ( p <= n ) : p = p * x if ( p == n ) : x += 1 return True x += 1 return False
"def FirstAndLast ( string ) : arrOfStr = string.split ( ) res = """" for a in arrOfStr : res = res + a [ 1 : len ( a ) - 1 ] + """" return res"
def moveSpaceInFront ( s ) : i = len ( s ) - 1 j = i while j in list ( range ( - 1 ) ) : if ( s [ j ] != '' ) : s = s [ : i ] + s [ j ] + s [ i + 1 : ] i -= 1 j += - 1 while ( i >= 0 ) : s = s [ : i ] + '' + s [ i + 1 : ] i -= 1 return s
"def isCyclic ( N ) : num = N count = 0 digit = ( num % 10 ) allSame = True while ( num > 0 ) : count += 1 if ( num % 10 != digit ) : allSame = False num = num // 10 if ( allSame == True ) : return False if ( count % 2 == 0 ) : halfPower = pow ( 10 , count // 2 ) firstHalf = N % halfPower secondHalf = N / halfPower if ( firstHalf == firstHalf and isCyclic ( firstHalf ) ) : return False num = N while ( True ) : rem = num % 10 div = num // 10 num = pow ( 10 , count - 1 ) * rem + div if ( N == num ) : break if ( num % N != 0 ) : return False return True"
"def findRealAndImag ( s ) : l = len ( s ) i = 0 if ( - 1 != s.find ( '+' ) ) : i = s.find ( '+' ) else : i = s.find ( '-' ) real = s [ : i ] imaginary = s [ i + 1 : l - 1 ] print ( ""Realpart:"" , real ) print ( ""Imaginarypart:"" , imaginary )"
def isPower ( n ) : x = 2 while x in list ( range ( int ( math.sqrt ( n ) ) + 1 ) ) : f = math.log ( n ) / math.log ( x ) if ( ( f - int ( f ) ) == 0.0 ) : x += 1 return True x += 1 return False
"def isPower ( x , y ) : res1 = math.log ( y ) / math.log ( x ) res2 = math.log ( y ) / math.log ( x ) return 1 if ( res2 == res1 ) else 0"
def get_last_two_digit ( N ) : if N <= 10 : ans = 0 fac = 1 i = 1 while i in list ( range ( N + 1 ) ) : fac = fac * i ans += fac i += 1 ans = ans % 100 return ans else : return 13
"def find ( n ) : arr = [ '' ] * ( n + 1 ) size = 1 m = 1 while ( size <= n ) : i = 0 while ( i < m and ( size + i ) <= n ) : arr [ size + i ] = ""3"" + arr [ size - m + i ] i += 1 i = 0 while ( m > i and ( size + m + i ) <= n ) : arr [ size + m + i ] = ""4"" + arr [ size - m + i ] i += 1 m = m << 1 size = size + m print ( arr [ n ] )"
"def findMin ( arr , low , high ) : if high < low : return arr [ 0 ] if high == low : return arr [ low ] mid = int ( ( low + high ) / 2 ) if mid < high and arr [ mid + 1 ] < arr [ mid ] : return arr [ mid + 1 ] if low < mid and arr [ mid ] < arr [ mid - 1 ] : return arr [ mid ] if arr [ high ] > arr [ mid ] : return findMin ( arr , low , mid - 1 ) return findMin ( arr , mid + 1 , high )"
"def calculate_angle ( n , i , j , k ) : x , y = 0 , 0 if ( i < j ) : x = j - i else : x = j + n - i if ( k > j ) : y = k - j else : y = k + n - j ang1 = ( 180 * x ) // n ang2 = ( 180 * y ) // n ans = 180 - ang1 - ang2 return ans"
"def firstElement ( arr , n , k ) : count_map = { } for i in range ( 0 , n ) : if ( arr [ i ] in count_map.keys ( ) ) : count_map [ arr [ i ] ] += 1 else : count_map [ arr [ i ] ] = 1 i += 1 i = 0 while i in list ( range ( n ) ) : if ( count_map [ arr [ i ] ] == k ) : i += 1 return arr [ i ] i += 1 i += 1 return - 1"
"def maximumDifferenceSum ( arr , N ) : dp = [ [ 0 , 0 ] for i in range ( N ) ] i = 0 while i in list ( range ( N ) ) : dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 i += 1 for i in range ( N - 1 ) : dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + abs ( 1 - arr [ i ] ) ) dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] + abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + abs ( arr [ i + 1 ] - arr [ i ] ) ) return max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] )"
"def countPairs ( arr , N ) : M = dict.fromkeys ( arr , 0 ) i = 0 while i in list ( range ( N ) ) : M [ arr [ i ] ] += 1 i += 1 maxFreq = 0 for it in M.values ( ) : maxFreq = max ( maxFreq , it ) print ( N - maxFreq )"
def isMultipleOf10 ( n ) : return ( 0 == n % 15 )
"def findElements ( arr , n ) : i = 0 while i in list ( range ( n ) ) : count = 0 for j in range ( 0 , n ) : if arr [ j ] > arr [ i ] : count = count + 1 if count >= 2 : print ( arr [ i ] , end = """" ) i += 1"
"def findSplTripletsSum ( a , b , c , p , q , r ) : summ = 0 i = 0 while i in list ( range ( p ) ) : for j in range ( q ) : for k in range ( r ) : if ( a [ i ] <= b [ j ] and c [ k ] <= b [ j ] ) : summ += ( a [ i ] + b [ j ] ) * ( b [ j ] + c [ k ] ) i += 1 return summ"
"def countSteps ( x , y ) : if x >= y : return x + y + 2 * ( ( ( x - y ) + 1 ) // 2 ) else : return x + y + 2 * ( ( y - x ) // 2 )"
"def findRepeating ( arr , n ) : res = 0 i = 0 while i in list ( range ( n - 1 ) ) : res = res ^ ( i + 1 ) ^ arr [ i ] i += 1 res = res ^ arr [ n - 1 ] return res"
"def productPrimeFactors ( n ) : product = 1 for i in range ( 2 , n + 1 ) : if ( n % i == 0 ) : isPrime = 1 j = 2 while j in list ( range ( int ( i / 2 + 1 ) ) ) : if ( i % j == 0 ) : isPrime = 0 j += 1 break j += 1 if ( isPrime ) : product = product * i return product"
"def findMaxGCD ( arr , n ) : high = 0 for i in range ( 0 , n ) : high = max ( high , arr [ i ] ) count = [ 0 ] * ( high + 1 ) i = 0 while i in list ( range ( n ) ) : count [ arr [ i ] ] += 1 i += 1 counter = 0 for i in range ( high , 0 , - 1 ) : j = i while ( j <= high ) : if ( count [ j ] > 0 ) : counter += count [ j ] j += i if ( counter == 2 ) : return i counter = 0"
"def find_greatest_divisor ( l , r ) : if ( r == l ) : return l return 1"
def isDivisible ( n ) : while ( n // 100 ) : d = n % 10 n //= 10 n -= d * 5 return ( 0 == n % 17 )
"def getTotalNumberOfSequences ( m , n ) : T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( m + 1 ) ] i = 0 while i in list ( range ( m + 1 ) ) : for j in range ( n + 1 ) : if i == 0 or j == 0 : T [ i ] [ j ] = 0 elif i < j : T [ i ] [ j ] = 0 elif j == 1 : T [ i ] [ j ] = i else : T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i // 2 ] [ j - 1 ] i += 1 return T [ m ] [ n ]"
"def maximum_middle_value ( n , k , arr ) : ans = - 1 low = ( n + 1 - k ) // 2 high = ( n + 1 - k ) // 2 + k i = low while i in list ( range ( high + 1 ) ) : ans = max ( ans , arr [ i - 1 ] ) i += 1 return ans"
"def CalculateDifference ( arr , n ) : max_val = - 1 i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] > max_val ) : max_val = arr [ i ] i += 1 prime = [ True for i in range ( max_val + 1 ) ] prime [ 0 ] = False prime [ 1 ] = False p = 2 while ( p * p <= max_val ) : if prime [ p ] == True : for i in range ( p * 2 , max_val + 1 , p ) : prime [ i ] = False p += 1 S1 = 0 S2 = 0 for i in range ( 0 , n ) : if prime [ arr [ i ] ] : S1 += arr [ i ] elif arr [ i ] != 1 : S2 += arr [ i ] return abs ( S2 - S1 )"
"def checkPattern ( string , pattern ) : l = len ( pattern ) if len ( string ) < l : return False i = 0 while i in list ( range ( l - 1 ) ) : x = pattern [ i ] y = pattern [ i + 1 ] last = string.rindex ( x ) first = string.index ( y ) if last == - 1 or first == - 1 or last > first : i += 1 return False i += 1 return True"
"def solve ( s , k ) : count , length , pos = 0 , 0 , 0 m = dict.fromkeys ( s , 0 ) i = 0 while i in list ( range ( len ( s ) ) ) : m [ s [ i ] ] += 1 length += 1 if length > k : m [ s [ pos ] ] -= 1 pos += 1 length -= 1 if length == k and m [ s [ i ] ] == length : count += 1 i += 1 print ( count )"
"def OR ( a , n ) : ans = a [ 0 ] i = 1 while i in list ( range ( n ) ) : ans |= a [ i ] i += 1 return ans"
"def printMultiples ( n ) : unit_digit = n % 10 if ( unit_digit == 0 ) : unit_digit = 10 i = unit_digit while i in list ( range ( n + 1 ) ) : print ( i , end = """" ) i += unit_digit"
"def block ( x ) : v = [ ] print ( ""Blocksfor%d:"" % x , end = """" ) while ( x > 0 ) : v.append ( int ( x % 2 ) ) x = int ( x / 2 ) i = 0 while i in list ( range ( len ( v ) ) ) : if ( v [ i ] == 1 ) : print ( i , end = """" ) if ( i != len ( v ) - 1 ) : print ( "","" , end = """" ) i += 1 print ( ""\n"" )"
"def findgroups ( arr , n ) : c = [ 0 , 0 , 0 ] res = 0 for i in range ( 0 , n ) : c [ arr [ i ] % 3 ] += 1 res = res + ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) res = res + c [ 1 ] * c [ 2 ] res = res + ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 res = res + ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 res = res + ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) res = res + c [ 0 ] * c [ 1 ] * c [ 2 ] return res"
"def findElements ( arr , n ) : arr.sort ( ) i = 0 while i in list ( range ( n - 2 ) ) : print ( arr [ i ] , end = """" ) i += 1"
def countFriendsPairings ( n ) : dp = [ 0 for i in range ( n + 1 ) ] i = 0 while i in list ( range ( n + 1 ) ) : if ( i <= 2 ) : dp [ i ] = i else : dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] i += 1 return dp [ n ]
def getProduct ( n ) : product = 1 while ( 0 != n ) : product = product * ( n % 10 ) n = n // 10 return product
"def count4Divisibiles ( arr , n ) : freq = [ 0 , 0 , 0 , 0 ] i = 0 while i in list ( range ( n ) ) : freq [ arr [ i ] % 4 ] += 1 i += 1 ans = freq [ 0 ] * ( freq [ 0 ] - 1 ) / 2 ans += freq [ 2 ] * ( freq [ 2 ] - 1 ) / 2 ans += freq [ 1 ] * freq [ 3 ] return int ( ans )"
"def trianglearea ( a ) : if ( 0 > a ) : return - 1 area = ( 3 * math.sqrt ( 3 ) * math.pow ( a , 2 ) ) / 4 return area"
"def maxPrefix ( s , t ) : count = 0 i = 0 while i in list ( range ( len ( t ) ) ) : if ( count == len ( s ) ) : i += 1 break if ( t [ i ] == s [ count ] ) : count = count + 1 i += 1 return count"
"def fillWithFreq ( arr , n ) : temp = [ 0 for i in range ( n ) ] for i in range ( n ) : temp [ arr [ i ] ] += 1 i = 0 while i in list ( range ( n ) ) : arr [ i ] = temp [ i ] i += 1"
"def CountPair ( arr , n ) : result = 0 i = 0 while i in list ( range ( n ) ) : j = i + 1 while ( j < n ) : if ( i * arr [ i ] > j * arr [ j ] ) : result = result + 1 j = j + 1 i += 1 return result"
def CountPairs ( n ) : k = n imin = 1 ans = 0 while ( n >= imin ) : imax = n / k ans += k * ( imax - imin + 1 ) imin = imax + 1 k = n / imin return ans
def countIntegralSolutions ( n ) : result = 0 for i in range ( n + 1 ) : j = 0 while j in list ( range ( n + 1 ) ) : for k in range ( n + 1 ) : if i + j + k == n : result += 1 j += 1 return result
"def XorSum ( arr , n ) : result = 0 for i in range ( 0 , n ) : k = 0 j = 1 while j in list ( range ( arr [ i ] + 1 ) ) : k = k ^ arr [ i ] j += 1 result = result + k return result"
"def findBitonicity ( arr , n ) : bt = 0 i = 1 while i in list ( range ( n ) ) : if ( arr [ i ] > arr [ i - 1 ] ) : bt += 1 elif ( arr [ i ] < arr [ i - 1 ] ) : bt -= 1 i += 1 return bt"
"def getTrailingZeroes ( n ) : count = 0 val , powerTwo = 1 , 2 while ( val != 0 ) : val = n // powerTwo count = count + val powerTwo *= 2 return ( count // 4 )"
"def cost ( st ) : l = len ( st ) res = 0 j = l - 1 i = 0 while ( j > i ) : if ( st [ i ] != st [ j ] ) : res += ( min ( ord ( st [ i ] ) , ord ( st [ j ] ) ) - ord ( 'a' ) + 1 ) i = i + 1 j = j - 1 return res"
"def minChanges ( str , n ) : count , zeros , ones = 0 , 0 , 0 if ( ord ( str [ 0 ] ) != ord ( '1' ) ) : count += 1 ones += 1 i = 1 while i in list ( range ( n ) ) : if ( ord ( str [ i ] ) == ord ( '0' ) ) : zeros += 1 else : ones += 1 if ( zeros > ones ) : zeros -= 1 ones += 1 count += 1 i += 1 return count"
"def countEle ( s , a , N ) : mp = { } i = 0 while i in list ( range ( N ) ) : num = a [ i ] if num in mp : print ( ""0"" , end = """" ) else : cnt = 0 while s [ - 1 ] != num : mp [ s.pop ( ) ] = True cnt += 1 s.pop ( ) cnt += 1 print ( cnt , end = """" ) i += 1"
"def solve ( d1 , d2 , d3 ) : maxx = max ( d1 , max ( d2 , d3 ) ) sum = ( d1 + d2 + d3 ) if ( 2 * maxx > sum or 1 == sum % 2 ) : print ( ""-1"" ) return x1 = 0 y1 = 0 x2 = d1 y2 = 0 x3 = ( d1 + d2 - d3 ) // 2 y3 = ( d2 + d3 - d1 ) // 2 print ( ""("" , x1 , "","" , y1 , ""),("" , x2 , "","" , y2 , "")and("" , x3 , "","" , y3 , "")"" )"
"def countDecreasing ( A , n ) : cnt = 0 len = 1 i = 0 while i in list ( range ( n - 1 ) ) : if ( A [ i + 1 ] < A [ i ] ) : len += 1 else : cnt += ( ( ( len - 1 ) * len ) // 2 ) len = 1 i += 1 if ( len > 1 ) : cnt += ( ( ( len - 1 ) * len ) // 2 ) return cnt"
"def getIndexInSortedArray ( arr , n , idx ) : result = 0 i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] < arr [ idx ] ) : result += 1 if ( arr [ i ] == arr [ idx ] and i < idx ) : result += 1 i += 1 return result"
"def printArray ( matrix ) : rowCount = len ( matrix ) if 0 == rowCount : return columnCount = len ( matrix [ 0 ] ) if columnCount == 0 : return row_output_format = """".join ( [ ""%s"" ] * columnCount ) printed = { } for row in matrix : routput = row_output_format % tuple ( row ) if routput not in printed : printed [ routput ] = True print ( routput )"
"def maxAND ( L , R ) : maximum = L & R for i in range ( L , R , 1 ) : j = i + 1 while j in list ( range ( R + 1 ) ) : maximum = max ( maximum , ( i & j ) ) j += 1 return maximum"
"def subArraySum ( arr , n , sum ) : curr_sum = arr [ 0 ] start = 0 i = 1 while i <= n : while curr_sum > sum and start < i - 1 : curr_sum = curr_sum - arr [ start ] start += 1 if curr_sum == sum : print ( ""Sumfoundbetweenindexes"" ) print ( ""%dand%d"" % ( start , i - 1 ) ) return 1 if n > i : curr_sum = curr_sum + arr [ i ] i += 1 print ( ""Nosubarrayfound"" ) return 0"
"def findOddPair ( A , N ) : oddPair = 0 i = 0 while i in list ( range ( N ) ) : for j in range ( i + 1 , N ) : if ( ( A [ i ] ^ A [ j ] ) % 2 != 0 ) : oddPair += 1 i += 1 return oddPair"
"def kmax ( arr , k , n ) : for c in range ( k ) : max_so_far = - float ( """" ) max_here = 0 start = 0 end = 0 s = 0 for i in range ( n ) : max_here = max_here + arr [ i ] if ( max_so_far < max_here ) : max_so_far = max_here start = s end = i if ( max_here < 0 ) : max_here = 0 s = i + 1 print ( """" , c + 1 , """" , max_so_far , """" , start , """" , end , """" , sep = """" ) for l in range ( start , end + 1 ) : arr [ l ] = - float ( """" ) print ( )"
"def findWinner ( n ) : if ( ( n - 1 ) % 6 != 0 ) : print ( ""FirstPlayerwinsthegame"" ) else : print ( ""SecondPlayerwinsthegame"" )"
"def countPairs ( a , b , n , m ) : cnt = 0 s = dict ( ) i = 0 while i in list ( range ( n ) ) : for j in range ( m ) : sum = a [ i ] + b [ j ] if ( sum not in s.keys ( ) ) : cnt += 1 s [ sum ] = 1 i += 1 return cnt"
"def calTime ( arr , n ) : work = 0 i = 0 while i in list ( range ( n ) ) : work += 1 / arr [ i ] i += 1 return 1 / work"
"def findWays ( f , d , s ) : mem = [ [ 0 for i in range ( s + 1 ) ] for j in range ( d + 1 ) ] mem [ 0 ] [ 0 ] = 1 i = 1 while i in list ( range ( d + 1 ) ) : for j in range ( 1 , s + 1 ) : mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ] if j - f - 1 >= 0 : mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ] i += 1 return mem [ d ] [ s ]"
"def alternateSubarray ( arr , n ) : len = [ ] for i in range ( n + 1 ) : len.append ( 0 ) len [ n - 1 ] = 1 for i in range ( n - 2 , - 1 , - 1 ) : if ( arr [ i ] ^ arr [ i + 1 ] == True ) : len [ i ] = len [ i + 1 ] + 1 else : len [ i ] = 1 i = 0 while i in list ( range ( n ) ) : print ( len [ i ] , """" , end = """" ) i += 1"
def countWays ( s ) : count = [ 0 ] * 26 for x in s : count [ ord ( x ) - ord ( 'a' ) ] = ( count [ ord ( x ) - ord ( 'a' ) ] ) + 1 count [ ord ( s [ 0 ] ) - ord ( 'a' ) ] = 1 ans = 1 i = 0 while i in list ( range ( 26 ) ) : if ( count [ i ] != 0 ) : ans *= count [ i ] i += 1 return ans
def removeConsecutiveSame ( v ) : n = len ( v ) i = 0 while ( i < n - 1 ) : if ( len ( v ) > ( i + 1 ) ) and ( v [ i ] == v [ i + 1 ] ) : v = v [ : i ] v = v [ : i ] if ( i > 0 ) : i -= 1 n = n - 2 else : i += 1 return len ( v [ : i - 1 ] )
"def positiveNegativeZero ( arr ) : length = len ( arr ) positiveCount = 0 negativeCount = 0 zeroCount = 0 i = 0 while i in list ( range ( length ) ) : if ( arr [ i ] > 0 ) : positiveCount += 1 elif ( arr [ i ] < 0 ) : negativeCount += 1 elif ( arr [ i ] == 0 ) : zeroCount += 1 i += 1 print ( ""{0:.4f}"".format ( ( positiveCount / length ) ) , end = """" ) print ( ""%1.4f"" % ( negativeCount / length ) , end = """" ) print ( ""%1.4f"" % ( zeroCount / length ) , end = """" ) print ( )"
"def maxval ( a , n ) : if ( n < 2 ) : print ( ""InvalidInput"" ) return - 9999 ( max1 , max2 ) = ( 0 , 0 ) i = 0 while i in list ( range ( n ) ) : x = a [ i ] + i if ( x > max1 ) : max2 = max1 max1 = x elif ( x > max2 and x != max1 ) : max2 = x i += 1 return ( max1 * max2 )"
"def countSubarrays ( arr , n ) : difference = 0 ans = 0 hash_positive = [ 0 ] * ( n + 1 ) hash_negative = [ 0 ] * ( n + 1 ) hash_positive [ 0 ] = 1 i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] & 1 == 1 ) : difference = difference + 1 else : difference = difference - 1 if ( difference < 0 ) : ans += hash_negative [ - difference ] hash_negative [ - difference ] = hash_negative [ - difference ] + 1 else : ans += hash_positive [ difference ] hash_positive [ difference ] = hash_positive [ difference ] + 1 i += 1 return ans"
"def printClosest ( ar1 , ar2 , m , n , x ) : diff = sys.maxsize l = 0 r = n - 1 while ( l < m and 0 <= r ) : if abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff : res_l = l res_r = r diff = abs ( ar1 [ l ] + ar2 [ r ] - x ) if ar1 [ l ] + ar2 [ r ] > x : r = r - 1 else : l = l + 1 print ( ""Theclosestpairis["" , ar1 [ res_l ] , "","" , ar2 [ res_r ] , ""]"" )"
"def findNums ( n ) : if ( n <= 11 ) : if ( n == 8 ) : print ( ""44"" , end = """" ) if ( 10 == n ) : print ( ""46"" , end = """" ) else : print ( ""-1"" , end = """" ) if ( n % 2 == 0 ) : print ( ""4"" , ( n - 4 ) , end = """" ) else : print ( ""9"" , n - 9 , end = """" )"
def findN ( k ) : if ( k == 0 ) : ans = 3 if ( k == 1 ) : ans = 1 elif ( k % 4 == 0 ) : ans = k elif ( 3 == k % 4 ) : ans = k - 1 else : ans = - 1 return ans
"def removeOddFrequencyCharacters ( s ) : m = dict ( ) for i in s : m [ i ] = m.get ( i , 0 ) + 1 new_s = """" for i in s : if ( m [ i ] & 1 ) : continue new_s = new_s + i return new_s"
"def sortWithRemainderP ( arr , n , k , p ) : v1 = [ ] v2 = [ ] i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] % k == p ) : v1.append ( i ) v2.append ( arr [ i ] ) i += 1 v2.sort ( reverse = False ) for i in range ( 0 , len ( v1 ) , 1 ) : arr [ v1 [ i ] ] = v2 [ i ] for i in range ( 0 , n , 1 ) : print ( arr [ i ] , end = """" )"
"def sortedAfterSwap ( A , B , n ) : for i in range ( 0 , n - 1 ) : if B [ i ] : if A [ i ] != i + 1 : A [ i ] , A [ i + 1 ] = A [ i + 1 ] , A [ i ] i = 0 while i in list ( range ( n ) ) : if A [ i ] != i + 1 : i += 1 return False i += 1 return True"
"def findAndPrintOriginalArray ( arr , n ) : arr_sum = 0 i = 0 while i in list ( range ( n ) ) : arr_sum += arr [ i ] i += 1 arr_sum = int ( arr_sum / ( n - 1 ) ) for i in range ( 0 , n ) : print ( ( arr_sum - arr [ i ] ) , end = """" )"
"def arrangeString ( str1 , x , y ) : count_0 = 0 count_1 = 0 n = len ( str1 ) for i in range ( n ) : if str1 [ i ] == '0' : count_0 += 1 else : count_1 += 1 while count_0 > 0 or count_1 > 0 : i = 0 while i in list ( range ( x ) ) : if count_0 > 0 : print ( ""0"" , end = """" ) count_0 -= 1 i += 1 for j in range ( 0 , y ) : if count_1 > 0 : print ( ""1"" , end = """" ) count_1 -= 1"
"def minOperations ( n ) : count = 0 d = 0 if ( n == 1 ) : return 0 while ( n > 9 ) : d = max ( n % 10 , d ) n //= 10 count = count + 10 d = max ( d , n - 1 ) count = count + abs ( d ) return count - 1"
"def maxValue ( a , b ) : b = sorted ( b ) bi = [ i for i in b ] ai = [ i for i in a ] n = len ( a ) m = len ( b ) j = m - 1 i = 0 while i in list ( range ( n ) ) : if ( j < 0 ) : i += 1 break if ( bi [ j ] > ai [ i ] ) : ai [ i ] = bi [ j ] j -= 1 i += 1 x = """".join ( ai ) return x"
"def midPoint ( X1 , Y1 , X2 , Y2 ) : dx = X2 - X1 dy = Y2 - Y1 d = dy - ( dx / 2 ) x = X1 y = Y1 print ( x , "","" , y , ""\n"" ) while ( X2 > x ) : x = x + 1 if ( d < 0 ) : d = d + dy else : d = d + ( dy - dx ) y = y + 1 print ( x , "","" , y , ""\n"" )"
"def countDigits ( a , b ) : count = 0 p = abs ( a * b ) if ( p == 0 ) : return 1 while ( 0 < p ) : count = count + 1 p = p // 10 return count"
"def minimumflip ( mat , n ) : flip = 0 i = 0 while i in list ( range ( n ) ) : for j in range ( i ) : if mat [ i ] [ j ] != mat [ j ] [ i ] : flip += 1 i += 1 return flip"
"def findMinimumK ( a , n , s ) : maximum = a [ 0 ] for i in range ( n ) : maximum = max ( maximum , a [ i ] ) low = 1 high = maximum + 1 ans = high while ( low <= high ) : mid = ( low + high ) // 2 sum = 0 i = 0 while i in list ( range ( n ) ) : sum += ( a [ i ] // mid ) i += 1 if ( sum > s ) : low = mid + 1 else : ans = min ( ans , mid ) high = mid - 1 return ans"
"def firstLetterWord ( str ) : result = """" v = True i = 0 while i in list ( range ( len ( str ) ) ) : if ( str [ i ] == '' ) : v = True elif ( str [ i ] != '' and v == True ) : result += ( str [ i ] ) v = False i += 1 return result"
def countMultiples ( n ) : res = 0 i = 1 while i in list ( range ( n + 1 ) ) : if ( i % 3 == 0 or i % 7 == 0 ) : res += 1 i += 1 return res
"def isPossible ( a , b , n , k ) : a.sort ( reverse = True ) b.sort ( ) i = 0 while i in list ( range ( n ) ) : if ( a [ i ] + b [ i ] < k ) : i += 1 return False i += 1 return True"
"def OddDivCount ( a , b ) : res = 0 i = a while i in list ( range ( b + 1 ) ) : divCount = 0 for j in range ( 1 , i + 1 ) : if ( i % j == 0 ) : divCount += 1 if ( divCount % 2 ) : res += 1 i += 1 return res"
"def findArea ( arr , n ) : s = [ ] first = 0 second = 0 i = 0 while i in list ( range ( n ) ) : if arr [ i ] not in s : s.append ( arr [ i ] ) i += 1 continue if ( arr [ i ] > first ) : second = first first = arr [ i ] elif ( arr [ i ] > second ) : second = arr [ i ] i += 1 return ( first * second )"
"def countPairs ( arr1 , arr2 , m , n , x ) : count = 0 for i in range ( m ) : j = 0 while j in list ( range ( n ) ) : if arr1 [ i ] + arr2 [ j ] == x : count = count + 1 j += 1 return count"
def lastFiveDigits ( n ) : n = ( ( int ) ( n / 10000 ) * 10000 + ( ( int ) ( n / 100 ) % 10 ) * 1000 + ( n % 10 ) * 100 + ( ( int ) ( n / 10 ) % 10 ) * 10 + ( int ) ( n / 1000 ) % 10 ) ans = 1 i = 0 while i in list ( range ( 5 ) ) : ans *= n ans %= 100000 i += 1 print ( ans )
"def countRotations ( arr , low , high ) : if ( high < low ) : return 0 if ( high == low ) : return low mid = low + ( high - low ) / 2 mid = int ( mid ) if ( high > mid and arr [ mid + 1 ] < arr [ mid ] ) : return ( mid + 1 ) if ( mid > low and arr [ mid ] < arr [ mid - 1 ] ) : return mid if ( arr [ high ] > arr [ mid ] ) : return countRotations ( arr , low , mid - 1 ) return countRotations ( arr , mid + 1 , high )"
"def numberofways ( n , m ) : dp = np.zeros ( ( n + 2 , n + 2 ) ) dp [ 0 ] [ n + 1 ] = 1 for k in range ( n , m - 1 , - 1 ) : i = 0 while i in list ( range ( n + 1 ) ) : dp [ i ] [ k ] = dp [ i ] [ k + 1 ] if ( i - k >= 0 ) : dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) i += 1 return dp [ n ] [ m ]"
"def find_array ( a , n ) : x = 0 i = 0 while i in list ( range ( n ) ) : a [ i ] += x print ( a [ i ] , end = '' ) x = max ( x , a [ i ] ) i += 1"
"def findGreater ( a , b ) : x = a * ( math.log ( b ) ) y = b * ( math.log ( a ) ) if ( y > x ) : print ( ""a^bisgreater"" ) elif ( x > y ) : print ( ""b^aisgreater"" ) else : print ( ""Bothareequal"" )"
def countDigit ( n ) : temp = n count = 0 while ( temp != 0 ) : d = temp % 10 temp //= 10 if ( d == 2 or d == 3 or 5 == d or d == 7 ) : count += 1 return count
"def CntDivbyX ( arr , n , x ) : number = 0 count = 0 i = 0 while i in list ( range ( n ) ) : number = number * 2 + arr [ i ] if ( ( number % x == 0 ) ) : count += 1 i += 1 return count"
def isCorrectOrder ( n ) : flag = True prev = - 1 type = - 1 while ( n != 0 ) : if ( type != - 1 ) : if ( prev == n % 10 ) : flag = False break if ( prev < n % 10 ) : flag = False break prev = n % 10 n = int ( n / 10 ) else : if ( prev == - 1 ) : prev = n % 10 n = int ( n / 10 ) continue if ( prev == n % 10 ) : flag = False break if ( prev > n % 10 ) : type = 1 prev = n % 10 n = int ( n / 10 ) continue prev = n % 10 n = int ( n / 10 ) return flag
"def checkDivisibility ( num ) : length = len ( num ) if ( length == 1 and num [ 0 ] == '0' ) : return True if ( length % 3 == 1 ) : num = str ( num ) + ""00"" length += 2 elif ( length % 3 == 2 ) : num = str ( num ) + ""0"" length += 1 sum = 0 p = 1 i = length - 1 while i in list ( range ( - 1 ) ) : group = 0 group += ord ( num [ i ] ) - ord ( '0' ) i -= 1 group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10 i -= 1 group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100 sum = sum + group * p p *= ( - 1 ) i += - 1 sum = abs ( sum ) return ( sum % 13 == 0 )"
"def calculateDifference ( arr , n ) : max_val = max ( arr ) prime = ( max_val + 1 ) * [ True ] prime [ 0 ] = False prime [ 1 ] = False p = 2 while p * p <= max_val : if prime [ p ] == True : i = p * 2 while i in list ( range ( max_val + 1 ) ) : prime [ i ] = False i += p p += 1 P1 = 1 ; P2 = 1 for i in range ( n ) : if prime [ arr [ i ] ] : P1 *= arr [ i ] elif arr [ i ] != 1 : P2 *= arr [ i ] return abs ( P2 - P1 )"
"def solve ( N , M , cp , sp ) : profit = [ ] for i in range ( N ) : profit.append ( sp [ i ] - cp [ i ] ) profit.sort ( reverse = True ) sum = 0 i = 0 while i in list ( range ( M ) ) : if profit [ i ] > 0 : sum += profit [ i ] else : i += 1 break i += 1 return sum"
"def findExtraCharcter ( strA , strB ) : res = 0 i = 0 while i in list ( range ( len ( strA ) ) ) : res = res ^ ( ord ) ( strA [ i ] ) i += 1 for i in range ( 0 , len ( strB ) ) : res = res ^ ( ord ) ( strB [ i ] ) return ( ( chr ) ( res ) )"
"def nondecdigits ( s ) : m = len ( s ) a = [ 0 ] * m i = 0 while i in list ( range ( m ) ) : a [ i ] = ord ( s [ i ] ) - ord ( '0' ) i += 1 level = m - 1 for i in range ( m - 1 , 0 , - 1 ) : if ( a [ i ] < a [ i - 1 ] ) : a [ i - 1 ] -= 1 level = i - 1 if ( a [ 0 ] != 0 ) : for i in range ( level + 1 ) : print ( a [ i ] , end = """" ) for i in range ( level + 1 , m ) : print ( ""9"" , end = """" ) else : for i in range ( 1 , level ) : print ( a [ i ] , end = """" ) for i in range ( level + 1 , m ) : print ( ""9"" , end = """" )"
"def minDaysToEmpty ( C , l ) : if ( C <= l ) : return C eq_root = ( math.sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2 return math.ceil ( eq_root ) + l"
def calculateSum ( n ) : sum = 0 row = 0 while row in list ( range ( n ) ) : sum = sum + ( 1 << row ) row += 1 return sum
def findIndex ( n ) : if ( 1 >= n ) : return n a = 0 b = 1 c = 1 res = 1 while ( c < n ) : c = a + b res = res + 1 a = b b = c return res
"def isPossible ( A , n , k ) : countOfTwo = 0 i = 0 while i in list ( range ( n ) ) : if ( A [ i ] % 2 == 0 ) : countOfTwo += 1 i += 1 if ( k == 0 and countOfTwo == n ) : print ( ""NO\n"" ) elif ( countOfTwo >= k ) : print ( ""Yes\n"" ) else : print ( ""No\n"" )"
"def maxProfit ( prices , n , k ) : profit = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n ) ] for i in range ( 1 , n ) : for j in range ( 1 , k + 1 ) : max_so_far = 0 l = 0 while l in list ( range ( i ) ) : max_so_far = max ( max_so_far , prices [ i ] - prices [ l ] + profit [ l ] [ j - 1 ] ) l += 1 profit [ i ] [ j ] = max ( profit [ i - 1 ] [ j ] , max_so_far ) return profit [ n - 1 ] [ k ]"
"def printElements ( arr , n ) : i = 1 while i in list ( range ( n - 1 ) ) : if ( arr [ i ] > arr [ i - 1 ] and arr [ i ] > arr [ i + 1 ] ) : print ( arr [ i ] , end = """" ) i += 1"
"def findevenPair ( A , N ) : count = 0 i = 0 while i in list ( range ( N ) ) : if ( A [ i ] % 2 != 0 ) : count += 1 i += 1 oddCount = count * ( count - 1 ) / 2 return ( int ) ( ( N * ( N - 1 ) / 2 ) - oddCount )"
"def minInsertionStepToSortArray ( arr , N ) : lis = [ 0 ] * N for i in range ( N ) : lis [ i ] = 1 for i in range ( 1 , N ) : for j in range ( i ) : if ( arr [ i ] >= arr [ j ] and lis [ i ] < lis [ j ] + 1 ) : lis [ i ] = lis [ j ] + 1 max = 0 i = 0 while i in list ( range ( N ) ) : if ( max < lis [ i ] ) : max = lis [ i ] i += 1 return ( N - max )"
"def MinDeletion ( a , n ) : map = dict.fromkeys ( a , 0 ) i = 0 while i in list ( range ( n ) ) : map [ a [ i ] ] += 1 i += 1 ans = 0 for key , value in map.items ( ) : x = key frequency = value if ( x <= frequency ) : ans += ( frequency - x ) else : ans += frequency return ans"
"def solve ( arr , n , k ) : arr.sort ( ) if ( k == 1 and arr [ n - 2 ] != arr [ n - 1 ] ) : print ( arr [ n - 1 ] ) return count = 1 i = n - 2 while i in list ( range ( - 1 ) ) : if ( arr [ i ] == arr [ i + 1 ] ) : count += 1 else : count = 1 if ( count == k and ( i == 0 or ( arr [ i - 1 ] != arr [ i ] ) ) ) : print ( arr [ i ] ) i += - 1 return i += - 1 print ( ""Nosuchelement"" )"
"def findNormal ( A , x , y ) : dif = A - x * 2 if ( ( 2 * x - x * x ) == y ) : if ( dif < 0 ) : print ( 0 - dif , ""y="" , ""x"" , ( 0 - x ) + ( y * dif ) ) elif ( dif > 0 ) : print ( dif , ""y="" , ""-x+"" , x + dif * y ) else : print ( ""x="" , x ) else : print ( ""Notpossible"" )"
"def calculateSum ( n , k ) : res = 1 MOD = 1000000007 while k > 0 : if 1 == ( k & 1 ) : res = ( res * n ) % MOD k = k // 2 n = ( n * n ) % MOD return res"
"def findCart ( arr1 , arr2 , n , n1 ) : for i in range ( 0 , n ) : j = 0 while j in list ( range ( n1 ) ) : print ( ""{"" , arr1 [ i ] , "","" , arr2 [ j ] , ""},"" , sep = """" , end = """" ) j += 1"
"def printReverseFloyd ( n ) : curr_val = int ( n * ( n + 1 ) / 2 ) i = n + 1 while i in list ( range ( 1 ) ) : for j in range ( i , 1 , - 1 ) : print ( curr_val , end = """" ) curr_val -= 1 print ( """" ) i += - 1"
"def findMaxGuests ( arrl , exit , n ) : arrl.sort ( ) exit.sort ( ) guests_in = 1 max_guests = 1 time = arrl [ 0 ] i = 1 j = 0 while ( i < n and j < n ) : if ( arrl [ i ] > exit [ j ] ) : guests_in = guests_in - 1 j = j + 1 else : guests_in = guests_in + 1 if ( guests_in > max_guests ) : max_guests = guests_in time = arrl [ i ] i = i + 1 print ( ""MaximumNumberofGuests="" , max_guests , ""attime"" , time )"
"def isProduct ( arr , n , x ) : for i in arr : for j in arr : if x == i * j : return True return False"
"def binarySearch ( arr , l , r , x ) : while l <= r : mid = l + ( r - l ) // 2 if arr [ mid ] == x : return mid elif x > arr [ mid ] : l = mid + 1 else : r = mid - 1 return - 1"
"def sortSquares ( arr , n ) : K = 0 K = 0 while K in list ( range ( n ) ) : if ( arr [ K ] >= 0 ) : K += 1 break K += 1 i = K - 1 j = K ind = 0 temp = [ 0 ] * n while ( i >= 0 and j < n ) : if ( arr [ i ] * arr [ i ] < arr [ j ] * arr [ j ] ) : temp [ ind ] = arr [ i ] * arr [ i ] i -= 1 else : temp [ ind ] = arr [ j ] * arr [ j ] j += 1 ind += 1 while ( i >= 0 ) : temp [ ind ] = arr [ i ] * arr [ i ] i -= 1 ind += 1 while ( j < n ) : temp [ ind ] = arr [ j ] * arr [ j ] j += 1 ind += 1 for i in range ( n ) : arr [ i ] = temp [ i ]"
"def geometricMean ( arr , n ) : product = 1 i = 0 while i in list ( range ( n ) ) : product = product * arr [ i ] i += 1 gm = ( float ) ( math.pow ( product , ( 1 / n ) ) ) return ( float ) ( gm )"
def findpos ( n ) : i = 0 j = len ( n ) pos = 0 while ( i < j ) : if ( n [ i ] == '4' ) : pos = pos * 2 + 1 if ( '7' == n [ i ] ) : pos = pos * 2 + 2 i = i + 1 return pos
"def compute ( st , n ) : reverseAlphabet = ""zyxwvutsrqponmlkjihgfedcba"" l = len ( st ) answer = """" i = 0 while i in list ( range ( n ) ) : answer = answer + st [ i ] i += 1 for i in range ( n , l ) : answer = ( answer + reverseAlphabet [ ord ( st [ i ] ) - ord ( 'a' ) ] ) return answer"
"def gcdExtended ( a , b , x , y ) : if 0 == a : x = 0 y = 1 return b x1 = 1 y1 = 1 gcd = gcdExtended ( b % a , a , x1 , y1 ) x = y1 - ( b / a ) * x1 y = x1 return gcd"
"def checkSame ( n ) : set , unset = 0 , 0 while ( n ) : if ( n and 1 ) : set + 1 else : unset += 1 n = n >> 1 if ( unset == set ) : return True else : return False"
"def MinimumValue ( x , y ) : if ( y < x ) : x , y = y , x a = 1 b = x - 1 c = y - b print ( a , b , c )"
"def calculateSum ( arr , n ) : if ( n == 0 ) : return 0 s = arr [ 0 ] value = int ( s ) sum = value i = 2 while i in list ( range ( n ) ) : s = arr [ i ] value = int ( s ) operation = arr [ i - 1 ] [ 0 ] if ( operation == '+' ) : sum += value else : sum -= value i += 2 return sum"
"def removeDuplicates ( arr , n ) : st = 0 for i in range ( n ) : if ( i < n - 2 and arr [ i ] == arr [ i + 1 ] and arr [ i ] == arr [ i + 2 ] ) : continue else : arr [ st ] = arr [ i ] st += 1 print ( ""{"" , end = """" ) i = 0 while i in list ( range ( st ) ) : print ( arr [ i ] , end = """" ) if ( i != st - 1 ) : print ( "","" , end = """" ) i += 1 print ( ""}"" , end = """" )"
"def nthXorFib ( n , a , b ) : if 0 == n : return a if n == 1 : return b if n == 2 : return a ^ b return nthXorFib ( n % 3 , a , b )"
"def check ( s , l ) : freq = [ 0 for i in range ( 26 ) ] for i in range ( l ) : freq [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1 i = 0 while i in list ( range ( 26 ) ) : if ( freq [ i ] >= 2 ) : i += 1 return True i += 1 return False"
def equilibrium ( arr ) : leftsum = 0 rightsum = 0 n = len ( arr ) for i in range ( n ) : leftsum = 0 rightsum = 0 for j in range ( i ) : leftsum += arr [ j ] j = i + 1 while j in list ( range ( n ) ) : rightsum += arr [ j ] j += 1 if leftsum == rightsum : return i return - 1
"def minimumValue ( arr , n , k ) : arr.sort ( ) answer = 0 i = 0 while i in list ( range ( k ) ) : answer += arr [ i ] * arr [ i ] i += 1 return answer * ( 2 * k - 2 )"
"def countFreq ( a , n ) : hm = dict ( ) i = 0 while i in list ( range ( n ) ) : hm [ a [ i ] ] = hm.get ( a [ i ] , 0 ) + 1 i += 1 cumul = 0 for i in range ( n ) : cumul += hm [ a [ i ] ] if ( hm [ a [ i ] ] > 0 ) : print ( a [ i ] , ""->"" , cumul ) hm [ a [ i ] ] = 0"
"def findElement ( arr , n , key ) : i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] == key ) : i += 1 return i i += 1 return - 1"
def getValueOfF ( n ) : if ( n == 1 ) : return 0 if ( n == 2 ) : return 1 cnt = 0 while ( n % 2 == 0 ) : cnt = cnt + 1 n /= 2 return 2 * cnt
"def getChicks ( n ) : size = max ( n , 7 ) dp = [ 0 ] * size dp [ 0 ] = 0 dp [ 1 ] = 1 for i in range ( 2 , 7 ) : dp [ i ] = dp [ i - 1 ] * 3 dp [ 6 ] = 726 i = 8 while i in list ( range ( n + 1 ) ) : dp [ i ] = ( dp [ i - 1 ] - ( 2 * dp [ i - 6 ] // 3 ) ) * 3 i += 1 return dp [ n ]"
"def getMissingNo ( a , n ) : i , total = 0 , 1 i = 2 while i in list ( range ( n + 2 ) ) : total += i total -= a [ i - 2 ] i += 1 return total"
"def getIndex ( n , shuffle ) : i = 0 while i in list ( range ( 3 ) ) : if ( shuffle [ i ] [ 0 ] == n ) : n = shuffle [ i ] [ 1 ] elif ( shuffle [ i ] [ 1 ] == n ) : n = shuffle [ i ] [ 0 ] i += 1 print ( n )"
def floatError ( no ) : sum = 0.0 i = 0 while i in list ( range ( 10 ) ) : sum = sum + no i += 1 return sum
"def NthCharacter ( n ) : s = """" c = 1 while ( True ) : if ( c < 10 ) : s = s + chr ( 48 + c ) else : s1 = """" dup = c while ( dup > 0 ) : s1 = s1 + chr ( ( dup % 10 ) + 48 ) dup //= 10 s1 = """".join ( reversed ( s1 ) ) s = s + s1 c = c + 1 if ( len ( s ) >= n ) : return s [ n - 1 ]"
def fnMod ( n ) : if ( 1 == n % 5 ) : return 4 else : return 0
"def maxCost ( a , n , l , r ) : mx = 0 for i in range ( n ) : mx = max ( mx , a [ i ] ) count = [ 0 ] * ( mx + 1 ) for i in range ( n ) : count [ a [ i ] ] += 1 res = [ 0 ] * ( mx + 1 ) res [ 0 ] = 0 l = min ( l , r ) num = 1 while num in list ( range ( mx + 1 ) ) : k = max ( num - l - 1 , 0 ) res [ num ] = max ( res [ num - 1 ] , num * count [ num ] + res [ k ] ) num += 1 return res [ mx ]"
"def min_changes ( a , n ) : ans_a = 0 ans_b = 0 i = 0 while i in list ( range ( n ) ) : if ( i % 2 == 0 ) : if ( a [ i ] == 0 ) : ans_a += 1 else : ans_b += 1 else : if ( a [ i ] == 0 ) : ans_b += 1 else : ans_a += 1 i += 1 return min ( ans_a , ans_b )"
def divisibleBy20 ( num ) : lastTwoDigits = int ( num [ - 2 : ] ) return ( ( 0 == lastTwoDigits % 5 and lastTwoDigits % 4 == 0 ) )
"def minimumCostOfBreaking ( X , Y , m , n ) : res = 0 X.sort ( reverse = True ) Y.sort ( reverse = True ) hzntl = 1 vert = 1 i = 0 j = 0 while ( i < m and j < n ) : if ( X [ i ] > Y [ j ] ) : res = res + X [ i ] * vert hzntl = hzntl + 1 i = i + 1 else : res = res + Y [ j ] * hzntl vert = vert + 1 j = j + 1 total = 0 while ( i < m ) : total = total + X [ i ] i = i + 1 res = res + total * vert total = 0 while ( j < n ) : total = total + Y [ j ] j = j + 1 res = res + total * hzntl return res"
"def StrictlyPositiveXor ( A , N ) : allxor = 0 checkallzero = True for i in range ( N ) : allxor ^= A [ i ] if ( A [ i ] > 0 ) : checkallzero = False if ( allxor != 0 ) : return N if ( checkallzero ) : return - 1 l = N ; r = - 1 for i in range ( N ) : if ( A [ i ] > 0 ) : l = i + 1 break i = N - 1 while i in list ( range ( - 1 ) ) : if ( A [ i ] > 0 ) : r = i + 1 i += - 1 break i += - 1 return max ( N - l , r - 1 )"
"def xor_triplet ( arr , n ) : ans = 0 for i in range ( n ) : for j in range ( i + 1 , n ) : for k in range ( j , n ) : xor1 = 0 ; xor2 = 0 x = i while x in list ( range ( j ) ) : xor1 ^= arr [ x ] x += 1 for x in range ( j , k + 1 ) : xor2 ^= arr [ x ] if ( xor1 == xor2 ) : ans += 1 return ans"
"def xorOfSum ( a , n ) : answer = 0 for i in range ( n ) : j = i + 1 while j in list ( range ( n ) ) : answer ^= ( a [ i ] + a [ j ] ) j += 1 return answer"
"def check ( Arr , n , M , K ) : flag = 0 i = 0 while i in list ( range ( n ) ) : if ( Arr [ i ] == 0 ) : flag = 1 i += 1 if ( K % 2 != 0 and flag == 0 ) : return ""No"" else : return ""Yes"""
def findS ( s ) : _sum = 0 n = 1 while ( s > _sum ) : _sum += n * n * n n += 1 n -= 1 if _sum == s : return n return - 1
"def Segment ( x , l , n ) : if ( n == 1 ) : return 1 ans = 2 i = 1 while i in list ( range ( n - 1 ) ) : if ( x [ i ] - l [ i ] > x [ i - 1 ] ) : ans += 1 elif ( x [ i ] + l [ i ] < x [ i + 1 ] ) : x [ i ] = x [ i ] + l [ i ] ans += 1 i += 1 return ans"
"def sumFirst ( a , n ) : mp = { i : 0 for i in range ( 7 ) } suf = 0 i = n - 1 while ( i >= 0 ) : suf += a [ i ] mp [ suf ] = i i -= 1 pre = 0 maxi = - 1 i = 0 while i in list ( range ( n ) ) : pre += a [ i ] if ( mp [ pre ] > i ) : if ( pre > maxi ) : maxi = pre i += 1 if ( maxi == - 1 ) : return 0 else : return maxi"
"def printPermutation ( N , K ) : res = list ( ) l , r , flag = 1 , N , 0 for i in range ( K ) : if flag == False : res.append ( l ) l += 1 else : res.append ( r ) r -= 1 flag = flag ^ 1 if flag == False : for i in range ( r , 2 , - 1 ) : res.append ( i ) else : i = l while i in list ( range ( r ) ) : res.append ( i ) i += 1 for i in res : print ( i , end = """" )"
def check ( n ) : n = str ( n ) if n [ : : - 1 ] == n : return True else : return False
"def multiply ( a , n ) : if 0 == n : return ( a [ n ] ) else : return ( a [ n ] * multiply ( a , n - 1 ) )"
def findNth ( n ) : count = 0 for curr in itertools.count ( ) : sum = 0 x = curr while ( x ) : sum = sum + x % 10 x = x // 10 if ( sum == 10 ) : count = count + 1 if ( n == count ) : return curr return - 1
def hexagonside ( a ) : if 0 > a : return - 1 x = a // 3 return x
"def pairs ( n ) : c = [ [ 0 for i in range ( 10 ) ] for i in range ( 10 ) ] tmp = 1 i = 1 while i in list ( range ( n + 1 ) ) : if ( i >= tmp * 10 ) : tmp *= 10 c [ i // tmp ] [ i % 10 ] += 1 i += 1 ans = 0 for i in range ( 1 , 10 ) : for j in range ( 1 , 10 ) : ans += c [ i ] [ j ] * c [ j ] [ i ] return ans"
"def binomialCoeff ( n , k ) : if k == 0 or n == k : return 1 return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k )"
"def countDistictSubarray ( arr , n ) : vis = dict ( ) i = 0 while i in list ( range ( n ) ) : vis [ arr [ i ] ] = 1 i += 1 k = len ( vis ) vid = dict ( ) ans = 0 right = 0 window = 0 for left in range ( n ) : while ( right < n and window < k ) : if arr [ right ] in vid.keys ( ) : vid [ arr [ right ] ] += 1 else : vid [ arr [ right ] ] = 1 if ( vid [ arr [ right ] ] == 1 ) : window += 1 right += 1 if ( window == k ) : ans += ( n - right + 1 ) vid [ arr [ left ] ] -= 1 if ( vid [ arr [ left ] ] == 0 ) : window -= 1 return ans"
"def product ( ar , n ) : result = 1 i = 0 while i in list ( range ( n ) ) : result = result * ar [ i ] i += 1 return result"
"def findMaximum ( arr , low , high ) : max = arr [ low ] i = low i = 0 while i in list ( range ( high + 1 ) ) : if arr [ i ] > max : max = arr [ i ] i += 1 return max"
"def equal_xor_sum ( arr , n ) : Sum = 0 Xor = 0 i = 0 while i in list ( range ( n ) ) : Sum = Sum + arr [ i ] Xor = Xor ^ arr [ i ] i += 1 if ( Sum == Xor ) : print ( ""YES"" ) else : print ( ""NO"" )"
"def countSubarrays ( a , n , m ) : count = 0 i = 0 while i in list ( range ( n ) ) : odd = 0 for j in range ( i , n ) : if ( a [ j ] % 2 ) : odd += 1 if ( odd == m ) : count += 1 i += 1 return count"
"def printOtherSides ( n ) : if ( n & 1 ) : if ( n == 1 ) : print ( - 1 ) else : b = ( n * n - 1 ) // 2 c = ( n * n + 1 ) // 2 print ( ""b="" , b , "",c="" , c ) else : if ( 2 == n ) : print ( - 1 ) else : b = n * n // 4 - 1 c = n * n // 4 + 1 print ( ""b="" , b"",c="" , c )"
"def printPattern ( n ) : line_no = 1 curr_star = 0 line_no = 1 while ( n >= line_no ) : if ( curr_star < line_no ) : print ( ""*"" , end = """" ) curr_star += 1 continue if ( curr_star == line_no ) : print ( """" ) line_no += 1 curr_star = 0"
"def right_left ( a , n ) : total = dict.fromkeys ( a , 0 ) left = dict.fromkeys ( a , 0 ) for i in range ( n ) : if a [ i ] not in total : total [ a [ i ] ] = 1 total [ a [ i ] ] += 1 i = 0 while i in list ( range ( n ) ) : print ( total [ a [ i ] ] - 1 - ( 2 * left [ a [ i ] ] ) , end = """" ) left [ a [ i ] ] += 1 i += 1"
def checkYear ( year ) : return ( ( ( year % 4 == 0 ) and ( year % 100 != 0 ) ) or ( 0 == year % 400 ) )
"def minCost ( coin , n , k ) : coin.sort ( ) coins_needed = math.ceil ( 1.0 * n // ( k + 1 ) ) ans = 0 i = 0 while i in list ( range ( coins_needed - 1 + 1 ) ) : ans += coin [ i ] i += 1 return ans"
"def findIndex ( a , n , key ) : start = - 1 for i in range ( n ) : if a [ i ] == key : start = i break if start == - 1 : print ( ""Keynotpresentinarray"" ) return 0 end = start i = n - 1 while i in list ( range ( start - 1 ) ) : if a [ i ] == key : end = i i += - 1 break i += - 1 if start == end : print ( ""Onlyonekeyispresentatindex:"" , start ) else : print ( ""Startindex:"" , start ) print ( ""Lastindex:"" , end )"
"def maxLen ( arr , n ) : hash_map = { } curr_sum = 0 max_len = 0 ending_index = - 1 for i in range ( 0 , n ) : if ( arr [ i ] == 0 ) : arr [ i ] = - 1 else : arr [ i ] = 1 for i in range ( 0 , n ) : curr_sum = curr_sum + arr [ i ] if ( curr_sum == 0 ) : max_len = i + 1 ending_index = i if ( curr_sum + n ) in hash_map : max_len = max ( max_len , i - hash_map [ curr_sum + n ] ) else : hash_map [ curr_sum ] = i i = 0 while i in list ( range ( n ) ) : if ( arr [ i ] == - 1 ) : arr [ i ] = 0 else : arr [ i ] = 1 i += 1 print ( ending_index - max_len + 1 , end = """" ) print ( ""to"" , end = """" ) print ( ending_index ) return max_len"
"def solution ( a , b , n ) : i = 0 while i * a <= n : if 0 == ( n - ( i * a ) ) % b : print ( ""x="" , i , "",y="" , int ( ( n - ( i * a ) ) / b ) ) return 0 i = i + 1 print ( ""Nosolution"" )"
"def countPairs ( n ) : count = 0 for x in range ( 1 , n ) : y = x + 1 while y in list ( range ( n + 1 ) ) : if ( ( y * x ) % ( y + x ) == 0 ) : count += 1 y += 1 return count"
